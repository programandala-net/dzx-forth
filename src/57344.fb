\ Miscellaneous functions                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \ Common forth words                                            : 0<= ( n -- flag )  0> 0= ;                                    : 0>= ( n -- flag )  0< 0= ;                                    : <=  ( n1 n2 -- flag )  > 0= ;                                 : >=  ( n1 n2 -- flag )  < 0= ;                                 : U<= ( u1 u2 -- flag )  u> 0= ;                                : U>= ( u1 u2 -- flag )  u< 0= ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                \ Common forth words                                            \ Duplicate a triple number                                     : 3DUP ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 )  dup 2over rot ;                                                                       \ Negate n1/d1 if n is negative  (FIG: +- D+-)                  : ?NEGATE ( n1 n -- n2 )  0< if negate then ;                   : ?DNEGATE ( d1 n -- d2 )  0< if dnegate then ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 \ UNDER+                                                                                                                        \ : UNDER+ ( a b x .. a+x b )  rot + swap ;                                                                                     code UNDER+ ( a b x .. a+x b )                                    d pop  2 h lxi  sp dad  m a mov  e add  a m mov                 h inx  m a mov  d adc  a m mov  next  end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                \ Number utilities                                              : (UD.) ( ud -- a u )  <# #s #> ;                               : (U.)  ( u  -- a u )  0 (d.) ;                                 : (.)   ( n  -- a u )  s>d (d.) ;                               : UD.   ( ud -- )  (ud.) type space ;                           : UD.R  ( ud n -- )  >r (ud.) r> s.r ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          \ Number utilities                                              \ OpenFirmware                                                  : PUSH-HEX     ( -- )  base @ r> 2>r hex ;                      : PUSH-DECIMAL ( -- )  base @ r> 2>r decimal ;                  : POP-BASE     ( -- )  2r> >r base ! ;                                                                                          : (DH.) ( ud -- a u )                                             push-hex  <# 8 0 do # loop #>  pop-base ;                     : (H.)  ( u -- a u )  0 (dh.) 4 /string ;                       : (HB.) ( u -- a u )  (h.) 2 /string ;                          : H.    ( u -- )  (h.) type space ;                             : HB.   ( u -- )  (hb.) type space ;                                                                                                                                                                                                                                                                                            \ NUMBER? (old version)                                         : NUMBER? ( c-addr u -- d true | 0 )                              over c@ [char] - = >r  0. 2swap  dup if                           r@ 1 and /string  >number  dpl on                               begin                                                             dup if  over c@ bl <> and  then                               dup while                                                         over c@  dup [char] : =                                         swap [char] +  [char] 0  within  or                           0= if  r> drop 2drop 2drop 0 exit  then                           1 /string  dpl off  >number                                   repeat                                                        then  2drop  r> if dnegate then  true ;                                                                                       \ Patch into forth interpreter                                  \  ' NUMBER?  SYS-VEC #18 + @  !  FREEZE                        \ Comma formatted numeric output                                \ Adapted from code by C.Curley FD15/5                                                                                          \ As for #S but places a comma after each 3 digits              : #,S ( +d -- 0. )  0  begin  >r  #  2dup or                      while  r> 1+  dup 3 = if  [char] , hold  drop 0  then           repeat  r> drop ;                                                                                                             : (D,.) ( d -- a u )  tuck dabs <# #,s rot sign #> ;            : D,.   ( d -- )      (d,.) type space ;                        : D,.R  ( d n -- )    >r (d,.) r> s.r ;                                                                                         : (UD,.) ( ud -- a u )  <# #,s #> ;                             : UD,.   ( ud -- )      (ud,.) type space ;                     : UD,.R  ( ud n -- )    >r (ud,.) r> s.r ;                                                                                      \ FOR NEXT                                                      \ Count is placed on return stack and decremented at NEXT,      \ terminates when zero.                                         sys @  application                                              -? code nxt ( run-time for NEXT )                                  rpp lhld  m e mov  h inx  m d mov  d dcx  e a mov               d ora  1 $ jz  d m mov  h dcx  e m mov  bran jmp             1 $:  h inx  rpp shld  b inx  b inx  next  end-code                                                                             system                                                          : FOR ( u -- )  postpone >r  postpone begin ;  immediate        : NEXT ( -- )  postpone nxt  <resolve ;  immediate                                                                              sys !  behead nxt nxt                                                                                                                                                                           \ Misc functions                                                \ Input string of n chars max, return false if empty or blanks  : INPUT ( n -- c-addr u true | false )                            here  dup rot accept  bl skip  dup if  -1  else  and  then ;                                                                  \ Convert hex string to a double number                         : HEXNUMBER? ( c-addr u -- d -1 | 0 )                             base @ >r  hex number?  r> base ! ;                                                                                           \ Display n backspace characters                                : BACKSPACES ( n -- )  0 max  0 ?do  8 emit  loop ;                                                                                                                                                                                                                                                                                                                                             \ Exception tools                                               \ THROW exception code n if flag is non-zero                    : ?THROW ( flag n -- )  swap 0<> and throw ;                                                                                    \ Perform CATCH intercepting exception code n only              : ?CATCH ( xt n -- n )  >r catch dup r> <> over and throw ;                                                                     \ Intercepting a range of exception codes                       \  ['] do-it CATCH  case                                        \    x1  of  ...  endof  \ catch error x1                       \    x2  of  ...  endof  \ catch error x2                       \    dup throw           \ throw all others                     \  endcase                                                                                                                                                                                                                                                      \ DEFER tools                                                   sys @  system                                                   \ Add new behaviour to existing deferred word                   : +IS ( xt <name> -- )  >r  :noname  r> compile,                  ' >body  dup >r  @ compile,  postpone ;  r> ! ;                                                                               \ Compile current behaviour of a deferred word                  : DEFERS ( <name> -- )  ' >body @ compile, ;  immediate                                                                         sys !                                                                                                                                                                                                                                                                                                                                                                                                                                                           \ Stack tools                                                   \ A version of ?STACK for use within turnkey applications.      \ Checks data, return and fp stacks for under/overflow.                                                                         : ?STACK ( ? -- ? )                                               sp@  s0 @  over u<  swap  pad u<  or abort" stack?"             r0 @  rp@  u<  rp@  fs0 @  u<  or abort" r-stack?"            \  fs0 @  fsp @  u<  fsp @  fs0 @  [ sys-vec #20 + ] literal    \  @  -  u<  or abort" f-stack?"                                ;                                                                                                                                                                                                                                                                                                                                                                                                                                                               \\ Quad - DUM*                                                  \ Multiply doubles leaving quad. Unsigned.                      code DUM* ( ud1 ud2 -- uq )                                       di pop  bx pop  cx pop  dx pop                                  2 # sp sub  bp push  si push                                    dx si mov  bx ax mov  dx mul                                    sp bp mov  ax 4 [bp] mov                                        dx si xchg  di ax mov  dx mul                                   ax si add  0 # dx adc                                           bx ax mov  dx bx mov  cx mul                                    bp bp xor  ax si add  dx bx adc                                 0 # bp adc  cx ax mov  di mul                                   bx ax add  bp dx adc  si bx mov  si pop  bp pop                 bx push  ax push  dx push  next  end-code                                                                                                                                                     \\ Quad - DUM/MOD                                               \ Divide quad by double. Unsigned.                              code DUM/MOD ( uq ud -- udrem udquot )                            di pop  es pop  ax pop  bx pop  cx pop  dx pop                  si push  bp push  es si mov  #32 # bp mov                     1 $:  dx shl  cx rcl  bx rcl  ax rcl  2 $ jnc                     si bx sub  di ax sbb  3 $ ju                                  2 $:  si bx sub  di ax sbb  3 $ jnc                               si bx add  di ax adc  1 # dx sub  0 # cx sbb                  3 $:  dx inc  4 $ jnz  cx inc                                   4 $:  bp dec  1 $ jnz  bp pop  si pop                             bx push  ax push  dx push  cx push  next  end-code                                                                                                                                                                                                                                                                            \\ Double - D* DU/MOD                                           \ Multiply doubles. Signed or unsigned                          code D* ( d|ud1 d|ud2 -- d|ud3 )                                  cx pop  bx pop  ax pop  di pop  bx mul                          cx ax xchg  di mul  ax cx add  di ax xchg  bx mul               cx dx add  ax push  dx push  next  end-code                                                                                   \ Divide doubles. Unsigned.                                     code DU/MOD ( ud1 ud2 -- udrem udquot )                           di pop  bx pop  dx pop  ax pop  si push  bp push                bx si mov  cx cx sub  bx bx sub  #33 # bp mov                 1 $:  bx rcl  cx rcl  si bx sub  di cx sbb  2 $ jnc               si bx add  di cx adc                                          2 $:  cmc  ax rcl  dx rcl  bp dec  1 $ jnz  bp pop  si pop        bx push  cx push  ax push  dx push  next  end-code                                                                            \\ Double - FD/MOD                                              \ Divide doubles signed by unsigned. Floored.                   code FD/MOD ( d ud -- drem dquot )                                di pop  ax pop  cx pop  dx pop  si push  bp push                ax si mov  bx bx sub  ax ax sub  cx cx or  1 $ jns              bx dec  ax dec  si bx add  di ax adc                          1 $:  #32 # bp mov                                              2 $:  dx shl  cx rcl  bx rcl  ax rcl  3 $ jnc                     si bx sub  di ax sbb  4 $ ju                                  3 $:  si bx sub  di ax sbb  4 $ jnc                               si bx add  di ax adc  1 # dx sub  0 # cx sbb                  4 $:  dx inc  5 $ jnz  cx inc                                   5 $:  bp dec  2 $ jnz  bp pop  si pop                             bx push  ax push  dx push  cx push  next                      end-code                                                                                                                        \ Double - high level                                           \ Multiply doubles. Signed or unsigned.                         : D* ( d|ud1 d|ud2 -- d|ud3 )                                     >r swap >r 2dup um* rot r> * + rot r> * + ;                                                                                   \ Divide doubles. Unsigned.                                     : DU/MOD ( ud1 ud2 -- udrem udquot )                              0. 2rot  #32 0 do  2 pick over 2>r  d2*  2swap d2*  r> 0<       1 and m+  2dup  7 pick 7 pick  du< 0=  r> 0<  or  if  5 pick    5 pick  d-  2swap 1 m+  else  2swap  then  loop  2rot 2drop ;                                                                 \ Divide doubles. Signed. Symmetric.                            : D/MOD ( d1 d2 -- drem dquot )                                   2 pick  2dup xor 2>r  dabs  2swap dabs  2swap du/mod  r>        0< if dnegate then  r> 0< if 2swap dnegate 2swap then ;                                                                       \ Double operations                                             \ Memory                                                        : M+! ( n a -- )  dup >r 2@ rot m+ r> 2! ;                      : D+! ( d a -- )  dup >r 2@ d+ r> 2! ;                                                                                          \ Logical                                                       : DAND ( xd1 xd2 -- xd3 )  rot and >r and r> ;                  : DOR  ( xd1 xd2 -- xd3 )  rot or >r or r> ;                    : DXOR ( xd1 xd2 -- xd3 )  rot xor >r xor r> ;                  : DINVERT ( xd1 -- xd2 )  invert swap invert swap ;                                                                             \ Shift                                                         : DLSHIFT ( xd1 n -- xd2 )  0 ?do d2* loop ;                    : DRSHIFT ( xd1 n -- xd2 )  0 ?do d2/ $7FFF and loop ;                                                                                                                                          \ Mixed - MU/MOD UT* UT/ UM*/                                   \ Divide double by single. Unsigned.                            : MU/MOD ( ud u -- urem udquot )                                  >r 0 r@ um/mod r> swap >r um/mod r> ;                                                                                         \ Multiply double by single leaving triple. Unsigned.           : UT* ( ud u -- ut )  dup rot um* 2>r um* 0 2r> d+ ;                                                                            \ Divide triple by single leaving double. Unsigned.             : UT/ ( ut u -- ud )                                              dup >r um/mod swap rot 0 r@ um/mod                              swap rot r> um/mod nip 0 2swap swap d+ ;                                                                                      \ Unsigned M/*                                                  : UM*/ ( ud1 u1 u2 -- ud2 )  >r ut* r> ut/ ;                                                                                    \ Mixed - FDM/MOD                                               \ Divide signed double by positive single. Floored.             : FDM/MOD ( d +n -- drem dquot )                                  tuck >r s>d r> fm/mod >r swap um/mod 0 swap r> ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \ 16-bit fast integer square root                               \ Returns root and remainder, or 0 -1 if n is negative  FD14/5  : SQRT ( +n -- root rem )                                         dup 0<  if  drop 0 -1  else                                       0 swap 16384 ( 2^14 )                                           begin                                                             >r  dup  2 pick  -  r@ -  dup 0<                                if    drop swap 2/                                              else  nip  swap 2/  r@ +  then                                  swap  r> 2/                                                     2/  dup 0=                                                    until  drop                                                   then ;                                                                                                                                                                                                                                                        \ 32-bit fast integer square root                               \ Returns root and remainder, or 0 -1 if d is negative  FD14/5  : DSQRT ( +d -- droot drem )                                      dup 0<  if  2drop 0. -1.  else                                    0. 2swap 1073741824. ( 2^30 )                                   begin                                                             2>r  2dup  5 pick 5 pick  d-  2r@ d-  dup 0<                    if    2drop  2swap d2/                                          else  2nip  2swap d2/  2r@ d+  then                             2swap  2r> d2/                                                  d2/  2dup d0=                                                 until  2drop                                                  then ;                                                                                                                                                                                                                                                        \\ 32-bit integer square root                                   \ Returns root or -1 if d is negative  M.Barr                   code DSQRT ( +d -- u )                                            cx pop  bx pop  3 $ jcxz  cx dx mov  -1 # di mov              1 $: dx shl  2 $ jc  dx shl  2 $ jc  di shr  1 $ ju             2 $: cx dx mov  bx ax mov  di dx cmp  4 $ jnc  di div             di ax cmp  4 $ jnc  ax di add  di rcr  2 $ ju                 3 $: bx dx mov  $FF # di mov  bx bx or  1 $ jnz                   bx di mov  4 $: di push  next  end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \\ 31-bit integer square root                                   code DSQRT ( +d -- +n )                                           bx pop  dx pop  ax ax sub  di di sub  16 # cx mov             1 $:  dx shl  bx rcl  di rcl  dx shl  bx rcl  di rcl              ax shl  ax shl  ax inc  ax di cmp  2 $ jc  ax di sub            ax inc  2 $:  ax shr  1 $ loop  ax push  next  end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \ Simple random number generator                                \ LCS generator from 'Starting Forth'                                                                                           variable RND  1 rnd !                                                                                                           \ Get random number                                             : RAND ( -- u )  rnd @  31421 *  6727 +  dup rnd ! ;                                                                            \ Get random number between 0 and u-1                           : RANDOM ( u -- 0..u-1 )  rand um* nip ;                                                                                                                                                                                                                                                                                                                                                                                                                        \ Minimum standard random number generator                      \ Multiply doubles. Signed or unsigned.                         : D* ( d|ud1 d|ud2 -- d|ud3 )                                     >r swap >r 2dup um* rot r> * + rot r> * + ;                                                                                   \ LCS generator using Turbo-C algorithm                         2variable RND  1. rnd 2!                                                                                                        \ Get random number                                             : RAND ( -- u )                                                   rnd 2@ $015A4E35. d* 1. d+ tuck rnd 2! ;                                                                                      \ Get random number between 0 and u-1                           : RANDOM ( u -- 0..u-1 )  rand um* nip ;                                                                                                                                                        \ CRC-16                                                        \ x16+x15+x2+1  Initial CRC = 0                                                                                                 \ : CRC-16 ( crc byt -- crc' )                                  \  xor 8 0 do dup 1 and if u2/ $A001 xor else u2/ then loop ;                                                                   code CRC-16 ( crc byt -- crc' )                                   d pop  h pop  e a mov  l xra  a l mov  8 e mvi  1 $:            a ora  h a mov  rar  a h mov  l a mov  rar  a l mov             2 $ jnc  l a mov  $01 xri  a l mov  h a mov  $A0 xri            a h mov  2 $:  e dcr  1 $ jnz  1push  end-code                                                                                                                                                                                                                                                                                                                                                \ CRC-16 table-driven                                           \ x16+x15+x2+1  Initial CRC = 0                                 -? create tb  #256 cells allot                                                                                                  -? : !tb  #256 0 do i 8 0 do dup 1 and >r u2/ r> if $A001 xor     then loop i 2* tb + ! loop ;  !tb forget  !tb                                                                                 \ : CRC-16 ( crc byt -- crc' )                                  \  over xor $FF and cells tb + @ swap 8 rshift xor ;                                                                            code CRC-16  ( crc byt -- crc' )                                  h pop  d pop  l a mov  e xra  a l mov  d a mov  h dad           tb d lxi  d dad  m xra  h inx  m h mov  a l mov  1push          end-code                                                                                                                      behead tb tb                                                    \ CRC-CCITT                                                     \ x16+x12+x5+1  Initial CRC = $1D0F                                                                                             \ : CRC-CCITT ( crc byt -- crc' )                               \  >< xor 8 0 do dup 0< if 2* $1021 xor else 2* then loop ;                                                                     code CRC-CCITT ( crc byt -- crc' )                                d pop  h pop  e a mov  h xra  a h mov  8 e mvi  1 $:            a ora  l a mov  ral  a l mov  h a mov  ral  a h mov             2 $ jnc  l a mov  $21 xri  a l mov  h a mov  $10 xri            a h mov  2 $:  e dcr  1 $ jnz  1push  end-code                                                                                                                                                                                                                                                                                                                                                \ CRC-CCITT table-driven                                        \ x16+x12+x5+1  Initial CRC = $1D0F                             -? create tb  #256 cells allot                                                                                                  -? : !tb  #256 0 do 0 i >< xor 8 0 do dup 0< if 2* $1021 xor      else 2* then loop i 2* tb + ! loop ;  !tb  forget !tb                                                                         \ : CRC-CCITT ( crc byt -- crc' )                               \  over 8 rshift xor 2* tb + @ swap 8 lshift xor ;                                                                              code CRC-CCITT ( crc byt -- crc' )                                h pop  d pop  l a mov  d xra  a l mov  e a mov  h dad           tb d lxi  d dad  m e mov  h inx  m xra  a h mov  e l mov        1push  end-code                                                                                                               behead tb tb                                                    \ CRC-X25                                                       \ x16+x12+x5+1  Initial CRC = -1, INVERT final CRC                                                                              \ : CRC-X25 ( crc byt -- crc' )                                 \  xor 8 0 do dup 1 and if u2/ $8408 xor else u2/ then loop ;                                                                   code CRC-X25 ( crc byt -- crc' )                                  d pop  h pop  e a mov  l xra  a l mov  8 e mvi  1 $:            a ora  h a mov  rar  a h mov  l a mov  rar  a l mov             2 $ jnc  l a mov  $08 xri  a l mov  h a mov  $84 xri            a h mov  2 $:  e dcr  1 $ jnz  1push  end-code                                                                                                                                                                                                                                                                                                                                                \ CRC-X25 table-driven                                          \ x16+x12+x5+1  Initial CRC = -1, INVERT final CRC              -? create tb  #256 cells allot                                                                                                  -? : !tb  #256 0 do i 8 0 do dup 1 and >r u2/ r> if $8408 xor     then loop i 2* tb + ! loop ;  !tb forget  !tb                                                                                 \ : CRC-X25 ( crc byt -- crc' )                                 \  over xor $FF and cells tb + @ swap 8 rshift xor ;                                                                            code CRC-X25  ( crc byt -- crc' )                                 h pop  d pop  l a mov  e xra  a l mov  d a mov  h dad           tb d lxi  d dad  m xra  h inx  m h mov  a l mov  1push          end-code                                                                                                                      behead tb tb                                                    \ CRC-XMODEM                                                    \ x16+x12+x5+1  Initial CRC = 0                                                                                                 \ : CRC-XMODEM ( crc byt -- crc' )                              \  >< xor 8 0 do dup 0< if 2* $1021 xor else 2* then loop ;                                                                     code CRC-XMODEM ( crc byt -- crc' )                               d pop  h pop  e a mov  h xra  a h mov  8 e mvi  1 $:            a ora  l a mov  ral  a l mov  h a mov  ral  a h mov             2 $ jnc  l a mov  $21 xri  a l mov  h a mov  $10 xri            a h mov  2 $:  e dcr  1 $ jnz  1push  end-code                                                                                                                                                                                                                                                                                                                                                \ CRC-XMODEM table-driven                                       \ x16+x12+x5+1  Initial CRC = 0                                 -? create tb  #256 cells allot                                                                                                  -? : !tb  #256 0 do 0 i >< xor 8 0 do dup 0< if 2* $1021 xor      else 2* then loop i 2* tb + ! loop ;  !tb  forget !tb                                                                         \ : CRC-XMODEM ( crc byt -- crc' )                              \  over 8 rshift xor cells tb + @ swap 8 lshift xor ;                                                                           code CRC-XMODEM ( crc byt -- crc' )                               h pop  d pop  l a mov  d xra  a l mov  e a mov  h dad           tb d lxi  d dad  m e mov  h inx  m xra  a h mov  e l mov        1push  end-code                                                                                                               behead tb tb                                                    \ CRC-32                                                        \ CCITT  Initial CRC = -1, DINVERT final CRC                                                                                    : CRC-32 ( dcrc byt -- dcrc' )                                    8 0 do -rot over 3 pick xor 1 and >r d2/ $7FFF and r> if        $EDB8 xor swap $8320 xor swap then rot 1 rshift loop drop ;                                                                   \ code CRC-32 ( dcrc byt -- dcrc' )                             \  bx pop  ax pop  dx pop  8 # cx mov  1 $: bl bh mov  dl bh xor\  ax 1 shr  dx 1 rcr  bh 1 shr  2 $ jnc  $EDB8 # ax xor        \  $8320 # dx xor  2 $: bl 1 shr  1 $ loop  2push  end-code                                                                     : DINVERT ( d1 -- d2 )  invert swap invert swap ;                                                                                                                                                                                                               \ CRC-32 table-driven                                           \ CCITT  Initial CRC = -1, DINVERT final CRC                    -? create tb  #256 2* cells allot                               -? : !tb  #256 0 do i 0 8 0 do over 1 and >r d2/ $7fff and        r> if $EDB8 xor swap $8320 xor swap then loop i 2* 2*           tb + 2! loop ;  !tb  forget !tb                                                                                               : CRC-32 ( dcrc byt -- dcrc' )                                    2 pick xor $FF and 2* 2* tb + 2@ 2>r 8 0 do                     d2/ loop $FF and r> xor swap r> xor swap ;                                                                                    \ code CRC-32  ( dcrc byt -- dcrc' )                            \  bx pop  ax pop  dx pop  dl bl xor  bx bx add  bx bx add      \  tb # bx add  dh dl mov  al dh mov  ah al mov  ah ah sub      \  0 [bx] ax xor  2 [bx] dx xor  2push  end-code                behead tb tb  : DINVERT ( d1 -- d2 )  invert swap invert swap ; \ BYTE benchmark - Sieve of Eratosthenes                        8190 constant SIZE  create FLAGS  size allot                                                                                    : PRIME ( -- )                                                    flags size 1 fill                                               0 size 0 do                                                       flags i + c@ if                                                   i dup + 3 + dup i +                                             begin dup size <                                                while 0 over flags + c! over +                                  repeat drop drop 1+                                           then                                                          loop cr . ." Primes " ;                                                                                                       : SIEVE ( -- )  cr 10 0 do prime loop ;                                                                                         \ Interface Age benchmark                                       : BENCH ( 1000 -- )                                               dup 2 / 1+ swap cr ." Starting " CR                             1 do dup i 1 rot                                                  2 do drop dup i /mod                                              dup 0= if drop drop 1 leave                                       else 1 = if drop 1                                                else dup 0 > if drop 1                                            else 0= if 0 leave then                                         then                                                          then                                                          then                                                          loop                                                          if 4 .r else drop then                                          loop                                                          drop cr ." Finished. " ;                                      \ Simple locals - based on 'Anonymous Things' FD12/1            \  LOCAL <local>             headerless CREATE                  \ :NONAME ... ;  IS %1       create a nameless function         \ : FUNCTION  ... %1 ... ;   use it in another function         system                                                          : LOCAL ( <local> )  \ assign HERE to a local                     here  ' >body !  $CD c,  'next , ;                                                                                            : LOCAL| ( "name" )  \ define a local                             sys @  system  ['] noop value  immediate  sys !                 does>  @  state @ if  compile,  else  execute  then ;         application                                                     \ predefined locals                                             local| %1  local| %2  local| %3  local| %4                      local| %5  local| %6  local| %7  local| %8                                                                                      \ PARSE-WORD                                                    sys @  system                                                                                                                   : PARSE-WORD ( char -- c-addr u )                                 >r source >in @ /string over swap r@ skip drop                  swap - >in +! r> parse ;                                                                                                      : PARSE-NAME ( -- c-addr u )  bl parse-word ;                                                                                   sys !                                                                                                                                                                                                                                                                                                                                                                                                                                                           \ Multi-dimension array                                         : NARRAY ( dimn..dim1 n itemsize "name" )                         create                                                            >r dup c, 1 swap 0 do over , * loop r> dup , *                  dup 0< abort" array size" allot                               does> ( idxn..idx1 -- addr )                                      count 0 tuck do >r cell+ dup @ rot r> + * loop + cell+ ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \ Multi-dimension array                                         sys @  application                                              -? code doa ( idxn..idx1 -- addr )                                c l mov  b h mov  2 $ shld  b pop  b ldax  b inx  0 h lxi     1 $:  d pop  d dad  psw push  b inx  b inx  b ldax  a e mov       b inx  b ldax  a d mov  b dcx  mulx call  xchg  psw pop         a dcr  1 $ jnz  b inx  b inx  b dad  h push  2 $ lhld           l c mov  h b mov  next  2 $:  0 ,  end-code                                                                                   system                                                          : NARRAY                                                          ['] doa build ( dimn..dim1 n itemsize "name" )                  >r dup c, 1 swap 0 do over , * loop r> dup , *                  dup 0< abort" array size" allot ;                                                                                             sys !  behead doa doa                                           \ F2DUP FTUCK FNIP FCEIL FTRUNC FMOD                            : F2DUP ( r1 r2 -- r1 r2 r1 r2 )  fover fover ;                 : FTUCK ( r1 r2 -- r2 r1 r2 )  fswap fover ;                    : FNIP ( r1 r2 -- r2 )  fswap fdrop ;                                                                                           : FCEIL ( r1 -- r2 )  fnegate floor fnegate ;                   : FTRUNC ( r1 -- r2 )  fdup f0< if fceil else floor then ;                                                                      : FMOD ( r1 r2 -- r3 )  f2dup f/ ftrunc f* f- ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 \ FATAN2                                                        : FATAN2 ( y x -- r )                                             fdup f0< >r                                                     fdup f0= if                                                       fswap f< if                                                       [ pi  0.5e f* ] fliteral                                      else                                                              [ pi -0.5e f* ] fliteral                                      then                                                          else  f/ fatan  then                                            r> if                                                             pi fover f0> if  f-  else  f+  then                           then ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \ FIELD                                                         \ Define a field within a data structure                                                                                        \ : FIELD                                                       \  create ( offs1 size "name" -- offs2 )  over , +              \  does> ( a1 -- a2 )  @ + ;                                                                                                    : FIELD                                                           create ( offs1 size "name" -- offs2 )  over , +                 ;code ( a1 -- a2 )                                                h pop  d pop  m a mov  e add  a e mov  h inx                    m a mov  d adc  a d mov  d push  next  end-code                                                                             aka field +FIELD  \ Forth200x name                                                                                                                                                              \ FIELD                                                         \ Define a field within a data structure                        sys @  application                                              -? code dof ( a1 -- a2 )  h pop ( pfa)                            d pop  m a mov  e add  a e mov  h inx                           m a mov  d adc  a d mov  d push  next  end-code                                                                               system                                                          : FIELD ( offs1 size "name" -- offs2 )                            ['] dof build over , + ;                                                                                                      sys !  behead dof dof                                                                                                           aka field +FIELD  \ Forth200x name                                                                                                                                                              \ FVALUE FTO                                                    sys @  system                                                                                                                   : FVALUE  ['] f@ build f, ;                                                                                                     : FTO ( r "name" -- )  postpone addr                              state @ if  postpone f!  else  f!  then ; immediate                                                                           sys !                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \ @+ !+                                                         \ : @+ ( a1 -- a2 n )  dup 2+ swap @ ;                          \ : !+ ( n a1 -- a2 )  tuck ! 2+ ;                                                                                              code @+ ( a1 -- a2 n )                                            h pop  m e mov  h inx  m d mov  h inx  xchg  2push            end-code                                                                                                                        code !+ ( n a1 -- a2 )                                            h pop  d pop  e m mov  h inx  d m mov  h inx  1push           end-code                                                                                                                                                                                                                                                                                                                                                                                        \ F@+                                                           \ : F@+ ( a1 -- a2 r )                                          \  dup [ 1 floats ] literal + swap f@ ;                                                                                         code F@+ ( a1 -- a2 r )                                           d pop  1 floats h lxi  d dad  h push  d push  ' f@ jmp        end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \ R-BUF                                                         \ Allocate u bytes on return stack. R@ gives buffer address.    \ Discard return stack item before exiting definition.                                                                          -? label rb  \ discards buffer on exit                            here cell+ ,  rpp lhld  m e mov  h inx  m d mov  xchg           rpp shld  ' (exit) jmp  end-code                                                                                              code R-BUF ( u -- )                                               d pop  b push  rpp lhld  h b mov  l c mov  dsub call            h push  h dcx  b m mov  h dcx  c m mov  rb d lxi                h dcx  d m mov  h dcx  e m mov  d pop  h dcx  d m mov           h dcx  e m mov  rpp shld  b pop  next  end-code                                                                               behead rb rb                                                                                                                    \ Z80 16-bit multiply/divide subroutine                         label MUL16  \ Multiply  HL <- HL*DE                              b push  h b mov  l c mov  0 h lxi  #16 a mvi                    1 $:  b srlr  c rarr  2 $ jnc  d dad  2 $:                      e slar  d ralr  a dcr  1 $ jnz  b pop  ret                    end-code                                                                                                                        label DIV16  \ Divide  HL <- HL/DE  DE <- rem                     b push  h b mov  l c mov  0 h lxi  #16 a mvi                    1 $:  c ralr  b ralr  h dadc  d dsbc  2 $ jnc                   d dad  2 $:  cmc  a dcr  1 $ jnz  c ralr                        b ralr  b d mov  c e mov  xchg  b pop  ret                    end-code                                                                                                                                                                                                                                                        \ 8080 16-bit multiply/divide subroutine                        label MUL16  \ Multiply  HL <- HL*DE                              b push  d b mov  e c mov  0 d lxi  1 $:  a ora  b a mov         rar  a b mov  c a mov  rar  a c mov  2 $ jnc  xchg  d dad       xchg  2 $:  h dad  b a mov  c ora  1 $ jnz  b pop  ret        end-code                                                                                                                        label DIV16  \ Divide  HL <- HL/DE  DE <- rem                     e a mov  d ora  rz  b push  a xra  xchg  1 $:  a inr  h dad     1 $ jnc  xchg  e c mov  d b mov  0 d lxi  2 $:  psw push        b a mov  rar  a b mov  c a mov  rar  a c mov  stc  e a mov      ral  a e mov  d a mov  ral  a d mov  l a mov  c sbb             a l mov  h a mov  b sbb  a h mov  3 $ jnc  b dad  e dcr         3 $:  psw pop  a ora  a dcr  2 $ jnz  xchg  b pop  ret        end-code                                                                                                                        \ Euclidean division                                            \ Returns positive remainder irrespective of input sign         \ Ref: 'divmodnote.pdf' D.Leijen                                                                                                : E/MOD ( dividend divisor -- rem quot )                          >r s>d r@ sm/rem over 0< if                                       r@ 0> if                                                          1- swap r@ + swap                                             else                                                              1+ swap r@ - swap                                             then                                                          then  r> drop ;                                                                                                                                                                                                                                                                                                               \ ANEW                                                          system                                                          : ANEW ( "name" )                                                 >in @  postpone [defined]  if  dup >in !  forget  then          >in !  marker ;                                               application                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     