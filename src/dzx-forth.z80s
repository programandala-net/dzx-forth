; DZX-Forth {{{

_version: macro
  version.major:                equ 'A'         ; = alpha state
  db version.major
  version.minor:                equ 3           ; branch
  db '-0',version.minor+'0','-'
  db                            '201502202215'  ; release
  endm

; A direct-threaded Forth for ZX Spectrum,
; with support for +3DOS and IDEDOS
;
; (Project under development)
;
; DZX-Forth is a fork of CP/M DX-Forth v4.09 (2014-12)

; Copyright (C) 2014,2015 Marcos Cruz (programandala.net)
;
; DZX-Forth is free software; you can redistribute it and/or modify it under
; the terms of the GNU General Public License as published by the Free Software
; Foundation; either version 3 of the License, or (at your option) any later
; version.
;
; DZX-Forth is distributed in the hope that it will be useful, but WITHOUT ANY
; WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
; A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License along with
; DZX-Forth; if not, see <http://gnu.org/licenses>.

; Version history: see the file <VERSIONS.md>.
; TO-DO list: see the file <TO-DO.md>.

; }}} **********************************************************
; Boot {{{

start: equ 25000 ; start of DZX-Forth in memory

  org start

  jp cold_boot
;  jp warm_boot  ; XXX TODO

; }}} **********************************************************
; Labels {{{

; ------------------------------
; Naming convention

; In order to prevent name clashes and make the code more legible, the
; following convention was adopted:

; A "?" suffix means the label is a boolean used for configuration by
; conditional assembling.

; A "_" prefix means the label is a Z80 macro or a macro parameter.

; A "_" suffix means the label is the code address of a Forth word (its actual
; code address, the xt, not the cfa).  The label itself is the name of the
; word, after its latest standard (Forth 2012, Forth 94, Forth 83...).  Other
; labels in the same word add its own suffix, separated by a dot.

; Other labels have no affix.

; ------------------------------

; }}} **********************************************************
; System configuration {{{

; ------------------------------
; Generic

true:   equ -1
false:  equ 0
yes:    equ true
no:     equ false

; ------------------------------
; System

cell:   equ 2 ; cell size (bytes)

top_prunes:             defl 0 ; XXX OLD ?

; XXX TODO Convert stack sizes to user variables? The point is
; a task could need just a little stack.

parsed_string_buffer_size:    equ 255 ; XXX TODO create a circular string buffer
user_data_size:               equ 128
max_word_length:              equ 31
word_buffer_size:             equ max_word_length+5

; ------------------------------
; ZX Spectrum

  include "zx_spectrum_system_variables.z80s"
  include "zx_spectrum_rom_routines.z80s"
  include "zx_spectrum_char_codes.z80s"
  include "zx_spectrum_colors.z80s"

bank1_port: equ 0x07FFD ; "horizontal" and RAM switch port
bank2_port: equ 0x01FFD ; "vertical" switch port

lf_char:                    equ 0x0A ; line feed ; XXX OLD?
ff_char:                    equ 0x0C ; form feed (printer only)
cursor_left_word_char:      equ 0x18 ; XXX TODO -- implement
cursor_right_word_char:     equ 0x19 ; XXX TODO -- implement

ctrl_z_char:                equ 0x1A ; used by +3DOS to pad the files

; ------------------------------
; +3DOS

  include "zx_spectrum_plus3dos.z80s"

max_file_id:            equ 15 ; 0..15 are the possible file numbers in +3DOS
max_file_ids:           equ max_file_id+1

filename_size:          equ 16 ; "uud:nnnnnnnn.eee"
filename_buffer_size:   equ filename_size+1 ; for trailing 0xFF
;file_handle_size:       equ 6+36  ; (keep even) ; XXX OLD


; }}} **********************************************************
; User configuration {{{

; The values in this section may be changed by the user in order to assemble a
; specific version of DZX-Forth, with or without certain features.

; XXX TODO organize and documentate

debug?:                           equ no ; debugging messages?

debug_blocks?: equ no  ; XXX TMP

case_insensitive_names?:          equ yes
control_flow_stack_extensions?:   equ yes
warning_options?:                 equ no ; XXX TODO does this causes trouble?

; XXX FIXME when yes, some things don't work fine:
size_optimization?:                equ no ; if yes, the code will be smaller but slower

; Where the xt of a defered body is stored and managed.
; yes = the xt is stored into the pfa, so 'is' and 'to' are synonyms.
; no  = the xt is stored as a jump address; this saves one byte and is faster.
; XXX TODO -- the 'no' option is not fully implemented yet
defer_uses_body?:                  equ yes

floored_division?:                 equ yes  ; integer division method

; ..............................

block_files?:                     equ yes
; XXX Note: >1743 bytes used

if block_files?
  max_open_source_files:  equ 6  ; (min = 2) ; XXX OLD
  block_size:                   equ 1024
endif

; ..............................

; user config

floating_point?:           equ no
; XXX Note: aprox. 2336 bytes used

if floating_point?
  floating_point_engineering_output?:  equ yes
  floating_point_stack?:               equ no ; XXX TODO -- not fully implemented in DX-Forth
  if floatin_poin_stack?
    f_stack_items: defl 6
  endif
endif

; system

; f_init_patch:     defl noop_ ; XXX OLD
; f_identify_patch: defl noop_ ; XXX OLD
; f_number_patch:   defl false_ ; XXX OLD
f_stack_items:    defl 0
f_stack_size:     defl 0 ; bytes

  if floating_point?

    floating_point_engineering_output?:  equ yes
    floating_point_stack?:                equ no ; XXX TODO -- not fully implemented in DX-Forth

    float:  equ 4 ; floating point number size (bytes) ; XXX TODO move to 'float'?

    max_significant_digits: equ 7

;    f_init_patch:     defl f_init_ ; XXX OLD
;    f_identify_patch: defl f_identify_ ; XXX OLD
;    f_number_patch:   defl f_number_ ; XXX OLD

    if floating_point_stack?
      f_stack_size:  defl (f_stack_items+5)*float ; allow extra for fp display etc
    endif

;    top_prunes: defl paren_minus_fp_.1 ; XXX OLD

  else
    ; defaults
    floating_point_engineering_output?:   equ no
    floating_point_stack?:                equ no
endif

; ..............................

circular_string_buffer?: equ yes
if circular_string_buffer?
  cbs_size: equ 512
endif

classic_Forth_behaviours?:         equ no ; XXX OLD ; XXX TODO study and remove
tib?:                        equ yes ; include the obsolescent words 'tib' and '#tib'?

fast_emit?:                        equ yes ; if yes, some words jump directly into '(emit_)', don't call 'emit'

; XXX TMP
restore_user?           equ no ; define the word 'restore-user'? (it needs 28 bytes)

pictured_numeric_output_buffer_size:  equ 34 ; XXX it was 68 in DX-Forth, why? -- min: 2 x cell_bits + 2 = 34
stack_size:                           equ 256
return_stack_size:                    equ 256
tib_size:                             equ 80    ; Terminal Input Buffer

; }}} **********************************************************
; Description {{{

; ------------------------------
; Forth Registers
;
; Forth Z80  Forth preservation rules
; ----- ---  ------------------------
; IP    BC   Interpretive pointer. Should be preserved across
;            Forth words.
; SP    SP   Data stack pointer. Should be used only as data
;            stack across Forth words. May be used within Forth
;            words if restored before NEXT.
;       DE   Input only when pushde called.
;       HL   Input only when pushhl called.

; ------------------------------
; Stack comment conventions:
;
; a       = address
; aa      = cell-aligned address
; ca      = character-aligned address
; fa      = float-aligned address
; false   = boolean flag (0)
; f       = flag (false is 0; true is any other value)
; wf      = well-formed flag (false is 0; true is -1)
; c       = 8-bit character
; u       = 16-bit unsigned number
; len     = 16-bit unsigned number, length of memory zone or string
; ca len  = string
; n       = 16-bit signed number
; x       = 16-bit signed or unsigned number
; d       = 32-bit signed double number
; ud      = 32-bit unsigned double number
; xd      = 32-bit signed or unsigned number
; xt      = execution token (same as cfa) ; XXX FIXME
; cfa     = address of code field (same as xt) ; XXX FIXME
; lfa     = address of link field
; nfa     = address of name field
; pfa     = address of parameter field (body)
; true    = boolean flag (-1)
; orig    = address of a control structure origin
; fam     = file access method

; ------------------------------
; Header structure

; nfa db length+flags     ; length = 1..max_word_length
;     ds length           ; name
; lfa dw previousnfa
; cfa dw codeaddress
; pfa ds ...              ; data or code

; ------------------------------
; Memory map

; XXX TODO -- unfinished

; <----- 0xFFFF, top of memory
; UDG definitions ; XXX OLD
; <---- UDG system variable ; XXX OLD
; ... free dictionary space
; PAD buffer
; <---- PAD
; picture numeric output buffer
; <---- DP
; ... used dictionary space
;
; circular string buffer XXX TODO
;
; parsed string buffer XXX OLD
; WORD buffer XXX OLD
;
; <---- F0 (bottom of floating point stack)
; ...  floating point stack (grows toward low memory)
; <---- FP@
; ...
; <---- R0 (bottom of return stack)
; ...  return stack (grows toward low memory)
; <---- RP@
; ...
; <---- S0 (bottom of data stack)
; ... data stack (grows toward low memory)
; <---- SP@
; ...
; User data area
; <---- UDP (User Data Pointer)
; Terminal Input Buffer
; <---- TIB
; boot jumps
; <---- DZX-Forth origin
; <---- BASIC's RAMTOP
; ...
; BASIC program and variables
; system variables
; <----- 0x5B00
; screen
; <----- 0x4000
; ROM
; <----- 0x0000, bottom of memory

; }}} **********************************************************
; Macros {{{

; ------------------------------
; Word header

alias_bit:          equ 7
alias_mask:         equ 1 shl alias_bit
immediate_bit:      equ 6
immediate_mask:     equ 1 shl immediate_bit
smudge_bit:         equ 5
smudge_mask:        equ 1 shl smudge_bit

_public:      equ yes
_hidden:      equ yes ; create headers of hidden words? ; XXX TODO rename
_immediate:   equ yes

previous_nfa: defl 0   ; initial link pointer (end of chain)

_header: macro enabled,name,immediate,alias_xt

  ; enabled     = (yes/no, _public/_hidden)
  ; name        = name string
  ; immediate   = _immediate or nothing
  ; alias_xt    = alias xt

  if enabled

    ; the name field
    last_nfa: defl $ ; link address for next word
    bits: defl 0
    if not nul immediate
      ; set immediate bit
      bits: defl bits | immediate_mask
    endif
    if not nul alias_xt
      ; set alias bit
      bits: defl bits | alias_mask
    endif
    local _first ; address of the first char of the name
    local _next  ; address after the last char of the name
    db _next-_first+bits    ; count and flags byte
    _first: db name
    _next:

    ; the link field
    dw previous_nfa

    ; the code field
    if nul alias_xt
      last_xt: defl $+2
    else
      last_xt: defl alias_xt
    endif
    dw last_xt
    previous_nfa: defl last_nfa

  endif

endm

; ------------------------------
; Counted string

_dcs: macro string.1,string.2,string.3,string.4 ; allow comma separated strings
  local _first,_next
  db _next-_first ; count byte
  _first: db string.1
  if not nul string.2
    db string.2
    if not nul string.3
      db string.3
      if not nul string.4
        db string.4
      endif
    endif
  endif
  _next:
endm

; ------------------------------
; Save and restore the Forth IP

; This is used when a ROM call needs many parameters and all of them can not be
; taken from stack in order to push BC before the call

_do_save_ip: macro
  ld h,b           ;  4 t
  ld l,c           ;  4 t
  ld (saved_ip),hl ; 16 t
  endm

_save_ip: macro
  if size_optimization?
    call save_ip
  else
    _do_save_ip ; inline code
  endif
endm

if 1;size_optimization? ; XXX TMP
  save_ip:
    _do_save_ip
    ret
endif

restore_ip:
saved_ip: equ $+1
  ld bc,0 ; patched by save_ip
  ret

; ------------------------------
; Size-optimized jumps

; Create relative or absolute jumps, depending on the configured optimization

_jump: macro _address
  if size_optimization?
    jr _address
  else
    jp _address
  endif
  endm

_jump_nc: macro _address
  if size_optimization?
    jr nc,_address
  else
    jp nc,_address
  endif
  endm

_jump_z: macro _address
  if size_optimization?
    jr z,_address
  else
    jp z,_address
  endif
  endm
  
_push_hl_jp_next: macro
  if size_optimization?
    jp push_hl
  else
    push hl
    jp next
  endif
  endm

; ------------------------------
; Debug

_show_depth: macro
  dw paren_dot_quote_
  _dcs 'Depth is '
  dw depth_,dot_,cr_
  endm

_border_halt: macro color

  ; Debug check point

  ; Change the border to the given color (red by default) and halt.

  local border_color
  border_color: defl red_color
  if not nul color
    border_color: defl color
  endif
  ld a,border_color
  out (254),a
  jr $
  endm

_debug: macro message,flag

  ; Debug check point for colon definitions
  ; 
  ; If the given flag is not zero or the 'debug?' label is not zero, then show
  ; the given message, show the content of the stack and wait for a key.

  local show
  show: defl false
  if not nul flag
    show: defl flag
  endif
  if debug? or show
    dw cr_,paren_dot_quote_
    _dcs message
    dw cr_,dot_s_
    dw cr_,paren_dot_quote_
    _dcs "Press any key"
    dw key_,drop_,cr_
  endif

  endm

_debug_variable: macro message,address

  ; Debug check point for colon definitions, depending on a variable
  ;
  ; 
  ; If the content of the given address is not zero, then show the given
  ; message, show the content of the stack and wait for a key.

  local _debug_variable.the_end

  if debug?
      dw lit_,address,fetch_
      dw branch_if_0_,_debug_variable.the_end
      _debug message,true
    _debug_variable.the_end: equ $
  endif

  endm

; }}} **********************************************************
; Data zones {{{

tib_address:
  ds tib_size ; terminal input buffer

user_data:
  ds user_data_size

stack_end:
  ds stack_size
stack_0:

return_stack_end:
  ds return_stack_size
return_stack_0:

  if floating_point? and floating_point_stack?
      ds float_stack_size
    float_stack_0:
  endif

  if circular_string_buffer?

    csb_unused:  dw cbs_size
    csb0:        ds cbs_size

;  else
  endif

    parsed_string_buffer:
      if classic_Forth_behaviours?
        ; buffer of 's"'
        ds parsed_string_buffer_size
      else
        ; buffer of 's"' and 'word'
        ds parsed_string_buffer_size+word_buffer_size
      endif

;  endif

hm: equ $   ; system definitions and header memory ; XXX OLD ?

dummy_nfa: ; XXX OLD ?
  db 0   ; dummy nfa - don't remove! ; XXX NEW -- changed its position in DX-Forth 4.09

user_data_pointer:
  dw user_data
return_stack_pointer:
  dw return_stack_0

; cpu speed (TURBO PASCAL compatible)
; XXX OLD -- not needed, unless the OS is not used
; XXX TODO convert into a variable, or calculate depending o the host machine
speed:
  dw 4   ; 1..8191 MHz

; ------------------------------
; Init user variables

; They are copied by 'COLD' into the user data area
; and must be in same order as 'USER' variables.

init_user_variables: ; start of data

                ds 3*cell     ; 00..04 = reserved for multitasking
cold_s0:        dw stack_0  ; 06 = s0
cold_r0:        dw return_stack_0 ; 08 = r0
cold_dp:        dw init_dp  ; 10 = dp
cold_dph:       equ cold_dp ; XXX TMP -- still used by old code
                dw init_dp  ; 12 = not used ; XXX FIXME still fetched by 'empty'
cold_voc_link:  dw forth_.2  ; 14 = voc-link
cold_fs0:                   ; 16 = fs0

  if floating_point? and floating_point_stack? ; XXX TODO
                dw float_stack_0 ; 16 = fs0
  else
                dw 0             ; 16
  endif
                ds cell       ; 18 = reserved

init_user_variables_size: equ $-init_user_variables

; ------------------------------

;esm:
;  ds cell    ; end of memory pointer
; XXX OLD
;;initbootxt:
;;  dw noop
;default_drive: ; XXX TODO convert to user variable?
;  db 'A'
;default_user: ; XXX TODO convert to user variable?
;  db 0
; XXX OLD
;;scaps:   ; XXX converted to user variable
;;  ds 1   ; 'compare' and 'search' case flag
; XXX OLD
;;ulimit:
;;  ds cell    ; LIMIT for turnkey ; XXX NEW -- from DX-Forth 4.09
;;  ds 2   ; spare


; }}} **********************************************************
; Misc. subroutines {{{

; ------------------------------
; BC is preserved

de_minus_hl_to_hl:
  ; Input:  de, hl
  ; Output: hl = de-hl
  ex de,hl

hl_minus_de_to_hl:
  ; Input:  de, hl
  ; Output: hl = hl-de
  ld a,l
  sub e
  ld l,a
  ld a,h
  sbc a,d
  ld h,a
  ret

compare_de_hl_unsigned:
  ; Input:  de, hl
  ; Output:
  ;  flag C if hl < de
  ;  flag Z if hl = de
  ld a,h
  cp d
  ret nz
  ld a,l
  cp e
  ret

compare_de_hl_signed:
  ; Input:  de, hl
  ; Output: flag C if hl < de
  ld a,h
  xor d
  jp p,compare_de_hl_unsigned
  ld a,h
  or a
  ret p
  scf
  ret

; ------------------------------
; BC is affected

move_block_upwards:

  ; Move block upwards
  ; hl = source
  ; de = destination
  ; bc = count

  add hl,bc
  ex de,hl
  add hl,bc
  ex de,hl
move_block_upwards.1:
  ld a,c
  or b
  ret z
  dec hl
  dec de
  ld a,(hl)
  ld (de),a
  dec bc
  jp move_block_upwards.1

move_block:

  ; Move block up/down
  ; hl = source
  ; de = destination
  ; bc = count

  call compare_de_hl_unsigned
  jp c,move_block_upwards

move_block_downwards:

  ; Move block downwards
  ; hl = source
  ; de = destination
  ; bc = count

  ld a,c
  or b
  ret z
  ld a,(hl)
  ld (de),a
  inc hl
  inc de
  dec bc
  jp move_block_downwards

; XXX OLD -- not used
; amovd: ; XXX OLD name
; move_block_downwards.a:

;   ; Move block downwards
;   ; hl = source
;   ; de = destination
;   ; a  = count

;   push bc
;   ld c,a
;   ld b,0
;   call move_block_downwards
;   pop bc
;   ret

; }}} **********************************************************
; Virtual machine {{{

; XXX TODO -- add headers?
do_create:        equ next
do_variable:      equ next
do_value:         equ fetch_
do_constant:      equ fetch_
do_two_constant:  equ two_fetch_
do_byte_constant: equ c_fetch_

; runtime for colon definitions

; XXX TODO -- add a header
do_colon:
  ld hl,(return_stack_pointer)  ; push IP onto return stack
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c
  ld (return_stack_pointer),hl
  pop bc    ; get new IP from 'call'
  jp next

; runtime for user variables

; XXX TODO -- add a header
do_user_variable:
  pop hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  ld hl,(user_data_pointer)
  add hl,de
  _push_hl_jp_next

; NOOP  ( -- )

  _header _public,'NOOP'
noop_: equ $

; NEXT - The Forth Address Interpreter

next:
  ld a,(bc)   ; 7T
  ld l,a      ; 4T
  inc bc      ; 6T
  ld a,(bc)   ; 7T
  ld h,a      ; 4T
  inc bc      ; 6T
  jp (hl)     ; 4T

; UNNEST  ( -- )

  _header _public,'UNNEST',,r_drop_
unnest_: equ r_drop_

; (EXIT)  ( -- )
;   exit colon definition

  _header _public,'(EXIT)'
paren_exit_: ; XXX TODO rename 'paren_exit'
  ld bc,next
  push bc
  ld hl,(return_stack_pointer)  ; pop IP from return stack
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ld (return_stack_pointer),hl
  ret ; execute NEXT

; EXECUTE  ( xt -- )

  _header _public,'EXECUTE'
execute_:
  ret

; @?EXECUTE  ( a -- )

  _header _public,'@?EXECUTE'
fetch_question_execute_:
  pop hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  or h
  jp z,next
  jp (hl)

; @EXECUTE  ( a -- )

  _header _public,'@EXECUTE'
fetch_execute_:
  pop hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  jp (hl)

; CLIT  ( -- c )

  _header _hidden,'CLIT'
c_lit_:
  ld a,(bc)
  inc bc

push_a:
  ld l,a
push_l:
  ld h,0
push_hl:
  push hl
  jp next

; LIT  ( -- n )

  _header _hidden,'LIT'
lit_:
  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a
  inc bc
  _push_hl_jp_next

; 2LIT  ( -- d )

  _header _hidden,'2LIT'
two_lit_:
  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a
  inc bc
  ld a,(bc)
  ld e,a
  inc bc
  ld a,(bc)
  ld d,a
  inc bc
  jp push_de_hl

; }}} **********************************************************
; Stack pointer manipulation {{{

; SP@  ( -- a )

  _header _public,'SP@'
sp_fetch_:
  ld hl,0
  add hl,sp
  _push_hl_jp_next

; SP!  ( a -- )

  _header _public,'SP!'
sp_store_:
  pop hl
  ld sp,hl
  jp next

; RP@  ( -- a )

  _header _public,'RP@'
rp_fetch_:
  ld hl,(return_stack_pointer)
  _push_hl_jp_next

; RP!  ( a -- )

  _header _public,'RP!'
rp_store_:
  pop hl
  ld (return_stack_pointer),hl
  jp next

; }}} **********************************************************
; Return stack {{{

; >R  ( x -- )

  _header _public,'>R'
to_r_:
  ld hl,(return_stack_pointer)
  pop de
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e
  ld (return_stack_pointer),hl
  jp next

; R>  ( -- x )

  _header _public,'R>'
from_r_:
  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (return_stack_pointer),hl
push_de:
  push de
  jp next

; R@  ( -- x )

  _header _public,'R@'
r_fetch_:
  ld hl,(return_stack_pointer)
  jp fetch_.1

; 2>R  ( x1 x2 -- )

  _header _public,'2>R'
two_to_r_:
  ld hl,(return_stack_pointer)
  ; XXX TODO faster per macro loop with 'inc hl'?
  ld de,-cell*2
  add hl,de
  ld (return_stack_pointer),hl
  jp two_store_.into_hl_pointer

; 2R>  ( -- x1 x2 )

  _header _public,'2R>'
two_from_r_:
  ld hl,(return_stack_pointer)
  push hl
  ld de,cell*2
  add hl,de
  ld (return_stack_pointer),hl
  jp two_fetch_

; 2R@  ( -- x1 x2 )

  _header _public,'2R@'
two_r_fetch_:
  ld hl,(return_stack_pointer)
  jp two_fetch_.hl

; RDROP  ( -- ) ; XXX NEW

  _header _public,'RDROP'
r_drop_:
rdrop_:
  ld hl,(return_stack_pointer)
  inc hl
  inc hl
  ld (return_stack_pointer),hl
  jp next

; }}} **********************************************************
; Data stack {{{

; DROP  ( x -- )

  _header _public,'DROP'
drop_:
  pop hl
  jp next

; 2DROP  ( x1 x2 -- )

  _header _public,'2DROP'
two_drop_:
  pop hl
  pop hl
  jp next

; DUP  ( x -- x x )

  _header _public,'DUP'
dup_:
  pop hl
  push hl
  if size_optimization? ; XXX TODO -- levels of optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; ?DUP  ( x -- 0 | x x )

  _header _public,'?DUP'
question_dup_:
  pop hl
  ld a,l
  or h
  _jump_z question_dup_.end
  push hl
question_dup_.end:
  _push_hl_jp_next

; SWAP  ( x1 x2 -- x2 x1 )

  _header _public,'SWAP'
swap_:
  pop hl
  ex (sp),hl
  _push_hl_jp_next

; OVER  ( x1 x2 -- x1 x2 x1 )

  _header _public,'OVER'
over_:
  pop de
  pop hl
  push hl
  jp push_de_hl

; ROT  ( x1 x2 x3 -- x2 x3 x1 )

  _header _public,'ROT'
rot_:
  pop de
  pop hl
  ex (sp),hl
  jp push_de_hl

; -ROT  ( x1 x2 x3 -- x3 x1 x2 )

  _header _public,'-ROT'
minus_rot_:
  pop hl
  pop de
  ex (sp),hl
  ex de,hl
  jp push_de_hl

; ROLL  ( xu xn .. x0 u -- xn .. x0 xu )

  _header _public,'ROLL'
roll_:
  pop hl
  add hl,hl
  ld e,l
  ld d,h
  add hl,sp
  push bc
  ld c,(hl)
  inc hl
  ld b,(hl)
  push bc
  ld c,e
  ld b,d
  ld e,l
  ld d,h
  inc de
  dec hl
  call move_block_upwards.1
  pop hl
  pop bc
  ex (sp),hl
  jp next

if control_flow_stack_extensions?

; -ROLL  ( xu .. xu+1 x0 u -- x0 xu .. xu+1 )

  _header _public,'-ROLL'
minus_roll_:
  pop hl
  add hl,hl
  ex de,hl
  ld hl,0
  add hl,sp
  push bc
  ld c,(hl)
  inc  hl
  ld b,(hl)
  push bc
  ld c,e
  ld b,d
  ld e,l
  ld d,h
  dec  de
  inc  hl
  call move_block_downwards
  pop hl
  pop bc
  ex de,hl
  jp store_.de_into_hl_pointer

endif

; PICK  ( xu .. x1 x0 u -- xu .. x1 x0 xu )

  _header _public,'PICK'
pick_:
  pop hl
  add hl,hl
  add hl,sp
  jp fetch_.1

; NIP  ( x1 x2 -- x2 )

  _header _public,'NIP'
nip_:
  pop hl
  inc sp
  inc sp
  _push_hl_jp_next

; TUCK  ( x1 x2 -- x2 x1 x2 )

  _header _public,'TUCK'
tuck_:
  pop hl
  pop de
  push hl
  jp push_de_hl

; 2DUP  ( x1 x2 -- x1 x2 x1 x2 )

  _header _public,'2DUP'
two_dup_:
  pop hl
  pop de
  push de
  push hl
  jp push_de_hl

; 2SWAP  ( x1 x2 x3 x4 -- x3 x4 x1 x2 )

  _header _public,'2SWAP'
two_swap_:
; XXX OLD -- DX-Forth 4.00
;;  pop de
;;  pop hl
;;  inc sp
;;  inc sp
;;  ex (sp),hl
;;  dec sp
;;  dec sp
;;  ex de,hl
;;  ex (sp),hl
;;  jp pushde
; XXX NEW -- DX-Forth 4.09
  pop hl
  pop de
  ex (sp),hl
  push hl
  ld hl,5
  add hl,sp
  ld a,(hl)
  ld (hl),d
  ld d,a
  dec  hl
  ld a,(hl)
  ld (hl),e
  ld e,a
  pop hl
  jp push_de_hl

; 2OVER  ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )

  _header _public,'2OVER'
two_over_:
  ld hl,4
  add hl,sp
  jp two_fetch_.hl

; 2ROT  ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
;  5 roll 5 roll

  _header _public,'2ROT'
two_rot_:
  call do_colon
  dw c_lit_
  db 5
  dw roll_
  dw c_lit_
  db 5
  dw roll_
  dw paren_exit_

; 2NIP  ( x1 x2 x3 x4 -- x3 x4 )

  _header _public,'2NIP'
two_nip_:
  pop hl
  pop de
  inc  sp
  inc  sp
  inc  sp
  inc  sp
push_de_hl: ; XXX this is DX-Forth's dpush
  push de
  _push_hl_jp_next

; DEPTH  ( -- u )
;   sp@ s0 @ swap - 2/

  _header _public,'DEPTH'
depth_:
  call do_colon
  dw sp_fetch_
  dw s0_,fetch_
  dw swap_,minus_
  dw two_slash_
  dw paren_exit_

; MAXDEPTH-.S  ( -- a )
; XXX NEW -- after Gforth
; max items shown by '.s'
  ; XXX TODO -- make it optional

  _header _public,'MAXDEPTH-.S'
maxdepth_dot_s_:
  call do_create
  dw 9 ; default

; .S  ( -- )
; XXX NEW -- after Gforth

  ; XXX TODO -- make it optional
  _header _public,'.S'
dot_s_:
  call do_colon
  ; show the depth:
  dw depth_
  dw c_lit_
  db '<'
  dw emit_,zero_,dot_r_
  dw c_lit_
  db '>'
  dw emit_,space_
  ; calculate the items to show:
  dw depth_,zero_,max_,maxdepth_dot_s_,fetch_,min_
  ; do it:
  dw dup_,zero_
  dw paren_question_do_,dot_s_.end
dot_s_.do:
  dw dup_,i_,minus_,pick_,dot_
  dw paren_loop_,dot_s_.do
dot_s_.end:
  dw drop_
  dw paren_exit_

; BOUNDS  ( ca len -- ca1 ca )

  _header _public,'BOUNDS'
bounds_:
  call do_colon
  dw over_,plus_,swap_
  dw paren_exit_

; DUMP  ( ca len -- )

  ; XXX TMP -- for debugging
  _header _public,'DUMP'
dump_:
  call do_colon
  dw cr_,base_,fetch_,to_r_,hex_
  dw bounds_,paren_question_do_,dump_.end
dump_.do:
  dw i_,dup_,u_dot_,c_fetch_,dup_,u_dot_
  dw dup_
  dw c_lit_
  db sp_char
  dw less_
  dw branch_if_false_,dump_.emit
  dw drop_
  dw c_lit_
  db '.'
dump_.emit
  dw emit_,cr_
  dw paren_loop_,dump_.do
dump_.end:
  dw from_r_,base_,store_
  dw paren_exit_

; }}} **********************************************************
; Memory operations {{{

; @  ( aa -- x )

  _header _public,'@'
fetch_:
  pop hl
fetch_.1:
  ld e,(hl)
  inc hl
  ld d,(hl)
  if size_optimization?
    jp push_de
  else
    push de
    jp next
  endif

; 2!  ( x1 x2 aa -- )

  _header _public,'2!'
two_store_:
  pop hl
two_store_.into_hl_pointer:
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  jp store_.into_hl_pointer

; !  ( x aa -- )

  _header _public,'!'
store_:
  pop hl
store_.into_hl_pointer:
  pop de
store_.de_into_hl_pointer:
  ld (hl),e
  inc hl
  ld (hl),d
  jp next

; C@  ( ca -- c )

  _header _public,'C@'
c_fetch_:
  pop hl
  ld l,(hl)
  ld h,0
  _push_hl_jp_next

; C!  ( c ca -- )

  _header _public,'C!'
c_store_:
  pop hl
  pop de
  ld (hl),e
  jp next

; 2@  ( aa -- x1 x2 )

  _header _public,'2@'
two_fetch_:
  pop hl
two_fetch_.hl:
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  ex de,hl
  jp push_de_hl

; +!  ( x aa -- )

  _header _public,'+!'
plus_store_:
  pop hl
  pop de
plus_store_.de_into_hl:
  ld a,(hl)
  add a,e
  ld (hl),a
  inc hl
  ld a,(hl)
  adc a,d
  ld (hl),a
  jp next

; MOVE  ( a1 a2 u -- )

  _header _public,'MOVE'
move_:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
  call move_block
  pop bc
  jp next

; ERASE  ( a len -- )

  _header _public,'ERASE'
erase_:
  ld e,0
  jp fill_.1

; FILL  ( ca len c -- )

  _header _public,'FILL'
fill_:
  pop de
fill_.1:
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
  jp fill_.3

fill_.2:
  ld (hl),e
  inc hl
  dec bc
fill_.3:
  ld a,c
  or b
  jp nz,fill_.2
  pop bc
  jp next

; ON  ( a -- )
;   -1 swap !

  _header _public,'ON'
on_:
  pop hl
on_.hl:
  ld de,true
  jp store_.de_into_hl_pointer

; OFF  ( a -- )
;   0 swap !

  _header _public,'OFF'
off_:
  pop hl
off_.hl:
  ld de,false
  jp store_.de_into_hl_pointer

; CTOGGLE  ( x ca -- )

  _header _public,'CTOGGLE'
c_toggle_:
  pop hl
c_toggle_.hl:
  pop de
  ld a,(hl)
  xor e
  ld (hl),a
  jp next

; CHAR+  ( ca1 -- ca2 )

  _header _public,'CHAR+',,one_plus_
char_plus_: equ one_plus_

; CHAR-  ( ca1 -- ca2 )

  _header _public,'CHAR-',,one_minus_
char_minus_: equ one_minus_

; CHARS  ( n1 -- n2 )

  _header _public,'CHARS',_immediate,noop_
chars_: equ next

; CELL  ( -- u ) ; XXX NEW

  _header _public,'CELL',,two_
cell_: equ two_

; CELL+  ( a1 -- a2 )

  _header _public,'CELL+',,two_plus_
cell_plus_: equ two_plus_

; CELL-  ( a1 -- a2 )

  _header _public,'CELL-',,two_minus_
cell_minus_: equ two_minus_

; CELLS  ( n1 -- n2 )

  _header _public,'CELLS',,two_star_
cells_: equ two_star_

; ALIGN  ( -- )

  _header _public,'ALIGN',_immediate,noop_
align_: equ next

; ALIGNED  ( a -- aa )

  _header _public,'ALIGNED',_immediate,noop_
aligned_: equ next


; }}} **********************************************************
; Circular string buffer {{{

if circular_string_buffer?

; CSB-UNUSED  ( -- len )
  _header _public,'CSB-UNUSED'
csb_unused_:
  ld hl,(csb_unused)
  jp push_hl

; CSB0  ( -- a )
  _header _public,'CSB0'
csb0_:
  ld hl,csb0
  jp push_hl

; ?CSB  ( len -- )
; Make sure there's room for the given characters.
  _header _hidden,'?CSB'
question_csb_:
  call do_colon
  dw dup_,lit_,csb_unused,fetch_,greater_
  dw branch_if_false_,question_csb_.enough
  ; not enough space; reset the pointer
  dw lit_,cbs_size
  dw lit_,csb_unused,store_
question_csb_.enough:
  dw negate_,lit_,csb_unused,plus_store_
  dw paren_exit_

; STRING-ALLOCATE  ( len -- ca )
  _header _hidden,'STRING-ALLOCATE'
string_allocate_:
  call do_colon
  dw question_csb_
  dw csb0_,csb_unused_,plus_
  dw paren_exit_

; SAVE-STRING  ( ca1 len1 -- ca2 len1 )
  _header _public,'SAVE-STRING'
save_string_:
  call do_colon
  dw dup_,string_allocate_,swap_
  dw two_dup_,two_to_r_
  dw move_,two_from_r_
  dw paren_exit_

; SAVE-COUNTED-STRING  ( ca1 len1 -- ca2 )
  _header _public,'SAVE-COUNTED-STRING'
save_counted_string_:
  call do_colon
  dw dup_,one_plus_,string_allocate_
  dw dup_,to_r_,place_,from_r_
  dw paren_exit_

endif

; }}} **********************************************************
; Arithmetic and logical {{{

; ><  ( x1 -- x2 )

  _header _public,'><'
byte_swap_:
  pop de
  ld h,e
  ld l,d
  _push_hl_jp_next

; AND  ( x1 x2 -- x3 )

  _header _public,'AND'
and_:
  pop de
  pop hl
  ld a,e
  and l
  ld l,a
  ld a,d
  and h
  ld h,a
  _push_hl_jp_next

; OR  ( x1 x2 -- x3 )

  _header _public,'OR'
or_:
  pop de
  pop hl
  ld a,e
  or l
  ld l,a
  ld a,d
  or h
  ld h,a
  _push_hl_jp_next

; XOR  ( x1 x2 -- x3 )

  _header _public,'XOR'
xor_:
  pop de
  pop hl
  ld a,e
  xor l
  ld l,a
  ld a,d
  xor h
  ld h,a
  _push_hl_jp_next

abs_hl:
  ld a,h
  or a
  ret p

negate_hl:
  ; two's complement
  dec hl
negate_hl.1:
  ; one's complement
  ld a,l
  cpl
  ld l,a
  ld a,h
  cpl
  ld h,a
  ret

sra_hl:
  ld a,h   ; shift arithmetic right
  rlca
  rrca
sra_hl.1:
  rra
  ld h,a
  ld a,l
  rra
  ld l,a
  ret

abs_hlde:
  ld a,h
  or a
  ret p

negate_hlde:
  sub a   ; 16 bit two's complement
  sub e
  ld e,a
  ld a,0
  sbc a,d
  ld d,a
  ld a,0
  sbc a,l
  ld l,a
  ld a,0
  sbc a,h
  ld h,a
  ret

; INVERT  ( x1 -- x2 )
;   one's complement

  _header _public,'INVERT'
invert_:
  pop hl
  call negate_hl.1
  _push_hl_jp_next

; S>D  ( n -- d )

  _header _public,'S>D'
s_to_d_:
  ld hl,0
  pop de
  ld a,d
  or a
  jp p,push_de_hl
  dec hl
  jp push_de_hl

; D>S  ( d -- n )

  _header _public,'D>S',,drop_
d_to_s_: equ drop_

; NEGATE  ( n1 -- n2 )

  _header _public,'NEGATE'
negate_:
  pop hl
  call negate_hl
  _push_hl_jp_next

; ABS  ( n -- +n )

  _header _public,'ABS'
abs_:
  pop hl
  call abs_hl
  _push_hl_jp_next

; DNEGATE  ( d1 -- d2 )

  _header _public,'DNEGATE'
d_negate_:
  pop hl
  pop de
  call negate_hlde
  jp push_de_hl

; DABS  ( d -- +d )

  _header _public,'DABS'
d_abs_:
  pop hl
  pop de
  call abs_hlde
  jp push_de_hl

; +  ( x1 x2 -- x3 )

  _header _public,'+'
plus_:
  pop de
plus_de:
  pop hl
  add hl,de
  _push_hl_jp_next


; -  ( x1 x2 -- x3 )

  _header _public,'-'
minus_:
  pop de
  pop hl
  call hl_minus_de_to_hl
  _push_hl_jp_next


; D+  ( xd1 xd2 -- xd3 )

  _header _public,'D+'
d_plus_:
  ld hl,6
  add hl,sp
  ld e,(hl)
  ld (hl),c
  inc hl
  ld d,(hl)
  ld (hl),b
  pop bc
  pop hl
  add hl,de
  ex de,hl
  pop hl
  ld a,l
  adc a,c
  ld l,a
  ld a,h
  adc a,b
  ld h,a
  pop bc
  jp push_de_hl

; D-  ( xd1 xd2 -- xd3 )
;   dnegate d+

  _header _public,'D-'
d_minus_:
  call do_colon
  dw d_negate_,d_plus_
  dw paren_exit_

; M+  ( xd1 n -- xd2 )
;   s>d d+

  _header _public,'M+'
m_plus_:
  call do_colon
  dw s_to_d_,d_plus_
  dw paren_exit_

; 1+  ( x1 -- x2 )

  _header _public,'1+'
one_plus_:
  pop hl
  inc hl
  _push_hl_jp_next


; 2+  ( x1 -- x2 )

  _header _public,'2+'
two_plus_:
  pop hl
  inc hl
  inc hl
  _push_hl_jp_next


; 1-  ( x1 -- x2 )

  _header _public,'1-'
one_minus_:
  pop hl
  dec hl
  _push_hl_jp_next


; 2-  ( x1 -- x2 )

  _header _public,'2-'
two_minus_:
  pop hl
  dec hl
  dec hl
  _push_hl_jp_next


; ------------------------------
; Multiplication primitives

; AHL <- A * DE

a_by_de_to_ahl:
  ld hl,0
  ld c,8
a_by_de_to_ahl.1:
  add hl,hl
  rla
  jp nc,a_by_de_to_ahl.2
  add hl,de
  adc a,0
a_by_de_to_ahl.2:
  dec c
  jp nz,a_by_de_to_ahl.1
  ret

; Unsigned 16*16 multiply, 32 bit result

; HLDE <- HL * DE

hl_by_de_to_hlde_unsigned:
  push bc    ; save IP
  ld b,h
  ld a,l
  call a_by_de_to_ahl
  push hl
  ld h,a
  ld a,b
  ld b,h
  call a_by_de_to_ahl
  pop de
  ld c,d
  add hl,bc
  adc a,0
  ld d,l
  ld l,h
  ld h,a
  pop bc    ; restore IP
  ret

; Signed 16*16 multiply, 32 bit result

; HLDE <- HL * DE

hl_by_de_to_hlde_signed:
  ld a,d
  xor h
  rla
  push af
  call abs_hl
  ex de,hl
  call abs_hl
  call hl_by_de_to_hlde_unsigned
  pop af
  ret nc
  jp negate_hlde

; UM*  ( u1 u2 -- ud )

  _header _public,'UM*'
umstr_:
  pop de
  pop hl
  call hl_by_de_to_hlde_unsigned
  jp push_de_hl

; M*  ( n1 n2 -- d )
; 2dup xor >r abs swap abs um* r> ?dnegate

  _header _public,'M*'
mstar_:
  pop de
  pop hl
  call hl_by_de_to_hlde_signed
  jp push_de_hl

; *  ( x1 x2 -- x3 )
; um* drop

  _header _public,'*'
star_:
  pop de
  pop hl
  call hl_by_de_to_hlde_unsigned
  if size_optimization?
    jp push_de
  else
    push de
    jp next
  endif

; ------------------------------
; Division primitives

usl.1:
  sub c
  ld h,a
  ld a,e
  sbc a,b
usl.2:
  inc l
  dec d
  ret z

usl.3:
  add hl,hl
  rla
  ld e,a
  ld a,h
  jp c,usl.1
  sub c
  ld h,a
  ld a,e
  sbc a,b
  jp nc,usl.2
  ld a,h
  add a,c
  ld h,a
  ld a,e
  dec d
  jp nz,usl.3
  ret

usl:
  ld a,h
  ld h,l
  ld l,d
  ld d,8   ; loop counter
  push de
  call usl.3
  pop de
  push hl
  ld l,e
  call usl.3
  ld d,a
  ld e,h
  ld a,l
  pop hl
  ld h,l
  ld l,a
  ret

; Unsigned 32/16 divide
;
; entry HLDE = dividend, BC = divisor
; exit  HL = quotient, DE = remainder

mum:
  ld a,l   ; if overflow
  sub c
  ld a,h
  sbc a,b
  jp c,usl
  ld hl,-1   ; set rem & quot to max
  ld de,-1
  ret

; UM/MOD  ( ud u1 -- u2 u3 )

  _header _public,'UM/MOD'
umslm_:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
  ex de,hl
  call mum
  pop bc
  jp push_de_hl

; Signed 32/16 divide - floored
;
; entry HLDE = dividend, BC = divisor
; exit  HL = quotient, DE = remainder

msm:
  push bc    ; save divisor
  ld a,b
  xor h
  push af    ; save quot sign
  push hl    ; save dividend
  push hl
  ld l,c
  ld h,b
  call abs_hl
  ld c,l
  ld b,h
  pop hl
  call abs_hlde
  call mum
  pop af    ; sign remainder
  or a
  ex de,hl
  call m,negate_hl
  ex de,hl
  pop af
  pop bc    ; restore divisor
  or a   ; sign quot
  jp p,msm.1
  jp negate_hl

msm.1:
  pop bc    ; discard return
msm.2:
  pop bc
  if size_optimization?
    jp push_de_hl
  else
    push de
    push hl
    jp next
  endif

; SM/REM  ( d n1 -- n2 n3 )
; XXX checked against DX-Forth 4.09
  _header _public,'SM/REM'
s_m_slash_rem_:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
  ex de,hl
s_m_slash_rem_.1:
  call msm
  jp msm.2

; FM/MOD  ( d n1 -- n2 n3 )
; XXX checked against DX-Forth 4.09

  _header _public,'FM/MOD'
fm_slash_mod_:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
  ex de,hl
fm_slash_mod_.1:
  call msm
  ld a,d
  or e
  jp z,msm.2    ; skip if remainder = 0
  dec hl    ; floor
  push hl
  ex de,hl
  add hl,bc
  ex de,hl
  pop hl
  jp msm.2

; M/MOD  ( d n1 -- n2 n3 )
;   fm/mod or sm/rem

; XXX OLD -- DX-Forth 4.00 -- but kept
  _header _hidden,'M/MOD',,m_slash_mod_

if floored_division?
  m_slash_mod_: equ fm_slash_mod_
else
  m_slash_mod_: equ s_m_slash_rem_
endif

; /MOD  ( n1 n2 -- n3 n4 )
;   >r s>d r> m/mod
; XXX NEW -- DX-Forth 4.09 -- instead of 'M/MOD'
; XXX checked against DX-Forth 4.09
  _header _public,'/MOD'
slash_mod_:
  call do_colon
  dw to_r_,s_to_d_
;  dw from_r_,m_slash_mod_ ; XXX not in 4.09
  dw from_r_,s_m_slash_rem_ ; XXX yes
  dw paren_exit_

; /  ( n1 n2 -- n3 )
;   /mod nip
; XXX checked against DX-Forth 4.09

  _header _public,'/'
slash_:
  call do_colon
  dw slash_mod_,nip_
  dw paren_exit_

; MOD  ( n1 n2 -- n3 )
;   /mod drop

  _header _public,'MOD'
modd_:
  call do_colon
  dw slash_mod_,drop_
  dw paren_exit_

; */MOD  ( n1 n2 n3 -- n4 n5 )
;   >r m* r> sm/rem
; XXX checked against DX-Forth 4.09

  _header _public,'*/MOD'
star_slash_mod_:
  call do_colon
  dw to_r_,mstar_
  dw from_r_
  dw s_m_slash_rem_ ; DX-Forth 4.00 used 'm_slash_mod' here instead
  dw paren_exit_

; */  ( n1 n2 n3 -- n4 )
;   */mod nip

  _header _public,'*/'
star_slash_:
  call do_colon
  dw star_slash_mod_,nip_
  dw paren_exit_

; M*/  ( d1 n1 +n2 -- d2 )
;   abs >r 2dup xor swap abs >r -rot
;         dabs swap r@ um* rot r> um* rot 0 d+
;         r@ um/mod -rot r> um/mod nip swap
;         rot 0< if dnegate then

  _header _public,'M*/'
m_star_slash_:
  call do_colon
  dw abs_,to_r_
  dw two_dup_,xor_
  dw swap_,abs_,to_r_
  dw minus_rot_,d_abs_
  dw swap_,r_fetch_,umstr_
  dw rot_,from_r_,umstr_
  dw rot_,zero_,d_plus_
  dw r_fetch_,umslm_
  dw minus_rot_,from_r_
  dw umslm_,nip_
  dw swap_,rot_,zero_less_
  dw question_branch_,m_star_slash_.end
  dw d_negate_
m_star_slash_.end:
  dw paren_exit_

; 2*  ( x1 -- x2 )

  _header _public,'2*'
two_star_:
  pop hl
  add hl,hl
  _push_hl_jp_next


; 2/  ( n1 -- n2 )

  _header _public,'2/'
two_slash_:
  pop hl
  call sra_hl
  _push_hl_jp_next


; U2/  ( x1 -- x2 )

  _header _public,'U2/'
u_two_slash_:
  pop hl
  or a
  ld a,h
  call sra_hl.1
  _push_hl_jp_next


; D2*  ( xd1 -- xd2 )
; XXX TODO check if this works

  _header _public,'D2*'
d_two_star_:
  pop de
  pop hl
  add hl,hl
  ld a,e
  rla
  ld e,a
  ld a,d
  rla
  ld d,a
  if size_optimization?
    ex de,hl
    jp push_de_hl
  else
    push hl
    push de
    jp next
  endif

; D2/  ( d1 -- d2 )

  _header _public,'D2/'
d_two_slash_:
  pop hl
  pop de
  call sra_hl
  ld a,d
  rra
  ld d,a
  ld a,e
  rra
  ld e,a
  if size_optimization?
    jp push_de_hl
  else
    push de
    push hl
    jp next
  endif

; LSHIFT  ( x1 u -- x2 )

  _header _public,'LSHIFT'
lshift_:
  pop de
  pop hl
  inc e
lshift_.1:
  dec e
  jp z,push_hl
  add hl,hl
  jp lshift_.1

; RSHIFT  ( x1 u -- x2 )

  _header _public,'RSHIFT'
rshift_:
  pop de
  pop hl
  inc e
rshift_.1:
  dec e
  jp z,push_hl
  or a
  ld a,h
  call sra_hl.1
  jp rshift_.1

; }}} **********************************************************
; Comparison {{{

; 0=  ( x -- flag )

  _header _public,'0='
zero_equals_:
  pop hl
zero_equals_hl:
  ld a,l
  or h
  if size_optimization?
    jr true_if_z
  else
    jp z,true_
    jp false_
  endif

  ; XXX TMP still used in the Forth sources
  _header _public,'NOT',,zero_equals_
not_: equ zero_equals_

; 0<>  ( x -- flag )

  _header _public,'0<>'
zero_not_equals_:
  pop hl
zero_not_equals_hl:
  ld a,l
  or h
  jp z,false_
  jp true_

; =  ( x1 x2 -- flag )
;   - 0=

  _header _public,'='
equals_:
  pop de
  pop hl
equals_.de_hl:
  call compare_de_hl_unsigned
true_if_z:
  jp z,true_
  jp false_

; <>  ( x1 x2 -- flag ) - 0= 0=

  _header _public,'<>'
not_equals_:
  pop de
  pop hl
  call compare_de_hl_unsigned
  jp z,false_
  jp true_

; 0<  ( n -- flag )

  _header _public,'0<'
zero_less_:
  pop hl
zero_less_.hl:
  add hl,hl
true_if_cy: ; XXX TODO macro for this jump
  jp c,true_
  jp false_

; 0>  ( n -- flag )

  _header _public,'0>'
zero_greater_:
  pop de
  ld hl,0
zero_greater_.1:
  call compare_de_hl_signed
  if size_optimization?
    jp true_if_cy
  else
    jp c,true_
    jp false_
  endif

; <  ( n1 n2 -- flag )

  _header _public,'<'
less_:
  pop de
  pop hl
  jp zero_greater_.1

; >  ( n1 n2 -- flag )

  _header _public,'>'
greater_:
  pop hl
  pop de
  jp zero_greater_.1

; U<  ( u1 u2 -- flag )

  _header _public,'U<'
u_less_:
  pop de
  pop hl
u_less_.de_hl:
  call compare_de_hl_unsigned
  if size_optimization?
    jp true_if_cy
  else
    jp c,true_
    jp false_
  endif

; U>  ( u1 u2 -- flag )

  _header _public,'U>'
u_greater_:
  pop hl
u_greater_.hl:
  pop de
  jp u_less_.de_hl

; 0MAX  ( n1 -- n2 )
;   0 max

  _header _hidden,'0MAX'
zero_max_:
  ld de,0
  jp max_de

; MAX  ( n1 n2 -- n1 | n2 )
;   2dup < if swap then drop

  _header _public,'MAX'
max_:
  pop de
max_de:
  pop hl
  call compare_de_hl_signed
max_.1:
  ccf
max_.2:
  jp c,max_.3
  ex de,hl
max_.3:
  _push_hl_jp_next


; MIN  ( n1 n2 -- n1 | n2 )
;   2dup > if swap then drop

  _header _public,'MIN'
min_:
  pop de
  pop hl
  call compare_de_hl_signed
  jp max_.2

; UMAX  ( u1 u2 -- u1 | u2 )
;   2dup u< if swap then drop

  _header _public,'UMAX'
u_max_:
  pop de
  pop hl
  call compare_de_hl_unsigned
  jp max_.1

; UMIN  ( u1 u2 -- u1 | u2 )
;   2dup u> if swap then drop

  _header _public,'UMIN'
u_min_:
  pop de
  pop hl
  call compare_de_hl_unsigned
  jp max_.2

; WITHIN  ( n1|u1 n2|u2 n3|u3 -- flag )
;   over - >r - r> u<
; XXX checked

  _header _public,'WITHIN'
within_:
  pop hl
  pop de
  call hl_minus_de_to_hl
  ex (sp),hl
  call hl_minus_de_to_hl
  jp u_greater_.hl

; BETWEEN  ( n1|u1 n2|u2 n3|u3 -- flag )
;   over - -rot - u< 0=

  _header _public,'BETWEEN'
between_:
  pop hl
  pop de
  call hl_minus_de_to_hl
  ex (sp),hl
  call hl_minus_de_to_hl
  pop de
  call compare_de_hl_unsigned
  jp z,true_
  if size_optimization?
    jp true_if_cy
  else
    jp c,true_
    jp false_
  endif

; D0=  ( d -- flag )
;   or 0=

  _header _public,'D0='
d_zero_equals_:
  call do_colon
  dw or_,zero_equals_
  dw paren_exit_

; D=  ( d1 d2 -- flag )

  _header _public,'D='
d_equals_:
  pop de
  pop hl
  ex (sp),hl
  call compare_de_hl_unsigned
  pop de
  pop hl
  jp nz,false_
  jp equals_.de_hl

; D0<  ( d -- flag )
;   swap drop 0<

  _header _public,'D0<'
d_zero_less_:
  pop hl
  pop de
  jp zero_less_.hl

; D<  ( d1 d2 -- flag ) rot 2dup = if 2drop u< exit then 2nip >

  _header _public,'D<'
d_less_:
  pop de
  pop hl
  ex (sp),hl
  call compare_de_hl_unsigned
  jp z,u_less_
  inc sp
  inc sp
  inc sp
  inc sp
  jp zero_greater_.1

; DU<  ( ud1 ud2 -- flag )
;   rot swap 2dup u< if 2drop 2drop -1 exit
;         then - if 2drop 0 exit then u<

  _header _public,'DU<'
d_u_less_:
  pop de
  pop hl
  ex (sp),hl
  call compare_de_hl_unsigned
  pop de
  pop hl
  jp c,true_
  jp nz,false_
  jp u_less_.de_hl

; DMIN  ( d1 d2 -- d1 | d2 )
;   2over 2over d< 0= if 2swap then 2drop

  _header _public,'DMIN'
d_min_:
  call do_colon
  dw two_over_,two_over_
  dw d_less_,zero_equals_
d_min_.1:
  dw question_branch_,d_min_.2
  dw two_swap_
d_min_.2:
  dw two_drop_
  dw paren_exit_

; DMAX  ( d1 d2 -- d1 | d2 )
;   2over 2over d< if 2swap then 2drop

  _header _public,'DMAX'
d_max_:
  call do_colon
  dw two_over_,two_over_
  dw d_less_
  dw branch_,d_min_.1

; }}} **********************************************************
; Numeric conversion {{{

; DECIMAL  ( -- )
;   10 base !

  _header _public,'DECIMAL'
decimal_:
  call do_colon
  dw c_lit_
  db 10
  dw base_,store_
  dw paren_exit_

; HEX  ( -- )
;   16 base !

  _header _public,'HEX'
hex_:
  call do_colon
  dw c_lit_
  db 16
  dw base_,store_
  dw paren_exit_

; BINARY  ( -- )
;   2 base !

  _header _public,'BINARY'
binary_:
  call do_colon
  dw c_lit_
  db 2
  dw base_,store_
  dw paren_exit_

; DIGIT  ( c base -- u -1 | 0 )

  _header _hidden,'DIGIT'
digit_:
  pop hl
  pop de
  ld a,e
  call toupper_.a
  sub  '0'
  jp m,false_
  cp 10
  jp m,digit_.1
  sub  7
  cp 10
  jp m,false_
digit_.1:
  cp l
  jp p,false_
  ld e,a
  push de
  jp true_

; >NUMBER  ( d1 ca1 len1 -- d2 ca2 len2 )
;        begin dup while over c@ base @ digit while
;        >r 2swap r> swap base @ um* drop rot base @
;        um* d+ 2swap 1 /string 1 dpl +! repeat then

  _header _public,'>NUMBER'
to_number_:
  call do_colon
to_number_.1:
  dw dup_    ; begin
  dw question_branch_,to_number_.end  ; while
  dw over_,c_fetch_
  dw base_,fetch_
  dw digit_
  dw question_branch_,to_number_.end  ; while
  dw to_r_
  dw two_swap_,from_r_
  dw swap_
  dw base_,fetch_
  dw umstr_,drop_
  dw rot_
  dw base_,fetch_
  dw umstr_
  dw d_plus_
  dw two_swap_
  dw one_,slash_string_
  dw one_,dpl_,plus_store_
  dw branch_,to_number_.1  ; repeat
to_number_.end:
  dw paren_exit_    ; then

; NUMBER?  ( ca u -- d true | false )
; Convert a string to a double number.
;        over c@ [char] - = over 0> and dup >r 1
;        and /string over c@ [char] . > and 0 0
;        2swap ?dup if >number dpl on dup if 1-
;        over c@ [char] . - or dpl off then while
;        then r> 2drop 2drop false else drop r> if
;        dnegate then true then

  _header _public,'NUMBER?'
number_question_:
  call do_colon
  if debug? ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'number_question: '
    dw two_dup_,dot_,dot_,cr_
  endif
  dw over_,c_fetch_
  dw c_lit_
  db '-'
  dw equals_
  dw over_,zero_greater_
  dw and_
  dw dup_,to_r_
  dw one_,and_
  dw slash_string_
  dw over_,c_fetch_
  dw c_lit_
  db '.'
  dw greater_,and_
  dw zero_,zero_
  dw two_swap_
  dw question_dup_
  dw question_branch_,number_question_.2
  dw to_number_
  dw dpl_,on_
  dw dup_
  dw question_branch_,number_question_.1
  dw one_minus_
  dw over_,c_fetch_
  dw c_lit_
  db '.'
  dw minus_,or_
  dw dpl_,off_
number_question_.1:
  dw question_branch_,number_question_.3
number_question_.2:
  dw from_r_
  dw two_drop_,two_drop_
  dw false_
  dw branch_,number_question_.end
number_question_.3:
  dw drop_
  dw from_r_
  dw question_branch_,number_question_.4
  dw d_negate_
number_question_.4:
  dw true_
number_question_.end:
  dw paren_exit_

; <#  ( -- )
;   pad hld !
; XXX FIXME do not use PAD, but the circular string buffer
  _header _public,'<#'
less_number_sign_:
  call do_colon
  dw pad_
  dw hld_,store_
  dw paren_exit_

; #>  ( d -- ca u )
;   2drop hld @ pad over -
; XXX FIXME do not use PAD, but the circular string buffer
  _header _public,'#>'
number_sign_greater_:
  call do_colon
  dw two_drop_
  dw hld_,fetch_
  dw pad_
  dw over_
  dw minus_
  dw paren_exit_

; +HLD  ( +n -- ca )
;   negate hld +! hld @ dup dp @ u<
;        abort" HOLD buffer overflow"

  _header _hidden,'+HLD'
phld_:
  call do_colon
  dw negate_,hld_,plus_store_
  dw hld_,fetch_,dup_
  dw here_,u_less_
  dw paren_abort_quote_
  _dcs 'HOLD buffer overflow' ; XXX TODO ; -17 ; pictured numeric output string overflow
  dw paren_exit_

; HOLD  ( c -- )
;   1 +hld c!

  _header _public,'HOLD'
hold_:
  call do_colon
  dw one_,phld_
  dw c_store_
  dw paren_exit_

; SIGN  ( n -- )
;   0< if [char] - hold then

  _header _public,'SIGN'
sign_:
  call do_colon
  dw zero_less_
  dw question_branch_,sign_.end
  dw c_lit_
  db '-'
  dw hold_
sign_.end:
  dw paren_exit_

; #  ( ud1 -- ud2 )
;   0 base @ um/mod >r base @ um/mod r>
;        rot 9 over < if 7 + then [char] 0 + hold

  _header _public,'#'
number_sign_:
  call do_colon
  dw zero_
  dw base_,fetch_
  dw umslm_
  dw to_r_
  dw base_,fetch_
  dw umslm_
  dw from_r_
  dw rot_
  dw c_lit_
  db 9
  dw over_,less_
  dw question_branch_,number_sign_.end
  dw c_lit_
  db 7
  dw plus_
number_sign_.end:
  dw c_lit_
  db '0'
  dw plus_
  dw hold_
  dw paren_exit_

; #S  ( +d -- 0 0 )
;   begin # 2dup d0= until

  _header _public,'#S'
number_sign_s_:
  call do_colon
number_sign_s_.begin:
  dw number_sign_,two_dup_,d_zero_equals_
  dw question_branch_,number_sign_s_.begin
  dw paren_exit_

; SHOLD  ( ca u -- )
;   dup +hld swap move

  _header _public,'SHOLD'  ; hold string
s_hold_:
  call do_colon
  dw dup_,phld_
  dw swap_,move_
  dw paren_exit_

; NHOLD  ( n c -- )
;   over +hld -rot fill

  _header _public,'NHOLD'  ; hold n characters
n_hold_:
  call do_colon
  dw over_,phld_
  dw minus_rot_,fill_
  dw paren_exit_

; DECIMAL?  ( -- flag )
;   base @ 10 =

  _header _public,'DECIMAL?'
decimal_question_:
  call do_colon
  dw base_,fetch_    ; decimal base?
  dw c_lit_
  db 10
  dw equals_
  dw paren_exit_

; }}} **********************************************************
; Strings {{{

; CMOVE  ( ca1 ca2 len -- )

  _header _public,'CMOVE'
cmove_:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
cmove_.1:
  call move_block_downwards
  pop bc
  jp next

; CMOVE>  ( ca1 ca2 len -- )

  _header _public,'CMOVE>'
cmovu_:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
cmovu_.1:
  call move_block_upwards
  pop bc
  jp next

; BLANK  ( ca len -- )
;   bl fill

  _header _public,'BLANK'
blank_:
  ld e,' '
  jp fill_.1

; COUNT  ( ca1 -- ca2 len )
;   dup 1+ swap c@

  _header _public,'COUNT'
count_:
  pop de
  ld a,(de)
  inc de
  push de
  jp push_a

; PACKED  ( ca1 len1 ca2 -- ca2 )
;            2dup 2>r 1+ swap move 2r> tuck c!

; Store the string ca1 len1 as a counted string at ca2 leaving
; the destination address on the stack.  The source and destination
; strings are permitted to overlap.  An ambiguous condition exists
; if len is greater than 255 or the buffer at ca2 is less than len+1
; characters.

  _header _public,'PACKED'
packed_:
  ld l,c
  ld h,b
  pop de
  pop bc
  ex (sp),hl
  push bc
  push de
  inc  de
  call move_block
  pop hl
  pop de
  ld (hl),e
  pop bc
  _push_hl_jp_next

; PLACE  ( ca1 len1 ca2 -- )
;   packed drop

  _header _public,'PLACE'
place_:
  call do_colon
  dw packed_,drop_
  dw paren_exit_

; XXX OLD -- DX-Forth 4.00
;;; PLACE  ( ca1 u ca2 -- )
;;  2dup 2>r 1+ swap move 2r> c!
;;
;;  header 1,'PLACE'
;;place:
;;  call docolon
;;  dw two_dup_
;;  dw two_to_r_
;;  dw one_plus_,swap_
;;  dw move_
;;  dw two_from_r_
;;  dw c_store_
;;  dw paren_exit_

; AFFIX  ( ca c -- ca )
; append char to counted string
; count unchanged
;
;   over count + c!
;
; XXX TODO rename? 'affix-char' 'trailing-char'

  _header _hidden,'AFFIX'
affix_:
  call do_colon
  dw over_
  dw count_,plus_
  dw c_store_
  dw paren_exit_

; SCAN  ( ca1 len1 c -- ca2 len2 )

  _header _public,'SCAN'
scan_:
  pop de
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl ; XXX TODO use this trick in file words
scan_.1:
  ld a,c
  or b
  _jump_z scan_.2
  ld a,e
  cp (hl)
  _jump_z scan_.2
  inc hl
  dec bc
  jp scan_.1

scan_.2:
  ex (sp),hl
scan_.3:
  push bc
  ld c,l
  ld b,h
  jp next

; SKIP  ( ca1 len1 c -- ca2 len2 )

  _header _public,'SKIP'
skip_:
  pop de
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
skip_.1:
  ld a,c
  or b
  jp z,scan_.2
  ld a,e
  cp (hl)
  jp nz,scan_.2
  inc hl
  dec bc
  jp skip_.1

; -TRAILING  ( ca len1 -- ca len2 )

  _header _public,'-TRAILING'
minus_trailing_:
  pop de
  pop hl
  push hl
  add hl,de
  ex de,hl
minus_trailing_.begin:
  ; de = address
  ; hl = count
  dec de
  ld a,l
  or h
  jp z,push_hl
  ld a,(de)
  cp ' '
  jp nz,push_hl
  dec hl
  jp minus_trailing_.begin

; /STRING  ( ca1 len1 n -- ca2 len2 )
;   rot over + -rot -

  _header _public,'/STRING'
slash_string_:
  pop de ; n
  pop hl ; u1
  call hl_minus_de_to_hl ; hl=u2
  ex (sp),hl ; (sp)=u2 hl=ca1
  add hl,de ; hl=ca2
  ex (sp),hl ; (sp)=ca2 hl=u2
  _push_hl_jp_next

; XXX OLD
;;; CAPS  ( -- )
;;; enable caps COMPARE/SEARCH
;;; XXX TODO use a user variable instead
;;  header public,'CAPS'
;;caps:
;;  ld a,1
;;  jp dcaps.1
  ; XXX TMP still used in the Forth sources:
;  _header _public,'CAPS',_immediate,noop_
;caps_: equ noop_
;;
;;; -CAPS  ( -- )
;;;   disable caps COMPARE/SEARCH
;;; XXX TODO use a user variable instead
;;  header hidden,'-CAPS'
;;dcaps:
;;  xor a
;;dcaps.1:
;;  ld (scaps),a
;;  jp next
  ; XXX TMP still used in the Forth sources?:
;  _header _public,'-CAPS',_immediate,noop_
;minus_caps_: equ noop_

patch_compare_strings:

  ; Patch an address with the address of the routine 'compare' and 'search' use
  ; to compare strings, which depends on a user variable.
  ;
  ; This routine is called at the start of 'compare' and 'search', in order to
  ; patch themselves.

  ; Input:
  ;   DE = address to patch with the routine address

  ; ++++++++++++++++++++++++++++++++++++++++++++
  ;
  ; XXX TODO
  ;
  ; It's not a good idea to execute this routine everytime 'compare' and
  ; 'search' are called.
  ;
  ; Solution 1: Use two patching words instead. PROBLEM: .
  ;
  ; Solution 2: write 'insensitive-search' and 'insensitive-compare' (or
  ; 'search-insensitive' and 'compare-insensitive') to patch the normal words,
  ; call them and restore them. PROBLEM: that would not affect words that use
  ; compare, like 'str=', 'str<', etc.
  ;
  ; ++++++++++++++++++++++++++++++++++++++++++++

  push bc
  ld hl,(user_data_pointer)
  ld bc,case_sensitive_search_user_variable
  add hl,bc
  ld a,(hl)
  inc hl
  ld l,(hl)
  or l ; case sensitive search?
  ld hl,compare_strings_case_insensitive ; routine
  _jump_z patch_compare_strings.end
  ld hl,compare_strings_case_sensitive ; routine
patch_compare_strings.end:
  ex de,hl
  ld (hl),e
  inc hl
  ld (hl),d
  pop bc
  ret

compare_strings_case_insensitive:
  ; Used by 'compare' and 'search'.
  ; Input:
  ;   HL = a1
  ;   BC = a2
  ;   DE = len
  ; Output:
  ;   Z = match?
  ld a,e
  or d
  ret z
  push bc
  ld a,(bc)
  call toupper_.a
  ld c,a
  ld a,(hl)
  call toupper_.a
  cp c
  pop bc
  ret nz
  inc hl
  inc bc
  dec de
  jp compare_strings_case_insensitive

; XXX OLD -- substituted by 'patch_compare_strings'
;;comparestrings:
;;  ; Input:
;;  ;   HL = a1
;;  ;   BC = a2
;;  ;   DE = len
;;  ; Output:
;;  ;   Z = match?
;;  push hl
;;  push de
;;  ld hl,(user_data_pointer)
;;  ld de,case_sensitive_search_user_variable
;;  add hl,de
;;  ld a,(hl) ; XXX TODO -- check the whole cell?
;;  or a
;;  pop de
;;  pop hl
;;  jp nz,compare_strings_case_insensitive

compare_strings_case_sensitive:
  ; Used by 'compare' and 'search'.
  ; Input:
  ;   HL = a1
  ;   BC = a2
  ;   DE = len
  ; Output:
  ;   Z = match?
  ld a,e
  or d
  ret z
  ld a,(bc)
  cp (hl)
  ret nz
  inc hl
  inc bc
  dec de
  jp compare_strings_case_sensitive

; COMPARE  ( ca1 len1 ca2 len2 -- -1 | 0 | 1 )

  _header _public,'COMPARE'
compare_:
  ld de,compare_.compare_strings
  call patch_compare_strings
  pop de
  pop hl
  ex (sp),hl
  ld a,d
  cp h
  jp nz,compare_.1
  ld a,e
  cp l
compare_.1:
  jp c,compare_.2
  ex de,hl
compare_.2:
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
  push af
compare_.compare_strings: equ $+1
  call 0 ; patched
  _jump_z compare_.4
  pop bc
compare_.3:
  pop bc
; XXX OLD -- Why this?:
;;  ld a,0
;;  ld (scaps),a
  jp c,one_
  jp z,false_
  jp true_

compare_.4:
  pop af
  jp compare_.3

; SEARCH  ( ca1 len1 ca2 len2 -- ca3 len3 -1 | ca1 len1 0 )

  _header _public,'SEARCH'
search_:
  ld de,search_.compare_strings
  call patch_compare_strings
  call do_colon
  dw $+2
  pop hl
  ld (string_2_len),hl
  ld a,l
  or h
  pop bc
  pop hl
  ld (string_1_len),hl
  ex de,hl
  pop hl
  ld (string_1_addr),hl
  jp z,search_.2
  dec hl
  inc de
search_.1:
  inc hl
  dec de
  ld a,e
  or d
  jp z,search_.4
; XXX commented out in DX-Forth:
; ld a,(bc)
; CP  (hl)
; jp nz,search.1
  push de
  push bc
  push hl
  ex de,hl
string_2_len equ $+1
  ld hl,0  ; length of the second string
  ex de,hl
search_.compare_strings: equ $+1
  call 0 ; patched
  pop hl
  pop bc
  pop de
  jp nz,search_.1

search_.2:
  ld bc,-1
search_.3:
  push hl
  push de
  push bc
; XXX OLD -- Why this?
;;  xor a
;;  ld (scaps),a
  jp paren_exit_

search_.4:
  ld bc,0
string_1_len equ $+1
  ld hl,0  ; length of the first string
  ex de,hl
string_1_addr equ $+1
  ld hl,0  ; address of the first string
  jp search_.3

; +STRING  ( ca1 len1 ca2 len2 -- ca2 len3 )
;
; Append the string ca1 len1 to the end of string ca2 len2
; returning the resulting string ca2 len3.  It is the programmer's
; responsibility to ensure sufficient room is available at ca2
; to hold both strings.
;
;   2swap swap 2over + 2 pick cmove +
;
; XXX TODO rename and change the order of parameters,
; or keep this word and do a wrapper with the parameters swapped.
;
; XXX TODO suggest this improved version to the author of DX-Forth.

  _header _public,'+STRING'
plus_string_:

  ; Save the Forth IP
  ld l,c
  ld h,b
  ld (plus_string_.ip),hl

  ; Concatenate the strings
  pop de
  pop hl
  ld (plus_string_.address),hl ; save ca2
  add hl,de
  ex de,hl
  pop bc
  add hl,bc
  ld (plus_string_.length),hl ; save len3
  pop hl
  call move_block_downwards

  ; Restore the Forth IP
plus_string_.ip: equ $+1
  ld bc,0

  ; Return the string
plus_string_.address: equ $+1
  ld hl,0
  push hl
plus_string_.length: equ $+1
  ld hl,0
  _push_hl_jp_next

; S.R  ( ca len n -- )
;
; Type a string right-justified
;
;   over - spaces type
;
; XXX TODO -- rename to 'type.r' or 'type>', 'type-right'?

  _header _public,'S.R'
s_dot_r_:
  call do_colon
  dw over_,minus_,spaces_,type_
  dw paren_exit_

; UPPER  ( ca len -- )
; make string uppercase

  _header _public,'UPPER'
upper_:
  pop de
  pop hl
upper_.1:
  ld a,d
  or e
  jp z,next
  ld a,(hl)
  call toupper_.a
  ld (hl),a
  inc hl
  dec de
  jp upper_.1

; XXX NEW -- after Gforth
; TOUPPER  ( c1 -- c2 )
; XXX TODO Configure for 8-bit charsets

  _header _public,'TOUPPER'

toupper_:
  pop hl
  ld a,l
  call toupper_.a
  jp push_a
toupper_.a:
  cp 'a'
  ret c
  cp 'z'+1
  ret nc
  xor 0x20
  ret

; XXX NEW -- after UPPER
; LOWER  ( ca u -- )

  _header _public,'LOWER' ; make string lowercase
lower_:
  pop de
  pop hl
lower_.1:
  ld a,d
  or e
  jp z,next
  ld a,(hl)
  call tolower_.a
  ld (hl),a
  inc hl
  dec de
  jp lower_.1

; XXX NEW -- after TOUPPER
; TOLOWER  ( c1 -- c2 )
; XXX TODO Configure for 8-bit charsets

  _header _public,'TOLOWER' ; make char lowercase

tolower_:
  pop hl
  ld a,l
  call tolower_.a
  jp push_a
tolower_.a:
  cp 'A'
  ret c
  cp 'Z'+1
  ret nc
  xor 0x20
  ret

; }}} **********************************************************
; Control structures {{{

; (OF)  ( n1 n2 -- n1 | )

  _header _hidden,'(OF)'
paren_of_:
  pop hl ; n2
  pop de ; n1
  call hl_minus_de_to_hl
  ld a,l
  or h ; n1=n2?
  jp z,question_branch_.1
  push de ; n1
  jp branch_

; BRANCH  ( -- )

  _header _hidden,'BRANCH'
branch_:
  ld h,b
  ld l,c
  ld c,(hl)
  inc hl
  ld b,(hl)
  jp next

; <>0BRANCH  ( flag -- )

  ; XXX TODO remove?
  _header _hidden,'<>0BRANCH'
not_equals_0_branch_:
branch_if_not_0_:
branch_if_not_false_:
branch_if_not_zero_:
branch_if_true_:
  pop hl
  ld a,l
  or h
  jp nz,branch_
  if size_optimization?
    jr question_branch_.1
  else
    inc bc
    inc bc
    jp next
  endif

; ?BRANCH  ( flag -- )

  _header _hidden,'?BRANCH'
question_branch_:
zero_branch_:
branch_if_0_:
branch_if_false_:
branch_if_zero_:
  pop hl
  ld a,l
  or h
  _jump_z branch_
question_branch_.1:
  inc bc
  inc bc
  jp next

; (LOOP)  ( -- )

  _header _hidden,'(LOOP)'
paren_loop_:
  ld hl,(return_stack_pointer)
  inc (hl)
  jp nz,branch_
  inc hl
  inc (hl)
  jp nz,branch_
paren_loop_.1:
  inc bc    ; skip over branch
  inc bc
  jp unloop_

; UNLOOP  ( -- )
; XXX FIXME add to the glossary

  _header _public,'UNLOOP'
unloop_:
  ld hl,(return_stack_pointer)  ; discard loop parameters
  ld de,cell*2
  add hl,de
  ld (return_stack_pointer),hl
  jp next

; (+LOOP)  ( n -- )

  _header _hidden,'(+LOOP)'
paren_plus_loop_:
  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  pop hl
  ld a,h
  or a
  jp m,paren_plus_loop_.2
  add hl,de
  jp c,paren_loop_.1
paren_plus_loop_.1:
  ex de,hl
  ld hl,(return_stack_pointer)
  ld (hl),e
  inc hl
  ld (hl),d
  jp branch_

paren_plus_loop_.2:
  add hl,de
  jp c,paren_plus_loop_.1
  jp paren_loop_.1

; (LEAVE)  ( -- )

  _header _hidden,'(LEAVE)'
paren_leave_:
  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a
  ld c,(hl)
  inc hl
  ld b,(hl)
  jp unloop_

; (?DO)  ( n1 n2 -- )
;
;   2dup = if 2drop r> @ >r exit then (do)

  _header _hidden,'(?DO)'
paren_question_do_:
  call do_colon
  dw two_dup_,equals_
  dw question_branch_,paren_do_.1
  dw two_drop_
  dw from_r_,fetch_,to_r_
  dw paren_exit_

; (DO)  ( n1 n2 -- )
;   over - r> cell+ -rot 2>r >r

  _header _hidden,'(DO)'
paren_do_:
  call do_colon
paren_do_.1: ; '(?do)' jumps here
  dw over_,minus_
  dw from_r_,cell_plus_
  dw minus_rot_
  dw two_to_r_
  dw to_r_
  dw paren_exit_

; BAL  ( -- a )

  _header _hidden,'BAL'
bal_:
  call do_create
bal_.variable:
  ds cell

; +BAL  ( -- )
;   1 bal +!

  _header _public,'+BAL'
plus_bal_:
  ld de,1
plus_bal_.1:
  ld hl,bal_.variable
  jp plus_store_.de_into_hl

; -BAL  ( -- )
;   -1 bal +!

  _header _public,'-BAL'
minus_bal_:
  ld de,-1
  jp plus_bal_.1

; ?BAL  ( flag -- )
;   checking @ 0<> and
;         abort" definition unbalanced"

  _header _public,'?BAL'
question_bal_:
  call do_colon
  dw checking_,fetch_
  dw zero_not_equals_,and_
  dw paren_abort_quote_
  _dcs 'definition unbalanced'
  dw paren_exit_

; ?DEPTH  ( x -- x )
;   ?comp depth 0= ?bal

  _header _hidden,'?DEPTH'
question_depth_:
  call do_colon
  dw question_comp_
  dw depth_,zero_equals_
  dw question_bal_
  dw paren_exit_

; ?ORIG  ( orig -- orig )
;   ?depth dup @ ?bal

  _header _hidden,'?ORIG'
question_orig_:
  call do_colon
  dw question_depth_
  dw dup_,fetch_
  dw question_bal_
  dw paren_exit_

; ?DEST  ( dest -- dest )
;   ?depth dup @ 0= ?bal

  _header _hidden,'?DEST'
question_dest_:
  call do_colon
  dw question_depth_
  dw dup_,fetch_
  dw zero_equals_
  dw question_bal_
  dw paren_exit_

; BEGIN  ( -- dest )
;   ?comp here +bal ; immediate

  _header _public,'BEGIN',_immediate
begin_:
  call do_colon
  dw question_comp_
  dw here_
  dw plus_bal_
  dw paren_exit_

; >MARK  ( -- orig )
;   postpone begin 0 ,

  _header _public,'>MARK'
forward_mark_:
  call do_colon
  dw begin_
  dw zero_
  dw comma_
  dw paren_exit_

; <RESOLVE  ( dest -- )
;   ?dest , -bal

  _header _public,'<RESOLVE'
backward_resolve_:
  call do_colon
  dw question_dest_
  dw comma_
  dw minus_bal_
  dw paren_exit_

; THEN  ( orig -- )
;   ?orig here swap ! -bal ; immediate

  _header _public,'THEN',_immediate
then_:
  call do_colon
  dw question_orig_
  dw here_
  dw swap_,store_
  dw minus_bal_
  dw paren_exit_

; IF  ( -- orig )
;   postpone ?branch >mark
         ; immediate

  _header _public,'IF',_immediate
iff_:
  call do_colon
  dw compile_,question_branch_
  dw forward_mark_
  dw paren_exit_

; AHEAD  ( -- orig )
;   postpone branch >mark
         ; immediate

  _header _public,'AHEAD',_immediate
ahead_:
  call do_colon
  dw compile_,branch_
  dw forward_mark_
  dw paren_exit_

; ELSE  ( orig1 -- orig2 )
;   ?orig postpone ahead swap postpone then ; immediate

  _header _public,'ELSE',_immediate
else_:
  call do_colon
  dw question_orig_
  dw ahead_
  dw swap_
  dw then_
  dw paren_exit_

; UNTIL  ( dest -- )
;   postpone ?branch <resolve
         ; immediate

  _header _public,'UNTIL',_immediate
until_:
  ld hl,question_branch_
until_.1:
  push hl
  call do_colon
  dw compile_comma_
  dw backward_resolve_
  dw paren_exit_

; AGAIN  ( dest -- )
;   postpone branch <resolve ; immediate

  _header _public,'AGAIN',_immediate
again_:
  ld hl,branch_
  jp until_.1

; WHILE  ( x -- orig x )
;   ?depth postpone if swap ; immediate

  _header _public,'WHILE',_immediate
while_:
  call do_colon
  dw question_depth_
  dw iff_
  dw swap_
  dw paren_exit_

; REPEAT  ( orig dest -- )
;   postpone again postpone then
         ; immediate

  _header _public,'REPEAT',_immediate
repeat_:
  call do_colon
  dw again_
  dw then_
  dw paren_exit_

; LV  ( -- a )
;   0 value lv

  _header _hidden,'LV'
lv_:
  call do_value
  dw 0

; DO  ( -- orig dest )
;   postpone (do) lv >mark dup to lv
;         postpone begin ; immediate

  _header _public,'DO',_immediate
do_:
  ld hl,paren_do_
do_.hl:
  push hl
  call do_colon
  dw compile_comma_
  dw lv_
  dw forward_mark_
  dw dup_
  dw paren_to_,lv_
  dw begin_
  dw paren_exit_

; ?DO  ( -- orig dest )
;   postpone (?do) lv >mark dup to lv
;         postpone begin ; immediate

  _header _public,'?DO',_immediate
question_do_:
  ld hl,paren_question_do_
  jp do_.hl

; I  ( -- x )

  _header _public,'I'
i_:
  ld hl,(return_stack_pointer)
i_.1:
  ld e,(hl)
  inc hl
  ld d,(hl)
i_.2:
  inc hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  add hl,de
  _push_hl_jp_next


if 0 ; XXX commented out in DX-Forth

; I'  ( -- x )

  _header _public,"I'"
i_tick_:
  ld hl,(return_stack_pointer)
  inc hl
  ld de,0
  jp i_.2

endif

; J  ( -- x )

  _header _public,'J'
j_:
  ld hl,(return_stack_pointer)
  ld de,cell*2
  add hl,de
  jp i_.1

; LEAVE  ( -- )
;   postpone (leave) lv ?orig ,
         ; immediate

  _header _public,'LEAVE',_immediate
leave_:
  call do_colon
  dw compile_,paren_leave_
  dw lv_
  dw question_orig_
  dw comma_
  dw paren_exit_

; LOOP  ( a1 a2 -- )
;   postpone (loop) <resolve
;         postpone then to lv ; immediate

  _header _public,'LOOP',_immediate
loop_:
  ld hl,paren_loop_
loop_.1:
  push hl
  call do_colon
  dw compile_comma_
  dw backward_resolve_
  dw then_
  dw paren_to_,lv_
  dw paren_exit_

; +LOOP  ( a1 a2 -- )
;   postpone (+loop) <resolve
;   postpone then to lv ; immediate

  _header _public,'+LOOP',_immediate
plus_loop_:
  ld hl,paren_plus_loop_
  jp loop_.1

if control_flow_stack_extensions?

; CS-PICK
;   pick +bal

  _header _public,'CS-PICK'
cs_pick_:
  call do_colon
  dw pick_
  dw plus_bal_
  dw paren_exit_

; CS-ROLL
;   aka roll cs-roll

  _header _public,'CS-ROLL',,roll_
cs_roll_: equ roll_

; CS-DROP
;   drop -bal

  _header _public,'CS-DROP'
cs_drop_:
  pop hl
  jp minus_bal_

; CS0  ( -- a )
; control flow stack base

  _header _hidden,'CS0'
cs0_:
  call do_create
cs0_.variable:
  ds cell

; #CS  ( -- cells )
;   sp@ cs0 @ - negate 2/ 1- 0 max

  _header _hidden,'#CS'
ncs_:
  ld hl,(cs0_.variable)
  call negate_hl
  add hl,sp
  call negate_hl
  call sra_hl
  dec hl
  push hl
  jp zero_max_

; CS-PUSH
;   #cs -roll

  _header _public,'CS-PUSH'
cs_push_:
  call do_colon
  dw ncs_
  dw minus_roll_
  dw paren_exit_

; CS-POP        #cs roll

  _header _public,'CS-POP'
cs_pop_:
  call do_colon
  dw ncs_
  dw roll_
  dw paren_exit_

; CS-MARK
;   0 +bal

  _header _public,'CS-MARK'
cs_mark_:
  ld hl,0
  push hl
  jp plus_bal_

; CS-TEST
;   ?depth dup 0<>

  _header _public,'CS-TEST'
cs_test_:
  call do_colon
  dw question_depth_
  dw dup_
  dw zero_not_equals_
  dw paren_exit_

; COND
;   ?comp cs-mark ; immediate

  _header _public,'COND',_immediate
cond_:
  call do_colon
  dw question_comp_
  dw cs_mark_
  dw paren_exit_

; THENS
;   ?comp begin cs-test while postpone
;   then repeat cs-drop ; immediate

  _header _public,'THENS',_immediate
thens_:
  call do_colon
  dw question_comp_
thens_.1:
  dw cs_test_
  dw question_branch_,thens_.2
  dw then_
  dw branch_,thens_.1
thens_.2:
  dw cs_drop_
  dw paren_exit_

else ; no control_flow_stack_extensions?

; COND        ?comp 0 +bal ; immediate

  _header _public,'COND',_immediate
cond_:
  call do_colon
  dw question_comp_
  dw zero_
  dw plus_bal_
  dw paren_exit_

; THENS
;   ?comp begin ?depth ?dup while
;   postpone then repeat -bal ; immediate

  _header _public,'THENS',_immediate
thens_:
  call do_colon
  dw question_comp_
thens_.1:
  dw question_depth_
  dw question_dup_
  dw question_branch_,thens_.2
  dw then_
  dw branch_,thens_.1
thens_.2:
  dw minus_bal_
  dw paren_exit_

endif ; control_flow_stack_extensions?

; Eaker/ANS CASE support
;
; N.B. OF may be used in the form:  COND .. OF .. ELSE .. THENS

; OF  ( -- a )
;   postpone (of) >mark ; immediate

  _header _public,'OF',_immediate
of_:
  call do_colon
  dw compile_,paren_of_
  dw forward_mark_
  dw paren_exit_

; ENDOF  ( a1 -- a2 )
;   aka else endof

  _header _public,'ENDOF',_immediate,else_
endof_: equ else_

; CASE  ( -- sys )
;   aka cond case

  _header _public,'CASE',_immediate,cond_
case_: equ cond_

; ENDCASE  ( sys -- )
;   postpone drop postpone thens
   ; immediate

  _header _public,'ENDCASE',_immediate
endcase_:
  call do_colon
  dw compile_,drop_
  dw thens_
  dw paren_exit_

; [ELSE]  ( -- )
;   1
;   begin
;     parse-name 2dup upper dup if
;       2dup s" [IF]" compare if
;         2dup s" [ELSE]" compare if
;           s" [THEN]" compare 0=
;         else
;           2drop dup 1 =
;         then
;       else
;         2drop 1
;       then +
;     else
;       2drop refill and
;     then
;     ?dup 0=
;   until
 ; immediate

  _header _public,'[ELSE]',_immediate
bracket_else_:
  call do_colon
  dw one_
bracket_else_.1:
  dw parse_name_
  if case_insensitive_names?
    dw two_dup_,upper_
  endif
  dw dup_
  dw question_branch_,bracket_else_.6
  dw two_dup_
  dw paren_s_quot_
  _dcs '[IF]'
  dw compare_
  dw question_branch_,bracket_else_.4
  dw two_dup_
  dw paren_s_quot_
  _dcs '[ELSE]'
  dw compare_
  dw question_branch_,bracket_else_.2
  dw paren_s_quot_
  _dcs '[THEN]'
  dw compare_,zero_equals_
  dw branch_,bracket_else_.3
bracket_else_.2:
  dw two_drop_
  dw dup_,one_,equals_
bracket_else_.3:
  dw branch_,bracket_else_.5
bracket_else_.4:
  dw two_drop_,one_
bracket_else_.5:
  dw plus_
  dw branch_,bracket_else_.7
bracket_else_.6:
  dw two_drop_
  dw refill_,and_
bracket_else_.7:
  dw question_dup_,zero_equals_
  dw question_branch_,bracket_else_.1
  dw paren_exit_

; [IF]  ( flag -- )
; 0= if [compile] [else] then ; immediate

  _header _public,'[IF]',_immediate
bracket_if_:
  pop hl
  ld a,l
  or h
  jp z,bracket_else_
  jp next

; [THEN]  ( -- )
;   aka noop [then] immediate

  _header _public,'[THEN]',_immediate,noop_
bracket_then_: equ next

; }}} **********************************************************
; Numeric output {{{

; (D.)  ( d -- ca u )
;   tuck dabs <# #s rot sign #>

  _header _public,'(D.)'
paren_d_dot_:
  call do_colon
  dw tuck_
  dw d_abs_
  dw less_number_sign_
  dw number_sign_s_
  dw rot_,sign_
  dw number_sign_greater_
  dw paren_exit_

; U.R  ( u1 u2 -- ) 0 swap d.r

  _header _public,'U.R'
udotr_:
  ld hl,0
  ex (sp),hl
  push hl
  jp d_dot_r_

; XXX OLD -- DX-Forth 4.00
;;; D.R  ( d u -- )   >r (d.) r> over - spaces type
;;
;;  header 1,'D.R'
;;ddotr:
;;  call docolon
;;  dw tor
;;  dw parenddot
;;ddotr.1:
;;  dw fromr
;;  dw over,minus
;;  dw spaces
;;  dw type
;;  dw parenexit

; XXX NEW -- DX-Forth 4.09
; D.R  ( d n -- )
;   >r (d.) r> s.r

  _header _public,'D.R'
d_dot_r_:
  call do_colon
  dw to_r_
  dw paren_d_dot_
d_dot_r_.1:
  dw from_r_
  dw s_dot_r_
  dw paren_exit_

; .R  ( n u -- )
;   >r s>d r> d.r

  _header _public,'.R'
dot_r_:
  call do_colon
  dw to_r_
  dw s_to_d_
  dw from_r_,d_dot_r_
  dw paren_exit_

; U.  ( u -- )
;   0 d.

  _header _public,'U.'
u_dot_:
  ld hl,0
  push hl
  jp d_dot_

; D.  ( d -- )
;   0 d.r space

  _header _public,'D.'
d_dot_:
  call do_colon
  dw zero_,d_dot_r_
  dw space_
  dw paren_exit_

; ?  ( a -- )

  _header _public,'?'
question_:
  pop hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  jp dot_

; .  ( n -- )
;   s>d d.
  _header _public,'.'
dot_:
  call do_colon
  dw s_to_d_,d_dot_
  dw paren_exit_

; HEX.  ( n -- )  Gforth
; Note: taken from Gforth, except "$" prefix.
  _header _public,'HEX.'
hex_dot_:
  call do_colon
  dw base_,fetch_
  dw swap_,hex_,u_dot_
  dw base_,store_
  dw paren_exit_

; }}} **********************************************************
; DOS {{{

back_from_dos:
  ; cy = no error?
  ; a  = error code
  jp c,false_   ; no error

back_from_dos.error:
  ; a = error code
  call convert_dos_error_code
  ; hl = error code
  jp push_hl

convert_dos_error_code:
  ; XXX TODO see '>ior' and combine both
  ; XXX TODO use the standard codes
  ; Input:   a  = original DOS error code (0..36)
  ; Outptut: hl = DOS error code converted to Forth range (-1000..-1036)
  ld h,0
  ld l,a
convert_dos_error_code.hl:
  ld de,1000
  add hl,de
  jp negate_hl

get_current_drive:
  ld a,0xFF

set_current_drive:
  ; a = drive (ASCII 'A'..'P' to set it; 0xFF to get it)
  ld ix,dos_set_drive
  jr do_dos

get_current_user:
  ld a,0xFF

set_current_user:
  ; a = user (0x00..0x0F to set it; 0xFF to get it)
  ld ix,dos_set_user

; ------------------------------
; DOS call

dos:

  ; Adapted from the ZX Spectrum +3 manual.

  ; IX holds the address of the DOS routine to be run. All other registers are
  ; passed intact to the DOS routine and are returned from it.

  ; Stack must be somewhere in central 32K (conforming to DOS requirements), so
  ; saved AF and BC will not be switched out.

  push af
  push bc                  ; temp save registers while switching
  ld   a,(sys_bankm)       ; RAM/ROM switching system variable
  or   7                   ; want RAM page 7
  res  4,a                 ; and DOS ROM
  ld   bc,bank1_port       ; port used for horiz ROM switch and RAM paging
  di
  ld   (sys_bankm),a       ; keep system variables up to date
  out  (c),a               ; RAM page 7 to top and DOS ROM
  ei
  pop  bc
  pop  af

  ;_border_halt blue_color ; XXX INFORMER
  call call_dos.ix         ; go sub routine address in IX

  push af
  push bc
  ld   a,(sys_bankm)
  and  0F8h                ; reset bits for page 0
  set  4,a                 ; switch to ROM 3 (48 BASIC)
  ld   bc,bank1_port
  di
  ld   (sys_bankm),a
  out  (c),a               ; switch back to RAM page 0 and 48 BASIC
  ei
  pop  bc
  pop  af
  ret

call_dos.ix:

  jp   (ix)                ; standard way to CALL (IX), by calling this jump

; ------------------------------
; DOS call preserving the Forth IP

; This is used when the BC register (the Forth IP) is not a parameter of the
; DOS routine

do_dos:
  ; IX = DOS routine to run
  push bc
  call dos
  pop bc
  ret

; DOS-VERSION  ( -- minor major )

  _header _public,'DOS-VERSION'
dos_version_:
  ld ix,dos_version
  call do_dos
push_version:
  ; d=issue = major
  ; e=version (within issue) = minor
  xor a
  ld h,a
  ld l,e
  ld e,d
  ld d,a
  jp push_de_hl

; UNUSED-DISK ( c -- u )

  _header _public,'UNUSED-DISK'
unused_disk_:
  pop hl
  ld a,l
  ld ix,dos_free_space
  call do_dos
  jp nc,dos_error_.a
  jp push_hl

; DOS-ERROR ( +n -- )

  _header _public,'DOS-ERROR'

dos_error_:
  ; XXX TMP entry
  pop hl
  ld a,l

dos_error_.a:
  ; XXX TMP entry
  ; a = DOS error code
  call convert_dos_error_code
  push hl
  jp throw_

; FDOS  ( DE u -- HL A )

  _header _public,'FDOS'
fdos_:
  ; XXX OLD
;;  pop hl
;;  ld a,l
;;  pop de
;;  call dodos
;;  push hl
;;  jp pusha
  ; XXX TODO
  jp next

; BDOS  ( DE u -- A )

  _header _public,'BDOS'
bdos_:
  ; XXX TODO
  call do_colon
  ; XXX OLD
;;  dw fdos,nip
  dw paren_exit_

; BIOS  ( BC u -- A )

  _header _public,'BIOS'
bios_:
  jp next
; XXX OLD
;;  pop  de
;;  ld a,e
;;  ld (biosparameterblock),a
;;  pop  hl
;;  ld (biosparameterblock+1),hl
;;  push  bc
;;  call biosj
;;  pop  bc
;;  jp pusha

; BIOSHL  ( DE BC u -- HL )

  _header _public,'BIOSHL'
;biosh:
; XXX OLD
;;  pop  de
;;  ld a,e
;;  ld (biosparameterblock),a
;;  pop  hl
;;  ld (biosparameterblock+1),hl
;;  pop  hl
;;  ld (biosparameterblock+3),hl
;;  push  bc
;;  call biosj
;;  pop  bc
;;  push hl
  jp next

; PC@  ( pa -- x )

  _header _public,'PC@'    ; FIG P@
p_c_fetch_:
  pop hl
  ld a,l
  ld (p_c_fetch_.1),a
  in  a,(0)    ; modified
p_c_fetch_.1  equ  $-1
  jp push_a

; PC!  ( x pa -- )

  _header _public,'PC!'    ; FIG P!
p_c_store_:
  pop hl
  pop de
  ld a,l
  ld (p_c_store_.1),a
  ld a,e
  out  (0),a    ; modified
p_c_store_.1  equ  $-1
  jp next

; ?TERMINAL  ( -- flag )

  _header _hidden,'?TERMINAL'
qterm_:
  call do_colon
; XXX OLD
;;  dw zero,two
;;  dw bios
; XXX TODO
  dw paren_exit_

; CONIN  ( -- c )
;
;       begin key? until 0 3 bios
;       (iofn+cell) @ over = if 0 bdos then

  _header _hidden,'CONIN'
conin_:
  call do_colon    ; console input
conin_.1:
; XXX TODO
;;  dw keyquestion
;;  dw questionbranch,conin.1
;;  dw zero,three
;;  dw bios
;;  dw lit,iofn+cell  ; ctl-C check
;;  dw fetch
;;  dw over,equals
;;  dw questionbranch,conin.end
;;  dw zero,bdos  ; exit to CP/M
conin_.end:
  dw paren_exit_

dcono:
  call do_colon
  dw two_
  dw bdos_,drop_
  dw paren_exit_

bcono:
  call do_colon
  ; XXX OLD
;;  dw clit
;;  db 4
;;  dw bios,drop
  ; XXX TODO
  dw paren_exit_

; CONOUT  ( c -- )

  _header _hidden,'CONOUT'
conout_:
; XXX TODO
;;  pop  de
;;  ld a,e
;;  cp  ff
;;  jp z,cls
;;  push  de
;;  ld hl,(iofn)
;;  jp (hl)
  jp next

; LSTOUT  ( c -- )

  _header _hidden,'LSTOUT'
lstout_:
  call do_colon
  dw c_lit_
  db 5
  dw bios_,drop_
  dw paren_exit_

; XXX OLD
;;;  ZENV  ( -- a )  return Z-System address (0=none)
;;
;;  header  1,'ZENV'
;;zenv:
;;  ld hl,(z3eadr)
;;  jp pushhl

; }}} **********************************************************
; Facility {{{

; (MS)  ( ms -- )

  _header _hidden,'(MS)'
paren_ms_:
  pop de
paren_ms_.1:
  ld a,e
  or d
  jp z,next
  ld hl,(speed)
  add hl,hl
  add hl,hl
  add hl,hl
paren_ms_.2:
  ex (sp),hl    ; 19T
  ex (sp),hl    ; 19T
  ex (sp),hl    ; 19T
  ex (sp),hl    ; 19T
  push hl    ; 11T
  pop hl    ; 10T
  dec  hl    ; 6T
  ld a,0    ; 7T
  ld a,l    ; 4T
  or h    ; 4T
  jp nz,paren_ms_.2    ; 10T
  dec  de
  jp paren_ms_.1

; MS  ( ms -- )

  _header _public,'MS'
ms_:
  call fetch_execute_
  dw paren_ms_

; }}} **********************************************************
; Sound {{{

; SOUND  ( freq ms -- )
;
  ; XXX TODO
;  header  1,'SOUND'
;sound:  call fetchexecute
;  dw sound0

; (BEEP)  ( -- )

  _header _hidden,'(BEEP)'
paren_beep_:
  call do_colon
  ; XXX TODO
  dw paren_exit_

; BEEP  ( -- )

  _header _public,'BEEP'
beep_:
  call fetch_execute_
  dw paren_beep_

; }}} **********************************************************
; Keyboard input {{{

; KEY?  ( -- flag )

  ; XXX FIXME
  _header _public,'KEY?'
key_question_:
  ld hl,0 ; false
  ld a,(sys_last_k)
  and a
  jp z,push_hl
  dec hl  ; true
  jp push_hl

if 0 ; XXX TODO -- alternative
key_question_:
  ld hl,0 ; false
  ld a,(sys_last_k)
  and a
  jp z,push_hl
  dec hl  ; true
  jp push_hl
endif

; (DECODE)  ( c -- c' )
;
; Translate a key code using 'keyboard-table'.

  _header _public,'(DECODE)'

paren_decode_:
  ld hl,keyboard_table_.address
  pop de
  add hl,de
  ld a,(hl)
  if size_optimization?
    jp push_a
  else
    ld h,0
    ld l,a
    jp push_hl
  endif

; DECODE  ( c -- c' )
;
; Translate a key code.

  _header _public,'DECODE'
decode_:
  call fetch_execute_
  dw paren_decode_

; KEYBOARD-TABLE  ( -- a )

  ; Address of a table used to translate key codes to actual chars.  The table
  ; has one byte for every key code (0x00..0xFF), representing the char the key
  ; is translated to.
  ;
  ; This table can be configured to make non-ASCII characters accessible when
  ; an 8-bit charset is used, or graphics.

  _header _public,'KEYBOARD-TABLE'

keyboard_table_:
  call do_create

  ; The first half of the table (0x00..0x79) translates every key to the same
  ; char:

keyboard_table_.address:
  rept 0x80,_char_code
    db _char_code
  endm

  ; The second half of the table (0x80..0xFF) provides some useful translations
  ; by default.  They make accessible with Symbol Shift all ASCII characters
  ; that in Sinclair BASIC need Extended Mode.  This is the same method used by
  ; ZX Spectrum Abersoft Forth (by John Jones-Steele, 1983).
  ;
  ; The copyright symbol has been associated to "I" as its own key is already
  ; used.

  ; Keys (with Symbol Shift) affected:
  ;
  ; Key From code             To code
  ; --- -----------------     --------------
  ; "A" 226 (0xE2) "STOP" --> 126 (0x7E) "~"
  ; "D" 205 (0xCD) "STEP" --> 092 (0x5C) "\"
  ; "F" 204 (0xCC) "TO"   --> 123 (0x7B) "{"
  ; "G" 203 (0xCB) "THEN" --> 125 (0x7D) "}"
  ; "I" 172 (0xAC) "AT"   --> 127 (0x7F) "(C)"
  ; "S" 195 (0xC3) "NOT"  --> 124 (0x7C) "|"
  ; "U" 197 (0xC5) "OR"   --> 093 (0x5D) "]"
  ; "Y" 198 (0xC6) "AND"  --> 091 (0x5B) "["

  db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 0x80..0x87
  db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 0x88..0x8A
  db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 0x90..0x97
  db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 0x98..0x9A
  db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 0xA0..0xA7
  db 0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00 ; 0xA8..0xAA
  db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 0xB0..0xB7
  db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 0xB8..0xBA
  db 0x00,0x00,0x00,0x7C,0x00,0x5D,0x5B,0x00 ; 0xC0..0xC7
  db 0x00,0x00,0x00,0x7D,0x7B,0x5C,0x00,0x00 ; 0xC8..0xCA
  db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 0xD0..0xD7
  db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 0xD8..0xDA
  db 0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00 ; 0xE0..0xE7
  db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 0xE8..0xEA
  db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 0xF0..0xF7
  db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 0xF8..0xFA

; (KEY)  ( -- c )

  _header _public,'(KEY)'
paren_key_:
  ld a,(sys_last_k)
  ld (previous_key),a
paren_key_.1
;  call pause ; XXX FIXME this causes trouble because of the way 'pause' calls 'fetchexecute'
  ; call rom_keyboard ; XXX TODO not needed if system interrupts are on
  ld a,(sys_last_k)
previous_key equ $+1
  cp 0 ; a different key?
  jp z,paren_key_.1
  ld h,0
  ld l,a
  xor a
  ld (sys_last_k),a ; delete the last key
  push hl
  jp decode_

; KEY  ( -- c )

  _header _public,'KEY'
key_:
  call fetch_execute_
  dw paren_key_

; }}} **********************************************************
; Basic screen and printer output {{{

; (EMIT)  ( c -- )

  _header _public,'(EMIT)'
paren_emit_:
  pop hl
paren_emit_.l:
  ld a,l
paren_emit_.a:
  call emit_a
  jp pause_

emit_l:
  ld a,l
emit_a:
  rst 0x10
  ld a,0xFF
  ld(sys_scr_ct),a ; no "scroll?" message
  ret

; EMIT  ( c -- )

  _header _public,'EMIT'
emit_:
  call fetch_execute_
  dw paren_emit_

; TYPE  ( ca u -- )
  _header _public,'TYPE'
type_:

  ; XXX INFORMER
  ; ld a,2
  ; out (254),a
  ; jr $

  push bc ; save the Forth IP
  call rom_chan_s ; set print to screen
  pop hl  ; IP
  pop bc ; length
  pop de ; address
  push hl ; IP
  call rom_print_string
  pop bc ; restore the Forth IP
  jp next

; XXX OLD
; 0max 0 ?do count emit loop drop
;;  call docolon
;;  dw zeromax,zero
;;  dw parenquestiondo,type.2
;;type.do:
;;  dw count,emit
;;  dw parenloop,type.do
;;type.2:
;;  dw drop
;;  dw parenexit


; SPACE  ( -- )

  _header _public,'SPACE'
space_:
  if fast_emit?
    ld a,sp_char
    jp paren_emit_.a
  else
    ld hl,sp_char
    push hl
    jp emit_
  endif

; SPACES  ( +n -- )

  _header _public,'SPACES'
spaces_:
  call do_colon
  dw zero_max_,zero_ ; 0max 0
  dw paren_question_do_,spaces_.end ; ?do
spaces_.do:
  dw space_
  dw paren_loop_,spaces_.do ; loop
spaces_.end:
  dw paren_exit_

; CR  ( -- )

  _header _public,'CR'
cr_:
  ; XXX TODO -- printer too? lfchar?
  if fast_emit?
    ld a,cr_char
    jp paren_emit_.a
  else
    ld hl,cr_char
    push hl
    jp emit_
  endif

; CONSOLE  ( -- )
;   (vcon) @ (vemit) !
  ; set EMIT to terminal

  _header _public,'CONSOLE'
console_:
  ; XXX TODO
; XXX OLD
;;  ld hl,(vcon)
;;  ld (vemit),hl
  jp next

; PRINTER  ( -- )
  ; set EMIT to printer
  _header _public,'PRINTER'
printer_:
  ; XXX TODO
; XXX OLD
;;  ld hl,(vlst)
;;  ld (vemit),hl
  jp next

; }}} **********************************************************
; Compiler {{{

; WORDLIST-FIND  ( ca wid -- 0 | xt nfa -1 | xt nfa 1 )

  _header _public,'WORDLIST-FIND'
wordlist_find_:
  call do_colon   ; save IP
  dw $+2
  pop hl
  ld a,l
  or h
  jp z,wordlist_find_.2  ; wid=0
  ld e,(hl)
  inc hl
  ld d,(hl)
wordlist_find_.1:
  pop hl    ; string
  push hl
  ld a,e   ; end of list?
  or d
  ex de,hl
  jp nz,wordlist_find_.3
wordlist_find_.2:
  pop de    ; discard string
  jp wordlist_find_.6    ; no match

wordlist_find_.3:
  push hl    ; save nfa
  ld c,(hl)
  ld a,c
  and 0x1F
  ld b,a   ; dict name length
  ld a,(de)    ; string length
  xor c   ; check lengths/smudge bit
  and 0x3F
  jp z,wordlist_find_.5
  inc hl    ; to link
wordlist_find_.4:
  inc hl
  dec b
  jp nz,wordlist_find_.4
  ld e,(hl)    ; next nfa
  inc hl
  ld d,(hl)
  pop hl    ; discard old
  jp wordlist_find_.1

wordlist_find_.5:
  inc hl    ; check each char
  inc de
  ld a,(de)
  if case_insensitive_names?
    call toupper_.a
  endif
  ld c,a
  ld a,(hl)
  if case_insensitive_names?
    call toupper_.a
  endif
  xor c
  jp nz,wordlist_find_.4 ; no match
  dec b
  jp nz,wordlist_find_.5
  inc hl    ; to link
  inc hl    ; to cfa pointer
  inc hl
  ld e,(hl)    ; get xt
  inc hl
  ld d,(hl)
  pop hl    ; nfa
  pop bc    ; discard string
  push de
  push hl
  ld a,(hl)
  and immediate_mask   ; immediate?
  ld hl,-1
  jp z,wordlist_find_.6
  inc hl
  inc hl
wordlist_find_.6:
  push hl
  jp paren_exit_

; (FIND)  ( ca -- ca 0 | xt -1 | xt 1 )
;
; searches CONTEXT CURRENT FORTH ; XXX ?
;
;       0  3 0 do
;         over i cells context + @
;         wordlist-find ?dup if  nip 2nip leave  then
;       loop

  _header _hidden,'(FIND)'
paren_find_:
  call do_colon
  dw zero_,three_,zero_
  dw paren_do_,paren_find_.end
paren_find_.do:
  dw over_
  dw i_,cells_
  dw context_,plus_,fetch_
  dw wordlist_find_,question_dup_
  dw question_branch_,paren_find_.loop
  dw nip_,two_nip_
  dw paren_leave_,paren_find_.do-cell
paren_find_.loop:
  dw paren_loop_,paren_find_.do
paren_find_.end:
  dw paren_exit_

; FIND  ( ca -- ca 0 | xt -1 | xt 1 )

  _header _public,'FIND'
find_:
  call fetch_execute_
  dw paren_find_

if 0 ; XXX TODO -- commented out in DX-Forth

; SEARCH-WORDLIST  ( ca u wid -- 0 | xt -1 | xt 1 )
;       >r wpack r> wordlist-find dup if nip then

  _header _public,'SEARCH-WORDLIST'
search_wordlist_:
  call do_colon
  dw to_r_
  if circular_string_buffer?
    dw save_counted_string_
  else
    dw wpack_
  endif
  dw from_r_
  dw wordlist_find_,dup_
  dw branch_if_0_,search_wordlist_.end
  dw nip_
search_wordlist_.end:
  dw paren_exit_

endif

if warning_options?

; -?  ( -- ) ; XXX OLD
; disable warnings for next definition only
; warning @ $fffe and warning !

  _header _public,'-?'
minus_question_:
  ld hl,warning_.variable
  ld a,(hl)
  and 0xFE    ; clear bit 0
  ld (hl),a
  jp next

; WARNING?  ( -- 0|1 )
; get warning flag and apply mask
;
;     warning @ dup if dup 1 and tuck if -1
;     else $7fff and 1 then or warning ! then

  _header _hidden,'WARNING?'
warning_question_:
  call do_colon
  dw warning_,fetch_
  dw dup_
  dw question_branch_,warning_question_.end
  dw dup_,one_,and_ ; test bit 0
  dw tuck_
  dw question_branch_,warning_question_.1
  dw true_    ; enable all warnings
  dw branch_,warning_question_.2
warning_question_.1:
  dw lit_,0x7FFF  ; disable compile warning
  dw and_
  dw one_   ; enable redefinition warning
warning_question_.2:
  dw or_
  dw warning_,store_
warning_question_.end:
  dw paren_exit_

endif

; IMMEDIATE  ( -- )

  _header _public,'IMMEDIATE'
immediate_:
  ld e,immediate_mask
  jp smudge_.1

; SMUDGE  ( -- )
;   $20 xnfa

  _header _public,'SMUDGE'
smudge_:
  ld e,smudge_mask
smudge_.1:
  push de
;  jp xnfa ; XXX OLD -- already commented out in DX-Forth, because 'xnfa' is headerless

; XNFA  ( x -- )
;   toggle nfa bit

xnfa:
  ld hl,(last_.nfa)
  jp c_toggle_.hl

; HEADER  ( xt|0 "name" -- )

;       warning? 2>r
;       bl-word  ( ca )
;       dup c@ 32 1 within abort" invalid name"
;       dup find nip r> and
;       if  dup count type ."  redefined"  then
;       dup count tuck +
;       get-current wordlist>name over ! cell+ swap
;       5 + dph @ over dph +!  dup
;       get-current ! rot r>
;       ?dup 0= if  here  then
;       dup rot ! over last 2! swap
;       cmove

  _header _public,'HEADER'
header_:
  call do_colon
  if warning_options?
    dw warning_question_
  else
    dw warning_,fetch_
  endif
  ; ( xt|0 f1 "name" )
  dw two_to_r_
  dw bl_word_
  dw dup_,c_fetch_ ; name length
  dw dup_,zero_equals_
  dw lit_,-16 ; attempt to use zero-length string as a name
  dw and_,throw_
  dw c_lit_
  db max_word_length
  dw greater_
  dw lit_,-19 ; definition name too long
  dw and_,throw_
  ; ( ca )
  dw dup_,find_,nip_ ; ( ca f ) found?
  dw from_r_       ; ( ca f f1 ) is 'warning' on?
  dw and_         ; ( ca wf )
  dw branch_if_zero_,header_.1
  ; the name was found and 'warning' is on
  ; ( ca )
  dw dup_,count_,type_
  dw paren_dot_quote_
  _dcs ' redefined  '
  ; XXX TODO  "redefined WORD  ", after Gforth, clearer?
header_.1:
  ; the name was not found or 'warning' is off
  dw dup_,count_ ; ( ca ca1 len1 )
  dw tuck_      ; ( ca len1 ca1 len1 )
  dw plus_      ; ( ca len1 ca1+len1 )
  dw get_current_,wordlist_to_name_ ; ( ca len1 ca1+len1 nfa )
  dw over_,store_ ; ( ca len1 ) store nfa after the name
  dw cell_plus_,swap_ ; ( len1+cell ca )
  dw c_lit_
  db 5
  dw plus_ ; ( len1+cell ca+5 )
  dw dph,fetch_ ; ( len1+cell ca+5 dp )
  ; XXX TODO -- keep on studying from here:
  dw over_,dph,plus_store_
  dw dup_
  dw get_current_
  dw store_   ; CP/M version
  dw rot_
  dw from_r_,question_dup_,zero_equals_
  dw question_branch_,header_.2
  dw here_
header_.2:
  dw dup_,rot_,store_
  dw over_,last_,two_store_
  dw swap_,cmove_
  dw paren_exit_

; ,CALL ( a -- )  $CD c, ,

  _header _hidden,',CALL'
comma_call_:
  call do_colon
  dw c_lit_
  db 0xCD    ; Z80 'call' opcode
  dw c_comma_
  dw comma_
  dw paren_exit_

; BUILD ( xt "name" -- )

  _header _public,'BUILD'
build_:
  call do_colon
  dw zero_,header_
  dw comma_call_
  dw paren_exit_

; :  ( "name" -- )
;
;       (docolon) build smudge bal off !csp
;       sp@ cs0 ! ]

  _header _public,':'
colon_:
  call do_colon
  dw lit_,do_colon
  dw build_
  dw smudge_
colon_.1:
  dw bal_,off_
  dw store_csp_
  if control_flow_stack_extensions?
    dw sp_fetch_,cs0_,store_
  endif
  dw right_bracket_
  dw paren_exit_

; EXIT  ( -- )
;   postpone (exit) ; immediate

  _header _public,'EXIT',_immediate
exit_: ; XXX TODO rename 'exit'
  if  0;debug? ; XXX INFORMER
    push af
    ld a,2
    out (254),a
    pop af
    ;jr $
  endif

  call do_colon

  if  0;debug? ; XXX INFORMER
    ; XXX FIXME this resets the machine:
    ;dw lit,2,border_
    ;dw paren_dotquote_
    ;_dcs 'exit',crchar
  endif

  dw compile_,paren_exit_
  if  0;debug? ; XXX INFORMER
    ; XXX FIXME this resets the machine
    ;dw lit,3,border_
    ;dw paren_dotquote_
    ;_dcs 'exit',crchar
  endif
  dw paren_exit_

; XXX TMP NEW layout
; : ;  ( -- )
;   postpone exit  bal @ ?bal ?csp smudge
;   postpone [
   ; immediate

  _header _public,';',_immediate
semicolon_:
  call do_colon
  dw exit_
  dw bal_,fetch_
  dw question_bal_
  dw question_csp_
  dw smudge_
  dw left_bracket_
  dw paren_exit_

; :NONAME  ( -- xt )
;   warning? drop here dup (dummynfa) last 2!
;       (docolon) ,call bal off !csp sp@ cs0 ! ]

  _header _public,':NONAME'
nonam_:
  call do_colon
  if warning_options?
    dw warning_question_,drop_  ; allow -?
  endif
  dw here_
  dw dup_    ; allow RECURSE etc
  dw lit_,dummy_nfa  ; allow IMMEDIATE etc
  dw last_,two_store_
  dw lit_,do_colon
  dw comma_call_
  dw branch_,colon_.1

; (;CODE)     r> last cell+ @ 1+ !

  _header _public,'(;CODE)'
paren_semicolon_code_:
  ld hl,(last_.xt)
  inc hl
  ld (hl),c
  inc hl
  ld (hl),b
  jp paren_exit_

; DOES>

  _header _public,'DOES>',_immediate
does_:
  call do_colon
  dw compile_,paren_semicolon_code_   ; postpone (;code)
  dw lit_,do_colon                   ; do_colon
  dw comma_call_                     ; ,call
  dw paren_exit_

; CREATE  ( -- a ) 'next build

  _header _public,'CREATE'
create_:
  ld hl,next
  push hl
  jp build_

; VARIABLE  ( -- a ) create 2 allot

  _header _public,'VARIABLE'
variable_:
  call do_colon
  dw create_
  dw two_,allot_
  dw paren_exit_

; VALUE  ( -- x )
;   (dovalue) build ,

  _header _public,'VALUE'
value_:
  call do_colon
value_.1:
  dw lit_,do_value
  dw build_
  dw comma_
  dw paren_exit_

; CONSTANT  ( -- x )
;   char? if (dobyteconstant) build c,
;       else value then

  _header _public,'CONSTANT'
constant_:
  call do_colon
  dw char_question_ ; 8-bit number?
  dw branch_if_false_,value_.1 ; no
  ; yes
  dw lit_,do_byte_constant
  dw build_
  dw c_comma_
  dw paren_exit_

; 2VARIABLE  ( -- a )
;   create 4 allot

  _header _public,'2VARIABLE'
two_variable_:
  call do_colon
  dw create_
  dw c_lit_
  db 4
  dw allot_
  dw paren_exit_

; 2CONSTANT  ( -- x2 x1 )
;   (dotwoconstant) build , ,

  _header _public,'2CONSTANT'
two_constant_:
  call do_colon
  dw lit_,do_two_constant
  dw build_
  dw comma_,comma_
  dw paren_exit_

; USER  ( -- a )

  _header _public,'USER'
user_:
  call do_colon
  dw lit_,do_user_variable
  dw build_
  dw comma_
  dw paren_exit_

; ADDR  ( "name" -- a )
;
;   ' >body  compiling? if  postpone literal  then  ; immediate
;
; Note: immediate, state-smart

  _header _public,'ADDR',_immediate
addr_:
  call do_colon
  dw tick_,to_body_
  dw compiling_question_
  dw question_branch_,addr_.end
  dw literal_
addr_.end:
  dw paren_exit_

; (TO)  ( x -- )
;   r> dup cell+ >r @ >body !

  _header _hidden,'(TO)'
paren_to_:
  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a
  inc bc
  inc hl
  inc hl
  inc hl
  jp store_.into_hl_pointer

; TO  ( x "name" -- )
;
;   ' state? if postpone (to) , else >body !  then ; immediate
; Note: state-smart

  _header _public,'TO',_immediate
to_:
  call do_colon
  dw tick_
  dw compiling_question_
  dw question_branch_,to_.1
  dw compile_,paren_to_,comma_
  dw branch_,to_.end
to_.1:
  dw to_body_,store_
to_.end:
  dw paren_exit_

; (DEFER-DEFAULT)  ( -- )

  _header _public,'(DEFER-DEFAULT)'
paren_defer_default_:
  call do_colon
  dw lit_,-13 ; undefined word
  dw throw_

; DEFER-DEFAULT  ( -- )  gforth

  _header _public,'DEFER-DEFAULT'
defer_default_:
  call fetch_execute_
  dw paren_defer_default_

; DEFER  ( "name" -- )  comus 2012

  ; XXX TODO use 'jp deferdefault' instead of 'call fetch_execute'. It would
  ; save one byte per definition and the execution would be faster, but then xt
  ; would not be stored in the body and 'is' could not be a synonym of 'to'.

  _header _public,'DEFER'
defer_:
  call do_colon
  dw lit_,fetch_execute_
  dw build_
  dw lit_,defer_default_,comma_
  dw paren_exit_

; DEFER!  ( xt1 xt2 -- )  2012

  _header _public,'DEFER!'
defer_store_:
  call do_colon
  if defer_uses_body?
    dw to_body_
  else ; XXX TODO -- not used yet
    dw one_plus_
  endif
  dw store_
  dw paren_exit_

; DEFER@  ( xt -- )  2012

  _header _public,'DEFER@'
defer_fetch_:
  ; XXX TODO faster with ix?
  pop de ; xt
  if defer_uses_body?
    inc de ; address after the 'call' opcode
    inc de
    inc de ; pfa
  else ; XXX TODO -- not used yet
    inc de ; address after the 'jp' opcode
  endif
  ld a,(de)
  ld l,a
  inc de
  ld a,(de)
  ld h,a
  jp push_hl

; IS  ( xt "name" -- )
;
; Note: state-smart

  ; XXX TODO see note in 'defer'
  _header _public,'IS',_immediate,to_
is_: equ to_

paren_is: equ paren_to_

; ALIAS  ( xt "newname" -- )  Gforth

; Note: alias doesn't copy the precedence bit of the xt

  _header _public,'ALIAS'
alias_:
  call do_colon
  dw header_
  dw c_lit_
  db alias_mask
  dw xnfa             ; set the alias mask of the header
  dw paren_exit_

; AKA  ( "oldname" "newname" -- )
;   defined tuck ?defined (header)
;   $80 xnfa 0> if immediate then
; XXX TODO move this to a Forth source file.

  _header _public,'AKA'
aka_:
  call do_colon
  dw defined_         ; ( ca|xt -1|0|1 )
  dw tuck_             ; save for later
  dw question_defined_ ; abort if not defined
aka_.alias:
  ; ( -1|1 xt "newname" )
  dw header_           ; ( -1|1 )
  dw c_lit_
  db alias_mask
  dw xnfa             ; set the alias mask of the header
  dw zero_greater_     ; is the old word immediate?
  dw branch_if_false_,aka_.end
  dw immediate_        ; make the new word immediate too
aka_.end:
  dw paren_exit_

; SYNONYM ( "newname" "oldname" -- )  2012
;   defined tuck ?defined (header)
;   $80 xnfa 0> if immediate then

  ; XXX TODO so far this is a copy of 'aka'

  _header _public,'SYNONYM'
synonym_:
  call do_colon
  dw defined_         ; ( ca|xt -1|0|1 )
  dw tuck_             ; save for later
  dw question_defined_ ; abort if not defined
synonym_.alias:
  ; ( -1|1 xt "newname" )
  dw header_           ; ( -1|1 )
  dw c_lit_
  db alias_mask
  dw xnfa             ; set the alias mask of the header
  dw zero_greater_     ; is the old word immediate?
  dw branch_if_false_,synonym_.end
  dw immediate_        ; make the new word immediate
synonym_.end:
  dw paren_exit_

; }}} **********************************************************
; Constants {{{

; TRUE  ( -- true )

  _header _public,'TRUE'
true_:
  ld hl,true
  _push_hl_jp_next

; FALSE  ( -- false )

  _header _public,'FALSE'
false_:
  ld hl,false
  _push_hl_jp_next

; -1  ( -- -1 )
;   aka true -1

  _header _public,'-1',,true_
minus_one_: equ true_

; 0  ( -- 0 )
;   aka false 0

  _header _public,'0',,false_
zero_: equ false_

; 1  ( -- 1 )

  _header _public,'1'
one_:
  call do_byte_constant
  db 1

; 2  ( -- 2 )

  _header _public,'2'
two_:
  call do_byte_constant
  db 2

; 3  ( -- 3 )

  _header _public,'3'
three_:
  call do_byte_constant
  db 3

; 4  ( -- 4 )

  _header _public,'4'
four_:
  call do_byte_constant
  db 4

; BL  ( -- 32 )
;   ascii value for space character

  _header _public,'BL'
bl_:
  call do_byte_constant
  db sp_char

; For applications, LIMIT is the upper limit of available memory.
; In Forth, it is the beginning of the area which holds the screen file
; buffer, word headers and system definitions.

; LIMIT  ( -- a )
; ; XXX OLD -- still used by 'forget' and 'words'
; XXX TODO convert
; XXX TODO move to <src/dxforth.fs>

  _header _public,'LIMIT'
limit_:
  call do_value
limit_.1:
  ds cell    ; patched by COLD

; 'NEXT  ( -- a )
;   address of NEXT

  _header _public,"'NEXT"
tick_next_:
  call do_constant
tick_next_.variable:
  dw next

; }}} **********************************************************
; Variables {{{

; UDP  ( -- a )
; user data pointer

  _header _public,'UDP'
udp_:
  call do_constant
  dw user_data_pointer

; FSP  ( -- a )
;   fp stack pointer

  _header _public,'FSP'
fsp_:
  call do_create
fsp_.variable:
  ds cell

; BOOT  ( -- xt )

  _header _hidden,'BOOT'
boot_:
  call do_create
boot_xt:
  dw 0

; SYS  ( -- a )
; compile system or application
; application word - used by HERE, UNUSED
; XXX OLD -- but still used by other words that will be rewritten
; XXX TODO move to <src/dxforth.fs>
  _header _public,'SYS'
sys_:
  call do_create
sys_.variable:
  dw 0

; LAST  ( -- a )
; occupies 2 cells
; XXX TODO separate and rename
; In Gforth: LATESTXT and LATEST
; XXX TODO : latest-xt latest-nt latest-name latest-nfa ?

  _header _hidden,'LAST'
last_:
  call do_create
last_.nfa:
  ds cell
last_.xt:
  ds cell

; BLK

  _header _public,'BLK'
blk_:
  call do_create
blk_.variable:
  ds cell

; >IN

  _header _public,'>IN'
in_:
  call do_create
in_.variable:
  ds cell

; SCR
; occupies 2 cells

  _header _public,'SCR'
scr_:
  call do_create
  ds 2*cell

; STATE

  _header _public,'STATE'
state_:
  call do_create
state_.variable:
  ds cell

; 'SOURCE     occupies 2 cells

  _header _public,"'SOURCE"
tick_source_:
  call do_create
tick_source_.variable:
  ds 2*cell

; WARNING

  _header _public,'WARNING'
warning_:
  call do_create
warning_.variable:
  ds cell

; CSP

  _header _public,'CSP'
csp_:
  call do_create
csp_.variable:
  ds cell

; CHECKING

  _header _public,'CHECKING'
checking_:
  call do_create
checking_.variable:
  ds cell

; ABORT-MESSAGE  ( -- a )
; message holder for abort"

  _header _hidden,'ABORT-MESSAGE'
abort_message_:
  call do_create
  ds 2*cell

; CONTEXT  ( -- a )

  _header _public,'CONTEXT'
context_:
  call do_create
context_.variable:
  ds cell    ; context
current.variable:
  ds cell    ; current
  dw forth_.1    ; Forth

; GET-CONTEXT  ( -- wid )

  ; XXX TODO -- why needed and hidden?
  ; 'context @' can be used instead
  _header _hidden,'GET-CONTEXT'
get_context_:
  ld hl,(context_.variable)
  _push_hl_jp_next

; GET-CURRENT  ( -- wid )

  _header _public,'GET-CURRENT'
get_current_:
  ld hl,(current.variable)
  _push_hl_jp_next


; SET-CURRENT  ( wid -- )

  _header _public,'SET-CURRENT'
set_current_:
  ld hl,current.variable
  jp store_.into_hl_pointer

; }}} **********************************************************
; User variables {{{

; user variables 0, 2, 4 are reserved for multitasking

; S0  ( -- a )

  _header _public,'S0'
s0_:
  call do_user_variable
  dw 6

; R0  ( -- a )

  _header _public,'R0'
r0_:
  call do_user_variable
  dw 8

; DP  ( -- a )

  _header _public,'DP'
dp_:
  call do_user_variable
  dw 10

dph: equ dp_ ; XXX TMP NEW

; VOC-LINK  ( -- a )

  _header _public,'VOC-LINK'
voc_link_:
  call do_user_variable
  dw 14

; FS0  ( -- a )

  _header _public,'FS0'
fs0_:
  call do_user_variable
  dw 16

; user variable 18 reserved for future expansion

; End of boot-up literals

; DPL  ( -- a )

  _header _public,'DPL'
dpl_:
  call do_user_variable
  dw 20

; HLD  ( -- a )

  _header _hidden,'HLD'
hld_:
  call do_user_variable
  dw 22

; BASE  ( -- a )

  _header _public,'BASE'
base_:
  call do_user_variable
  dw 24

; bytes 26-27   reserved for locals

; OUT  ( -- a )

  _header _public,'OUT'
out_:
  call do_user_variable
  dw 28

; bytes 30-33   reserved

; CATCHER  ( -- a )

  _header _public,'CATCHER'
catcher_:
  call do_user_variable
  dw 34

; bytes 36-43   reserved

; XXX NEW -- this substitutes the old 'scaps', 'caps' and '-caps'
; CASE-SENSITIVE-SEARCH  ( -- a )
; case flag for 'compare' and 'search'

  _header _public,'CASE-SENSITIVE-SEARCH'
case_sensitive_search_:
  call do_user_variable
case_sensitive_search_user_variable: equ 44
  dw case_sensitive_search_user_variable

; User area bytes 46 onwards are available for user applications

; }}} **********************************************************
; Forth system {{{

; SYS?  ( -- flag )
; sys @ 0<>

  ; XXX OLD -- but still used by
  _header _hidden,'SYS?'
sys_question_:
  ld hl,(sys_.variable)
  jp zero_not_equals_hl

; COMPILING?  ( -- flag )
;   state @ 0<>

  _header _public,'COMPILING?'
compiling_question_:
  ld hl,(state_.variable)
  jp zero_not_equals_hl

; EXECUTING?  ( -- flag )
;   state @ 0<>

  _header _public,'EXECUTING?'
executing_question_:
  ld hl,(state_.variable)
  jp zero_equals_hl

; CHECK?  ( -- flag ) checking @ 0<>

  _header _hidden,'CHECK?'
check_question_:
  ld hl,(checking_.variable)
  jp zero_not_equals_hl

; ALLOT  ( n -- )

  _header _public,'ALLOT'
allot_:
  call do_colon
  dw here_,over_
  dw zero_max_,dup_
  dw unused_,u_greater_
  dw lit_,-8 ; dictionary overflow
  dw and_,throw_
  dw erase_
  dw dp_,plus_store_
  dw paren_exit_

; HERE  ( -- a )

  _header _public,'HERE'
here_:
  call do_colon
  dw dp_,fetch_
  dw paren_exit_

; C,  ( c -- )

  _header _public,'C,'
c_comma_:
  call do_colon
  dw here_,one_,allot_,c_store_
  dw paren_exit_

; ,  ( n -- )

  _header _public,','
comma_:
  call do_colon
  dw here_,two_,allot_,store_
  dw paren_exit_

; >BODY  ( xt -- pfa )

  _header _public,'>BODY'
to_body_:
  ld de,3
  jp plus_de

; BODY>  ( a -- xt )
;
; XXX -- this word was commented out in DX-Forth, why?
  _header _hidden,'BODY>'
from_body_:
  ld de,-3
  jp plus_de

; N>LINK  ( nfa -- lfa )

  _header _public,'N>LINK'
n_to_link_:
  call do_colon
  dw name_to_string_,plus_
  dw paren_exit_

; N>NAME  ( nfa1 -- nfa2 | 0 )

  _header _public,'N>NAME'
n_to_name_:
  call do_colon
  dw n_to_link_,fetch_  ; n>link @
  dw paren_exit_

; NAME>  ( nfa -- xt )

  _header _public,'NAME>'
name_from_:
  call do_colon
  dw n_to_link_,cell_plus_,fetch_ ; n>link cell+ @
  dw paren_exit_

; WORDLIST>NAME  ( wid -- nfa | 0 )
;   aka @ wordlist>name

  _header _public,'WORDLIST>NAME',,fetch_
wordlist_to_name_: equ fetch_

; XXX TMP still used in the Forth sources
; XXX OLD moved to <src/dxforth.fs>
;  _header _public,'W>NAME',,fetch_
;w_to_name_: equ fetch_
  

; -ALIAS  ( nfa -- nfa flag )
; false if alias
; XXX TODO rename
;   dup c@ $80 <

  _header _hidden,'-ALIAS'
minus_alias_:
  pop hl
  push hl
  ld a,(hl)
  cp alias_mask
  if size_optimization?
    jp true_if_cy
  else
    jp c,true_
    jp false_
  endif

; >NAME  ( xt -- nfa | 0 )
;        voc-link begin @ dup while tuck cell-
;        wordlist>name
;        begin ?dup while -alias if 2dup name> = if
;        -rot 2drop exit then then n>name repeat swap
;        repeat nip

  _header _public,'>NAME'
to_name_:
  call do_colon
  dw voc_link_
to_name_.1:
  dw fetch_
  dw dup_
  dw question_branch_,to_name_.5
  dw tuck_
  dw cell_minus_
  dw wordlist_to_name_
to_name_.2:
  dw question_dup_
  dw question_branch_,to_name_.4
  dw minus_alias_    ; skip if alias
  dw question_branch_,to_name_.3
  dw two_dup_,name_from_
  dw equals_
  dw question_branch_,to_name_.3
  dw minus_rot_,two_drop_
  dw paren_exit_
to_name_.3:
  dw n_to_name_
  dw branch_,to_name_.2
to_name_.4:
  dw swap_
  dw branch_,to_name_.1
to_name_.5:
  dw nip_
  dw paren_exit_    ; not found

; NAME>STRING  ( nfa -- ca len )

; XXX TODO
; DX-Forth had '(name)' and 'n>count' for the same function.
; Ask Ed why.

  _header _hidden,'NAME>STRING'
name_to_string_:
  pop de
  ld a,(de)
  inc  de
  and max_word_length ; mask (0x1F)
  ld l,a
  ld h,0
  jp push_de_hl

; .ID  ( nfa | 0 -- )
;   ?dup if (name) type exit then
;         ." [noname]"

  _header _public,'.ID'
dot_id_:
  call do_colon
  dw question_dup_
  dw question_branch_,dot_id_.1
  dw name_to_string_,type_
  dw paren_exit_
dot_id_.1:
  dw paren_dot_quote_
  _dcs '[noname]'
  dw paren_exit_

; XXX TMP -- it's still used in the Forth sources
; XXX OLD -- moved to <src/dxforth.fs>
;_header _public,'SYSTEM',_immediate,noop_
;  system_: equ noop_

; .NAME  ( xt -- )
;   >name .id
; XXX TODO -- remove, ambiguous

  _header _public,'.NAME'
dot_name_:
  call do_colon
  dw to_name_,dot_id_
  dw paren_exit_

; .WID  ( wid -- )
; XXX NEW Renamed from '.VOC' (DX-Forth 4.09)
  _header _public,'.WID'
dot_wid_:
  call do_colon
  dw cell_plus_,cell_plus_
  dw fetch_,dot_id_
  dw paren_exit_

; !CSP  ( -- )
;   sp@ csp !

  _header _public,'!CSP'
store_csp_:
  ld hl,0
  add hl,sp
  ld (csp_.variable),hl
  jp next

; ?CSP  ( -- )
;   sp@ csp @ - ?bal

  _header _public,'?CSP'
question_csp_:
  call do_colon
  dw sp_fetch_
  dw csp_,fetch_
  dw minus_
  dw question_bal_
  dw paren_exit_

; ?COMP  ( -- )
;   executing? -14 and throw
; XXX TODO rename '?compiling'

  _header _public,'?COMP'
question_comp_:
  call do_colon
  dw executing_question_
  dw lit_,-14 ; interpreting a compile-only word
  dw and_,throw_
  dw paren_exit_

; ?EXEC  ( -- )
;   compiling? -14 and throw
; XXX TODO rename '?executing'

  _header _public,'?EXEC'
question_exec_:
  call do_colon
  dw compiling_question_
  dw lit_,-256 ; compiling an interpret-only word ; XXX TMP
  dw and_,throw_
  dw paren_exit_

; ?STACK  ( -- )
; XXX TODO finish
;       sp@ s0 @ u< abort" stack ?"
;       r0 @ rp@ u< rp@ fs0 @ u< or abort" r-stack?"
;       fs0 @ fsp @ u< fsp @ fs0 @ (nfpm) @ - u< or abort" f-stack?"

  _header _public,'?STACK'
question_stack_:
  call do_colon
  dw sp_fetch_
  dw s0_,fetch_
  dw u_greater_
  dw lit_,-4 ; stack underflow
  dw and_,throw_
  ; XXX TODO
;  dw sp_fetch_,s0_,fetch_,u_less_
;  dw lit_,-3 ; stack overrflow
;  dw and_,throw_
  dw rp_fetch_,r0_,fetch_,u_greater_
  dw lit_,-6 ; return stack underflow
  dw and_,throw_
  ; XXX TODO
;  dw rpfetch,r0,fetch,uless
;  dw lit_,-5 ; return stack overflow
;  dw and_,throw_
;  XXX TODO -- fp stack, if separated
  dw paren_exit_

; ?DEFINED  ( flag -- )

  _header _hidden,'?DEFINED'
question_defined_:
  call do_colon
  dw zero_equals_
  dw lit_,-13 ; undefined word
  dw and_,throw_

  dw paren_exit_

; [ ( -- )
;   state off ; immediate

  _header _public,'[',_immediate
left_bracket_:
  ld hl,state_.variable
  jp off_.hl

; ] ( -- )
;   state on

  _header _public,']'
right_bracket_:
  ld hl,state_.variable
  jp on_.hl

; COMPILE,  ( xt -- )

  _header _public,'COMPILE,',,comma_
compile_comma_:  equ comma_
; XXX OLD
;compilecomma:
;  call docolon
;  dw warning,fetch
;  if warningoptions
;    dw zeroless
;  endif
;  dw questionbranch,compilecomma.end
;  dw dup,limit
;  dw uless
;  dw sysquestion
;  dw dzeroequals
;  dw questionbranch,compilecomma.end
;  dw dup
;  dw dotname
;  dw parendotquote
;  dcs ' is system '
;compilecomma.end:
;  dw comma
;  dw parenexit

; COMPILE  ( -- )
;   ?comp r> dup cell+ >r @ compile,

  _header _public,'COMPILE'
compile_:
  if  0;debug? ; XXX INFORMER
    push af
    ld a,2
    out (254),a
    pop af
    ;jr $
  endif
  call do_colon
  dw question_comp_
  dw from_r_
  dw dup_,cell_plus_
  dw to_r_
  dw fetch_
  dw compile_comma_
  dw paren_exit_

; POSTPONE  ( "name" -- )
;   defined dup ?defined 0< if compile
;   compile then compile, ; immediate

  _header _public,'POSTPONE',_immediate
postp_:
  call do_colon
  dw defined_
  dw dup_,question_defined_
  dw zero_less_
  dw question_branch_,postp_.1
  dw compile_,compile_
postp_.1:
  dw compile_comma_
  dw paren_exit_

; -CURSOR ( n -- ) ; XXX NEW
;   delete the cursor

  _header _hidden,'-CURSOR'

minus_cursor_:
  call do_colon
  dw space_
  dw c_lit_
  db left_char
  dw emit_
  dw paren_exit_

; BACKSPACES  ( +n -- )
;   delete +n chars at the left of the cursor

  _header _hidden,'BACKSPACES'

backspaces_:
  call do_colon
backspaces_.do:
  dw c_lit_
  db left_char
  dw dup_,emit_,space_,emit_
  dw one_minus_,dup_
  dw branch_if_not_false_,backspaces_.do
  dw drop_
  dw paren_exit_

; (ACCEPT-CONTROL-CHAR)  ( ca len len2 c -- ca len len2' )

  _header _hidden,'(ACCEPT-CONTROL-CHAR)'

paren_accept_control_char_:

  call do_colon

paren_accept_control_char_.0:
  ; check the delete key
  dw dup_,c_lit_
  db delete_char
  dw equals_ ; delete?
  dw branch_if_false_,paren_accept_control_char_.edit
  ; delete the last char
  dw drop_ ; c
  dw dup_ ; something to delete?
  dw branch_if_zero_,paren_accept_control_char_.end
  ; do it
  dw minus_cursor_,one_minus_,one_,backspaces_
  dw paren_exit_

paren_accept_control_char_.edit:
  ; check the edit key
  dw c_lit_
  db edit_char
  dw equals_ ; edit?
  dw branch_if_false_,paren_accept_control_char_.end
  ; delete the whole input
  dw dup_ ; something to delete?
  dw branch_if_zero_,paren_accept_control_char_.end
  ; do it
  dw minus_cursor_,zero_,swap_,backspaces_

paren_accept_control_char_.end:
  dw paren_exit_

; (ACCEPT-PRINTABLE-CHAR)  ( ca len len2 c -- ca len len2' )

  _header _hidden,'(ACCEPT-PRINTABLE-CHAR)'

paren_accept_printable_char_:
  call do_colon ; XXX entry not used

paren_accept_printable_char_.0:
  dw to_r_,two_dup_,minus_,from_r_,swap_ ; space left
  dw branch_if_0_,paren_accept_printable_char_.no

  ; there's space left for the char
  dw dup_,emit_,over_
  dw c_lit_
  db 4
  dw pick_,plus_,c_store_,one_plus_
  dw paren_exit_

paren_accept_printable_char_.no:
  ; no space left for the char
  dw drop_
  dw paren_exit_

; (ACCEPT-KEY)  ( ca len len2 c -- ca len len2' )

  _header _hidden,'(ACCEPT-KEY)'

paren_accept_key_:
  call do_colon
  dw dup_,bl_,less_ ; control char?
  dw branch_if_true_,paren_accept_control_char_.0
  ; not a control char
  dw branch_,paren_accept_printable_char_.0
  dw paren_exit_

; (ACCEPT)  ( ca len -- len2 )

  _header _hidden,'(ACCEPT)'
paren_accept_:
  call do_colon
  dw zero_ ; len2
paren_accept_.do:
  dw c_lit_
  db 136 ; XXX TMP cursor char
  dw emit_
  dw c_lit_
  db bs_char
  dw emit_
  dw key_,dup_
  dw c_lit_
  db cr_char
  dw equals_  ; enter key?
  dw branch_if_true_,paren_accept_.end
  dw paren_accept_key_
  dw branch_,paren_accept_.do
paren_accept_.end:
  dw minus_cursor_,space_
  dw drop_,nip_,nip_
  dw paren_exit_

; ACCEPT  ( ca +n1 -- +n2 )

  _header _public,'ACCEPT'
accept_:
  call fetch_execute_
  dw paren_accept_

if tib?

; TIB  ( -- a )
; address of the terminal input buffer

  _header _public,'TIB'

tib_:
  ld hl,tib_address
  jp push_hl

; #TIB  ( -- u )
; characters in the terminal input buffer

  _header _public,'#TIB'

number_tib_:
  call do_variable
  dw 0

endif

; PAD  ( -- a )

  _header _public,'PAD'
pad_:
  call do_colon
  dw here_
  dw lit_,pictured_numeric_output_buffer_size
  dw plus_
  dw paren_exit_

; SOURCE  ( -- ca len )
;   'source 2@

  _header _public,'SOURCE'
source_:
  ld hl,tick_source_.variable
  jp two_fetch_.hl

; PARSE  ( c -- ca len )
;   0 (parse)

  _header _public,'PARSE'
parse_:
  ld hl,0
  push hl
  jp paren_parse_

if 0 and circular_string_buffer? ; XXX TMP

; XXX TODO

else

; XXX -- original version

; (PARSE)  ( c f -- ca len )
;
;         2>r source >in @ /string
;         r> if
;           tuck r@ skip over - >in +!
;         then
;         2dup r> scan nip tuck - dup rot 0<> -
;         >in +!
; 
; XXX TODO -- what f means?:
; f = true, when called from 'word'
; f = false, when called from 'parse'
; XXX -- It seems the difference is where the string
; will be stored; this distinction will not be needed
; with a circular string buffer.

  _header _hidden,'(PARSE)'
paren_parse_:
  call do_colon

  dw two_to_r_
  dw source_            ; ( ca len )
  dw in_,fetch_         ; ( ca len in )
  dw slash_string_      ; ( ca2 len2 )

  ; XXX TODO move this skipping to 'word':
  dw from_r_            ; ( ca2 len2 f )
  dw branch_if_0_,paren_parse_.1
  ; f<>0 (thus, '(parse)' was called by 'word')
  dw tuck_              ; ( len2 ca2 len2 )
  dw r_fetch_           ; ( len2 ca2 len2 c )
  dw skip_              ; ( len2 ca2' len2' )
  dw rot_,over_         ; ( ca2' len2' len2 len2' )
  dw minus_             ; ( ca2' len2' diff )
  dw in_,plus_store_    ; ( ca2' len2' )

paren_parse_.1:
  dw two_dup_           ; ( ca2' len2' ca2' len2' )
  dw from_r_            ; ( ca2' len2' ca2' len2' c )
  dw scan_,nip_         ; ( ca2' len2' len3 )
  dw tuck_              ; ( ca2' len3 len2' len3 )
  dw minus_,dup_        ; ( ca2' len3 len2'-len3 len2'-len3 )
  dw rot_               ; ( ca2' len2'-len3 len2'-len3 len3 )
  dw zero_not_equals_   ; ( ca2' len2'-len3 len2'-len3 len3<>0? )
  dw minus_             ; ( ca2' len2'-len3 len4 )
                        ; when len3=0,  then len4 = len2'
                        ; when len3<>0, then len4 = len2'-len3+1
  dw in_,plus_store_
  dw paren_exit_

endif

; +PSB  ( a1 n1 n2 -- n3 )
;
;   >r (parsed_string_buffer_size) r@ - umin r> 2dup + >r
;   (parsed_string_buffer) + swap cmove r>
;
; XXX -- needed only by 'parse$'

  _header _hidden,'+PSB'
plus_psb_:
  call do_colon
  dw to_r_
  dw lit_,parsed_string_buffer_size
  dw r_fetch_,minus_
  dw u_min_
  dw from_r_
  dw two_dup_,plus_
  dw to_r_
  dw lit_,parsed_string_buffer
  dw plus_
  dw swap_
  dw cmove_
  dw from_r_
  dw paren_exit_

; PARSE$  ( c "ccc<c>" -- ca len )
;         0 begin
;           >r dup parse 2dup r> +psb >r
;           1+ + dup source + u<
;         while
;           2dup c@ =
;         while
;             1 dup >in +! r> +psb
;         repeat then
;         2drop (parsed_string_buffer) r>

; XXX TODO -- rewrite in Z80 
; XXX TODO rename to 'parse-string'?

  _header _public,'PARSE$'
parse_dollar_:
  call do_colon
  dw zero_
parse_dollar_.1:
  dw to_r_
  dw dup_,parse_
  dw two_dup_
  dw from_r_,plus_psb_
  dw to_r_
  dw one_plus_,plus_
  dw dup_
  dw source_,plus_
  dw u_less_
  dw question_branch_,parse_dollar_.2
  dw two_dup_,c_fetch_
  dw equals_
  dw question_branch_,parse_dollar_.2
  dw one_,dup_
  dw in_,plus_store_
  dw from_r_,plus_psb_
  dw branch_,parse_dollar_.1
parse_dollar_.2:
  dw two_drop_
  dw lit_,parsed_string_buffer
  dw from_r_
  if circular_string_buffer?
    dw save_string_ ; XXX TMP until the 'parse$' is rewritten to use the buffer
  endif
  dw paren_exit_

; PWA  ( -- ca )
; parsed word address

  _header _public,'PWA'
pwa_:
  call do_value
  ds cell

if not circular_string_buffer?

; WPACK  ( ca1 len1 -- ca2 )
;
; Pack string in the 'word' buffer
;
;   255 min (hm-5) over - dup to pwa packed
;   bl affix

  _header _hidden,'WPACK'
wpack_:
  call do_colon
  dw c_lit_
  db 255          ; 255
  dw min_          ; min
  if  classic_Forth_behaviours?
    dw here_
  else
    dw lit_,hm-5     ; (hm) 5 -
    dw over_,minus_   ; over -
  endif
;  dw dup_,paren_to_,pwa_ ; to pwa ; XXX OLD
  dw packed_
  dw bl_,affix_     ; bl affix \ add a trailing blank
  dw paren_exit_

endif

; WORD  ( c -- ca )

  _header _public,'WORD'
word_:
  call do_colon
  dw true_,paren_parse_
  if circular_string_buffer?
    dw save_counted_string_
;    dw dup_,paren_to_,pwa_ ; XXX OLD -- it was copied from 'wpack'
  else
    dw wpack_
  endif
  dw paren_exit_

; BL-WORD  ( -- ca )

  _header _public,'BL-WORD'
bl_word_:
  ld hl,sp_char
  push hl     ; bl
  jp word_     ; word

; PARSE-NAME  ( "name" -- ca len )

  ; XXX TODO write 'word' based on 'parse-name', not the other way
  ; XXX TODO or make 'word' and 'parse-name' independent and faster
  _header _public,'PARSE-NAME'
parse_name_:
  call do_colon
  dw bl_word_,count_
  dw paren_exit_

; XXX TMP -- it's still used in the Forth source files
;  _header _public,'TOKEN',,parse_name_
;token_: equ parse_name_

; DEFINED  ( -- ca 0 | xt -1 | xt 1 )

  _header _hidden,'DEFINED'
defined_:
  call do_colon
  dw bl_word_,find_
  ; XXX INFORMER
;  _debug 'defined word: ',1
;  dw lit_,red_color,border_
;  dw pwa_,count_,type_
  dw paren_exit_

; '  ( -- a )

  _header _public,"'"
tick_:
  call do_colon
  dw defined_,question_defined_ ; defined ?defined
  dw paren_exit_

; [UNDEFINED]  ( -- flag )
;   defined nip 0= ; immediate

  _header _public,'[UNDEFINED]',_immediate
budef_:
  call do_colon
  dw defined_
  dw nip_
  dw zero_equals_
  dw paren_exit_

; [DEFINED]  ( -- flag )
;   postpone [undefined] 0= ; immediate

  _header _public,'[DEFINED]',_immediate
bdef_:
  call do_colon
  dw budef_,zero_equals_
  dw paren_exit_

; (  ( "ccc<delim>" ) [char] ) parse 2drop ; immediate

  _header _public,'(',_immediate
paren_:
  call do_colon
  dw c_lit_
  db ')'
  dw parse_,two_drop_
  dw paren_exit_

; .(  ( "ccc<delim>" )
;   [char] ) parse$ type ; immediate

  _header _public,'.(',_immediate
dot_paren_:
  call do_colon
  dw c_lit_
  db ')'
  dw parse_dollar_,type_
  dw paren_exit_

; \  ( "ccc" -- )
;
;   source nip blk @
;   if  c/l >in @ over / 1+ * min  then
;   >in ! ; immediate

  _header _public,'\',_immediate
back_slash_:
  call do_colon
  dw source_,nip_  ; ( u1 )
  dw blk_,fetch_   ; ( u1 u2 )
  dw branch_if_0_,back_slash_.end
  ; the source is a block
;  _debug_variable '\ before calculation',debug_interpret
  dw chars_per_line_
  dw in_,fetch_
  dw over_,slash_
  dw one_plus_,star_
  dw min_
;  _debug_variable '\ after calculation',debug_interpret
back_slash_.end:
  ; ( u )
  dw in_,store_
  dw paren_exit_

; \\  ( "ccc" -- )
;   source nip >in ! ; immediate

  _header _public,'\\',_immediate
back_slashes_:
  call do_colon
  dw source_,nip_,in_,store_
  dw paren_exit_

; XXX NEW -- DX-Forth 4.09
; LINK,  ( a -- )
;   here over @ , swap !

  _header _public,'LINK,'
link_comma_:
  call do_colon
  dw here_
  dw over_,fetch_
  dw comma_
  dw swap_,store_
  dw paren_exit_

; XXX OLD -- DX-Forth 4.00
;;; WORDLIST  ( -- wid )  $2001 , here 0 , here dup voc-link @ , !
;;;       0 ,
;;
;;  header 0,'WORDLIST'
  ; nameless wordlists not supported
;;wordlist:
;;  call docolon
;;  dw lit,0x2001
;;  dw comma
;;  dw here
;;  dw zero    ; nfa of top word in vocabulary
;;  dw comma
;;  dw here,voclink
;;  dw dup,fetch   ; link to previous vocabulary
;;  dw comma
;;  dw store
;;  dw zero,comma  ; null name
;;  dw parenexit

; XXX NEW -- DX-Forth 4.09
; WORDLIST  ( -- wid )
;   $2001 , here 0 , voc-link link, 0 ,

  _header _hidden,'WORDLIST'
wordlist_:
  call do_colon
  dw lit_,0x2001
  dw comma_
  dw here_
  dw zero_    ; nfa of top word in vocabulary
  dw comma_
  dw voc_link_,link_comma_  ; link in wordlist
  dw zero_,comma_  ; null name
  dw paren_exit_

; VOCABULARY  ( "name" )
;       sys? system wordlist
       ;;  create dup ,  ;; XXX OLD -- DX-Forth 4.00
;       dup value  ;; XXX NEW -- DX-Forth 4.09
;       last @
;       swap cell+ cell+ ! sys ! does> @ context !

  _header _public,'VOCABULARY'
vocabulary_:
  call do_colon
  dw sys_question_
  dw wordlist_
;;  dw create,dup,comma ; XXX OLD -- DX-Forth 4.00
  dw dup_,value_ ; XXX NEW -- DX-Forth 4.09
  dw last_,fetch_   ; set name field in wordlist struct
  dw swap_
  dw cell_plus_,cell_plus_
  dw store_
  dw sys_,store_
  dw paren_semicolon_code_
do_vocabulary:
  call do_colon
  dw fetch_
  dw context_,store_
  dw paren_exit_

; DEFINITIONS  ( -- ) get-context set-current

  _header _public,'DEFINITIONS'
definitions_:
  call do_colon
  dw get_context_
  dw set_current_
  dw paren_exit_

; wordlist structure

; XXX TODO -- study how this works

forth_.3: defl previous_nfa

  dw 0x2001    ; dummy nfa for vocabulary chaining
forth_.1: ; XXX TODO rename this label
  dw top_nfa    ; nfa of top word in vocabulary
forth_.2: ; XXX TODO rename this label
  dw 0   ; previous vocabulary
  dw forth_.3    ; vocabulary nfa

; FORTH  ( -- )
; Forth vocabulary

  _header _public,'FORTH'
forth_:
  call do_vocabulary
  dw forth_.1

; UNUSED  ( -- u )
;
; Free memory in bytes.

  _header _public,'UNUSED'
unused_:
  call do_colon
  dw lit_,0xFFFF,here_,minus_
  dw paren_exit_

; DEBUG-INTERPRET  ( -- a )
; XXX TMP for debugging

  _header _hidden,'DEBUG-INTERPRET'
debug_interpret_:
  call do_variable
debug_interpret:
  dw false

; INTERPRET  ( -- )

  _header _public,'INTERPRET'
interpret_:
  call do_colon
interpret_.begin:
  _debug_variable 'start of interpret',debug_interpret
  dw bl_word_
  dw dup_,paren_to_,pwa_ ; XXX NEW
  _debug_variable 'interpret after bl_word',debug_interpret
  dw dup_,c_fetch_
  dw branch_if_0_,interpret_.end  ; while not end of input stream
  _debug_variable 'interpret before find',debug_interpret
  dw find_
  _debug_variable 'interpret after find',debug_interpret
  dw question_dup_
  dw branch_if_0_,interpret_.not_found

  ; found
  ; ( xt 1 | xt -1 )
  _debug_variable 'interpret -- found',debug_interpret
  dw compiling_question_,equals_ ; compiling an immediate word?
  dw branch_if_false_,interpret_.execute

  ; compiling and not immediate
  ; ( xt )
  _debug_variable 'interpret -- compiling and not immediate',debug_interpret
  dw compile_comma_
  dw branch_,interpret_.repeat

interpret_.execute:
  ; executing or immediate
  ; ( xt )
  _debug_variable 'interpret before execute',debug_interpret
  dw execute_
  _debug_variable 'interpret after execute',debug_interpret
  dw branch_,interpret_.repeat

interpret_.not_found:
  ; ( ca )
  _debug_variable 'interpret.not_found',debug_interpret
  dw base_,fetch_,to_r_ ; save the current base
  dw count_,over_,c_fetch_ ; get the string and its first char
  ; ( ca len c )

  ; XXX TODO -- factor out to a new word the number recognition with prefixes
  ; -- see Gforth's '>number', 'number?', 'snumber?'...

  ; XXX TODO recognize also chars: 'c'

  ; ( ca len c )
  dw c_lit_
  db '$'
  dw paren_of_,interpret_.check_binary
  ; it's "$" -- hex number
  _debug_variable 'interpret: hex prefix found',debug_interpret
  dw hex_,one_
  dw branch_,interpret_.remove_the_prefix

interpret_.check_binary:
  ; ( ca len c )
  dw c_lit_
  db '%'
  dw paren_of_,interpret_.check_decimal
  ; it's "%" -- binary number
  _debug_variable 'interpret: binary prefix found',debug_interpret
  dw binary_,one_
  dw branch_,interpret_.remove_the_prefix

interpret_.check_decimal:
  ; ( ca len c )
  dw c_lit_
  db '#'
  dw paren_of_,interpret_.check_char
  ; it's "#" -- decimal number
  _debug_variable 'interpret: decimal prefix found',debug_interpret
  dw decimal_,one_
  dw branch_,interpret_.remove_the_prefix

; XXX TODO suggest this improvement to the author of DX-Forth:
interpret_.check_char:
  ; there is no number prefix.
  ; does the string represent a char?
  ; this check is done at the end, because it's easier not
  ; to use '(of)' with it.
  ; ( ca len c )
  _debug_variable 'interpret.check_char',debug_interpret
  dw c_lit_
  db "'"
  dw equals_ ; is the first char a single quote?
  dw branch_if_false_,interpret_.number_question ; no
  ; the first char is a single quote
  _debug_variable 'interpret.check_char first quote',debug_interpret
  dw dup_,three_,equals_ ; len is 3?
  dw branch_if_false_,interpret_.number_question ; no
  ; len is 3
  _debug_variable 'interpret.check_char len 3',debug_interpret
  dw two_dup_,plus_,one_minus_,c_fetch_
  dw c_lit_
  db "'"
  dw equals_ ; is the last char a single quote?
  dw branch_if_false_,interpret_.number_question ; no
  ; the last char is a single quote
  _debug_variable 'interpret.check_char last quote',debug_interpret
  dw drop_,one_plus_,c_fetch_
  dw branch_,interpret_.single_number

interpret_.remove_the_prefix:
  ; ( ca len n )
  _debug_variable 'interpret.remove_the_prefix',debug_interpret
  dw slash_string_

interpret_.number_question:
  ; The number prefix, if any, has been removed.
  ; Is the string a number in the current base?
  ; ( ca len )
  _debug_variable 'interpret.number_question',debug_interpret
  dw two_dup_
; interpret_.number_question_patch: ; XXX OLD -- not used
  ; ( ca len ca len )
  dw number_question_
  ; ( ca len d true | ca len false )
  _debug_variable 'after number_question',debug_interpret

  dw branch_if_false_,interpret_.f_number

  _debug_variable 'it is a number!',debug_interpret
  dw two_nip_
  dw dpl_,fetch_,zero_less_ ; single number?
  dw branch_if_false_,interpret_.double_number
  dw drop_
interpret_.single_number:
  dw compiling_question_ ; compiling?
;  dw branch_if_false_,interpret_.9 ; XXX OLD
  dw branch_if_false_,interpret_.number_done ; XXX NEW
  dw literal_
;interpret.9: ; XXX OLD
;  dw branch_,interpret_.notanumber ; XXX why?
  dw branch_,interpret_.number_done ; XXX NEW

interpret_.double_number:
  dw compiling_question_ ; compiling?
;  dw question_branch,interpret_.notanumber ; XXX why?
  dw branch_if_false_,interpret_.number_done ; XXX NEW
  dw two_literal_
  dw branch_,interpret_.number_done ; XXX NEW

; XXX OLD
;interpret_.not_a_number:
;  dw true
;  dw branch,interpret_.question_defined

interpret_.f_number:
  ; ( ca len )
  if floating_point?
    dw f_number_
  else
    dw false_
  endif
  ; ( flag )
  _debug_variable 'after interpret_.f_number',debug_interpret

interpret_.question_defined:
  ; ( flag -- )
  ; abort if flag<>0
  _debug_variable 'before question_defined',debug_interpret
  dw question_defined_
  _debug_variable 'after question_defined',debug_interpret

interpret_.number_done:
  dw from_r_,base_,store_

interpret_.repeat:
  ; XXX FIXME stack depth is -1 here after executing a word!
  _debug_variable 'interpret.repeat',debug_interpret
  dw question_stack_
  dw branch_,interpret_.begin

interpret_.end:
  _debug_variable 'interpret.end',debug_interpret
  dw drop_

;  dw lit_,debug_interpret,off_ ; XXX TMP for debugging

  dw paren_exit_

; (CONTROL>BL)  ( ca len -- ca len )
; 
; Change all end-of-word control chars (CR, LF, TAB)
; to spaces in the given text.

  _header _public,'(CONTROL>BL)'
paren_control_to_bl_:
  ; XXX TODO -- other method faster than pop-push:
  pop de
  pop hl
  push hl
  push de
paren_control_to_bl_.begin:
  ; hl = pointer to current char
  ; de = remaining chars
  ld a,d
  or e
  jp z,next
  dec de
  ld a,(hl)
  cp cr_char
  jp z, paren_control_to_bl_.space
paren_control_to_bl_.check_tab:
  cp 9 ; standard TAB char (not ZX Spectrum TAB char)
  jp z, paren_control_to_bl_.space
paren_control_to_bl_.check_lf:
  cp lf_char
  jp nz, paren_control_to_bl_.repeat
paren_control_to_bl_.space:
  ld (hl),sp_char
paren_control_to_bl_.repeat:
  inc hl
  jp paren_control_to_bl_.begin

; CONTROL>BL  ( ca len -- ca len )
; 
; Convert end-of-word control chars (CR, LF, TAB) to spaces.

  _header _public,'CONTROL>BL'
control_to_bl_:
  call fetch_execute_
  dw paren_control_to_bl_

; (EVALUATE)  ( ca len blk -- )
;
; does not restore block contents
;
;         blk @ >in @ 2>r
;         source 2>r
;         blk !  'source 2!  >in off  interpret
;         2r> 'source 2!
;         2r> >in ! blk !

  _header _hidden,'(EVALUATE)'
paren_evaluate_:
  call do_colon
  _debug "start of (evaluate)",0
  if block_files?
    dw blk_,fetch_
    dw in_,fetch_
    dw two_to_r_
  else
    dw in_,fetch_
    dw to_r_
  endif
  _debug "(evaluate) before source",0
  dw source_,two_to_r_
  dw blk_,store_
  dw control_to_bl_
  dw tick_source_,two_store_
  dw in_,off_
  _debug "(evaluate) before interpret",0
;  dw lit_,debug_interpret,on_ ; XXX TMP for debugging
  dw interpret_
  _debug "(evaluate) after interpret",0
  dw two_from_r_,tick_source_,two_store_
  if block_files?
    dw two_from_r_
    dw in_,store_
    dw blk_,store_
  else
    dw from_r_
    dw in_,store_
  endif
  dw paren_exit_

; EVALUATE  ( ca len -- ) 0 (evaluate) ?block

  _header _public,'EVALUATE'
evaluate_:
  call do_colon
  dw zero_,paren_evaluate_
  if block_files?
    dw question_block_
  endif
  dw paren_exit_

; (REFILL)  ( -- flag )
; doesn't correctly handle source

; blk @ ?dup if
;   \ block
;   1+ dup #screens u< and dup
;   while
;     dup blk ! block b/buf
;     \ continue -->
; else
;   \ no block
;   tib dup 80 accept space
;   \ continue -->
; then
;   \ --> continued here
;   'source 2! >in off true
; then

  _header _hidden,'(REFILL)'
paren_refill_:
  call do_colon

  if block_files?

  dw blk_,fetch_,question_dup_
  dw branch_if_0_,paren_refill_.no_block
  dw one_plus_,dup_
  dw number_screens_,u_less_
  dw and_,dup_
  dw branch_if_0_,paren_refill_.end
  dw dup_,blk_,store_
  dw block_,bytes_per_buffer_
  dw branch_,paren_refill_.2
paren_refill_.no_block:
  if tib?
    dw tib_
  else
    dw lit_,tib_address
  endif
  dw dup_
  dw c_lit_
  db 32*2-1 ; XXX TMP -- ZX Spectrum's chars per line; XXX TODO use a variable instead?
  dw cr_,accept_
  if tib?
    dw dup_,number_tib_,store_ ; update '#tib'
  endif
paren_refill_.2:
  dw tick_source_,two_store_
  dw in_,off_
  dw true_
paren_refill_.end:
  dw paren_exit_

  else

  ; XXX TMP -- version without blocks

  if tib?
    dw tib_
  else
    dw lit_,tib_address
  endif
  dw dup_
  dw c_lit_
  db 32*2-1 ; XXX TMP -- ZX Spectrum's chars per line; XXX TODO use a variable instead?
  dw cr_,accept_
  if tib?
    dw dup_,number_tib_,store_ ; update '#tib'
  endif
paren_refill_.2:
  dw tick_source_,two_store_
  dw in_,off_
  dw true_
paren_refill_.end:
  dw paren_exit_

  endif

; REFILL  ( -- flag )

  _header _public,'REFILL'
refill_:
  call fetch_execute_
  dw paren_refill_

; RESET  ( -- )

  _header _hidden,'RESET'
reset_:
  call do_colon
  dw catcher_,off_   ; reset error handler
  ;; dw dcaps ; XXX OLD
  dw case_sensitive_search_,off_ ; XXX NEW
  dw console_      ; set EMIT vector
  dw paren_exit_

; RESET-INTERPRETER  ( -- )
;   blk off >in off postpone [

  _header _hidden,'RESET-INTERPRETER'
reset_interpreter_:
  ld hl,0
  ld (blk_.variable),hl
  ld (in_.variable),hl
  jp left_bracket_

; RESET-FORTH  ( -- )
;       0 set-limit empty warning on checking
;       on (filedescriptorblocks) (filedescriptorsize*maxopensourcefiles) erase empty-buffers
;       reset-interpreter 'source off bl-word drop

  _header _hidden,'RESET-FORTH'
reset_forth_:
  call do_colon
; XXX TODO

; XXX OLD
;;  dw zero
;;  dw setlimit

  dw empty_   ; reset vocabulary pointers
  dw warning_,on_  ; enable warnings
  dw checking_,on_  ; enable checking

  ; XXX OLD
;;  dw lit,filedescriptorblocks  ; clear files
;;  dw lit,filedescriptorsize*maxopensourcefiles ;
;;  dw erase   ;
  ; XXX NEW
  dw file_id_table_
  dw c_lit_
  db max_file_ids
  dw erase_

  dw empty_buffers_   ; mark screen buffer as empty
  dw reset_interpreter_
  dw tick_source_,off_  ; clear parsed word buffer
;;  dw bl_word_,drop_ ; XXX what for?
  dw decimal_ ; XXX NEW -- moved here from cold_boot
  dw case_sensitive_search_,off_
  dw paren_exit_

; QUIT  ( -- )

  _header _public,'QUIT'
quit_:
  call do_colon
quit_.start:
  dw r0_,fetch_,rp_store_
  dw reset_
;** dw vnorm ; XXX OLD
  dw reset_interpreter_
quit_.begin:
  dw paren_refill_,drop_
  dw interpret_
  dw executing_question_
  dw branch_if_false_,quit_.begin
  dw paren_dot_quote_
  _dcs ' ok'
  dw branch_,quit_.begin

; RETURN  ( u -- )
; Exit to BASIC with return code u.
; The return code is used as line number for disk operations.

  _header _public,'RETURN'
return_:

; XXX TODO -- after Gforth, if blocks:
; ['] flush catch drop

  pop bc
  ld iy,sys_err_nr ; XXX TODO -- check if needed
  ld sp,(system_stack_pointer)
  ret

; BYE  ( -- )
; Exit to the BASIC command line.
  _header _public,'BYE'
bye_:

; XXX TODO -- after Gforth, if blocks:
; ['] flush catch drop

;  im 1 ; XXX TODO ?
system_stack_pointer: equ $+1
  ld sp,0
  ld iy,sys_err_nr ; XXX TODO -- check if needed
  rst 0x08     ; error
  db 0xFF      ; 0: "OK"

if 0
  ; XXX TODO -- Code from Benschop's ZX Spectrum Forth-83
  ld sp,(sys_err_sp)
  pop bc
  ld bc,0x1303
  push bc
  im 1
  ld (IY+31),2 ; update sys_e_line
  rst 0x08     ; error
  db 0xFF      ; error 0: OK
endif

; LITERAL  ( n -- ) char? if postpone clit c, exit then
;       postpone lit , ; immediate

  _header _public,'LITERAL',_immediate
literal_:
  call do_colon
  dw char_question_ ; 8-bit number?
  dw branch_if_false_,literal_.cell
  ; 8-bit number
  dw compile_,c_lit_
  dw c_comma_
  dw paren_exit_
literal_.cell:
  ; 16-bit number
  dw compile_,lit_
  dw comma_
  dw paren_exit_

; 2LITERAL  ( d -- )
;   postpone 2lit , , ; immediate

  _header _public,'2LITERAL',_immediate
two_literal_:
  call do_colon
  dw compile_,two_lit_
  dw comma_,comma_
  dw paren_exit_

; [']     ' [compile] literal  ; immediate

  _header _public,"[']",_immediate
bracket_tick_:
  call do_colon
  dw tick_
  dw literal_
  dw paren_exit_

; [COMPILE]   ' compile,  ; immediate

  _header _public,'[COMPILE]',_immediate
bracket_compile_:
  call do_colon
  dw tick_
  dw compile_comma_
  dw paren_exit_

; RECURSE  ( -- )
; last cell+ @ compile, ; immediate

  _header _public,'RECURSE',_immediate
recurse_:
  ld hl,(last_.xt)
  push hl
  jp compile_comma_

; }}} **********************************************************
; Errors {{{

; ------------------------------

; THROW code assignments in Forth-94

;  -1 ; ABORT
;  -2 ; ABORT"
;  -3 ; stack overflow
;  -4 ; stack underflow
;  -5 ; return stack overflow
;  -6 ; return stack underflow
;  -7 ; do-loops nested too deeply during execution
;  -8 ; dictionary overflow
;  -9 ; invalid memory address
; -10 ; division by zero
; -11 ; result out of range
; -12 ; argument type mismatch
; -13 ; undefined word
; -14 ; interpreting a compile-only word
; -15 ; invalid FORGET
; -16 ; attempt to use zero-length string as a name
; -17 ; pictured numeric output string overflow
; -18 ; parsed string overflow
; -19 ; definition name too long
; -20 ; write to a read-only location
; -21 ; unsupported operation (e.g., AT-XY on a too-dumb terminal)
; -22 ; control structure mismatch
; -23 ; address alignment exception
; -24 ; invalid numeric argument
; -25 ; return stack imbalance
; -26 ; loop parameters unavailable
; -27 ; invalid recursion
; -28 ; user interrupt
; -29 ; compiler nesting
; -30 ; obsolescent feature
; -31 ; >BODY used on non-CREATEd definition
; -32 ; invalid name argument (e.g., TO name)
; -33 ; block read exception
; -34 ; block write exception
; -35 ; invalid block number
; -36 ; invalid file position
; -37 ; file I/O exception
; -38 ; non-existent file
; -39 ; unexpected end of file
; -40 ; invalid BASE for floating point conversion
; -41 ; loss of precision
; -42 ; floating-point divide by zero
; -43 ; floating-point result out of range
; -44 ; floating-point stack overflow
; -45 ; floating-point stack underflow
; -46 ; floating-point invalid argument
; -47 ; compilation word list deleted
; -48 ; invalid POSTPONE
; -49 ; search-order overflow
; -50 ; search-order underflow
; -51 ; compilation word list changed
; -52 ; control-flow stack overflow
; -53 ; exception stack overflow
; -54 ; floating-point underflow
; -55 ; floating-point unidentified fault
; -56 ; QUIT
; -57 ; exception in sending or receiving a character
; -58 ; [IF], [ELSE], or [THEN] exception

; Additional THROW code assignments in Forth-2012

; -59 ; ALLOCATE
; -60 ; FREE
; -61 ; RESIZE
; -62 ; CLOSE-FILE
; -63 ; CREATE-FILE
; -64 ; DELETE-FILE
; -65 ; FILE-POSITION
; -66 ; FILE-SIZE
; -67 ; FILE-STATUS
; -68 ; FLUSH-FILE
; -69 ; OPEN-FILE
; -70 ; READ-FILE
; -71 ; READ-LINE
; -72 ; RENAME-FILE
; -73 ; REPOSITION-FILE
; -74 ; RESIZE-FILE
; -75 ; WRITE-FILE
; -76 ; WRITE-LINE
; -77 ; Malformed xchar
; -78 ; SUBSTITUTE
; -79 ; REPLACES

; Values in the range {-4095...-256} and their meanings are implementation defined.
; 
; XXX TODO search for a list used by a Forth system
;
; -256 ; compiling an interpret-only word ; XXX TMP
; -257 ; invalid vocabulary ; XXX TMP
; -258 ; no filename specified ; XXX TMP
; -259 ; can not resize block file ; XXX TMP

; Recoverable +3DOS errors:

; -1000       Drive not ready
; -1001       Disk is write protected
; -1002       Seek fail
; -1003       CRC data error
; -1004       No data
; -1005       Missing address mark
; -1006       Unrecognised disk format
; -1007       Unknown disk error
; -1008       Disk changed whilst +3DOS was using it
; -1009       Unsuitable media for drive

; Non-recoverable +3DOS errors:

; -1020      Bad filename
; -1021      Bad parameter
; -1022      Drive not found
; -1023      File not found
; -1024      File already exists
; -1025      End of file
; -1026      Disk full
; -1027      Directory full
; -1028      Read-only file
; -1029      File number not open (or open with wrong access)
; -1030      Access denied (file is in use already)
; -1031      Cannot rename between drives
; -1032      Extent missing (which should be there)
; -1033      Uncached (software error)
; -1034      File too big (trying to read or write past 8 megabytes)
; -1035      Disk not bootable (boot sector is not acceptable to DOS BOOT)
; -1036      Drive in use (trying to re-map or remove a drive with files open)

; Custom additions:

; -1100      Too many files open

; ------------------------------

; (ABORT)  ( -- )
;   s0 @ sp! fs0 @ fsp ! boot? if 1 return then
;       quit

  _header _hidden,'(ABORT)'
paren_abort_:
  call do_colon
  dw s0_,fetch_,sp_store_
  if floating_point? and floating_point_stack?
    dw fs0_,fetch_,fsp_,store_
  endif
;;  dw bootquestion ; XXX OLD
  if debug?
;;   dw questionbranch,parenabort.1
    ; XXX OLD
;;    dw one
;;    dw return
    paren_abort_.1:
      dw paren_dot_quote_
      _dcs ' (ABORT_) '
;;    dw quit
  else
;;    dw questionbranch,quit.start
;;    dw one
;;    dw return
  endif
  dw branch_,quit_.start

; .ERROR  ( -- )
;       cr
;       blk @ ?dup if
;         file? and if
;           filename type
;           >in @ 2- 0max blk @ 2dup scr 2! ."  Scr "
;           u. c/l / ." Line " . cr
;         then
;       then
;       ." Error: "
;       [char] " dup emit pwa count max_word_length min type emit

  _header _hidden,'.ERROR'
dot_error_:
  call do_colon
  dw cr_

  if block_files?

  dw blk_,fetch_
  dw question_dup_
  dw branch_if_0_,dot_error_.1
  dw file_question_
  dw and_    ; screen file open and loading from block?
  dw branch_if_false_,dot_error_.1
  dw current_block_file_,type_
  dw in_,fetch_
  dw two_minus_    ; adjust pointer
  dw zero_max_
  dw blk_,fetch_
  dw two_dup_    ; set error block_, offset
  dw scr_,two_store_
  dw paren_dot_quote_
  _dcs ' Screen '
  dw u_dot_
  dw chars_per_line_
  dw slash_
  dw paren_dot_quote_
  _dcs 'Line '
  dw dot_
  dw cr_

  endif

dot_error_.1:
  dw paren_dot_quote_
  _dcs 'Error: '
  dw c_lit_
  db '"'
  dw dup_,emit_

  ; XXX OLD -- use 'latest-word'
  dw pwa_,count_
  dw c_lit_
  db max_word_length
  dw min_
  dw type_

  dw emit_
  dw paren_exit_

; : ERROR  ( n -- )
;       -1 of (abort) then
;       -2 of boot cell+ @ 0= if  .error  then
;       space errmsg 2@ type (abort) then
;       ."  exception = " . (abort)
   ;

  ; XXX -- used only by 'throw'; I don't understand it yet

  _header _public,'ERROR'
error_:
  call do_colon

  dw true_    ; -1 = 'abort'
  dw paren_of_,error_.check_abort_quote
  dw paren_abort_

error_.check_abort_quote:
  dw lit_,-2  ; -2 = 'abort"'
  dw paren_of_,error_.other

; XXX OLD -- DX-Forth
;  dw boot_,cell_plus_,fetch_
;  dw zero_equals_
;  dw question_branch_,error_.2
;  dw dot_error_    ; skipped by applications

error_.2:
  dw space_
  dw abort_message_,two_fetch_
  dw type_
  dw paren_abort_

error_.other:
  dw pwa_,count_
  dw lit_,latest_word_.value,two_store_
  dw paren_dot_quote_
  _dcs ' exception = '
  dw dup_,dot_
  dw lit_,-13 ; undefined word
  dw equals_
  dw branch_if_false_,error_.end
  dw latest_word_,type_
error_.end:
  dw paren_abort_

; LATEST-WORD  ( -- ca len )
; Return the latest word parsed before any error.

  _header _public,'LATEST-WORD'
latest_word_:
  call do_two_constant
latest_word_.value:
  ds 2*cell

; CATCH  ( xt -- n | 0 )
;   sp@ >r fsp @ >r catcher @ >r rp@ catcher
;   ! execute r> catcher ! 2r> 2drop 0  ;

  _header _public,'CATCH'
catch_:
  call do_colon
  dw sp_fetch_,to_r_
  dw fsp_,fetch_
  dw to_r_
  dw catcher_,fetch_,to_r_
  dw rp_fetch_,catcher_,store_
  dw execute_
  dw from_r_,catcher_,store_
  dw two_from_r_,two_drop_
  dw zero_
  dw paren_exit_

; THROW  ( n -- )
;   ?dup if
;     catcher @ ?dup 0= if  error  then
;     rp! r> catcher ! r> fsp ! r> swap >r sp! drop r>
;   then  ;
;
; XXX FIXME -- it's not in the glossary

  _header _public,'THROW'
throw_:
  call do_colon
  dw question_dup_
  dw branch_if_0_,throw_.end
  dw catcher_,fetch_
  if debug?
    dw paren_dot_quote_
    _dcs ' THROW_:'
    dw over_,dot_
    dw paren_dot_quote_
    _dcs 'CATCHER:'
    dw dup_,u_dot_,space_,space_
  endif
  dw question_dup_,zero_equals_
  dw branch_if_false_,throw_.no_error
  dw error_
throw_.no_error:
  dw rp_store_
  dw from_r_,catcher_,store_
  dw from_r_,fsp_,store_
  dw from_r_,swap_,to_r_
  dw sp_store_
  dw drop_,from_r_
throw_.end:
  dw paren_exit_

; ABORT  ( -- )
;   -1 throw ;

  _header _public,'ABORT'
abort_:
  ld hl,-1
  push hl
  jp throw_

; (ABORT")  ( n -- )
;   r> count rot if  errmsg 2! -2 throw  then + >r ;

  _header _hidden,'(ABORT")'
paren_abort_quote_:
  call do_colon
  dw from_r_,count_,rot_
  dw branch_if_false_,paren_abort_quote_.noop
  dw abort_message_,two_store_
  dw lit_,-2,throw_
paren_abort_quote_.noop:
  dw plus_,to_r_
  dw paren_exit_

; ABORT"  ( compilation: "ccc<quote>" -- )
;   postpone (abort") ," ; immediate

  _header _public,'ABORT"',_immediate
abort_quote_:
  call do_colon
  dw compile_,paren_abort_quote_,comma_quote_
  dw paren_exit_

; }}} **********************************************************
; Boot {{{

cold_boot:

  ; XXX TODO
  ; save default drive and user
;  call getcurrentdrive
;  ld (defaultdrive),a
;  call getcurrentuser
;  ld (defaultuser),a


;;cldd.1:
  ; Save the system stack pointer
  ld hl,0
  add hl,sp
  ld (system_stack_pointer),hl
;;  sub 8     ; skip over CCP
;;
;;cldd.2:
;;  ld sp,tmpstack
;;  ld h,a
;;  ld l,0
;;  ld (esm),hl    ; patch end of memory value
;;  ex de,hl
;;
;;  ld hl,(boot.1)    ; get BOOT word
;;  ld (initbootxt),hl    ; save it
;;  ld a,h
;;  or  l
;;  ld l,a
;;  ld a,(boot.2)
;;  and l
;;  jp z,cldd.3     ; need Forth system
;;
;;  ld hl,noop
;;  ld (cold_.1),hl
;;  ld hl,(ulimit)
;;  ld a,l
;;  or  h
;;  jp nz,cldd.6
;;  ex de,hl
;;  jp cldd.6
;;
;;cldd.3:
;;
;;  ld hl,(colddph)   ; move system segment into place
;;  ld de,hm
;; XXX Some changes here in DX-Forth 4.09
;;  call hlminusdetohl
;;cldd.4:
;;  ld b,0     ; later patched to LD B,H
;;cldd.5:
;;  ld c,0     ; later patched to LD C,L
;;  ld hl,(colddp)
;;  call moveblockupwards
;;  ld de,start
;;
;;cldd.6:
;;  ex de,hl
;;  ld (limit.1),hl   ; patch LIMIT
;;
;;  db 0xC3      ; 'jmp'
;;cldd.7:
;;  dw movpat      ; later patched to 'cold'

  jp cold_ ; XXX TMP

; XXX OLD
;;; BOOT?  ( -- xt )
;;
;;  ; XXX TODO -- convert this into a variable that holds an xt?
;;  ; XXX TODO -- combine with 'boot'
;;  header hidden,'BOOT?'
;;bootquestion:
;;  ld hl,(initbootxt)
;;  push hl
;;  jp next

; (BOOT-MESSAGE)  ( -- )

  _header _public,'(BOOT-MESSAGE)'

paren_boot_message_:

  call do_colon

  dw paren_dot_quote_
  db paren_boot_message_.end-$-1  ; length
  db "DZX-Forth ",cr_char
  db "Version "
  _version
  db cr_char
  db copy_char," 2014,2015 Marcos Cruz",cr_char
  db "(programandala.net)",cr_char
  ; XXX TMP
;  db "DZX-Forth comes with",cr_char
;  db "ABSOLUTELY NO WARRANTY;",cr_char
;  db "for details see the license",cr_char
paren_boot_message_.end

  if floating_point?
    dw f_identify_,cr_
  endif
  dw unused_,u_dot_
  dw paren_dot_quote_
  ; _dcs "bytes free",cr_char,"Type 'bye' to exit"
  _dcs "bytes free"

  dw paren_exit_

; BOOT-MESSAGE  ( -- )

  _header _public,'BOOT-MESSAGE'

boot_message_:
  call fetch_execute_
  dw paren_boot_message_

; COLD ( -- )

  _header _public,'COLD'
cold_:
; XXX TODO
; XXX OLD
;;  ld sp,tmpstack
;;  ld hl,(limit.1)   ; get LIMIT
;;  ld de,-recsiz    ; file r/w buffer size
;;  add hl,de
;;  ld (hbuf_.value),hl    ; patch HBUF ; XXX TODO this is required
;;  push  hl
;;  ld hl,(nfcb.1)    ; #fcb
;;  ld de,-filehandlesize    ; handle size
;;  call hlbydetohldeunsigned
;;  pop hl
;;  add hl,de
;;  ex de,hl
;;  ld hl,(nus)    ; user area size
;;  call deminushltohl
;;  ld (userdatapointer),hl    ; patch UP
;;  ld (coldr0),hl    ; patch R0
;;  ld (returnstackpointer),hl    ; patch RP
;;  ex de,hl
;;  ld hl,(nrts)   ; return stack size
;;  call deminushltohl
;;  ld (fsp.variable),hl   ; init fp stack
;;  ld (coldfs0),hl   ; patch FS0
;;; XXX These lines were commented out in the original source:
;;; ex de,hl
;;; ld hl,(nfps)   ; fp stack size
;;; call deminushltohl
;;  ld sp,hl     ; set cpu stack pointer
;;  ld (colds0),hl    ; patch S0
;;   if controlflowstackextensions
;;  ld (cs0.variable),hl   ; init CS0 with safe value
;;   endif


  ld sp,(cold_s0) ; XXX NEW

  ; init the user data
  ld hl,(user_data_pointer) ; to
  ex de,hl
  ld hl,init_user_variables  ; from
  ld bc,init_user_variables_size ; count
  call move_block_upwards

  ; patch 'pause' to do nothing
  ld hl,noop_
  ld (pause_.action),hl

  ; delete the last key
  ; XXX needed by 'key?'?
  xor a
  ld (sys_last_k),a

  ; init +3DOS
  ; XXX needed?
;  ld ix,dos_initialise
;  call do_dos

  call do_colon
;;  dw zfh     ; reset handles
;;  dw sys,off     ; default is APPLICATION

  dw reset_     ; general reset
cold_.1:
  dw reset_forth_

  if floating_point?
;do_f_init_patch: ; XXX OLD
    dw f_init_
  endif

; XXX TODO -- user boot
;;  dw bootquestion
;;  dw dup,boot,store     ; restore BOOT
;;  dw questiondup
;;  dw questionbranch,cold_.3
;;  dw execute      ; run application
;;  dw zero,return  ; exit to DOS

cold_.3:

;;cold_.4:
;;  dw interpret      ; interpret
;;cold_.5:
  dw normal_
;;  dw cr,page
;;  dw parendotquote
;;  db cold_.8-$-1

;;cold_.6:
  dw page_,boot_message_

;;cold_.7:
;;cold_.8:
;;  dw parendotquote
;;  db dofidentifypatch-$-1
;;  db crchar,lfchar

;;  dw file_question
;;  dw question_branch_,cold_.10
;;  dw cr_
;;  dw paren_dot_quote
;;  dcs 'Using '
;;  dw current_block_file_,type_
;;  dw cr
;;cold_.10:

  dw quit_      ; jump to interpreter

; }}} **********************************************************
; Dictionary support {{{

; FREEZE  ( -- )

  ; XXX FIXME -- new words are lost after 'freeze'
  _header _public,'FREEZE'
freeze_:
  call do_colon
  dw udp_,fetch_ ; from
  dw lit_,init_user_variables ; to
  dw lit_,init_user_variables_size ; count
  dw cmove_
  dw paren_exit_

; XXX OLD
;;;  'prune      variable 'prune  'prune off
;;
;;  header hidden,"'PRUNE"
;;prune_:
;;  call docreate
;;  dw topprunes    ; 0=end

; XXX OLD
;;;  REMEMBER  ( xt -- )  'prune link, ,
;;; add xt to prunes
;;
;;  header public,'REMEMBER'
;;remember:
;;  call docolon
;;  dw prune_,link_comma_
;;  dw comma
;;  dw paren_exit

; XDP  ( adr -- adr xdp )
;   dup limit u< if dp else dph then

  ; _header _hidden,'XDP'
; xdp_:
  ; pop de
  ; push de
  ; ld hl,limit_.1
  ; ex de,hl
  ; call compare_de_hl_unsigned
  ; jp nc,dph
  ; jp dp_

; XXX OLD
;;;  prunes  ( -- )    begin 'prune @ dup while dup xdp @ u< 0=
;;;        while 2@ 'prune ! execute repeat then drop
;;
;;  header hidden,'PRUNES'
;;prunes_:
;;  call docolon
;;prunes_.1:
;;  dw prune_,fetch_
;;  dw dup
;;  dw question_branch_,prunes_.2
;;  dw dup
;;  dw xdp_,fetch_
;;  dw u_less_,zero_equals_
;;  dw question_branch_,prunes_.2
;;  dw two_fetch_
;;  dw prune_,store_
;;  dw execute_
;;  dw branch_,prunes_.1
;;prunes_.2:
;;  dw drop_
;;  dw paren_exit_

; NAME?  ( "name" -- xt nfa )
; find name in context wordlist
;         bl-word get-context wordlist-find ?defined

  _header _hidden,'NAME?'
name_question_:
  call do_colon
  dw bl_word_
  dw get_context_
  dw wordlist_find_,question_defined_
  dw paren_exit_

; LFIND  ( wid nfa -- lfa |0 )
;   swap begin 2dup @ - while @
;          dup while n>link repeat then nip

  ; find link field containing nfa, 0=none

  _header _hidden,'LFIND'
lfind_:
  call do_colon
  dw swap_
lfind_.1:
  dw two_dup_,fetch_
  dw minus_
  dw question_branch_,lfind_.end
  dw fetch_,dup_
  dw question_branch_,lfind_.end
  dw n_to_link_
  dw branch_,lfind_.1
lfind_.end:
  dw nip_
  dw paren_exit_

; BEHEAD  ( "name1" "name2" -- )
;   name? nip name? nip 2dup u< if swap
;   then n>name get-context rot lfind !

  ; unlink word heads
  _header _public,'BEHEAD'
behead_:
  call do_colon
  dw name_question_,nip_
  dw name_question_,nip_
  dw two_dup_,u_less_
  dw question_branch_,behead_.1
  dw swap_
behead_.1:
  dw n_to_name_
  dw get_context_
  dw rot_,lfind_
  dw store_
  dw paren_exit_

; ?VOC  ( flag -- )
;   abort" invalid vocabulary"

  _header _hidden,'?VOC'
question_voc_:
  call do_colon
  dw lit_,-257 ; invalid vocabulary ; XXX TMP
  dw throw_

;  CHAIN   ( "name" -- )    get-current postpone addr @ 2dup =
;          ?voc cell- $2001 over @ - ?voc
;          2dup lfind ?voc swap 0 lfind
;          2dup u> ?voc !

  _header _public,'CHAIN'
chain_:
  call do_colon
  dw get_current_
  dw addr_,fetch_
  dw two_dup_,equals_  ; same wordlist
  dw question_voc_
  dw cell_minus_
  dw lit_,0x2001
  dw over_,fetch_,minus_  ; not a wordlist
  dw question_voc_
  dw two_dup_,lfind_  ; already chained
  dw question_voc_
  dw swap_
  dw zero_,lfind_
  dw two_dup_,u_greater_  ; forward reference
  dw question_voc_
  dw store_
  dw paren_exit_

; (FORGET)  ( nfa dp -- )
;   dp ! >r voc-link begin @ dup cell+ @ r@
;   u< until dup voc-link ! begin dup cell-
;   dup @ begin dup r@ u< 0= while -alias if
;   dup name> dp @ umin dp ! then n>name
;   repeat swap ! @ ?dup 0= until r> dup dp
;   cell+ ! (colddph) @ u< if freeze then prunes

; XXX TODO study the parameters and adapt

  _header _hidden,'(FORGET)'
paren_forget_:
  call do_colon
  dw dp_,store_  ; starting maximums
  dw to_r_
  dw voc_link_    ; trim vocs > nfa
paren_forget_.1:
  dw fetch_
  dw dup_,cell_plus_,fetch_
  dw r_fetch_,u_less_
  dw question_branch_,paren_forget_.1
  dw dup_,voc_link_,store_
paren_forget_.2:
  dw dup_,cell_minus_  ; scan remaining vocs
  dw dup_
  dw fetch_
paren_forget_.3:
  dw dup_,r_fetch_  ; for each word >= nfa
  dw u_less_,zero_equals_
  dw question_branch_,paren_forget_.5
  dw minus_alias_    ; not an alias
  dw question_branch_,paren_forget_.4
  dw dup_,name_from_  ; get its xt
  dw here_
  dw u_min_,dp_,store_  ; trim dict
paren_forget_.4:
  dw n_to_name_
  dw branch_,paren_forget_.3
paren_forget_.5:
  dw swap_,store_
  dw fetch_
  dw question_dup_,zero_equals_
  dw question_branch_,paren_forget_.2  ; until all vocs done
  dw from_r_
  dw dup_,dp_
  dw cell_plus_,store_
  dw lit_,cold_dph  ; below fence?
  dw fetch_,u_less_
  dw question_branch_,paren_forget_.6
  dw freeze_    ; fix bootup values
paren_forget_.6:
;;  dw prunes_    ; run prunes chain ; XXX OLD
  dw paren_exit_

; EMPTY  ( -- )
;   forth definitions (colddp) 2@ (forget)

  _header _public,'EMPTY'
empty_:
  call do_colon
  dw forth_,definitions_  ; switch to a safe vocabulary
  dw lit_,cold_dp
  dw two_fetch_ ; XXX FIXME cold_dph is still used by '(forget_)'
  dw paren_forget_
  dw paren_exit_

; FORGET  ( "name" -- )
;   get-current context ! name? -alias 0=
;        abort" is alias" swap limit over u> if
;        drop dp @ then (forget)

  _header _public,'FORGET'
forget_:
  call do_colon
  dw get_current_
  dw context_,store_
  dw name_question_
  ; XXX TODO why an alias is not allowed?:
  dw minus_alias_,zero_equals_  ; alias?
  dw lit_,-15 ; invalid FORGET
  dw and_,throw_
  dw swap_
  dw limit_ ; XXX OLD
  dw over_,u_less_
  dw question_branch_,forget_.1
  dw drop_
  dw here_
forget_.1:
  dw paren_forget_
  dw paren_exit_

; MARKER  ( "name" -- )
;   sys? system create sys !

  _header _public,'MARKER'
marker_:
  call do_colon
  dw sys_question_
  dw create_
  dw sys_,store_
  dw paren_exit_

; }}} **********************************************************
; Strings {{{

; S,  ( ca len -- )
;   255 min 0max here over 1+ allot place

  _header _hidden,'S,'
s_comma_:
  call do_colon
  dw c_lit_
  db 255
  dw min_
  dw zero_max_
  dw here_,over_
  dw one_plus_,allot_
  dw place_
  dw paren_exit_

; ,"  ( "ccc" -- )
;   [char] " parse$ s,

  _header _public,',"'
comma_quote_:
  call do_colon
  dw c_lit_
  db '"'
  dw parse_dollar_
  dw s_comma_
  dw paren_exit_

; (S")  ( -- ca len )
;   r> count 2dup + >r

  _header _hidden,'(S")'
paren_s_quot_:
  ld a,(bc)
  ld l,a
  ld h,0
  inc bc
  push bc
  push hl
  add hl,bc
  ld c,l
  ld b,h
  jp next

; SLITERAL  ( ca len -- )
;   postpone (s") s, ; immediate

  _header _public,'SLITERAL',_immediate
s_literal_:
  call do_colon
  dw compile_,paren_s_quot_
  dw s_comma_
  dw paren_exit_

; S"  ( -- ca len )
;
;   [char] " parse$ state? if postpone sliteral
;   then ; immediate
;
; Note: this word is state-smart

  _header _public,'S"',_immediate
s_quote_:
  call do_colon
  dw c_lit_
  db '"'
  dw parse_dollar_
  dw compiling_question_
  dw branch_if_false_,s_quote_.end
  dw s_literal_
s_quote_.end:
  dw paren_exit_

; (.")
;   r> count 2dup + >r type

  _header _hidden,'(.")'
paren_dot_quote_:
  ld a,(bc)  ; length of the string
  ld h,0
  ld l,a
  inc bc      ; address of the first char
  push bc     ; address
  push hl     ; length
  add hl,bc   ; calculate the new IP
  ld b,h
  ld c,l      ; update the IP
  jp type_

; ."
;   compile (.") ," ; immediate

  _header _public,'."',_immediate
dot_quote_:
  call do_colon
  dw compile_,paren_dot_quote_
  dw comma_quote_
  dw paren_exit_

; CHAR?  ( x -- x flag )
;
; Is x an 8-bit number?
; XXX TODO make this word public and make it consume x.

  _header _hidden,'CHAR?'
char_question_:
  pop hl
  push hl
  ld l,h
  jp zero_equals_hl

; CHAR  ( -- c ) bl word 1+ c@

  _header _public,'CHAR'
char_:
  call do_colon
  dw bl_,word_
  dw one_plus_,c_fetch_
  dw paren_exit_

; [CHAR]  ( -- c ) char [compile] literal

  _header _public,'[CHAR]',_immediate
bracket_char_:
  call do_colon
  dw char_
  dw literal_
  dw paren_exit_

; }}} **********************************************************
; Misc {{{

; PAUSE  ( -- )
; multitasking support
; XXX TODO move

  _header _public,'PAUSE'
pause_:
  call fetch_execute_
pause_.action:
  dw noop_   ; patched by 'cold'

; Y/N  ( -- flag )
;   ." (y/n) N\bs" key toupper [char] Y = dup
;       if [char] Y else [char] N then emit space
; XXX TODO move to a .fs file

  _header _public,'Y/N'
yn_:
  call do_colon
  dw paren_dot_quote_
  _dcs '(y/n) N',bs_char
  dw key_,toupper_
  dw c_lit_
  db 'Y'
  dw equals_,dup_
  dw question_branch_,yn_.1
  dw c_lit_
  db 'Y'
  dw branch_,yn_.2
yn_.1:
  dw c_lit_
  db 'N'
yn_.2:
  dw emit_,space_
  dw paren_exit_

; DZX-FORTH  ( -- minor major )
; XXX TODO move

  _header _public,'DZX-FORTH'
dzx_forth_:
  ld de,version.major shl 8 + version.minor
  jp push_version

; }}} **********************************************************
; Files control XXX NEW {{{

; MAX-FILE-ID  ( -- u )
; XXX NEW
;   max number of file handle

  _header _public,'MAX-FILE-ID'
max_file_id_:
  call do_byte_constant
  db max_file_id

; FILE-ID-TABLE  ( -- a )
; XXX NEW
; XXX TODO rename?
; XXX TODO -- use also to remember which files are headed, one bit

  _header _public,'FILE-ID-TABLE'
file_id_table_:
  call do_create
file_id_table: ; XXX NEW
  ds max_file_ids

; FILE-ID  ( -- fid true | false )

  _header _public,'FILE-ID'
file_id_:
  call do_colon
  dw max_file_id_
file_id_.begin:
  dw dup_
  dw file_id_table_,plus_,dup_,c_fetch_
  dw branch_if_0_,file_id_.found
  dw drop_,one_minus_,dup_,zero_less_
  ; XXX TODO use '0>=' when available, and save one branch 
  dw branch_if_0_,file_id_.begin
  dw branch_,file_id_.begin
file_id_.found:
  dw c_lit_
  db 0xFF
  dw swap_,c_store_
  dw true_
file_id_.end:
  dw paren_exit_

if circular_string_buffer?

; >FILENAME  ( ca len -- ca2 )

; Convert the filename ca len to a 0xFF-terminated string at ca2 in the string
; buffer.
;
; ca2 = address of the first char of the 0xFF-terminated string,
;       as required by +3DOS

  _header _public,'>FILENAME'
to_filename_:

  call do_colon
  dw c_lit_
  db filename_size
  dw min_
  dw char_plus_ ; for the trailing 0xFF
  dw save_string_
  dw two_dup_,plus_,char_minus_ ; address of the last char
  dw c_lit_
  db 0xFF
  dw swap_,c_store_  ; trailing 0xFF
  dw drop_
  dw paren_exit_

else

; >FILENAME  ( ca len -- ca2 )

; Convert the filename ca len to a 0xFF-terminated string at ca2 in the
; filename buffer.  A maximum of two filenames can exist in the buffer at one
; time.
;
; ca2 = address of the first char of the 0xFF-terminated string,
;       as required by +3DOS

; Note: The returned string resides in a transient region which may
; be overwritten by subsequent operations.

  _header _public,'>FILENAME'
to_filename_:

  call do_colon
  dw c_lit_
  db filename_size
  dw min_
  dw filename_buffers_,fetch_
  dw packed_
  dw c_lit_
  db 0xFF
  dw affix_  ; trailing 0xFF
  dw filename_buffers_,two_fetch_
  dw swap_
  dw filename_buffers_,two_store_
  dw char_plus_
  dw paren_exit_

endif

; FILENAME-BUFFERS ( -- a )
; filename buffer pointers

; XXX TODO this will not be necessary with the circular string buffer,
; but still needed by '+ext'

  _header _hidden,'FILENAME-BUFFERS'
filename_buffers_:
  call do_create
filename_buffers_.next:
  dw filename_buffer.next ; address of the filename buffer to be used next
filename_buffers_.last:
  dw filename_buffer.last ; address of the filename buffer used last

filename_buffer.next: ds filename_buffer_size
filename_buffer.last: ds filename_buffer_size

; }}} **********************************************************
; Files control XXX OLD {{{

; HBUF  ( -- a )
; Handle r/w buffer (size: 128)
; XXX OLD -- still used by 'use', that will be removed

;   _header _hidden,'HBUF'
; hbuf_:
;   call do_value
; hbuf_.value:
;   ds cell    ; patched by COLD

; #FCB  ( -- u )
; number of file handles
; XXX TODO rename

; XXX OLD
  ; _header _public,'#FCB'
; nfcb_:
  ; call do_value
; nfcb_.value:
  ; dw max_file_ids

; FH  ( -- fid )
; current file handle
; XXX OLD -- useless after rewriting 'get-file-handle' ('file-id')?
  ; _header _hidden,'FH'
; fh_:
  ; call do_value
; fh_.value:
  ; dw 0

; /FH  ( -- )
;   #fcb (filehandlesize) * hbuf over - swap erase
;
; XXX TODO rename

  ; _header _hidden,'/FH'
; zfh_:
  ; ld hl,(nfcb_.value)
  ; ld de,file_handle_size
  ; call hl_by_de_to_hlde_unsigned
  ; ld hl,(hbuf_.value)
  ; call hl_minus_de_to_hl
  ; push hl
  ; push de
  ; jp erase_

; USE  ( -- a )
; XXX Control data of the current file?
; fh (file_handle_size) negate * hbuf +
; XXX OLD -- only used by 'getfh' ('get-file-handle'), that was rewritten ('file-id'?)

  ; _header _hidden,'USE'
; use_:
  ; ld hl,(fh_.value)
  ; ld de,-file_handle_size
  ; call hl_by_de_to_hlde_unsigned
  ; ld hl,(hbuf_.value)
  ; add hl,de
  ; if size_optimization?
  ;   jp push_hl
  ; else
  ;   push hl
  ;   jp next
  ; endif

; UID  ( -- a )
;   use 1+
; user number
; XXX OLD ?

  ; _header _hidden,'UID'
; uid_:
  ; call do_colon
  ; dw use_,one_plus_
  ; dw paren_exit_

; FCB  ( -- a )
; FCB address
;   use 6 +
; XXX OLD ?

  ; _header _hidden,'FCB'
; fcb_:
  ; call do_colon
  ; dw use_
  ; dw c_lit_
  ; db 6
  ; dw plus_
  ; dw paren_exit_

; RWP@  ( -- ud )
; Fetch the read/Write pointer of the current file
;   use 2+ 2@

  ; _header _hidden,'RWP@'
; rwp_fetch_:
  ; call do_colon
  ; dw use_,two_plus_
  ; dw two_fetch_
  ; dw paren_exit_

; RWP!  ( ud -- )
; Store into the Read/Write pointer of the current file
;   use 2+ 2! ;
; XXX OLD

  ; _header _hidden,'RWP!'
; rwpst_:
  ; call do_colon
  ; dw use_,two_plus_
  ; dw two_store_
  ; dw paren_exit_

; >IOR  ( err# -- ior )
;   dup if $fe00 or then
; XXX OLD 

  ; _header _public,'>IOR'
; to_ior_:
  ; pop hl
  ; ld a,h
  ; or l
  ; _jump_z to_ior_.end
  ; ld h,0xFE
; to_ior_.end:
  ; _push_hl_jp_next


; >FCB  ( a u -- fcb usr )
;   2dup >fname 18 + -rot 2 pick set-fcb
; XXX OLD

  ; _header _public,'>FCB'
; tfcb_:
  ; call do_colon
  ; dw two_dup_,to_filename_buffer_
  ; dw c_lit_
  ; db 18
  ; dw plus_
  ; dw minus_rot_
  ; dw two_,pick_
  ; dw set_fcb_
  ; dw paren_exit_

; }}} **********************************************************
; Files {{{

; XXX Note on +3DOS filenames:
; characters NOT allowed:
;     /<>-+=!&
; characters allowed:
;     "#'@^_{}~` (the ASCII '`' is ZX Spectrum's pound sign)

; ; >DRIVE  ( u1 -- u2 )
; ;   ?dup if 1- else 0 25 bdos then
; ;
; ; Convert logical drive number (0=default, 1=A, 2=B, etc) to absolute
; ; drive number (0=A, 1=B, 2=C, etc).
; ; XXX OLD?
; XXX TODO rewrite? -- meanwhile, a fake in <src/dxforth.fs>

;   _header _public,'>DRIVE'
; to_drive_:
;   pop de
;   ld a,e
;   dec  a
;   call m,get_current_drive
;   jp push_a

; ; PATH  ( u1 -- ca u2 ior )
; ;        255 32 bdos 0 <# [char] : hold #s rot >drive
; ;        [char] A + hold #> 0
; ;
; ; Get the full directory path for disk drive u1.  If an error occurs,
; ; ior is non-zero.  The returned string ca u2 includes the drive
; ; letter, current user number and trailing colon.  For the currently
; ; selected drive u1 = 0, otherwise u1 = 1 for drive A, 2 for drive B
; ; etc.
; ;
; ; Note: The returned string resides in a transient region which may
; ; be overwritten by subsequent operations.
; ;
; ; XXX OLD?
; XXX TODO rewrite? -- meanwhile, a fake in <src/dxforth.fs>

;   _header _public,'PATH'  ; uses numeric buffer
; path_:
;   call do_colon
;   dw c_lit_
;   db 255
;   dw c_lit_
;   db 32
;   dw bdos_
;   dw zero_,less_number_sign_
;   dw c_lit_
;   db ':'
;   dw hold_
;   dw number_sign_s_
;   dw rot_,to_drive_
;   dw c_lit_
;   db 'A'
;   dw plus_
;   dw hold_,number_sign_greater_
;   dw zero_
;   dw paren_exit_

; -PATH  ( ca1 len1 -- ca2 len2 )
;
;   2dup [char] : scan dup if  1 /string 2swap  then  2drop

  _header _public,'-PATH'
minus_path_:
  call do_colon
  dw two_dup_
  dw c_lit_
  db ':'
  dw scan_,dup_
  dw question_branch_,minus_path_.1
  dw one_,slash_string_
  dw two_swap_
minus_path_.1:
  dw two_drop_
  dw paren_exit_

; XXX OLD
; ; FILETYPE?  ( ca1 len1 -- len2 )
; ; length of the filetype extension, including the dot
; ;
; ; XXX TODO -- return the string

;   _header _hidden,'FILETYPE?'
; filetype_question_:
;   call do_colon
;   dw minus_path_ ; XXX why needed?
;   dw c_lit_
;   db '.'
;   dw scan_,nip_
;   dw paren_exit_

; FILETYPE  ( ca1 len1 -- ca2 len2 )
; filetype extension, including the dot

  _header _hidden,'FILETYPE'
filetype_:
  call do_colon
  dw minus_path_ ; XXX why needed?
  dw c_lit_
  db '.'
  dw scan_
  dw paren_exit_

; +EXT  ( ca1 len1 ca2 len2 -- ca3 len3 )
; 
; Add the filetype ca2 len2 to the filename ca1 len1, if needed.
; 
; ca2 len2 = filetype without the dot
;
;        2over filetype nip if 2drop exit then
;        3 min s" ." 2rot -trailing (filenamesize-4) min
;        filename-buffers @ 1+ 0 +string +string +string

  _header _public,'+EXT'
plus_ext_:
  call do_colon

  dw two_over_,filetype_,nip_
  dw branch_if_zero_,plus_ext_.do_it
  dw two_drop_,paren_exit_

plus_ext_.do_it:
  dw three_,min_
  dw paren_s_quot_
  _dcs '.'
  dw two_rot_
  dw minus_trailing_
  dw c_lit_
  db filename_size-4 ; 4 = the length of a filetype, including the dot
  dw min_
  if circular_string_buffer? and 0
    ; XXX TODO
    dw dup_
  else
    dw filename_buffers_,fetch_    ; unused
    dw one_plus_
    dw zero_
  endif
  dw plus_string_
  dw plus_string_
  dw plus_string_
  dw paren_exit_

; -EXT  ( ca1 len1 -- ca2 len2 )
;   2dup filetype? -

  _header _public,'-EXT'
minus_ext_:
  call do_colon
  dw two_dup_,filetype_,nip_
  dw minus_
  dw paren_exit_

; GET-USER  ( -- u )

  _header _public,'GET-USER'
get_user_:
  call get_current_user
  jp nc,dos_error_.a
  jp push_a

; SET-USER  ( u -- )

  _header _public,'SET-USER'
set_user_:
  if restore_user?
    call get_current_user
    ld (old_user),a  ; save current user
  endif
  pop hl
  ld a,l
set_user_.a:
  cp 255
  call nz,set_current_user
  jp nc,dos_error_.a
  jp next

if restore_user?
; RESTORE-USER  ( -- )
; XXX OLD -- useless?
;   instead of:
;     3 set-user restore-user
;   the programmer can do:
;     get-user  3 set-user  set-user

  _header _public,'RESTORE-USER'
restore_user_:
old_user: equ $+1
  ld a,0xFF  ; old user (0xFF = ignore)
  jp set_user_.a
endif

; GET-DRIVE  ( -- c )
;
; Get the default drive (i.e. the drive implied by all filenames that do not
; specify a drive).
;
; c = drive (ASCII 'A'..'P')

  _header _public,'GET-DRIVE'
get_drive_:
  call get_current_drive
  jp nc,dos_error_.a
  jp push_a

; SET-DRIVE  ( c -- )
;
; Set the default drive (i.e. the drive implied by all filenames that do not
; specify a drive).
;
; c = drive (ASCII 'A'..'P')

  _header _public,'SET-DRIVE'
set_drive_:
  pop hl
  ld a,l
set_drive_.a:
  call set_current_drive
  jp nc,dos_error_.a
  jp next

; FILE-POSITION  ( fid -- ud ior )
;
; ud = file pointer
;
; Note: the most significant byte of ud is zero, because the file pointer range
; is 0x000000..0xFFFFFF (0..16777215).

  _header _public,'FILE-POSITION'
file_position_:
  pop hl
  push bc ; save the Forth IP
  ld b,l ; fid
  ld ix,dos_get_position

dos_ehl:

  ; Call a DOS routine that returns a number in EHL and, as usual, an error
  ; code in A. Leave EHL on the stack as a double number, and then A.

  ; Input:
  ;   b    = file number
  ;   ix   = DOS routine
  ;   (sp) = Forth IP
  ; Output stack:
  ;   ( d ior )
  ;   Where d is the content of registers ehl

  call dos
  pop bc ; restore the Forth IP
  ; ehl = result
  push hl ; low part
  ld d,0
  push de ; high part
  jp back_from_dos

; REPOSITION-FILE  ( ud fid -- ior )
;
; ud = file pointer
;
; Note: the most significant byte of ud is ignored, because the file pointer
; range is 0x000000..0xFFFFFF (0..16777215).

  _header _public,'REPOSITION-FILE'
reposition_file_:
  pop hl
  ld d,l  ; fid
  pop hl  ; high 16-bit part of the file pointer
  ld e,l  ; actual most significant byte of the file pointer
  pop hl  ; low 16-bit part of the file pointer
  push bc ; save the Forth IP
  ld b,d  ; fid
  ld ix,dos_set_position
  call dos
  pop bc  ; restore the Forth IP
  jp back_from_dos

; FILE-SIZE  ( fid -- ud ior )

  _header _public,'FILE-SIZE'
file_size_:

  pop hl
  push bc ; save the Forth IP
  ld b,l ; fid
  ld ix,dos_get_eof
  jp dos_ehl

; CLOSE-FILE  ( fid -- ior )

  _header _public,'CLOSE-FILE'
close_file_:
  pop hl
  push hl ; save the fid
  push bc ; save the Forth IP
  ld b,l  ; fid
  ld ix,dos_close
  call dos
  pop bc  ; restore the Forth IP
  pop de  ; restore the fid
  _jump_nc back_from_dos.error
  ; no error; mark the file id as free
  ld hl,file_id_table
  add hl,de
  ld (hl),0
  jp false_

; (DELETE-FILE)  ( ca -- ior )
; ca = address of filename, with a trailing 0xFF

  _header _public,'(DELETE-FILE)'
paren_delete_file_:
  pop hl
  ld ix,dos_delete
  call do_dos
  jp back_from_dos

; DELETE-FILE  ( ca len -- ior )

  _header _public,'DELETE-FILE'
delete_file_:
  call do_colon
  dw to_filename_
  dw paren_delete_file_
  dw paren_exit_

; ABANDON-FILE  ( fid -- ior )

  _header _public,'ABANDON-FILE'
abandon_file_:
  pop hl
  push bc ; save the Forth IP
  ld b,l  ; fid
  ld ix,dos_abandon
  call dos
  pop bc  ; restore the Forth IP
  _jump back_from_dos

; R/O  ( -- fam )
;
; read-only file access method

  _header _public,'R/O',,one_
read_only_: equ one_

; W/O  ( -- fam )
;
; write-only file access method

  _header _public,'W/O',,two_
write_only_: equ two_

; R/W  ( -- fam )
;
; read-write file access method

  _header _public,'R/W',,three_
read_write_: equ three_

; S/R  ( -- fam )
;
; shared-read file access method

  _header _public,'S/R'
shared_read_:
  call do_byte_constant
  db 5

; BIN  ( fam1 -- fam2 )

  _header _public,'BIN',_immediate,noop_
bin_: equ  next

; HEADED  ( fam1 -- fam2 )

  _header _public,'HEADED'
headed_:
  pop hl
  set 7,l
  push hl
  jp next

; HEADED?  ( ca len -- wf )
;
; Does a file have a DOS header?

  _header _public,'HEADED?'
headed_question:
  ; XXX TODO
  call do_colon
  dw paren_exit_

; OPEN-DISK  ( c fam -- fid ior )
;
; XXX TODO -- DOS OPEN DRIVE

; (OPEN-FILE)  ( ca fam fid -- fid ior )
;
; ca = filename as a counted string, with a trailing 0xFF

  _header _public,'(OPEN-FILE)'
paren_open_file_:

  pop de  ; e=fid
  pop hl
  ld d,l  ; fam
  pop hl  ; ca

  push de ; save the fid (actually, fid + 256*fam)
  push bc ; save the Forth IP

  ld b,e  ; fid
  ld c,d  ; fam
  ; calculate the open action
  bit 7,c ; headed? (maybe set by 'headed')
  res 7,c
  ld a,1  ; open action 1: position after the header
  jr nz,paren_open_file_.actions ; jump if headed
  ; open a file with no header
  inc a   ; open action 2: ignore any header, position at 0
paren_open_file_.actions:
  ; a = open action
  ld d,0  ; create action: error, file does not exist
  ld e,a  ; open action

do_dos_open:
  ; Note: this entry point is used by '(create-file)'
  ; b = file number (=fid)
  ; c = access mode (=fam)
  ; d = create action
  ; e = open action
  ; hl = address of filename (no wildcards), with trailing 0xFF
  ; (sp) = Forth IP
  ; (sp+2) = fid + 256*fam
  ld ix,dos_open
  call dos

  pop bc  ; restore the Forth IP
  _jump_nc do_dos_open.error
  ; no error
  pop hl      ; l = fid
  ld h,0
  push hl     ; fid
  jp false_   ; no error

do_dos_open.error
  ; (sp) = fid + 256*fam (used as undefined fid)
  ; a = error code
  call convert_dos_error_code
  ; hl = error code
  jp push_hl

; OPEN-FILE  ( ca len fam -- fid ior )
;
; ca len = filename

  _header _public,'OPEN-FILE'
open_file_:

  call do_colon
  dw to_r_,to_filename_,from_r_
  ; ( ca2 fam )
  dw file_id_
  dw branch_if_zero_,no_free_fid
  ;  ( ca2 fam fid )
  dw paren_open_file_
  dw paren_exit_

no_free_fid:
  ; Error
  ; ( ca2 fam )
  dw drop_ ; leave only ca2, as an undefined fid
  dw lit_,-1100,throw_
  dw paren_exit_

; (CREATE-FILE)  ( ca fam fid -- fid ior )
;
; ca = filename as a counted string, with a trailing 0xFF

  _header _public,'(CREATE-FILE)'
paren_create_file_:

  ; ****************************
  ;
  ; XXX FIXME
  ;
  ; When 'headed' is used, 'create-file'
  ; fails with DOS error 23 (file not
  ; found), no matter the fam, e.g.:
  ;
  ;   s" headed" w/o headed create-file
  ;
  ; It works fine without 'headed', or when
  ; the file already exists.
  ;
  ; But 'open-file' works fine with and
  ; without 'header', and its code is
  ; identical except the actions.
  ;
  ; Tried with ZX Spectrum +3e too, no
  ; difference.
  ;
  ; ****************************

  pop de  ; e=fid
  pop hl
  ld d,l  ; fam
  pop hl  ; ca

  push de ; save the fid (actually, fid + 256*fam)
  push bc ; save the Forth IP

  ld b,e  ; fid
  ld c,d  ; fam
  ; calculate the create action
  bit 7,c ; headed? (maybe set by 'headed')
  res 7,c
  ld a,1  ; create action 1: new file with header; position after the header
  jp nz,paren_open_file_.actions ; jump if headed ; XXX TODO jr
  ; create a file with no header
  inc a   ; create action 2: new file without a header, position at 0
paren_create_file_.actions
  ; a = create action
  ld d,a  ; create action
  ld e,4  ; open action: erase and create

  jp do_dos_open

; CREATE-FILE  ( ca len fam -- fid ior )
;
; ca len = filename

  _header _public,'CREATE-FILE'
create_file_:

  call do_colon
  dw to_r_,to_filename_,from_r_
  ; ( ca2 fam )
  dw file_id_
  dw branch_if_zero_,no_free_fid
  ;  ( ca2 fam fid )
  dw paren_create_file_
  dw paren_exit_

; (RENAME-FILE)  ( ca1 ca2 -- ior )
;
; ca1 = current filename, as a 0xFF-terminated string
; ca2 = new filename, as a 0xFF-terminated string

  _header _public,'(RENAME-FILE)'
paren_rename_file_:
  pop de
  pop hl
  ld ix,dos_rename
  call do_dos
  jp back_from_dos

; RENAME-FILE  ( ca1 len1 ca2 len2 -- ior )
;
; ca1 len1 = current name
; ca2 len2 = new name

  _header _public,'RENAME-FILE'
rename_file_:
  call do_colon
  dw to_filename_,to_r_
  dw to_filename_,from_r_
  dw paren_rename_file_
  dw paren_exit_

; PAGE-READ-FILE  ( ca len fid +n -- ior )
;
; ca len = filename
; +n = RAM page for 0xC000..0xFFFF

  _header _public,'PAGE-READ-FILE'
page_read_file_:
  pop hl ; l = bank
  ld a,l
page_read_file_.a:
  call save_ip
  ld c,a
  pop hl
  ld b,l  ; fid
  pop de  ; len
  pop hl  ; ca
  push de ; len
  ld ix,dos_read
  call dos
  pop hl ; len
  call restore_ip
  jr c,page_read_file_.no_error

  ; error
  ; hl = len
  ; a = error code
  ; de = number of bytes remaining unread
  push af
  call hl_minus_de_to_hl
  ; hl = bytes actually read
  pop af
  cp 21 ; is it "bad parameter"? XXX TODO label
  jr z, page_read_file_.no_error
  push hl
  jp back_from_dos.error

page_read_file_.no_error:
  ; no error
  ; hl = len
  push hl
  jp false_

; READ-FILE  ( a len1 fid -- len2 ior )

  _header _public,'READ-FILE'
read_file_:
  ld a,(sys_bankm) ; XXX TODO factor out if size_optimization
  and %111 ; current page for 0xC000..0xFFFF
  _jump page_read_file_.a

; PAGE-WRITE-FILE  ( ca len fid +n -- ior )
;
; +n = RAM page for 0xC000..0xFFFF

  _header _public,'PAGE-WRITE-FILE'
page_write_file_:
  pop hl ; l = bank
  ld a,l
page_write_file_.a:
  call save_ip
  ld c,a
  pop hl
  ld b,l ; fid
  pop de ; len
  pop hl ; ca
  ld ix,dos_write
  call dos
  call restore_ip
  _jump back_from_dos

; WRITE-FILE  ( ca len fid -- ior )

  _header _public,'WRITE-FILE'
write_file_:
  ld a,(sys_bankm)
  and %111 ; current page for 0xC000..0xFFFF
  _jump page_write_file_.a

; NEW-LINE  ( -- ca len )  Gforth's 'newline' ; XXX NEW
; String used by 'WRITE-LINE' as end of line

  _header _public,'NEW-LINE'
new_line_:
  call do_two_constant
  dw new_line_.string,1 ; address and length
new_line_.string:
  db cr_char

; WRITE-LINE  ( ca len fileid -- ior )
;     dup >r write-file ?dup if  r> rdrop exit  then
;     new-line r> write-file
  _header _public,'WRITE-LINE'
write_line_:
  call do_colon
  dw dup_,to_r_
  dw write_file_
  dw question_dup_
  dw branch_if_0_,write_line_.end_of_line
  dw r_drop_
  dw paren_exit_
write_line_.end_of_line:
  dw new_line_
  dw from_r_
  dw write_file_
  dw paren_exit_

; EOL?  ( c -- 2|1|0 )
; c=CR  -> 2
; c=LF  -> 1
; other -> 0
;
; XXX NEW --- modified to accept a char, not an address

; XXX TODO --- return the char (cr or lf) or zero
; (but that would break 'read-line')

  _header _hidden,'EOL?'
eol_question_:
  pop hl
  ld a,l
  cp cr_char
  jp z,two_
  cp lf_char
  jp z,one_
  jp zero_

; READ-BYTE  ( fid -- b ior )
; XXX NEW

; XXX FIXME -- No EOF error: bytes 229 are read after the end of file (the byte
; used to format a disk).

  _header _public,'READ-BYTE'
read_byte_:
  pop hl
  push bc ; save the Forth IP
  ld b,l ; fid
  ld ix,dos_byte_read
  call dos
  ld d,0
  ld e,c  ; byte
  pop bc  ; restore the Forth IP
  push de ; byte
  jp nc,dos_error_.a
  jp zero_

; WRITE-BYTE  ( b fid -- ior )
; XXX NEW

  _header _public,'WRITE-BYTE'
write_byte_:
  pop hl
  pop de
  push bc ; save the Forth IP
  ld b,l ; fid
  ld c,e ; b
  ld ix,dos_byte_write
  call dos
  pop bc  ; restore the Forth IP
  jp back_from_dos

; READ-LINE  ( ca1 len1 fid -- len2 flag ior )

  _header _public,'READ-LINE'
read_line_:

; XXX TODO -- finish and check
  ; ca1   = address of the first char
  ; ca1'  = address of the currently examined char, in the loop
  ; ca2   = ca1'+eol = address after the end of line
  ; ca3   = ca1+len1' = address after the last char actually read
  ; eol   = type of EOL char (1=LF, 2=CR)
  ; flag  = succesful?
  ; ior   = input/output report
  ; len1' = number of chars actually read
  ; len2  = number of chars actually read, without line terminators
  ; n     = offset from the current file position to the start of
  ;         the next line

  call do_colon

  dw dup_,lit_,read_line_.fid,store_
  dw to_r_,over_,swap_,from_r_ ; ( ca1 ca1 len1 fid )
  dw read_file_ ; ( ca1 len1' ior )
  dw question_dup_
  dw branch_if_zero_,read_line_.ready
  ; 'read-file' error
  dw to_r_,nip_,zero_,from_r_
  dw paren_exit_

read_line_.ready:
  ; ( ca1 len1' )
  dw two_dup_,bounds_
  dw paren_question_do_,read_line_.end_of_loop

read_line_.do:
  ; ( ca1 len1' )
  dw i_,dup_,c_fetch_ ; current char
  dw c_lit_
  db ctrl_z_char
  dw equals_ ; CTRL-Z?
  dw branch_if_false_,read_line_.check_eol

  ; CTRL-Z found
  ; ( ca1 len1' ca1')
  dw rot_,minus_  ; ( len1' len2 )
  dw lit_
read_line_.fid:
  ds cell ; the file id is stored here at the start
  dw file_size_,drop_ ; XXX TODO manage the ior
  ; XXX TODO faster with 'dup' and 'rot'?:
  dw lit_,read_line_.fid,fetch_
  dw reposition_file_,drop_  ; XXX TODO manage the ior
  ; ( len1' len2 )
  dw paren_leave_,read_line_.do-cell ; leave the loop

read_line_.check_eol:
  ; ( ca1 len1' ca1' )
  dw c_fetch_,eol_question_,question_dup_
  dw branch_if_zero_,read_line_.loop
  ; EOL found
  ; ( ca1 len1' eol )
  dw i_,plus_,to_r_
  dw over_,plus_
  dw from_r_ ; ( ca1 ca3 ca2 )
  dw swap_,minus_ ; ( ca1 n )
  dw dup_,zero_not_equals_  ; handle buffer > 32K XXX ?

  ; Update the file position to the start of the next line
  ; ( ca1 d )
  dw lit_,read_line_.fid,fetch_
  dw file_position_,drop_ ; XXX TODO manage the ior
  dw d_plus_
  dw lit_,read_line_.fid,fetch_
  dw reposition_file_,drop_ ; XXX TODO manage the ior

  ; ( ca1 )
  dw i_,swap_,minus_    ; ( len2 )
  dw true_,zero_        ; ( flag ior )
  ; ( len2 flag ior )
  dw unloop_,paren_exit_

read_line_.loop:
  dw paren_loop_,read_line_.do
read_line_.end_of_loop:
  ; ( ca1 len2 | len1' len2 )
  dw nip_,dup_,zero_not_equals_,zero_
  ; ( len2 flag ior )
  dw paren_exit_

; PARSE-FILENAME  ( "filename" -- ca len )

  _header _public,'PARSE-FILENAME'
parse_filename_:
  call do_colon
  dw parse_name_,dup_,zero_equals_
  dw lit_,-258 ; no filename specified ; XXX TMP
  dw and_,throw_
  dw paren_exit_

; FLUSH-FILE  ( fid -- ior )  94  ; XXX NEW

  _header _public,'FLUSH-FILE'
flush_file_:
  ; XXX TODO fid -> disk of fid -> call dos_flush
  ; XXX TMP
  pop hl
  jp false_

; }}} **********************************************************
; Save system {{{

; SAVE-SYSTEM  ( "filename[.COM]" -- )
;        0 0 freeze parsefilename s" com" +ext
;        ?create >r over swap boot 2! (cold_.6) (zb1)
;        dup (zbsize*2) erase (cold_.7-cold_.6) cmove
;        $100 dp @ over - r@ write-file boot cell+
;        off ?dup 0= if (hm) dph @ over - rot 0=
;        and r@ write-file then r> close-file or
;        abort" can't save file"

  _header _public,'SAVE-SYSTEM'
save_system_:
  call do_colon
  ; XXX TODO
  ; XXX OLD
;;  dw zero,zero
  ; XXX 'turnkey' jumps here with ( 1 xt )
  ; XXX 'turnkey-system' jumps here with ( 0 xt )
  ; ( f xt )
  ; f = save only the application without the system?
  ; xf = boot word or 0
;;save-system_.1:
;;  dw freeze_
;;  dw parse_filename_
;;  dw paren_s_quot_
;;  dcs 'bin'
;;  dw plus_ext_
;;  dw question_create_
;;  dw to_r_    ; fid
;;  dw over_,swap  ; set boot flags
;;  dw boot_,two_store_
;;  dw lit_,cold_.6  ; insert compiler logo
;;  dw lit_,zb1
;;  dw dup_
;;  dw c_lit_
;;  db zbsize*2
;;  dw erase_
;;  dw c_lit_
;;  db cold_.7-cold_.6
;;  dw cmove_
;;  dw lit,0x0100
;;  dw here_
;;  dw over_,minus_
;;  dw r_fetch_,write_file_  ; save application
;;  dw boot_,cell_plus_,off_  ; reset Forth flag
;;  dw question_dup_,zero_equals_
;;  dw question_branch_,save-system_.2
;;  dw lit_,hm
;;  dw dph_,fetch_
;;  dw over_,minus_
;;  dw rot_,zero_equals_,and_  ; system size
;;  dw r_fetch_,write_file_  ; save system
;;save-system_.2:
;;  dw from_r_,close_file_,or_
;;  dw paren_abort_quote_
;;  dcs  "can't save file"
  dw paren_exit_

; TURNKEY  ( "bootword" "filename[.COM]" -- )

  _header _public,'TURNKEY'
turnkey_:
  call do_colon
  ; XXX TODO
  dw paren_exit_
  ; XXX OLD
;;  dw true
;;turnkey_.1:
;;  dw tick
;;  dw branch,save-system_.1

; TURNKEY-SYSTEM  ( "bootword" "filename[.COM]" -- )

  _header _public,'TURNKEY-SYSTEM'
turnkey_system_:
  call do_colon
  ; XXX TODO
  dw paren_exit_
  ; XXX OLD
;;  dw zero
;;  dw branch,turnkey_.1

; }}} **********************************************************
; Source files {{{

; XXX TODO
; ------------------------------
; Converted from files.fs (from tools.fb)
; ------------------------------

; ; LOADLINE  ( -- a )
; ; line number being loaded

;   _header _public,'LOADLINE'

; loadline_:
;   call do_create
;   ds cell



; }}} **********************************************************
; Block files {{{

if block_files?

; XXX TODO -- simplify: use the generic files layer, and just
; keep the fid of the current block file.

file_descriptor_size: equ filename_buffer_size+(4*cell)  ; XXX OLD

file_descriptor_blocks:
  ds file_descriptor_size*max_open_source_files

file_descriptor_blocks_table:
  proc
    local @a
    @a defl file_descriptor_blocks
    rept max_open_source_files
      dw @a
      @a defl @a+file_descriptor_size
    endm
  endp

block_buffer:
  ds block_size

block_updated_mask: equ 0x8000
block_number_mask:  equ 0x7FFF

; B/BUF  ( -- u )
;   bytes per screen buffer

  _header _public,'B/BUF'
bytes_per_buffer_:
  call do_value
bytes_per_buffer_.value:
  dw 1024 ; default

; C/L  ( -- u )
;   chars per screen line

  _header _public,'C/L'
chars_per_line_:
  call do_value
chars_per_line_.value:
  dw 64 ; default

; SFP  ( -- a )
; screen file selector

  _header _hidden,'SFP'
sfp_:
  call do_create
  dw file_descriptor_blocks_table       ; current
  dw file_descriptor_blocks_table+cell  ; swap file

; SWAP-FILE  ( -- )
;   scr @ scr# ! sfp 2@ swap sfp 2!
;        scr# @ scr ! empty-buffers

  _header _public,'SWAP-FILE'
swap_file_:
  call do_colon
  dw scr_,fetch_
  dw scr_number_,store_
  dw sfp_,two_fetch_
  dw swap_
  dw sfp_,two_store_
  dw scr_number_,fetch_
  dw scr_,store_
  dw empty_buffers_
  dw paren_exit_

; FDB  ( -- a )
;   (filedescriptorblockstable) (maxopensourcefiles) 0 do dup @ @ 0= if unloop exit
;        then cell+ loop abort" too many files"

; XXX TODO  this word must be out of the blocks, because it's required also
; by source text files.

  _header _public,'FDB'
  ; get a free slot
fdb_:
  call do_colon
  dw lit_,file_descriptor_blocks_table
  dw c_lit_
  db max_open_source_files
  dw zero_
  dw paren_do_,fdb_.3
fdb_.do:
  dw dup_,fetch_,fetch_
  dw zero_equals_
  dw question_branch_,fdb_.2
  dw unloop_
  dw paren_exit_
fdb_.2:
  dw cell_plus_
  dw paren_loop_,fdb_.do
fdb_.3:
  dw paren_abort_quote_ ; XXX TODO convert to 'throw'
  _dcs 'too many files'
  dw paren_exit_

; file descriptor fields
;
; XXX TODO -- document this
;
;  FD  cell    status 0=closed
;  FID  cell    file handle
;  BLKS  cell    file size (blocks)
;  SCR#  cell    current SCR#
;  FNB  'filenamesize' bytes  file name

; FD  ( -- a )
; File descriptor field,
; first field of the file descriptor block.

  _header _hidden,'FD'
fd_:
  call do_colon
  dw sfp_,fetch_,fetch_
  dw paren_exit_

; FID  ( -- a )
;
; XXX TODO -- document this

  _header _hidden,'FID'
fid_:
  ld e,cell    ; ofsset to file handle field

fid_.e:  ; XXX TODO rename this label
  ld d,0
  push de
  call do_colon
  dw fd_,plus_
  dw paren_exit_

; BLKS  ( -- a )
;
; XXX TODO -- document this
; XXX TODO -- rename to 'blocks'?

  _header _hidden,'BLKS'
blks_:
  ld e,cell*2    ; offset to file size field
  jp fid_.e

; SCR#  ( -- a )
;
; XXX TODO -- document this

  _header _hidden,'SCR#'
scr_number_:
  ld e,cell*3    ; offset to current SCR_# field
  jp fid_.e

; FNB  ( -- a )
;
; XXX TODO -- document this

  _header _hidden,'FNB'
fnb_:
  ld e,cell*4    ; offset to file name field
  jp fid_.e

; BUF  ( -- a )
; file buffer address

  _header _hidden,'BUF'
buf_:
  call do_constant
  dw block_buffer

; BLK#  ( -- a )
; update flag

  _header _hidden,'BLK#'
blk_number_:
  call do_create
blk_number_.variable:
  ds cell

; FILE?  ( -- flag )
;
; XXX TODO rename

  _header _public,'FILE?'
file_question_:
  call do_colon
  dw fd_,fetch_ ; fd @
  dw zero_not_equals_ ; 0<>
  dw paren_exit_

; CURRENT-BLOCK-FILE  ( -- ca len )

  _header _public,'CURRENT-BLOCK-FILE'
current_block_file_:
  call do_colon
  dw fnb_,count_
  dw paren_exit_

; ?OPEN  ( -- )
;   file? 0= abort" no file open"

  _header _hidden,'?OPEN'
question_open_:
  call do_colon
  dw file_question_
  dw zero_equals_
  dw paren_abort_quote_ ; XXX TODO convert to 'throw'
  _dcs 'no file open'
  dw paren_exit_

; #SCREENS  ( -- +n )
;   ?open blks @
; XXX TODO remove?

  _header _public,'#SCREENS'
number_screens_:
  call do_colon
  dw question_open_
  dw blks_,fetch_
  dw paren_exit_

; EMPTY-BUFFERS  ( -- )
;   $7fff blk# !

  _header _public,'EMPTY-BUFFERS'
empty_buffers_:
  ld hl,block_number_mask
  ld (blk_number_.variable),hl
  jp next

; UPDATE  ( -- )
;   ?open blk# @ $8000 or blk# !

  _header _public,'UPDATE'
update_:
  call do_colon
  dw question_open_
  dw blk_number_,fetch_
  dw lit_,block_updated_mask
  dw or_
  dw blk_number_,store_
  dw paren_exit_

; BLKERR  ( flag -- )
;   abort" block r/w error"
; 
; XXX TODO remove, use ior instead

  _header _hidden,'BLKERR'
blkerr_:
  call do_colon
  dw paren_abort_quote_ ; XXX TODO convert to 'throw'
; -33 ; block read exception
; -34 ; block write exception
  _dcs 'block r/w error'
  dw paren_exit_

; BLK-RW  ( +n mode -- )
;   >r b/buf um* fid @ reposition-file blkerr
;   buf b/buf fid @ r> if write-file else
;   read-file blkerr b/buf < then blkerr

  _header _hidden,'BLK-RW'
blk_rw_:
  call do_colon
  dw to_r_
  dw bytes_per_buffer_,umstr_
  dw fid_,fetch_
  dw reposition_file_
  dw blkerr_ ; XXX OLD
  dw buf_,bytes_per_buffer_
  dw fid_,fetch_
  dw from_r_
  dw question_branch_,blk_rw_.1
  dw write_file_
  dw branch_,blk_rw_.2
blk_rw_.1:
  dw read_file_
  dw blkerr_ ; XXX OLD
  dw bytes_per_buffer_,less_
blk_rw_.2:
  dw blkerr_ ; XXX OLD
  dw paren_exit_

; ?BLK  ( +n -- +n )

  _header _hidden,'?BLK'
question_blk_:
  call do_colon
  dw dup_
  dw number_screens_,zero_,within_ ; block in range?
  dw lit_,-35 ; invalid block number
  dw and_,throw_
  dw paren_exit_

; SAVE-BUFFERS  ( -- )
;   ?open blk# @ 0< if blk# @ $7fff and
;        dup blk# ! ?blk 1 blk-rw then

  _header _public,'SAVE-BUFFERS'
save_buffers_:
  call do_colon
  dw question_open_
  dw blk_number_,fetch_,zero_less_
  dw question_branch_,save_buffers_.end
  dw blk_number_,fetch_
  dw lit_,block_number_mask,and_
  dw dup_,blk_number_,store_
  dw question_blk_    ; block in range?
  dw one_,blk_rw_
save_buffers_.end:
  dw paren_exit_

; FLUSH  ( -- )
;   save-buffers empty-buffers

  _header _public,'FLUSH'
flush_:
  call do_colon
  dw save_buffers_,empty_buffers_
  dw paren_exit_

; BUFFER  ( +n -- a )
;   save-buffers ?blk blk# ! buf

  _header _public,'BUFFER'
buffer_:
  call do_colon
  dw save_buffers_
  dw question_blk_
  dw blk_number_,store_
  dw buf_
  dw paren_exit_

; BLOCK  ( +n -- a )
;   ?open blk# @
;   $7fff and \ block number mask
;   over - if dup
;   buffer drop 0 blk-rw else drop then buf

; XXX FIXME skip the +3DOS header

  _header _public,'BLOCK'
block_:
  call do_colon
  dw question_open_
  dw blk_number_,fetch_
  dw lit_,block_number_mask
  dw and_,over_,minus_
  dw question_branch_,block_.1
  dw dup_,buffer_,drop_
  dw zero_,blk_rw_
  dw branch_,block_.2
block_.1:
  dw drop_
block_.2:
  dw buf_
  dw paren_exit_

; -->  ( -- )
;   blk @ 0= abort" loading only" (refill) drop
        ; immediate

  _header _public,'-->',_immediate
next_block_:
  call do_colon
  dw blk_,fetch_,zero_equals_
  dw paren_abort_quote_
  _dcs 'loading only' ; XXX TODO convert to 'throw'
  dw paren_refill_,drop_
  dw paren_exit_

; (THRU)  ( +n1 +n2 -- )
;   1+ swap ?do i block b/buf i (evaluate) loop

debug_thru: equ false ; XXX TMP for debugging

  _header _hidden,'(THRU)'
paren_thru_:
  call do_colon
  _debug "start of (thru)",debug_thru
  dw one_plus_,swap_
  dw paren_question_do_,paren_thru_.end
paren_thru_.do:
  _debug "start of loop of (thru)",debug_thru
  dw i_,block_
  _debug "(thru) after block",debug_thru
  dw bytes_per_buffer_
  _debug "(thru) after b/buf",debug_thru
  dw i_,paren_evaluate_
  _debug "(thru) after (evaluate)",debug_thru
  dw paren_loop_,paren_thru_.do
paren_thru_.end:
  _debug "end of (thru)",debug_thru
  dw paren_exit_

; THRU  ( +n1 +n2 -- )
;   (thru) ?block

  _header _public,'THRU'
thru_:
  call do_colon
  _debug "start of thru",debug_thru
  dw paren_thru_
  _debug "thru before ?block",debug_thru
  dw question_block_
  _debug "end of thru",debug_thru
  dw paren_exit_

; LOAD  ( +n -- )
;   dup thru

  _header _public,'LOAD'
load_:
  pop hl
  push hl
  push hl
  jp thru_

; FNBUF  ( -- a )
; current file handle

  _header _hidden,'FNBUF'
fnbuf_:
  call do_create
  ds filename_buffer_size

; (FBK)  ( +n -- )
;   #screens 2dup u< if drop dup current-block-file -ext
;        s" $$$" +ext fnbuf place fnbuf count w/o
;        create-file throw over 0 ?do dup i block
;        b/buf rot write-file throw loop close-file
;        throw fid @ close-file throw current-block-file
;        delete-file throw fnbuf count current-block-file
;        rename-file throw current-block-file r/w open-file
;        throw fid ! then over blks ! ?do i buffer
;        b/buf blank update save-buffers loop

  _header _hidden,'(FBK)'
paren_fbk_:
  call do_colon
  dw number_screens_    ; tests if file open
  dw two_dup_,u_less_
  dw question_branch_,paren_fbk_.3
  dw drop_,dup_
  dw current_block_file_,minus_ext_
  dw paren_s_quot_
  _dcs '$$$'
  dw plus_ext_
  dw fnbuf_,place_
  dw fnbuf_,count_
  dw write_only_,create_file_,throw_
  dw over_,zero_
  dw paren_question_do_,paren_fbk_.2
paren_fbk_.do.1:
  dw dup_
  dw i_,block_
  dw bytes_per_buffer_
  dw rot_,write_file_,throw_
  dw paren_loop_,paren_fbk_.do.1
paren_fbk_.2:
  dw close_file_,throw_
  dw fid_,fetch_
  dw close_file_,throw_
  dw current_block_file_,delete_file_,throw_
  dw fnbuf_,count_
  dw current_block_file_,rename_file_,throw_
  dw current_block_file_
  dw read_write_,open_file_,throw_
  dw fid_,store_
paren_fbk_.3:
  dw over_
  _debug "(fbk) about to update BLKS",debug_blocks?
  dw blks_,store_  ; update max block
  dw paren_question_do_,paren_fbk_.end
paren_fbk_.do.2:
  dw i_,buffer_
  dw bytes_per_buffer_,blank_
  dw update_,save_buffers_
  dw paren_loop_,paren_fbk_.do.2
paren_fbk_.end:
  dw paren_exit_

; RESIZE-BLOCK-FILE  ( +n -- )
;   ['] (fbk) catch abort" can't resize file"

  _header _public,'RESIZE-BLOCK-FILE'
resize_block_file_:
  call do_colon
  dw lit_,paren_fbk_
  dw catch_ ; XXX TODO why? study this
  dw paren_abort_quote_ ; XXX TODO convert to 'throw' -259
  _dcs "can't resize file"
  dw paren_exit_

; CLOSE  ( -- )
;
; close current block-file
;
; Note: errors are NOT reported with this function
;
;  file? if flush fid @ close-file drop
;        fd off then empty-buffers

  _header _public,'CLOSE'
close_:
  call do_colon
  dw file_question_
  dw question_branch_,close_.1
  dw flush_
  dw fid_,fetch_
  dw close_file_,drop_
  dw fd_,off_
close_.1:
  dw empty_buffers_
  dw paren_exit_

; CLOSE-ALL  ( -- )
;   close (filedescriptorblockstable) maxopensourcefiles 0 do dup sfp ! close
;        cell+ loop drop
; XXX TODO write generic version for all open files

  _header _public,'CLOSE-ALL'
close_all_:
  call do_colon
  dw close_    ; ensure buffer flushed
  dw lit_,file_descriptor_blocks_table
  dw c_lit_
  db max_open_source_files
  dw zero_
  dw paren_do_,close_all_.end
close_all_.do:
  dw dup_
  dw sfp_,store_
  dw close_
  dw cell_plus_
  dw paren_loop_,close_all_.do
close_all_.end:
  dw drop_
  dw paren_exit_

; LAST-FILENAME  ( -- ca len )
; last filename used by 'open-file' etc
; XXX TODO add to glossary

  _header _public,'LAST-FILENAME'
last_filename_:
  call do_colon
  dw lit_,filename_buffers_.last
  dw fetch_
  dw count_
  dw paren_exit_

; .LASTFILE  ( -- )
;   beep cr lastfile type space
; XXX OLD -- removed, useless
  ; _header _hidden,'.LASTFILE'
; dot_last_filename_:
  ; call do_colon
  ; dw beep_,cr_
  ; dw last_filename_,type_
  ; dw space_
  ; dw paren_exit_


; ?CREATE  ( ca len -- fileid )
;        r/o open-file 0= tuck if close-file then
;        drop if .lastfile ." exists - delete it? "
;        y/n 0= if abort then then lastfile r/w
;        create-file abort" can't create file"
  ; XXX OLD -- move it to a .fs to reuse it as a library
  ; _header _hidden,'?CREATE'
; question_create_:
  ; call do_colon
  ; dw read_only_,open_file_  ; test if file exists
  ; dw zero_equals_,tuck_
  ; dw question_branch_,question_create_.1
  ; dw close_file_
; question_create_.1:
  ; dw drop_
  ; dw question_branch_,question_create_.2
  ; dw dot_last_filename_
  ; dw paren_dot_quote_
  ; _dcs 'exists - delete it? '
  ; dw yn_,zero_equals_ ; XXX TODO make this configurable
  ; dw question_branch_,question_create_.2
  ; dw abort_
; question_create_.2:
  ; dw last_filename_,read_write_,create_file_
  ; dw paren_abort_quote_
  ; _dcs "can't create file"
  ; dw paren_exit_

; INIT-SCR  ( fid ior -- )
;
; init screenfile
;
;   if drop exit then
;   fdb sfp !
;   fd on
;   dup fid !
;   file-size drop b/buf um/mod nip blks ! ; XXX FIXME fails with +3DOS headers
;   lastfile fnb place
;   current-block-file upper
;   empty-buffers

  _header _hidden,'INIT-SCR'
init_scr_:
  call do_colon
  _debug "Entry of 'init-scr'",debug_blocks?

  dw branch_if_0_,init_scr_.no_error
  dw drop_
  dw paren_exit_

init_scr_.no_error:
  dw fdb_,sfp_,store_
  dw fd_,on_
  dw dup_,fid_,store_
  dw file_size_,drop_
  _debug "files size",debug_blocks?

  dw blks_,fetch_
  _debug "current content of BLKS",debug_blocks?
  dw drop_

  dw bytes_per_buffer_,umslm_,nip_  ; overflow stores $FFFF

  _  ; XXX TMPdebug "new content of BLKS",debug_blocks?

  dw blks_,store_
  dw last_filename_,fnb_,place_

; XXX OLD -- why DX-Forth does this without an option?
;  dw current_block_file_
;  dw upper

  dw empty_buffers_
  dw paren_exit_

; OPEN-BLOCK-FILE  ( ca len fam -- ior )
;         fdb drop >r s" scr" +ext r>
;         open-file tuck init-scr
;
; XXX NEW -- formerly 'OPEN'
; XXX TODO -- leave the fid?

; XXX FIXME it works without modification, but leaves three numbers on the
; stack.

  _header _public,'OPEN-BLOCK-FILE'
open_block_file_:
  call do_colon
  dw fdb_,drop_  ; free slot?
  dw to_r_
  dw paren_s_quot_
  _dcs 'fb'
  dw plus_ext_
;  dw two_dup_,type_,cr_ ; XXX INFORMER
  dw from_r_,open_file_
  dw tuck_
  dw init_scr_
  dw paren_exit_

; (OPEN)  ( ca len -- )
;   r/w open abort" can't open file"
;
; XXX TODO -- it's a too generic name, change it

  _header _hidden,'(OPEN)'
paren_open_:
  call do_colon
  dw read_write_  ; XXX TODO read_only_ ?
  dw open_block_file_
  ; XXX FIXME
  dw paren_abort_quote_ ; XXX TODO convert to 'throw'
  _dcs "can't open file"
  dw paren_exit_

; LOAD-FILE  ( +n "filename[.fb]" -- )
;   dup parsefilename loaded

  _header _public,'LOAD-FILE'
load_file_:
  call do_colon
  dw dup_
  dw parse_filename_
  dw loaded_
  dw paren_exit_

; USING  ( "filename[.fb]" -- )
;         close parsefilename r/w open ?dup if
;          .lastfile -507 = if ." access denied"
;          0 else ." not found - create it? "
;          y/n then 0= if abort then lastfile
;          ?create 0 init-scr then 0 0 scr 2!
; open/make a screen file

  ; XXX TODO rename to 'use' (rename 'use' first)
  ; XXX TODO write non-parsing version 'used'
  ; XXX TODO better, after Gforth: non-parsing 'open-blocks'
  ; and
  ;   : use  parse-name open-blocks ;

  ; _header _public,'USING'
; using_:
  ; call do_colon
  ; dw close_
  ; dw parse_filename_
  ; dw read_write_,open_block_file_,question_dup_
  ; dw question_branch_,using_.4
  ; dw dot_last_filename_
  ; dw lit_,-507,equals_
  ; dw question_branch_,using_.1
  ; dw paren_dot_quote_
  ; _dcs 'access denied'
  ; dw zero_
  ; dw branch_,using_.2
; using_.1:
  ; dw paren_dot_quote_
  ; _dcs 'not found - create it? ' ; XXX OLD remove this!, use other word to create it.
  ; dw yn_
; using_.2:
  ; dw zero_equals_
  ; dw question_branch_,using_.3
  ; dw abort_
; using_.3:
  ; dw last_filename_,question_create_
  ; dw zero_,init_scr_
; using_.4:
  ; dw zero_,zero_,scr_,two_store_
  ; dw paren_exit_


; LOADED  ( +n1 +n2 ca len -- )
;   sfp @ >r (open) (thru) close r>
;          sfp ! ?block

  _header _public,'LOADED'
loaded_:
  call do_colon
  dw sfp_,fetch_
  dw to_r_
  dw paren_open_
  dw paren_thru_
  dw close_
  dw from_r_
  dw sfp_,store_
  dw question_block_
  dw paren_exit_

; ?BLOCK   ( -- )
; reload block
; blk @ ?dup if block drop then
; XXX OLD?
; XXX TODO rename

  _header _hidden,'?BLOCK'
question_block_:
  call do_colon
  dw blk_,fetch_,question_dup_
  dw question_branch_,question_block_.end
  dw block_,drop_
question_block_.end:
  dw paren_exit_


; INDEX   ( +n1 +n2 -- ) ; XXX TMP

; this word is defined in <src/tools.fb> and <src/tools.fs>
; i tried to define it here for debugging,
; but 'esc?' and '.line' are required too.

  ; _header _public,'INDEX'
; index_:
  ; call do_colon
  ; dw one_plus_,swap_
; index_.do:
  ; dw paren_question_do_,index_.end
  ; dw cr_,i_,three_,dot_r_,space_
  ; dw zero_,i_,dot_line_
  ; dw esc_question_
  ; dw branch_if_false_,index_.loop
  ; dw leave_
; index_.loop:
  ; dw paren_loop_,paren_.do
; index_.end:
  ; dw paren_exit_




endif ; end of block file words

; }}} **********************************************************
; Screen and graphics {{{

; AT-XY  ( u1 u2 -- )
;   position cursor at col u1, row u2

; XXX FIXME -- out of range error in BASIC

  _header _public,'AT-XY'
at_xy_:

  if fast_emit?

    ld a,at_char
    call emit_a
    pop hl
    call emit_l
    pop hl
    call emit_l
    jp next

  else

    call do_colon
  at_xy_.0:
    dw c_lit_
    db at_char
    dw emit_,emit_,emit_
    dw paren_exit_

  endif

; HOME  ( -- )  comus
;   position cursor at col 0, row 0

  _header _public,'HOME'
home_:

  if fast_emit?

    if size_optimization?

      ld hl,0
      push hl
      push hl
      jr at_xy_

    else

      ld a,at_char
      call emit_a
      xor a
      call emit_a
      xor a
      call emit_a
      jp next

    endif

  else

    call do_colon
    dw zero_,dup_
    dw branch_,at_xy_.0

  endif

; PAGE  ( -- )
  _header _public,'PAGE'
page_:
  ; XXX TODO adapt to printer too; check Forth-2012

  ; XXX INFORMER
;  ld a,2
;  out (254),a
;  jr $

  push bc
  call rom_cl_all
  ld a,2
  call rom_chan_open ; XXX TODO needed?
  pop bc
  jp next

; XXX OLD
;;; NORMAL  ( -- )
;;  _header _public,'NORMAL'
;;vnorm_:
; XXX TODO
;;  jp next
;;  ld hl,tlovid
;;vnorm.1:
;;  ld de,tceold
;;  jp atxy.1

; CLEAR-LINE  ( -- )

  _header _public,'CLEAR-LINE'
cleol_:
; XXX TODO
  jp next
;;  ld hl,tceol
;;  jp vnorm.1

; INSERT-LINE  ( -- )

  _header _public,'INSERT-LINE'
insln_:
; XXX TODO
  jp next
;;  ld hl,tinsln
;;insln.1:
;;  ld de,tclsd
;;  jp atxy.1

; DELETE-LINE  ( -- )

  _header _public,'DELETE-LINE'
delln_:
; XXX TODO
  jp next
;;  ld hl,tdelln
;;  jp insln.1

  _header _public,'BORDER'
border_:
  ; Code based on Lennart Benschop's ZX Spectrum Forth-83 System:
  ;   : BORDER  ( n -- )
  ;     DUP DUP 4 < 7 AND SWAP 8 * + 23624 C! 254 P! ;
  ; This is my translation to Z80:
  pop hl
border_.l:
  if 0

    ; XXX OLD -- the screen will be used as a whole, not like Sinclair BASIC,
    ; so this is not needed.

    ; Set the paper of the bottom screen
    ld a,l
    cp 4 ; dark color?
    jp nc,border_.a
    ; dark color
    sla a
    sla a
    sla a ; *8 (converted to paper_)
    add a,7 ; white ink
    ld (sys_bordcr),a

  endif
  ld a,l
border_.a:
  out (254),a
  jp next


; COLOR  ( +n c -- )
; Print control char c, char +n and update the permanent attributes.

; This word was inspired by the 'COLOR' defining word from Lennart Lennart
; Benchsop's ZX Spectrum Forth-83 Standard System (1988).

; XXX TODO don't print the codes, just change the variables...

  _header _public,'COLOR'
color_:
  pop hl
color_.l:
  call emit_l
  pop hl
  call emit_l
  ld a,(sys_attr_t)
  ld (sys_attr_p),a
  jp next

; PAPER  ( n -- )
  _header _public,'PAPER'
paper_:
  ld l,paper_char
  _jump color_.l

; INK  ( n -- )
  _header _public,'INK'
ink_:
  ld l,ink_char
  _jump color_.l

; BRIGHT  ( n -- )
  _header _public,'BRIGHT'
bright_:
  ld l,bright_char
  _jump color_.l

; FLASH  ( n -- )
  _header _public,'FLASH'
flash_:
  ld l,flash_char
  _jump color_.l

; OVERPRINT ( n -- )
  _header _public,'OVERPRINT'
overprint_:
  ; XXX TODO -- Benschop's Forth_-83 does this:
  ; 23697 DUP C@ 252 AND ROT 3 * OR SWAP C!
  pop hl
  jp next

; INVERSE  ( n -- )
  _header _public,'INVERSE'
inverse_:
  ; XXX TODO -- Benschop's Forth_-83 does this:
  ; 23697 DUP C@ 243 AND ROT 12 * OR SWAP C!
  pop hl
  jp next

; NORMAL  ( -- )
  _header _public,'NORMAL'
normal_:
  call do_colon
  dw c_lit_
  db 4
  dw dup_,border_,paper_
  dw zero_,ink_
  dw zero_,flash_
  dw zero_,inverse_
  dw zero_,overprint_
  dw paren_exit_

; }}} **********************************************************
; Floating point {{{

  if floating_point?

; -FP  ( -- a )
;   marker -FP

  _header _public,'-FP'
dfp_:
  call next

; FLOAT  ( -- u ) ; XXX NEW

  _header _public,'FLOAT',,four_
float_: equ four_

; FLOAT+  ( f-a1 -- f-a2 )
;   FLOAT +

  _header _public,'FLOAT+'
float_plus:
  pop hl
  ld de,float
  add hl,de
  _push_hl_jp_next

; FLOATS  ( n1 -- n2 )
;   FLOAT *

  _header _public,'FLOATS'
floats_:
  pop hl
  add hl,hl
  add hl,hl
  _push_hl_jp_next

; FALIGN  ( -- )
;   aka noop falign immediate

  _header _public,'FALIGN',_immediate,noop_
f_align_: equ  next

; FALIGNED  ( a -- fa )
;   aka noop faligned immediate

  _header _public,'FALIGNED',_immediate,noop_
f_aligned_: equ  next

; F,  (F: r -- ) or ( r -- )  , ,

  _header _public,'F,'
f_comma_:
  call do_colon
  dw comma_,comma_
  dw paren_exit_

; FLITERAL  ( -- r )
;   aka fliteral 2literal immediate

  _header _public,'FLITERAL',_immediate,two_literal_
f_literal_ equ  two_literal_
f_lit_:    equ  two_lit_

; FCONSTANT  ( -- r )
;   aka 2constant fconstant

  _header _public,'FCONSTANT',,two_constant_
f_constant_: equ  two_constant_

do_f_constant: equ  two_fetch_

; FVARIABLE  ( -- fa )
;   aka 2variable fvariable

  _header _public,'FVARIABLE',,two_variable_
f_variable_: equ  two_variable_

; FDEPTH   ( -- +n )
;   depth 2/

  _header _public,'FDEPTH'
f_depth_:
  call do_colon
  dw depth_,two_slash_
  dw paren_exit_

; FDROP  ( r -- )
;   aka 2drop fdrop

  _header _public,'FDROP',,two_drop_
f_drop_: equ  two_drop_

; FDUP  ( r -- r r )
;   aka 2dup fdup

  _header _public,'FDUP',,two_dup_
f_dup_: equ  two_dup_

; FSWAP  ( r1 r2 -- r2 r1 )
;   aka 2swap fswap

  _header _public,'FSWAP',,two_swap_
f_swap_: equ  two_swap_

; FOVER  ( r1 r2 -- r1 r2 r1 )
;   aka 2over fover

  _header _public,'FOVER',,two_over_
f_over_: equ  two_over_

; FROT  ( r1 r2 r3 -- r2 r3 r1 )
;   aka 2rot frot

  _header _public,'FROT',,two_rot_
f_rot_: equ  two_rot_

; F@  ( fa -- r )
;   aka 2@ f@

  _header _public,'F@',,two_fetch_
f_fetch_: equ  two_fetch_

; F!  ( r fa -- )
;   aka 2! f!

  _header _public,'F!',,two_store_
f_store_: equ  two_store_

; FPICK  ( +n -- r )
;   floats sp@ cell+ + f@

  _header _public,'FPICK'
f_pick_:
  call do_colon
  dw floats_
  if  floating_point_stack?
    dw fsp_,fetch_
  else
    dw sp_fetch_,cell_plus_
  endif
  dw plus_,f_fetch_
  dw paren_exit_

; floating point accumulator

accumulator_exponent:     ds 1
accumulator_sign:         ds 1
accumulator_1st_fraction  ds 1
accumulator_2nd_fraction  ds 1
accumulator_3rd_fraction  ds 1

substraction_flag:        ds 1

float_tmp_1:
  ds float    ; temp float storage
float_tmp_2:
  ds float    ;

f_ten:
  call do_f_constant    ; fconstant
fp10:
  db 0x84,0x20,0,0  ; 10.0

; save/load temp fp registers

savf.1:
  ld hl,float_tmp_1    ; save regs to float_tmp_1
  jp str

savf.2:
  ld hl,float_tmp_2    ; save regs to float_tmp_2
  jp str

lodf.1:
  ld hl,float_tmp_1    ; load accum/regs from float_tmp_1
  jp lod

lodf.2:
  ld hl,float_tmp_2    ; load accum/regs from float_tmp_2
  jp lod

; pop float from stack to accum, saving bc

ldop:
  pop de
  pop hl
  ld (float_tmp_1),hl
  pop hl
  ld (float_tmp_1+2),hl
  push bc
  push de
  ld hl,float_tmp_1
  jp lod

; pop 2 float from stack to hl (floattmp2) and accum, saving bc

ld2op:
  pop hl
  ld (ld2op1),hl
  pop hl
  ld (float_tmp_2),hl
  pop hl
  ld (float_tmp_2+2),hl
  call ldop
  ld hl,(ld2op1)
  push hl
  ld hl,float_tmp_2
  ret

ld2op1:
  ds 2

; push float registers to stack, restore bc and exit

svop:
  ld l,a
  ld h,b
  ld e,c
  pop bc
  jp push_de_hl

; str  store registers to accum

strr:
  ld hl,accumulator_exponent
  ld (hl),e
  inc  hl

; entry - hl=adr, a=exp, bcd (packed)
; exit  - none

str:
  ld (hl),a
str.1:
  inc  hl    ; entry when hl=accumulator_sign
  ld (hl),b
  inc  hl
  ld (hl),c
  inc  hl
  ld (hl),d
  ret

; zero - set accum and regs to zero

zro:
  xor a
  ld (accumulator_exponent),a
  ld b,a
  ld c,a
  ld d,a
  ret

; overflow - set regs to maximum, set cy

ovf:
  ld bc,0x7FFF
  ld a,c
  ld d,c
  scf
  ret

; chs  change sign of accumulator
; entry - none
; exit  - bcd (packed), a=exp, flags set

chs:
  ld a,0x80
  jp fab.1

; change sign of accumulator and again on result
; (when calling routine completes)

chss:
  call chs
  ld hl,chs
  ex (sp),hl
  jp (hl)

; fab  set acc to absolute
;
; entry - none
; exit  - bcd (packed), a=exp, flags set

fab:
  xor a
fab.1:
  ld hl,accumulator_sign
  and (hl)
  xor 0x80
  ld (hl),a    ; fall thru tst

; tst  load registers from acc and test
; exit  - bcd (packed), a=exp, flags set

tst:
  ld hl,accumulator_exponent
  ld a,(hl)
  and a
  jp z,zro
  ld e,a    ; e exp
  inc  hl
  ld a,(hl)    ; accumulator_sign
  inc  hl
  xor (hl)    ; pack msb with sign
  inc  hl
  ld c,(hl)
  inc  hl
  ld d,(hl)
  jp tst.1

; lod  load float (hl) to accum and regs, set flags
; entry - hl=adr
; exit  - bcd (packed), a=exp, flags set

lod:
  ld a,(hl)
  and a
  jp z,zro
  ld e,a
  inc  hl
  ld a,(hl)
  inc  hl
  ld c,(hl)
  inc  hl
  ld d,(hl)
  ld l,a
  or 0x80
  ld b,a
  xor l
lod.2:
  call strr
  xor b

; entry - acd (packed), e=exp
; exit  - bcd (packed), a=exp, flags set

tst.1:
  ld b,a
tst.2:
  or 1    ; test sign_, clear Z C flags
  ld a,e
  ret

; entry - a=exp
; exit  - e=exp  Z=zero M=negative

tstr:
  ld e,a
tstr.1:
  or a
  ret  z
tstr.2:
  ld a,b
  jp tst.2

; fcmp  compare registers with (hl), return M if regs < (hl)

fcmp:
  ld e,a
  ld a,(hl)
  or a
  ld a,e
  jp z,tstr.1    ; hl zero_, test sign regs
  or a
  inc  hl
  ld a,(hl)
  cpl
  jp z,tst.2    ; regs zero_, test sign hl
  xor b
  jp p,tstr.2    ; signs differ
  call fcmp.1
  rra
  xor b    ; complement sign for neg values
  ld a,e
  ret

fcmp.1:
  dec  hl
  ld a,e
  cp (hl)
  ret  nz
  inc  hl
  ld a,b
  cp (hl)
  ret  nz
  inc  hl
  ld a,c
  cp (hl)
  ret  nz
  inc  hl
  ld a,d
  cp (hl)
  ret  nz
  pop hl
  ld a,e
  ret

; right shift bcd by a bits
;
; entry - bcd, a=shift count
; exit  - bcde

shr_:
  ld e,0
  ld l,8    ; shift 8 bits by moving registers
shr_.1:
  cp l
  jp m,shr_.2    ; less than 8
  ld e,d
  ld d,c
  ld c,b
  ld b,0
  sub  l
  jp nz,shr_.1
shr_.2:
  and a
  ret  z    ; done
  ld l,a
shr_.3:
  and a    ; clear carry
  ld a,b
  rra
  ld b,a
  ld a,c
  rra
  ld c,a
  ld a,d
  rra
  ld d,a
  ld a,e
  rra
  ld e,a
  dec  l
  jp nz,shr_.3
  ret

; left shift bcde one bit
;
; entry - bcde
; exit  - bcde

shl_:
  ld a,e
  rla
  ld e,a
  ld a,d
  rla
  ld d,a
  ld a,c
  rla
  ld c,a
  ld a,b
  adc  a,a
  ld b,a
  ret

; Complement bcde adjust accumulatorsign, return sign flag

fcpl:
  ld hl,accumulator_sign    ; change accum sign
  ld a,(hl)
  xor 0x80
  ld (hl),a
  xor a    ; complement fraction
  ld l,a
  sub  e
  ld e,a
  ld a,l
  sbc a,d
  ld d,a
  ld a,l
  sbc a,c
  ld c,a
  ld a,l
  sbc a,b
  ld b,a
  ret

; Normalize bcde registers, adjust accumulatorexponent
;
; entry - bcde
; exit  - bcde, z= bcde=0 or accumulatorexponent=0

norm:
  ld l,32    ; max shift
norm.1:
  ld a,b
  and a
  jp nz,norm.3
  ld b,c
  ld c,d
  ld d,e
  ld e,a
  ld a,l
  sub  8
  ld l,a
  jp nz,norm.1
  ret     ; bcde = zero

norm.2:
  dec  l    ; shl until bit 31 set
  call shl_
norm.3:
  jp p,norm.2

  ld a,l    ; adjust accum exp
  sub  32
  ld hl,accumulator_exponent
  add a,(hl)
  ld (hl),a
  ret  z    ; if zero exp
  rra      ; move borrow bit to sign
  and a    ; set sign to indicate underflow
  ret

; Round the bcde registers, save to acc
;
; entry - bcde
; exit  - bcd, a=packed msb, e=exp, cy=ovf

rondr:
  ld a,e    ; lsb
  and a    ; test sign and clear cy
  ld hl,accumulator_exponent    ; exp
  ld e,(hl)
  call m,rondr.1
  ret  c    ; rounder overflow
  ld a,b
  inc  hl    ; accumulator_sign
  xor (hl)    ; a=packed msb
  jp str.1    ; save bcd to acc

; round up bcd e=exp, cy=ovf

rondr.1:
  inc  d
  ret  nz
  inc  c
  ret  nz
  inc  b
  ret  nz
  ld b,0x80    ; new 1st fraction
  ld a,e    ; inc exp
  add a,1    ; adjust cy
  ld e,a
  ld (accumulator_exponent),a  ; new acc exp
  ret

; fsu  floating point subtract subroutine

fsu:
  ld a,0x80    ; mask to change operand sign
  jp fad.1

; fad  floating point add subroutine

fad:
  xor a
fad.1:
  ld e,(hl)    ; load operand to abcd
  inc  hl
  xor (hl)
  ld b,a
  inc  hl
  ld c,(hl)
  inc  hl
  ld d,(hl)
  ld a,e
  and a
  jp z,tst    ; operand zero

  ld l,b    ; unpack
  ld a,b
  or 0x80
  ld b,a
  xor l    ; generate subtraction flag
  ld hl,accumulator_sign
  xor (hl)
  ld (substraction_flag),a

; determine relative magnitudes of operand and accum

  dec  hl    ; accumulator_exponent
  ld a,(hl)
  and a
  jp z,fad.8    ; accum zero

  sub  e    ; get difference of exponents
  jp c,fad.2    ; accum smaller

; check for insignificant operand

  jp m,tst
  cp 25    ; compare shift count to 25
  jp c,fad.3
  jp tst

; check for insignificant accum, exchange accum and operand

fad.2:
  jp p,fad.8
  cp 0-25    ; compare shift count to -25
  jp c,fad.8

  ld (hl),e    ; set accumulator_exponent

  ld e,a    ; save shift count

  ld a,(substraction_flag)    ; set accum sign
  inc  hl    ; accumulator_sign
  xor (hl)
  ld (hl),a

  xor a    ; complement shift count
  sub  e

  inc  hl    ; exchange fraction
  ld e,(hl)
  ld (hl),b
  ld b,e
  inc  hl
  ld e,(hl)
  ld (hl),c
  ld c,e
  inc  hl
  ld e,(hl)
  ld (hl),d
  ld d,e

; position the operand, check if add or subtract

fad.3:
  call shr_
  ld hl,accumulator_3rd_fraction
  ld a,(substraction_flag)
  and a
  jp m,fad.4

  ld a,(hl)    ; add
  add a,d
  ld d,a
  dec  hl
  ld a,(hl)
  adc  a,c
  ld c,a
  dec  hl
  ld a,(hl)
  adc  a,b
  ld b,a
  jp nc,fpack

  rra      ; got carry, so rshift fraction
  ld b,a
  ld a,c
  rra
  ld c,a
  ld a,d
  rra
  ld d,a
  rra
  ld e,a
  ld hl,accumulator_exponent    ; and adjust exponent
  ld a,(hl)
  add a,1
  ld (hl),a
  jp c,ovf    ; overflow
  jp fpack

fad.4:
  xor a    ; subtract
  sub  e
  ld e,a
  ld a,(hl)
  sbc a,d
  ld d,a
  dec  hl
  ld a,(hl)
  sbc a,c
  ld c,a
  dec  hl
  ld a,(hl)
  sbc a,b
  ld b,a

; complement bcde if carry

cnpack:
  call c,fcpl

; normalize and pack bcde

npack:
  ld a,b
  and a
  call p,norm
  jp p,zro    ; underflow or zero

; pack bcde

fpack:
  call rondr    ; round bcde
  jp c,ovf
  jp tst.1

; move operand to accumulator

fad.8:
  ld a,(substraction_flag)
  ld hl,accumulator_sign
  xor (hl)
  jp lod.2

; read the operand at (hl), check the accum exponent

mdex:
  ld b,a
  inc  hl
  ld c,(hl)
  inc  hl
  ld d,(hl)
  inc  hl
  ld e,(hl)

  ld hl,accumulator_exponent    ; accum exp
  ld a,(hl)
  and a
  ret  z    ; is zero

  add a,b    ; result exp plus bias
  ld b,a
  rra      ; carry to sign
  xor b    ; carry and sign must differ
  ld a,b    ; result exp plus bias
  ld b,0x80    ; exp bias, sign mask, most sig bit
  jp p,mdex.1    ; if over or underflow
  sub  b    ; remove excess exp bias
  ret  z    ; return if underflow
  ld (hl),a    ; result exp
  inc  hl    ; address accum sign
  ld a,(hl)
  xor c    ; result sign in sign bit
  and b    ; result sign
  ld (hl),a    ; store it
  ld a,c    ; operand sign and 1st fraction
  or b    ; operand first fraction
  ret

mdex.1:
  rlca      ; set carry bit if overflow
  ret  c
  xor a    ; clear a register
  ret      ; return if underflow

; fmu  floating point multiplication subroutine

fmu:
  ld a,(hl)    ; operand exponent
  and a
  push hl
  call nz,mdex    ; read operand
  pop hl
  jp z,zro    ; zero or underflow
  jp c,ovf    ; overflow
  call mulx    ; fixed mult
  ld a,b    ; normalize if necessary
  and a
  jp m,fpack

  ld hl,accumulator_exponent    ; dec accum exp
  dec  (hl)
  ret  z    ; underflow
  call shl_
  jp fpack

; fixed point multiply subroutine

mulx:
  ld hl,mulx.4
  ld (hl),e    ; 3rd multiplicand
  inc  hl
  ld (hl),d    ; 2nd multiplicand
  inc  hl
  ld (hl),a    ; 1st multiplicand

  xor a    ; clear 6th product
  ld e,a    ; clear 5th product
  ld d,a    ; clear 4th product

; multiply  by each accumulator fraction in turn

  ld hl,accumulator_3rd_fraction
  call mulx.2    ; multiply by accum 3rd fraction
  ld hl,accumulator_2nd_fraction
  call mulx.1    ; multiply by accum 2nd fraction
  ld hl,accumulator_1st_fraction

; multiply by one accumulator byte

mulx.1:
  ld a,d    ; 5th partial product
  ld e,c    ; 4th partial prod
  ld d,b    ; 3rd partial prod
mulx.2:
  ld b,(hl)    ; multiplier
  ld l,a    ; 5th partial prod
  xor a    ; zero a register
  ld c,a    ; 2nd partial prod
  sub  b    ; set carry bit for exit flag
  jp c,mulx.3    ; if multiplier is not zero
  ld c,d    ; 2nd partial product
  ld d,e    ; 3rd partial prod
  ret

; loop for each bit of multiplier byte

mulx.3:
  ld a,l    ; 5th partial product, exit flag
  adc  a,a    ; shift exit flag out if done
  ret  z    ; exit if multiplication done
  ld l,a    ; 5th partial prod, exit flag
  ld a,e    ; 4th partial prod
  rla      ; shift 4th partial prod
  ld e,a    ; 4th partial prod
  ld a,d    ; 3rd partial prod
  rla
  ld d,a
  ld a,c    ; 2nd partial prod
  rla
  ld c,a
  ld a,b    ; 1st partial prod and multiplier
  rla
  ld b,a
  jp nc,mulx.3  ; if no addition required

; add the multiplicand to the product if the multiplier bit is one

  ld a,(mulx.4)  ; operand 3rd fraction
  add a,e
  ld e,a    ; 4th partial prod
  ld a,(mulx.4+1)  ; operand 2nd fraction
  adc  a,d
  ld d,a    ; 3rd partial prod
  ld a,(mulx.4+2)  ; operand 1st fraction
  adc  a,c
  ld c,a    ; 2nd partial prod
  jp nc,mulx.3  ; if no carry to 1st prod
  inc  b    ; add carry to 1st prod
  and a    ; clear carry bit
  jp mulx.3

mulx.4:
  ds 3

; fdi  floating point division subroutine

fdi:
  xor a
  sub  (hl)    ; complement of divisor exponent
  cp 1    ; set carry if division by zero
  push hl
  call nc,mdex    ; read operand if not zero
  pop hl
  jp c,ovf    ; overflow or division by zero
  jp z,zro    ; underflow or zero
  ld c,a
  call divx    ; fixed division
  jp nc,ovf
  jp fpack

; fixed point divide subroutine

; subtract divisor from accum to obtain 1st remainder

divx:
  ld hl,accumulator_3rd_fraction
  ld a,(hl)    ; accum 3rd fraction
  sub  e
  ld (hl),a
  dec  hl
  ld a,(hl)    ; accum 2nd fraction
  sbc a,d
  ld (hl),a
  dec  hl
  ld a,(hl)    ; accum 1st fraction
  sbc a,c
  ld (hl),a

; halve the divisor and store for addition or subtraction

  ld a,c    ; get carry bit
  rla
  ld a,c    ; divisor 1st fraction
  rra
  ld (divx.4+3),a
  ld a,d    ; divisor 2nd fraction
  rra
  ld (divx.4+2),a
  ld a,e    ; divisor 3rd fraction
  rra
  ld (divx.4+1),a  ; 3rd subtract divisor
  ld b,0    ; init quot 1st fraction
  ld a,b    ; divisor 4th fraction is zero
  rra
  ld (divx.4),a  ; 4th subtract divisor

; load 1st remainder

  ld a,(hl)    ; 1st fraction
  inc  hl
  ld d,(hl)    ; 2nd fraction
  inc  hl
  ld e,(hl)    ; 3rd fraction

; position remainder, initialise quotient, check sign

  ex de,hl    ; remainder 3rd fraction
        ; remainder 2nd fraction
  ld e,a    ; remainder 1st fraction
  ld c,b    ; init quot 2nd fraction
  ld d,b    ; init quot 3rd fraction
  and a
  jp m,divx.3    ; if remainder is negative

; adjust exponent

  ld a,(accumulator_exponent)  ; increment quotient exp
  inc  a
  ret  z    ; overflow
  ld (accumulator_exponent),a

  inc  d    ; init quot 3rd fraction

; subtract the divisor if remainder positive

divx.1:
  push bc
  ld c,l
  ld b,h
  xor a    ; 4th fraction is zero
  ld hl,divx.4
  sub  (hl)
  ld a,c    ; 3rd fraction
  inc  hl
  sbc a,(hl)
  ld c,a
  ld a,b    ; 2nd fraction
  inc  hl
  sbc a,(hl)
  ld b,a
  ld a,e    ; 1st fraction
  inc  hl
  sbc a,(hl)
  ld e,a
  ld l,c
  ld h,b
divx.2:
  pop bc

  ld a,(divx.4)  ; remainder 4th fraction
  rlca      ; shift remainder 4th fraction to carry

; shift the remainder left one bit

  ld a,b
  rla
  ret  c    ; division complete
  rra      ; shift BCDEHL
  ld a,l
  rla
  ld l,a
  ld a,h
  rla
  ld h,a
  call shl_

; branch if subtraction is required

  ld a,d    ; quotient 3rd fraction
  rrca      ; remainder sign_ indic to carry bit
  jp c,divx.1    ; to_ sub divisor if remainder positive

; add the divisor if the remainder is negative

divx.3:
  push bc
  ld bc,divx.4+1
  ld a,(bc)    ; 3rd fraction
  add a,l
  ld l,a
  inc  bc
  ld a,(bc)    ; 2nd fraction
  adc  a,h
  ld h,a
  inc  bc
  ld a,(bc)    ; 1st fraction
  adc  a,e
  ld e,a
  jp divx.2

divx.4:
  ds float

; convert 32 bit signed integer to float
; entry - abcd (int)

flt:
  ld e,d
  ld d,c
  ld c,b
  ld b,a

; convert 32 bit signed integer to float
; entry - bc:de (int)

flt0:
  ld a,32    ; scaling factor
flt.1:
  xor 0x80    ; apply exponent bias
  ld hl,accumulator_exponent
  ld (hl),a
  inc  hl
  ld (hl),0x80  ; assume positive accum sign
  ld a,b    ; set cy if integer negative
  and a
  rla
  jp cnpack    ; complete the conversion

; convert signed integer A to float

flta:
  ld de,0
  ld c,e
  ld b,a
  ld a,8
  jp flt.1

; fix  convert float in acc to 32 bit integer
;
; exit  - abcd (int)

fix:
  ld e,32    ; scaling factor
  ld hl,accumulator_exponent
  ld a,(hl)
  and a
  jp z,zro    ; zero
  ld a,e
  add a,0x80-1    ; add bias-1
  sub  (hl)    ; shift count_ -1
  ret  c    ; accum too large
  cp 31    ; compare_ to_ large shift
  jp nc,zro    ; accum too small
  add a,1    ; shift count
  ld hl,accumulator_1st_fraction
  ld b,(hl)
  inc  hl
  ld c,(hl)
  inc  hl
  ld d,(hl)
  call shr_    ; position the fraction
  ld a,(accumulator_sign)  ; complement if negative
  and a
  call p,fcpl
  ld a,1    ; set flags
  or b
  ld a,b
  ld b,c
  ld c,d
  ld d,e
  ret

; Floor accum to integer
;
; entry - abcd
; exit  - abcd e=signed integer

flr:
  ld e,d
  cp 0x80+24
  ret  nc    ; no fraction
flr.1:
  ld e,a
  ld a,0x80    ; unpack b
  or b
  ld b,a
  ld a,(accumulator_sign)
  rla
  push af
  jp c,flr.3    ; positive
  ld a,d    ; decr bcd
  or a
  jp nz,flr.2
  dec  bc
flr.2:
  dec  d
flr.3:
  ld a,0x80+24
  sub  e
  call shr_
  pop af
  call nc,rondr.1  ; incr bcd
  ld a,0x80+24
  ld (accumulator_exponent),a
  ld a,d
  jp c,flr.4
  cpl
  inc  a
flr.4:
  push af
  ld e,0
  call npack    ; normalise and pack
  pop hl
  ld e,h
  ret

; Round accum to integer

rnd:
  call tstr
  call m,chss
  cp 0x80+24
  ret  nc    ; no fraction
  ld hl,fp50    ; 0.5
  call fad
  jp flr.1

; FABS  ( r1 -- r2 )

  _header _public,'FABS'
f_abs_:
  call ldop
  call fab
  jp svop

; FNEGATE  ( r1 -- r2 )

  _header _public,'FNEGATE'
fneg_:
  call ldop
  call chs
  jp svop

; D>F  ( d -- r )

  _header _public,'D>F'
d_to_f_:
  pop hl
  pop de
  push bc
  ld c,l
  ld b,h
  call flt0
  jp svop

; F>D  ( r -- d )

  _header _public,'F>D'
f_to_d_:
  call ldop
  call fix
  ld e,d
  ld d,c
  ld l,b
  ld h,a
  pop bc
  jp push_de_hl

; S>F  ( n -- r )
;   s>d d>f

  _header _public,'S>F'
s_to_f_:
  call do_colon
  dw s_to_d_,d_to_f_
  dw paren_exit_

; F>S  ( r -- n )
;   f>d d>s

  _header _public,'F>S'
f_to_s_:
  call do_colon
  dw f_to_d_,d_to_s_
  dw paren_exit_

; F0=  ( r -- flag )

  _header _public,'F0='
f_zero_equals_:
  pop hl
  ld h,l
  ex (sp),hl
  jp zero_equals_

; F=  ( r1 r2 -- flag )

  _header _public,'F='
f_equals_:
  call ld2op
  call fcmp
  pop bc
  jp nz,false_
  jp true_

; F0<  ( r -- flag )

  _header _public,'F0<'
f_zero_less_:
  pop hl
  pop de
  ld a,l
  or a
  jp z,false_    ; zero
  ld a,h
  rla
  jp c,true_    ; negative
  jp false_

; F<  ( r1 r2 -- flag )

  _header _public,'F<'
f_less_:
  call ld2op
  call fcmp
  pop bc
  jp m,true_
  jp false_

; F0>  ( r -- flag )

  _header _public,'F0>'
f_zero_greater_:
  call ldop
f_zero_greater_.1:
  pop bc
  jp z,false_
  jp m,false_
  jp true_

; F>  ( r1 r2 -- flag )

  _header _public,'F>'
f_greater_:
  call ld2op
  call fcmp
  jp f_zero_greater_.1

; FMIN  ( r1 r2 -- r1 | r2 )
;   fover fover f< 0= if fswap then fdrop

  _header _public,'FMIN'
f_min_:
  call ld2op
  push hl
  call fcmp
  pop hl
  call p,lod    ; r1 >= r2
  jp svop

; FMAX  ( r1 r2 -- r1 | r2 )
;   fover fover f< if fswap then fdrop

  _header _public,'FMAX'
f_max_:
  call ld2op
  push hl
  call fcmp
  pop hl
  call m,lod    ; r1 < r2
  jp svop

; FLOOR  ( r1 -- r2 )

  _header _public,'FLOOR'
floor_:
  call ldop
  call flr
  jp svop

; FROUND  ( r1 -- r2 )

  _header _public,'FROUND'
f_round_:
  call ldop
  call rnd
  jp svop

; F+  ( r1 r2 -- r3 )

  _header _public,'F+'
f_plus_:
  call ld2op
  call fad
  jp svop

; F-  ( r1 r2 -- r3 )

  _header _public,'F-'
f_minus_:
  call ld2op
  call fsu
  jp svop

; F*  ( r1 r2 -- r3 )

  _header _public,'F*'
f_star_:
  call ld2op
  call fmu
  jp svop

; F/  ( r1 r2 -- r3 )

  _header _public,'F/'
f_slash_:
  call ld2op
  call fdi
  jp svop

; FRANDOM  ( r1 -- r2 )

  _header _public,'FRANDOM'
f_random_:
  call ldop
  jp m,f_random_.1    ; seed generator
  push af
  ld hl,f_random_.4
  call lod
  ld e,a
  pop af
  ld a,e
  jp z,svop    ; return_ last_ value
  ld hl,f_random_.2  ; get next value
  call fmu
  ld hl,f_random_.3
  call fad
f_random_.1:
  ld hl,accumulator_3rd_fraction
  ld b,(hl)    ; swap_ msb lsb
  dec  hl
  ld c,(hl)
  dec  hl
  ld d,(hl)
  dec  hl
  ld (hl),0x80  ; make positive
  dec  hl
  ld e,(hl)
  ld (hl),0x80  ; fix exponent
  call npack    ; normalise
  ld hl,f_random_.4
  call str
  jp svop

f_random_.2:
  db 0x98,0x35,0x44,0x7A
f_random_.3:
  db 0x68,0x28,0xB1,0x46
f_random_.4:
  db 0x80,0x31,0x41,0x59    ; seed

finstr:
  ds 3  ; string address, count
finsgn:
  ds 1  ; sign
finpt:
  ds 1  ; decimal_ point flag
finexp:
  ds 1  ; decimal_ exponent
fincvt:
  ds 1  ; converted digits

; fin  convert character string to float
; entry - hl=adr, a=len
; exit  - result in accum, cy=error

fin:
  dec  hl    ; init string adr, count
  ld (finstr),hl
  inc  a
  ld (finstr+2),a

  ld a,0x80    ; set sign_ positive
  ld (finsgn),a
  xor a
  ld (finpt),a  ; clear decimal_ point flag
  ld (finexp),a  ; set decimal_ exponent = 0
  ld (fincvt),a  ; zero_ converted digits
  ld (accumulator_exponent),a  ; zero accum

  call fin.17    ; get 1st char
  jp z,fin.14    ; treat zero length as zero blanks

  cp ' '
  jp nz,fin.2
fin.1:
  call fin.17    ; treat all blanks as zero
  jp z,fin.14
  cp ' '
  jp z,fin.1
  scf
  ret

fin.2:
  cp '+'    ; check for sign
  jp z,fin.3
  cp '-'
  jp nz,fin.4
  xor a    ; set negative flag
  ld (finsgn),a
fin.3:
  call fin.17    ; get char after sign
  scf
  ret  z    ; none

fin.4:
  cp '.'    ; check for decimal point
  jp nz,fin.7
  ld hl,finpt
  xor (hl)
  ld (hl),a
  jp nz,fin.8
fin.5:
  scf      ; 2nd decimal point
  ret

fin.6:
  ld a,(fincvt)
  or a
  jp z,fin.5
  jp fin.14

; process char

fin.7:
  call fin.18    ; convert char to digit
  ret  c    ; bad

  ld hl,fincvt
  inc  (hl)
  push af
  ld hl,fp10    ; mult old value by 10
  call fmu
  call savf.1
  pop af    ; convert digit to floating point
  call flta
  ld hl,float_tmp_1    ; add to old value
  call fad

  ld a,(finpt)  ; if decimal point
  and a
  jp z,fin.8
  ld hl,finexp  ; decrement exponent
  dec  (hl)

; get next char

fin.8:
  ld b,0    ; zero exponent
  call fin.17
  jp z,fin.6    ; done

; check for exponent

  cp '+'
  jp z,fin.10
  cp '-'
  jp z,fin.10
  call toupper_.a
  cp 'E'
  jp z,fin.9
  cp 'D'
  jp nz,fin.4

; process exponent

fin.9:
  call fin.17    ; next char
  jp z,fin.6    ; done

fin.10:
  ld b,a    ; save 1st char
  sub  '-'    ; compare minus sign
  ld e,a
  jp z,fin.11
  add a,'-'-'+'  ; compare plus sign
  ld a,b
  jp nz,fin.12

fin.11:
  call fin.17    ; got sign_, get 1st digit

fin.12:
  ld b,0    ; possible decimal exponent
  jp z,fin.6    ; none - assume zero exponent

fin.13:
  call fin.18
  ret  c    ; not digit
  ld c,a    ; accumulate exponent
  ld a,b
  add a,a
  add a,a
  add a,b
  add a,a
  add a,c
  ld b,a
  call fin.17    ; get next
  jp nz,fin.13

  ld a,e    ; test exponent sign
  and a
  jp nz,fin.14
  sub  b    ; complement if neg
  ld b,a

fin.14:
  ld a,(finsgn)  ; store accum sign
  ld (accumulator_sign),a

; adjust exponent

  ld a,b
fin.15:
  ld hl,finexp
  add a,(hl)
  jp z,tst    ; done
  ld (hl),a
  ld hl,fp10
  jp p,fin.16
  call fdi    ; div by 10
  ld a,1
  jp fin.15

fin.16:
  call fmu    ; mul by 10
  ret  c    ; overflow
  ld a,0xFF
  jp fin.15

; get next char, return z if end reached

fin.17:
  ld hl,finstr+2
  dec  (hl)
  ld hl,(finstr)
  inc  hl
  ld (finstr),hl
  ld a,(hl)
  ret

; convert ascii char (a) to digit, return cy if not in range 0-9

fin.18:
  sub  '0'
  ret  c
  cp 10
  ccf
  ret

; >FLOAT  ( ca len -- r true | false )

  _header _public,'>FLOAT'
to_float_:
  pop hl
  ld a,l    ; assume u <= 255
  pop hl
  push bc
  call fin
  ld e,c
  ld h,b
  ld l,a
  pop bc
  jp c,false_
  push de
  push hl
  jp true_

  _header _public,'MAX-PRECISION'
max_precision_:
  call do_byte_constant    ; max precision
  db max_significant_digits

  _header _hidden,'EXSN'
exsn_:
  call do_create    ; exponent, sign
  ds 2*cell

; REPRESENT  ( r ca n -- exp sign flag )
;
;        2dup max-precision max [char] 0 fill
;        max-precision min 2>r fdup f0< 0 exsn 2!
;        fabs fdup f0= 0= if begin fdup 1.0e f<
;        0= while 10.0e f/ 1 exsn +! repeat begin
;        fdup 0.1e f< while 10.0e f* -1 exsn +!
;        repeat then r@ 0 max 0 ?do 10.0e f* loop
;        fround f>d 2dup <# #s #> dup r@ - exsn +!
;        2r> rot min 1 max cmove d0= if 1 0 else
;        exsn 2@ swap then true

  _header _public,'REPRESENT'
represent_:
  call do_colon
  dw two_dup_
  dw max_precision_,max_
  dw c_lit_
  db '0'
  dw fill_
  dw max_precision_,min_
  dw two_to_r_
  dw f_dup_,f_zero_less_
  dw zero_,exsn_,two_store_
  dw f_abs_
  dw f_dup_,f_zero_equals_
  dw zero_equals_
  dw question_branch_,represent_.3
represent_.1:
  dw f_dup_    ; begin
  dw f_lit_
  db 0x81,0,0,0
  dw f_less_,zero_equals_
  dw question_branch_,represent_.2  ; while
  dw f_ten,f_slash_
  dw one_,exsn_,plus_store_
  dw branch_,represent_.1  ; repeat
represent_.2:
  dw f_dup_    ; begin
  dw f_lit_
  db 0x7D,0x4C,0xCC,0xCD
  dw f_less_
  dw question_branch_,represent_.3  ; while
  dw f_ten,f_star_
  dw true_,exsn_,plus_store_
  dw branch_,represent_.2  ; repeat
represent_.3:
  dw r_fetch_
  dw zero_,max_,zero_
  dw paren_question_do_,represent_.5
represent_.do:
  dw f_ten,f_star_
  dw paren_loop_,represent_.do
represent_.5:
  dw f_round_,f_to_d_
  dw two_dup_
  dw less_number_sign_,number_sign_s_,number_sign_greater_
  dw dup_
  dw r_fetch_,minus_  ; handle overflow
  dw exsn_,plus_store_
  dw two_from_r_
  dw rot_,min_
  dw one_,max_
  dw cmove_
  dw d_zero_equals_
  dw question_branch_,represent_.6
  dw one_,zero_  ; 0.0E fixup
  dw branch_,represent_.7
represent_.6:
  dw exsn_,two_fetch_
  dw swap_
represent_.7:
  dw true_
  dw paren_exit_

; PRECISION  ( -- u )

  _header _public,'PRECISION'
precision_:
  call do_value
  dw max_significant_digits    ; default

; SET-PRECISION  ( u -- )
;   1 max max-precision min to precision

  _header _public,'SET-PRECISION'
set_precision_:
  call do_colon
  dw one_,max_
  dw max_precision_,min_
  dw paren_to_,precision_
  dw paren_exit_

; FDP  ( -- a )

  _header _public,'FDP'
fdp_:
  call do_create    ; decimal point display
  dw -1    ; set by FINIT
  ds 2

  _header _hidden,'FBUF'
fbuf_:
  call do_create    ; fp string buffer
  ds max_significant_digits

  _header _hidden,'EX#'
exn_:
  call do_value    ; exponent
  ds cell

  _header _hidden,'SN#'
snn_:
  call do_value    ; sign
  ds cell

  _header _hidden,'EF#'
efn_:
  call do_value    ; exponent factor
  ds cell

  _header _hidden,'PL#'
pln_:
  call do_value    ; places after decimal point
  ds cell

; (F1)  ( r -- r exp )
;        fdup fbuf max-precision represent 2drop

  _header _hidden,'(F1)'  ; get exponent
paren_f1_:
  call do_colon
  dw f_dup_
  dw fbuf_,max_precision_
  dw represent_,two_drop_  ; never error
  dw paren_exit_

; (F2)  ( exp -- offset exp' )
;   s>d ef# fm/mod ef# *

  _header _hidden,'(F2)'  ; apply exponent factor
paren_f2_:
  call do_colon
  dw s_to_d_
  dw efn_,fm_slash_mod_
  dw efn_,star_
  dw paren_exit_

; (F3)  ( r places -- ca len )
;                               dup to pl# 0< if precision else (f1) ef# 0>
;                               if 1- (f2) drop 1+ then pl# + max-precision
;                               min then fbuf swap represent drop to sn# to
;                               ex# fbuf max-precision -trailing <# ;

  _header _hidden,'(F3)'  ; float to ascii
paren_f3_:
  call do_colon
  dw dup_
  dw paren_to_,pln_
  dw zero_less_
  dw question_branch_,paren_f3_.1
  dw precision_
  dw branch_,paren_f3_.3
paren_f3_.1:
  dw paren_f1_
  dw efn_,zero_greater_
  dw question_branch_,paren_f3_.2
  dw one_minus_
  dw paren_f2_,drop_
  dw one_plus_
paren_f3_.2:
  dw pln_,plus_
  dw max_precision_,min_
paren_f3_.3:
  dw fbuf_,swap_
  dw represent_
  dw drop_    ; never error
  dw paren_to_,snn_
  dw paren_to_,exn_
  dw fbuf_
  dw max_precision_
  dw minus_trailing_
  dw less_number_sign_
  dw paren_exit_

; (F4)  ( exp -- )
;   pl# 0< >r dup abs s>d r@ 0= if # then #s
;        2drop dup sign 0< r> d0= if [char] + hold
;        then [char] E hold

  _header _hidden,'(F4)'  ; insert exponent
paren_f4_:
  call do_colon
  dw pln_,zero_less_
  dw to_r_
  dw dup_
  dw abs_,s_to_d_
  dw r_fetch_,zero_equals_
  dw question_branch_,paren_f4_.1
  dw number_sign_
paren_f4_.1:
  dw number_sign_s_
  dw two_drop_
  dw dup_,sign_
  dw zero_less_
  dw from_r_
  dw d_zero_equals_
  dw question_branch_,paren_f4_.2
  dw c_lit_
  db '+'
  dw hold_
paren_f4_.2:
  dw c_lit_
  db 'E'
  dw hold_
  dw paren_exit_

; (F5)  ( n -- +n|0 )
;   0max dup fdp 2+ +!

  _header _hidden,'(F5)'  ; conditionally set flag
paren_f5_:
  call do_colon
  dw zero_max_
  dw dup_
  dw fdp_,two_plus_
  dw plus_store_
  dw paren_exit_

; (F6)  ( ca len -- )
;   (f5) shold

  _header _hidden,'(F6)'  ; insert string
paren_f6_:
  call do_colon
  dw paren_f5_,s_hold_
  dw paren_exit_

; (F7)  ( n -- )
;   (f5) [char] 0 nhold

  _header _hidden,'(F7)'  ; insert '0's
paren_f7_:
  call do_colon
  dw paren_f5_
  dw c_lit_
  db '0'
  dw n_hold_
  dw paren_exit_

; (F8)  ( -- )
;   sn# sign 0 0 #>

  _header _hidden,'(F8)'  ; insert sign
paren_f8_:
  call do_colon
  dw snn_,sign_
  dw zero_,zero_
  dw number_sign_greater_
  dw paren_exit_

; (F9)  ( ca len1 -- ca len2 )
;        pl# 0< if begin dup while 1- 2dup
;        + c@ [char] 0 - until 1+ then then

  _header _hidden,'(F9)'  ; trim trailing '0's
paren_f9_:
  call do_colon
  dw pln_,zero_less_
  dw question_branch_,paren_f9_.end
paren_f9_.1:
  dw dup_
  dw question_branch_,paren_f9_.end
  dw one_minus_,two_dup_
  dw plus_,c_fetch_
  dw c_lit_
  db '0'
  dw minus_
  dw question_branch_,paren_f9_.1
  dw one_plus_
paren_f9_.end:
  dw paren_exit_

; (FA)  ( u1 -- u1 u2 )
;   pl# 0< if dup else pl# then

  _header _hidden,'(FA)'
paren_fa_:
  call do_colon
  dw pln_,zero_less_
  dw question_branch_,paren_fa_.1
  dw dup_
  dw branch_,paren_fa_.end
paren_fa_.1:
  dw pln_
paren_fa_.end:
  dw paren_exit_

; (FB)  ( ca len n -- )
; insert fraction n places right of dec. pt
;
;   fdp cell+ off >r (f9) r@ + (fa) over -
;        (f7) (fa) min r@ - (f6) r> (fa) min (f7)
;        fdp 2@ or if [char] . hold then

  _header _hidden,'(FB)'
paren_fb_:
  call do_colon
  dw fdp_,two_plus_
  dw off_
  dw to_r_
  dw paren_f9_
  dw r_fetch_,plus_
  dw paren_fa_
  dw over_,minus_
  dw paren_f7_
  dw paren_fa_,min_
  dw r_fetch_,minus_
  dw paren_f6_
  dw from_r_
  dw paren_fa_,min_
  dw paren_f7_
  dw fdp_,two_fetch_,or_
  dw question_branch_,paren_fb_.end
  dw c_lit_
  db '.'
  dw hold_
paren_fb_.end:
  dw paren_exit_

; (FC)  ( ca len n -- )
; split into int/frac and insert
;        >r 2dup r@ min 2swap r> /string 0 (fb) (f6)

  _header _hidden,'(FC)'
paren_fc_:
  call do_colon
  dw to_r_
  dw two_dup_
  dw r_fetch_,min_
  dw two_swap_
  dw from_r_,slash_string_
  dw zero_,paren_fb_
  dw paren_f6_
  dw paren_exit_

; (FD)  ( r n factor -- ca len )
; exponent form
;        to ef# (f3) ex# 1- (f2) (f4) 1+ (fc) (f8)

  _header _hidden,'(FD)'
paren_fd_:
  call do_colon
  dw paren_to_,efn_
  dw paren_f3_
  dw exn_,one_minus_
  dw paren_f2_
  dw paren_f4_
  dw one_plus_,paren_fc_
  dw paren_f8_
  dw paren_exit_

; (FS.)  ( r n -- ca len )
;   1 (fd)

  _header _public,'(FS.)'
paren_fs_dot_:
  ld hl,1
  push hl
  jp paren_fd_

; FS.R  ( r n1 n2 -- )
;        >r (fs.) r> s.r

  _header _public,'FS.R'
fs_dot_r_:
  call do_colon
  dw to_r_
  dw paren_fs_dot_
  dw branch_,d_dot_r_.1

; FS.  ( r -- )
;   -1 0 fs.r space

  _header _public,'FS.'
fs_dot_:
  call do_colon
  dw true_
  dw zero_,fs_dot_r_
  dw space_
  dw paren_exit_

if  floating_point_engineering_output?

; (FE.)  ( r -- ca len )
;   3 (fd)

  _header _public,'(FE.)'
paren_fe_dot_:
  ld hl,3
  push hl
  jp paren_fd_

; FE.R  ( r n1 n2 -- )
;   >r (fe.) r> s.r

  _header _public,'FE.R'
fe_dot_r_:
  call do_colon
  dw to_r_
  dw paren_fe_dot_
  dw branch_,d_dot_r_.1

; FE.  ( r -- )
;   -1 0 fe.r space

  _header _public,'FE.'
fe_dot_:
  call do_colon
  dw true_
  dw zero_,fe_dot_r_
  dw space_
  dw paren_exit_

endif ; floating_point_engineering_output?

; (F.)  ( r n -- ca len )
;        0 to ef# (f3) ex# dup max-precision > if
;        fbuf 0 0 (fb) max-precision - (f7) (f6)
;        else dup 0> if (fc) else abs (fb) 1 (f7)
;        then then (f8)

  _header _public,'(F.)'
paren_f_dot_:
  call do_colon
  dw zero_
  dw paren_to_,efn_
  dw paren_f3_
  dw exn_,dup_
  dw max_precision_,greater_
  dw question_branch_,paren_f_dot_.1  ; if
  dw fbuf_,zero_
  dw zero_,paren_fb_
  dw max_precision_,minus_
  dw paren_f7_
  dw paren_f6_
  dw branch_,paren_f_dot_.3  ; else
paren_f_dot_.1:
  dw dup_,zero_greater_
  dw question_branch_,paren_f_dot_.2
  dw paren_fc_
  dw branch_,paren_f_dot_.3  ; else
paren_f_dot_.2:
  dw abs_
  dw paren_fb_
  dw one_,paren_f7_
paren_f_dot_.3:
  dw paren_f8_    ; then then
  dw paren_exit_

; F.R  ( r n1 n2 -- )
;   >r (f.) r> s.r

  _header _public,'F.R'
f_dot_r_:
  call do_colon
  dw to_r_
  dw paren_f_dot_
  dw branch_,d_dot_r_.1

; F.  ( r -- )
;   -1 0 f.r space

  _header _public,'F.'
f_dot_:
  call do_colon
  dw true_
  dw zero_,f_dot_r_
  dw space_
  dw paren_exit_

; (G.)  ( r n -- ca len )
;   >r (f1) -3 7 within  r> swap if (f.) else
;        (fs.) then

  _header _public,'(G.)'
paren_g_dot_:
  call do_colon
  dw to_r_
  dw paren_f1_
  dw lit_,-3
  dw c_lit_
  db 7
  dw within_
  dw from_r_,swap_
  dw question_branch_,paren_g_dot_.1  ; if
  dw paren_f_dot_
  dw branch_,paren_g_dot_.end  ; else
paren_g_dot_.1:
  dw paren_fs_dot_
paren_g_dot_.end:
  dw paren_exit_    ; then

; G.R  ( r n1 n2 -- )
;   >r (g.) r> s.r

  _header _public,'G.R'
g_dot_r_:
  call do_colon
  dw to_r_,paren_g_dot_
  dw branch_,d_dot_r_.1

; G.  ( r -- )
;   -1 0 g.r space

  _header _public,'G.'
g_dot_:
  call do_colon
  dw true_
  dw zero_,g_dot_r_
  dw space_
  dw paren_exit_

;  sqr

sqr:
  call tstr
  ret  z    ; zero
  jp m,ovf    ; neg
  call savf.1
  and a
  rra
  add a,0x40
  call savf.2
  ld d,5
sqr.1:
  push de
  call lodf.1
  ld hl,float_tmp_2
  call fdi
  ld hl,float_tmp_2
  call fad
  sub  1
  call savf.2
  pop de
  dec  d
  jp nz,sqr.1
  ld hl,float_tmp_2
  jp lod

;  poly

poly:
  push hl
  call savf.1
  pop hl
  ld a,(hl)
  ld (poly.3),a
  inc  hl
  push hl
  call lod
  jp poly.2

poly.1:
  ld hl,poly.3
  dec  (hl)
  pop hl
  ret  z
  push hl
  ld hl,float_tmp_1
  call fmu
  pop hl
  push hl
  call fad
poly.2:
  pop hl
  inc  hl
  inc  hl
  inc  hl
  inc  hl
  push hl
  jp poly.1

poly.3:
  ds 1

;  polx

polx:
  push hl
  call savf.2
  ld hl,float_tmp_2
  call fmu
  pop hl
  call poly
  ld hl,float_tmp_2
  jp fmu

;  exp

exp:
  ld hl,ln2
  call fdi
  cp 0x88
  jp nc,ovf
  cp 0x68
  ld hl,fp1
  jp c,lod
  call savf.2
  call flr
  call savf.1
  ld a,e
  add a,0x81
  jp z,exp.1
  push af
  call lodf.2
  ld hl,float_tmp_1
  call fsu
  ld hl,exp.4
  call poly
  pop af
  ld bc,0
  ld d,b
  call savf.1
  ld hl,float_tmp_1
  jp fmu

exp.1:
  call tst
  jp m,zro
  jp ovf

exp.4:
  db 7
  db 0x74,0x59,0x88,0x7C
  db 0x77,0x26,0x97,0x00E0
  db 0x7A,0x1E,0x1D,0xC4
  db 0x7C,0x63,0x50,0x5E
  db 0x7E,0x75,0xFE,0x1A
ln2:
  db 0x80,0x31,0x72,0x18    ; ln2
fp1:
  db 0x81,0,0,0    ; 1.0

;  log

log:
  call tstr
  jp m,ovf    ; neg
  jp z,ovf    ; zero
  xor 0x80
  push af
  ld a,0x80
  ld hl,log.2
  call poly
  call savf.1
  pop af
  call flta
  ld hl,float_tmp_1
  call fad
  ld hl,ln2
  jp fmu

log.2:
  db 9
  db 0x82,0x94,0xEE,0xD8
  db 0x84,0x7D,0xAA,0xA9
  db 0x86,0xBF,0x99,0x7D
  db 0x87,0x28,0xE5,0x7B
  db 0x87,0x00C0,0x71,0x8A
  db 0x87,0x14,0x95,0x6E
  db 0x86,0x00A0,0x1E,0xB2
  db 0x85,0x02,0x7A,0xAD
  db 0x83,0x8D,0x9D,0x09

;  sin / cos

cos:
  ld hl,fpi.2
  call fad
sin:
  or a
  ret  z
  cp 0x80+25
  jp nc,ovf
  ld hl,f2pi
  call fdi
  call savf.1
  call flr
  or a
  push af
  ld hl,float_tmp_2
  call nz,str
  call lodf.1
  pop af
  ld hl,float_tmp_2
  call nz,fsu
  ld hl,fp25    ; 0.25
  call fsu
  push af
  jp m,sin.1
  ld hl,fp50    ; 0.5
  call fsu
  call p,chs
sin.1:
  ld hl,fp25    ; 0.25
  call fad
  ld e,a
  pop af
  ld a,e
  call p,chs
  ld hl,sin.7
  jp polx

sin.7:
  db 5
  db 0x86,0x1E,0xD7,0xFB
  db 0x87,0x99,0x26,0x64
  db 0x87,0x23,0x34,0x58
  db 0x86,0xA5,0x5D,0xE1
f2pi:
  db 0x83,0x49,0x0F,0xDB ; 2pi

fpi.2:
  db 0x81,0x49,0x0F,0xDB ; pi/2

fp50:
  db 0x80,0,0,0  ; 0.5
fp25:
  db 0x7F,0,0,0  ; 0.25

;  atan

atan:
  call tstr
  call m,chss    ; make positive
  cp 0x81
  jp c,atan.1    ; < 1
  ld hl,atan.3
  push hl
  call savf.1
  ld hl,fp1
  call lod
  ld hl,float_tmp_1
  call fdi
atan.1:
  ld hl,atan.9
  call fcmp
  jp m,atan.2
  ld hl,atan.4
  push hl
  call savf.1
  ld hl,atan.7
  call fad
  ld hl,atan.11
  call str
  call lodf.1
  ld hl,atan.6
  call poly
  ld hl,atan.11
  call fdi
atan.2:
  ld hl,atan.8
  jp polx

atan.3:
  ld hl,fpi.2
  call fsu
  jp chs

atan.4:
  ld hl,atan.10
  jp fad

atan.6:
  db 2
atan.7:
  db 0x81,0x5D,0xB3,0xD7
  db 0x81,0x80,0,0    ; -1.0

atan.8:
  db 4
  db 0x7E,0x83,0x35,0x62
  db 0x7E,0x4C,0x24,0x50
  db 0x7F,0xAA,0xA9,0x79
  db 0x81,0,0,0

atan.9:
  db 0x7F,0x09,0x38,0xA3
atan.10:
  db 0x80,0x06,0x0A,0x92

atan.11:
  ds float

; FSQRT  ( r1 -- r2 )

  _header _public,'FSQRT'
fsqr_:
  call ldop
  call sqr
  jp svop

; FEXP  ( r1 -- r2 )

  _header _public,'FEXP'
f_exp_:
  call ldop
  call exp
  jp svop

; FLN  ( r1 -- r2 )

  _header _public,'FLN'
f_ln_:
  call ldop
  call log
  jp svop

; F**  ( r1 r2 -- r3 )
;   fswap fln f* fexp

  _header _public,'F**'
f_star_star_:
  call do_colon
  dw f_swap_,f_ln_
  dw f_star_,f_exp_
  dw paren_exit_

; FSIN  ( r1 -- r2 )

  _header _public,'FSIN'
f_sin_:
  call ldop
  call sin
  jp svop

; FCOS  ( r1 -- r2 )

  _header _public,'FCOS'
f_cos_:
  call ldop
  call cos
  jp svop

; FATAN  ( r1 -- r2 )

  _header _public,'FATAN'
f_atan_:
  call ldop
  call atan
  jp svop

; PI  ( -- r )

  _header _public,'PI'
f_pi_:
  call do_f_constant
  db 0x82,0x49,0x0F,0xDB  ; pi

; FINIT  ( -- )
;   max-precision set-precision fdp on

  _header _hidden,'FINIT'
f_init_:
  call do_colon
  dw max_precision_,set_precision_
  dw fdp_,on_
  dw paren_exit_

; FIDENTIFY  ( -- )

  _header _hidden,'FIDENTIFY'
f_identify_:
  call do_colon
  dw paren_dot_quote_
  db f_identify_.end-$-1
  db 'Software floating-point ('
  if  floating_point_stack?
    db 'separate'
  else
    db 'common'
  endif
  db ' stack)'
f_identify_.end:
  dw paren_exit_

; FNUMBER  ( ca len -- [r] flag )
;        2dup s" E" caps search -rot 2drop decimal?
;        and if >float else 2drop 0 then dup >r
;        state? and if postpone fliteral then r>

  _header _hidden,'FNUMBER'
f_number_:
  call do_colon
  dw two_dup_    ; scan 'E'
  dw paren_s_quot_
  _dcs 'E'
  if  case_insensitive_names?
    ; XXX FIXME -- the logic is wrong, because conditional compilation
    ; sets a user variable to be modifed.
    ;; dw caps ; XXX OLD
    dw case_sensitive_search_,off_ ; XXX NEW
  endif
  dw search_
  dw minus_rot_,two_drop_
  dw decimal_question_ ; decimal base?
  dw and_
  dw question_branch_,f_number_.2
f_number_.1:
  dw to_float_
  dw branch_,f_number_.3
f_number_.2:
  dw two_drop_,zero_
f_number_.3:
  dw dup_,to_r_
  dw compiling_question_
  dw and_
  dw question_branch_,f_number_.4
  dw f_literal_
f_number_.4:
  dw from_r_
  dw paren_exit_

; (-FP)  ( -- )
;        :noname ['] noop dup (dofinitpatch) ! (dofidentifypatch) !
;        ['] false (interpret.fnumberpatch) ! (nfps) off (nfpm) off
;        ; remember
;        XXX OLD -- needed?

  ; _header _hidden,'(-FP)'
; paren_minus_fp_:
  ; ld hl,noop_
  ; ld (do_f_init_patch),hl    ; INIT
  ; ld (do_f_identify_patch),hl    ; INDENTIFY
  ; ld hl,false_
  ; ld (interpret_.f_number),hl    ; FNUMBER
; ;  ld hl,0
; ;  ld (nfps),hl
; ;  ld (nfpm),hl
  ; jp next

; paren_minus_fp_.1:
;   dw 0    ; link
;   dw paren_minus_fp_    ; xt

  endif ; floating_point?

; }}} **********************************************************
; End {{{

; XXX TODO it seems these 'last' labels could be renamed
; to 'top' instead:

top_nfa:  equ last_nfa   ; nfa of top word in FORTH vocabulary
top_xt:   equ last_xt   ; xt of top word in FORTH vocabulary ; XXX OLD -- not used

init_dp:   equ $

  end start
