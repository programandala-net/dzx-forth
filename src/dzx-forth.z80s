; DZX-Forth {{{

version: macro
  db 'A-01-201501132017'
  endm
  version.major: equ "A" ; alpha branch_
  version.minor: equ 01

; A direct-threaded Forth for ZX Spectrum
;
; (Project under development)
;
; DZX-Forth is a fork of CP/M DX-Forth v4.09 (2014-12)

; Copyright (C) 2014,2015 Marcos Cruz (programandala.net)
;
; DZX-Forth is free software; you can redistribute it and/or modify it under
; the terms of the GNU General Public License as published by the Free Software
; Foundation; either version 3 of the License, or (at your option) any later
; version.
;
; DZX-Forth is distributed in the hope that it will be useful, but WITHOUT ANY
; WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
; A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License along with
; DZX-Forth; if not, see <http://gnu.org/licenses>.

; 2014-11-03: Start.
; 2014-12-13: Version A-01.

; ------------------------------
; XXX TODO 

; 2015-01-12: implement 'allocate' in the ram disk?
;
; 2015-01-12: use 'throw' with Forth-94 codes instead of '(abort")'
;
; Fix the missing 'cr' after errors; it was removed from 'quit'. Where should it be?
;
; Rename the 'header' word to '(header)' and the 'hdr' macro to 'header'
;
; Check problems with backspace (char 8), depending on the ZX Spectrum ROM.
;
; See: "Programaci√≥n en Ensamblador", by Tony Woods, p. 168, ROM routines.

; }}} **********************************************************
; Labels {{{

no:     equ 0
yes:    equ not no

; Modification level
; XXX OLD
;;rel:  equ 4 ; release #
;;rev:  equ 00  ; revision #
;;beta: equ no  ; beta release

; ------------------------------
; Conditional assembly

debug:                            equ no ; debugging messages?
case_insensitive_names:           equ yes
control_flow_stack_extensions:    equ yes
warning_options:                  equ no ; XXX TODO does_ this causes trouble?

; XXX FIXME when yes, some things don't work fine:
size_optimization:                equ no ; if yes, the code will be smaller but slower

floored_division:                 equ no  ; integer division method
floating_point_support:           equ yes
fp_engineering_output_functions:  equ yes
separated_f_stack:                equ no ; XXX TODO -- not fully implemented in DX-Forth_

classic_Forth_behaviours:         equ no
tib_words:                        equ yes ; include the obsolescent words 'tib' and '#tib'?

fast_emit:                        equ yes ; if yes, 'space' and 'cr' jump directly into '(emit_)', don't call 'emit'

; ------------------------------
; Config

max_open_source_files:  equ 6  ; (min_ = 2)
max_open_file_handles:  equ 16 ; (0..15)
top_prunes:             defl 0 ; XXX OLD ?

; ------------------------------
; Memory 

start: equ 24000 ; start of_ DZX-Forth_ in memory

cw: equ 2 ; cell size (bytes)
fw: equ 4 ; floating point number size (bytes)

; ------------------------------
; Buffer sizes

; XXX TODO Convert stack sizes to user variables? The point is
; a task could need just a little stack.

filename_size:                equ 16+1  ; XXX TODO why 16 in CP/M? ("ud:nnnnnnnn.eee"=15)
file_descriptor_size:         equ filename_size+(4*cw)  ; XXX OLD?
block_size:                   equ 1024
file_handle_size:             equ 6+36  ; (keep even) ; XXX OLD?
parsed_string_buffer_size:    equ 255
pictured_numeric_buffer_size: equ 68
stack_size:                   equ 256
return_stack_size:            equ 256
tib_size:                     equ 80    ; Terminal Input Buffer_
user_data_size:               equ 128
word_buffer_size:             equ 31+5

; ------------------------------
; Blocks

block_updated_mask: equ 0x8000
block_number_mask:  equ 0x7fff

; ------------------------------
; DOS ; XXX OLD

;;dosfcb: equ 0x005c   ; default file control block
;;dosbuf: equ 0x0080   ; default DTA and command-line buffer
recsiz: equ 128   ; CP/M record size

; ------------------------------
; Floating point

f_init_patch:     defl noop_
f_identify_patch: defl noop_
f_number_patch:   defl false_
f_stack_items:    defl 0
f_stack_size:     defl 0 ; bytes

  if floating_point_support

    maxsig: equ 7 ; max_ significant digits

    f_init_patch:     defl f_init_
    f_identify_patch: defl f_identify_
    f_number_patch:   defl f_number_

    if separated_f_stack
      f_stack_items: defl 6
      f_stack_size:  defl (f_stack_items+5)*fw ; allow extra for fp display etc
    endif

    top_prunes: defl paren_minus_fp_.1

  endif

; ------------------------------
; ZX Spectrum

  include "zx_spectrum_system_variables.z80s"
  include "zx_spectrum_rom_routines.z80s"
  include "zx_spectrum_char_codes.z80s"
  include "zx_spectrum_colors.z80s"
  include "zx_spectrum_+3dos.z80s"

bank1_port: equ 0x07FFD ; "horizontal" and RAM switch port
bank2_port: equ 0x01FFD ; "vertical" switch port

lf_char:                    equ 0x0a ; line feed ; XXX OLD
ff_char:                    equ 0x0c ; form feed (printer_ only)
cursor_left_word_char:      equ 0x18 ; XXX TODO -- implement
cursor_right_word_char:     equ 0x19 ; XXX TODO -- implement

; }}} **********************************************************
; Description {{{

; ------------------------------
; Forth Registers
;
; Forth Z80  Forth preservation rules
; ----- ---  ------------------------
; IP    BC   Interpretive pointer. Should be preserved across
;            Forth words.
; SP    SP   Data stack pointer. Should be used only as data
;            stack across Forth words. May be used within Forth
;            words if restored before NEXT.
;       DE   Input only when pushde called.
;       HL   Input only when pushhl called.

; ------------------------------
; Stack comment conventions:
;
; a       = address
; aa      = cell-aligned address
; ca      = character-aligned address
; fa      = float-aligned address
; c       = 8-bit character
; u       = 16-bit unsigned number
; len     = 16-bit unsigned number, length of memory zone or string
; ca len  = string
; n       = 16-bit signed number
; x       = 16-bit signed or unsigned number
; d       = 32-bit signed double number
; ud      = 32-bit unsigned double number
; xd      = 32-bit signed or unsigned number
; xt      = execution token (same as cfa)
; cfa     = address of code field (same as xt)
; lfa     = address of link field
; nfa     = address of name field
; pfa     = address of parameter field (body)
; orig    = address of a control structure origin
; fam     = file access method

; ------------------------------
; Non Forth-83 Standard word definitions:
;
; FIG Fig-FORTH model
; ANS ANS FORTH Standard (document dpANS-6, June 1993)

; ------------------------------
; Memory allocation ; XXX OLD

; The memory above LIMIT is used only by the interpreter.  This space
; is not wasted for turnkey applications as LIMIT, user variables and
; stacks are relocated to EM giving applications more free ram (as
; indicated by UNUSED).

; EM  |-------------  end of memory
; |
; HM  |-------------
; |   parsed string buffer
; |-------------
; |   terminal input buffer
; TIB |-------------
; |   file descriptor blocks
; FDB |-------------
; |   block buffer
; LIMIT |-------------
; |   handle r/w buffer
; HBUF  |-------------
; |   file handles
; |-------------
; |   user variables
; R0  |-------------
; |   return stack
; S0  |-------------
; |   data stack
; PAD |-------------
; |   word and number conversion area
; DP  |-------------
; |   application dictionary
; 0x0100 |-------------

; ------------------------------
; Header structure

; nfa db length+flags     ; length = 1..31
;     ds length           ; name 
; lfa dw previousnfa
; cfa dw codeaddress
; pfa ds ...              ; data or code

; ------------------------------
; Memory map ; XXX TODO -- in progress

; ----- end of memory
; UDG definitions
; ---- UDG system variable
; ... free space
; PAD buffer
; ---- PAD
; ---- DP
; ... used space
; WORD buffer
; parsed string buffer
; ---- R0
; Return stack (grows toward low memory)
; ---- S0 
; Stack (grows toward low memory)
; User data
; TIB
; file descriptor
; block buffer
; boot jumps
; ---- DZX-Forth's org
; ---- BASIC's RAMTOP
; ...
; BASIC program and variables
; system variables
; screen memory
; ROM

; }}} **********************************************************
; Macros {{{

; ------------------------------
; Word header

alias_bit:          equ 7
alias_mask:         equ 1 shl alias_bit
immediate_bit:      equ 6
immediate_mask:     equ 1 shl immediate_bit
smudge_bit:         equ 5
smudge_mask:        equ 1 shl smudge_bit

_public:      equ yes
_hidden:      equ not _public ; change this to_ make all hidden words public
_immediate:   equ yes

previous_nfa: defl 0   ; initial link pointer (end of_ chain_)

_header: macro enabled,name,immediate,alias_xt

  ; enabled     = (yes/no, _public/_hidden)
  ; name        = name string
  ; immediate   = _immediate or nothing
  ; alias_xt    = alias_ xt

  if enabled

    ; the name field
    last_nfa: defl $ ; link address for next word_
    bits: defl 0
    if not nul immediate
      ; set immediate bit
      bits: defl bits | immediate_mask
    endif
    if not nul alias_xt
;      ; set alias bit
      bits: defl bits | alias_mask
    endif
    local _first ; address of_ the first char_ of_ the name
    local _next  ; address after the last_ char_ of_ the name
    db _next-_first+bits    ; count_ and flags byte
    _first: db name
    _next:
    
    ; the link field
    dw previous_nfa

    ; the code field
    if nul alias_xt
      last_xt: defl $+2
    else
      last_xt: defl alias_xt
    endif
    dw last_xt
    previous_nfa: defl last_nfa

  endif

endm

; ------------------------------
; Counted string

_dcs: macro string.1,string.2,string.3,string.4 ; allow comma_ separated strings
  local _first,_next
  db _next-_first ; count_ byte
  _first: db string.1
  if not nul string.2
    db string.2
    if not nul string.3
      db string.3
      if not nul string.4
        db string.4
      endif
    endif
  endif
  _next:
endm

; ------------------------------
; Save the IP

; This is used by words that call ROM routines.
; 'savedip' is defined in the word 'type'.
; See the word 'cls' as a usage example.

_save_ip: macro
  ld h,b
  ld l,c
  ld (saved_ip),hl
endm

; ------------------------------
; Size-optimized jumps

_jump: macro p1,p2
;  ; Create a relative or absolute jump,
;  ; depending on the configured optimization
  ; XXX FIXME -- this can not work?
  if nul p2
    if size_optimization
      jr p1
    else
      jp p1
    endif
  else 
    if size_optimization
      jr p1,p2
    else
      jp p1,p2
    endif
  endif
  endm

; ------------------------------
; Debug

_show_depth: macro
  dw paren_dot_quote_
  _dcs 'Depth is '
  dw depth_,dot_,cr_
  endm

; ------------------------------
; Files

; Macro to generate fdb table
; XXX OLD -- done at the place
; buildfiledescriptorblockstable: macro
;     local @a
; @a  defl  filedescriptorblocks
;     rept maxopensourcefiles
;           dw  @a
;       @a  defl  @a+filedescriptorsize
;     endm
;    endm

; }}} **********************************************************
; Boot {{{

  org start

  jp cold_boot
;  jp warmboot  ; XXX TODO

; }}} **********************************************************
; Data zones {{{

block_buffer:
  ds block_size    ; block_ buffer_

file_descriptor_blocks:
  ds file_descriptor_size*max_open_source_files

file_descriptor_blocks_table:
  proc
    local @a
    @a defl file_descriptor_blocks
    rept max_open_source_files
      dw @a
      @a defl @a+file_descriptor_size
    endm
  endp

tib_address:
  ds tib_size ; terminal input buffer_

user_data:
  ds user_data_size

stack_end:
  ds stack_size
stack_0:

return_stack_end:
  ds return_stack_size
return_stack_0:

  if separated_f_stack
    ds float_stack_size
    float_stack_0:
  endif

parsed_string_buffer:
  if classic_Forth_behaviours
    ds parsed_string_buffer_size   ; buffer_ of_ S"
  else
    ds parsed_string_buffer_size+word_buffer_size ; buffer_ of_ S" and WORD_
  endif

hm: equ $   ; system_ definitions_ and header_ memory ; XXX OLD ?

dummy_nfa: ; XXX OLD ?
  db 0   ; dummy nfa - don't remove! ; XXX NEW -- changed its position in DX-Forth_ 4.09

; Identification and version

;;  dw 0x4683   ; id  ('DXF' in radix 36) 0111
;;dxver:
;;  db rel   ; release     0113
;;  db rev   ; revision      0114

;
; XXX OLD
;;  ds cw    ; reserved
user_data_pointer:
  dw user_data
return_stack_pointer:
  dw return_stack_0

; cpu speed (TURBO PASCAL compatible)
; XXX OLD -- not needed, unless the OS is not used
; XXX TODO convert
speed:
  dw 4   ; 1..8191 MHz

; ------------------------------
; Init user variables

; They are copied by 'COLD' into the user data area
; and must be in same order as 'USER' variables.

init_user_variables: ; start of_ data

                ds 3*cw     ; 00..04 = reserved for multitasking
cold_s0:        dw stack_0  ; 06 = s0_
cold_r0:        dw return_stack_0 ; 08 = r0_
cold_dp:        dw init_dp  ; 10 = dp_
cold_dph:       equ cold_dp ; XXX TMP -- still used by old code
                dw init_dp  ; 12 = not used ; XXX FIXME still fetched by 'empty'
cold_voc_link:  dw forth_.2  ; 14 = voc-link
cold_fs0:                   ; 16 = fs0_
  if separated_f_stack ; XXX TODO
                dw float_stack_0 ; 16 = fs0_
  else
                dw 0             ; 16
  endif
                ds cw       ; 18 = reserved

init_user_variables.end:  ; end of_ data

; ------------------------------

system_stack_pointer:
  ds cw
esm:
  ds cw    ; end of_ memory pointer
; XXX OLD
;;initbootxt:
;;  dw noop
default_drive:
  ds 1
default_user:
  ds 1
; XXX OLD
;;scaps:   ; XXX converted to user variable
;;  ds 1   ; COMPARE SEARCH case flag
bios_parameter_block: ; XXX OLD
  ds 5
; XXX OLD 
;;ulimit:
;;  ds cw    ; LIMIT for turnkey ; XXX NEW -- from DX-Forth 4.09
;;  ds 2   ; spare

; Arrow key codes (default = Wordstar style) ; XXX OLD
;;  db 'E'-0x40   ; up arrow      014F
;;  db 'X'-0x40   ; down arrow      0150
;;  db 'D'-0x40   ; right arrow     0151
;;  db 'S'-0x40   ; left arrow      0152

; Scratch buffer - shared by several functions:
; +EXT  DELETE-FILE  RENAME-FILE
;; sbuf equ $ ; XXX OLD ? -- not used

; Buffer for temporary filename/fcb ; XXX OLD
zb_size:  equ filename_size+1+36
zb.1:   ds zb_size
zb.2:   ds zb_size

tmp_stack: equ $-cw ; temp stack for startup ; XXX OLD

; }}} **********************************************************
; Misc. subroutines {{{

; ------------------------------
; BC is preserved

de_minus_hl_to_hl:
  ; Input:  de, hl
  ; Output: hl = de-hl
  ex de,hl

hl_minus_de_to_hl:
  ; Input:  de, hl
  ; Output: hl = hl-de
  ld a,l
  sub e
  ld l,a
  ld a,h
  sbc a,d
  ld h,a
  ret

compare_de_hl_unsigned:
  ; Input:  de, hl
  ; Output:
  ;  flag C if hl < de
  ;  flag Z if hl = de
  ld a,h
  cp d
  ret nz
  ld a,l
  cp e
  ret

compare_de_hl_signed:
  ; Input:  de, hl
  ; Output: flag C if hl < de
  ld a,h
  xor d
  jp p,compare_de_hl_unsigned
  ld a,h
  or a
  ret p
  scf
  ret

; ------------------------------
; BC is affected

; move block upwards  HL = source, DE = destination, BC = count

move_block_upwards:
  add hl,bc
  ex de,hl
  add hl,bc
  ex de,hl
move_block_upwards.1:
  ld a,c
  or b
  ret z
  dec hl
  dec de
  ld a,(hl)
  ld (de),a
  dec bc
  jp move_block_upwards.1

; move block up/down  HL = source, DE = destination, BC = count

move_block:
  call compare_de_hl_unsigned
  jp c,move_block_upwards

; move block downwards  HL = source, DE = destination, BC = count

move_block_downwards:
  ld a,c
  or b
  ret z
  ld a,(hl)
  ld (de),a
  inc hl
  inc de
  dec bc
  jp move_block_downwards

; move block downwards  HL = source, DE = destination, A = count

amovd:
  push bc
  ld c,a
  ld b,0
  call move_block_downwards
  pop bc
  ret

; }}} **********************************************************
; Virtual machine {{{

; XXX TODO -- add headers?
do_create:        equ next
do_variable:      equ next
do_value:         equ fetch_
do_constant:      equ fetch_
do_two_constant:  equ two_fetch_
do_byte_constant: equ c_fetch_

; runtime for colon definitions

; XXX TODO -- add a header
do_colon:
  ld hl,(return_stack_pointer)  ; push IP onto return_ stack
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c
  ld (return_stack_pointer),hl
  pop bc    ; get new IP from 'call'
  jp next

; runtime for user variables

; XXX TODO -- add a header
do_user_variable:
  pop hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  ld hl,(user_data_pointer)
  add hl,de
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; NOOP  ( -- )

  _header _public,'NOOP'
noop_: equ $

; NEXT  -  Forth Address Interpreter

next:
  ld a,(bc)   ; 7T
  ld l,a      ; 4T
  inc bc      ; 6T
  ld a,(bc)   ; 7T
  ld h,a      ; 4T
  inc bc      ; 6T
  jp (hl)     ; 4T

; UNNEST  ( -- )

  _header _public,'UNNEST'
unnest_:
  ld hl,(return_stack_pointer)
  inc hl
  inc hl
  ld (return_stack_pointer),hl
  jp next

; (EXIT)  ( -- )
;   exit colon definition

  _header _public,'(EXIT)'
paren_exit_: ; XXX TODO rename 'paren_exit'
  ld bc,next
;;exit.1: ; XXX OLD -- not used
  push bc
  ld hl,(return_stack_pointer)  ; pop IP from return_ stack
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ld (return_stack_pointer),hl
  ret ; execute_ NEXT

; EXECUTE  ( xt -- )

  _header _public,'EXECUTE'
execute_:
  ret

; @?EXECUTE  ( a -- )

  _header _public,'@?EXECUTE'
fetch_question_execute_:
  pop hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  or h
  jp z,next
  jp (hl)

; @EXECUTE  ( a -- )

  _header _public,'@EXECUTE'
fetch_execute_:
  pop hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  jp (hl)

; CLIT  ( -- c )

  _header _hidden,'CLIT'
c_lit_:
  ld a,(bc)
  inc bc

push_a:
  ld l,a
push_l:
  ld h,0
push_hl:
  push hl
  jp next

; LIT  ( -- n )

  _header _hidden,'LIT'
lit_:
  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a
  inc bc
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; 2LIT  ( -- d )

  _header _hidden,'2LIT'
two_lit_:
  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a
  inc bc
  ld a,(bc)
  ld e,a
  inc bc
  ld a,(bc)
  ld d,a
  inc bc
  jp push_de_hl

; }}} **********************************************************
; Stack pointer manipulation {{{

; SP@  ( -- a )

  _header _public,'SP@'
sp_fetch_:
  ld hl,0
  add hl,sp
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; SP!  ( a -- )

  _header _public,'SP!'
sp_store_:
  pop hl
  ld sp,hl
  jp next

; RP@  ( -- a )

  _header _public,'RP@'
rp_fetch_:
  ld hl,(return_stack_pointer)
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; RP!  ( a -- )

  _header _public,'RP!'
rp_store_:
  pop hl
  ld (return_stack_pointer),hl
  jp next

; }}} **********************************************************
; Return stack {{{

; >R  ( x -- )

  _header _public,'>R'
to_r_:
  ld hl,(return_stack_pointer)
  pop de
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e
  ld (return_stack_pointer),hl
  jp next

; R>  ( -- x )

  _header _public,'R>'
from_r_:
  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (return_stack_pointer),hl
push_de:
  push de
  jp next

; R@  ( -- x )

  _header _public,'R@'
r_fetch_:
  ld hl,(return_stack_pointer)
  jp fetch_.1

; 2>R  ( x1 x2 -- )

  _header _public,'2>R'
two_to_r_:
  ld hl,(return_stack_pointer)
;  ; XXX TODO faster per macro loop with 'inc hl'?
  ld de,-cw*2
  add hl,de
  ld (return_stack_pointer),hl
  jp two_store_.into_hl_pointer

; 2R>  ( -- x1 x2 )

  _header _public,'2R>'
two_from_r_:
  ld hl,(return_stack_pointer)
  push hl
  ld de,cw*2
  add hl,de
  ld (return_stack_pointer),hl
  jp two_fetch_

; 2R@  ( -- x1 x2 )

  _header _public,'2R@'
two_r_fetch_:
  ld hl,(return_stack_pointer)
  jp two_fetch_.hl

; 2DROP  ( x1 x2 -- )

  _header _public,'2DROP'
two_drop_:
  pop hl
  pop hl
  jp next

; }}} **********************************************************
; Data stack {{{

; DROP  ( x -- )

  _header _public,'DROP'
drop_:
  pop hl
  jp next

; DUP  ( x -- x x )

  _header _public,'DUP'
dup_:
  pop hl
  push hl
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; ?DUP  ( x -- 0 | x x )

  _header _public,'?DUP'
question_dup_:
  pop hl
  ld a,l
  or h
  if size_optimization
    jr z,question_dup_.end
  else
    jp z,question_dup_.end
  endif
  push hl
question_dup_.end:
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; SWAP  ( x1 x2 -- x2 x1 )

  _header _public,'SWAP'
swap_:
  pop hl
  ex (sp),hl
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; OVER  ( x1 x2 -- x1 x2 x1 )

  _header _public,'OVER'
over_:
  pop de
  pop hl
  push hl
  jp push_de_hl

; ROT  ( x1 x2 x3 -- x2 x3 x1 )

  _header _public,'ROT'
rot_:
  pop de
  pop hl
  ex (sp),hl
  jp push_de_hl

; -ROT  ( x1 x2 x3 -- x3 x1 x2 )

  _header _public,'-ROT'
minus_rot_:
  pop hl
  pop de
  ex (sp),hl
  ex de,hl
  jp push_de_hl

; ROLL  ( xu xn .. x0 u -- xn .. x0 xu )

  _header _public,'ROLL'
roll_:
  pop hl
  add hl,hl
  ld e,l
  ld d,h
  add hl,sp
  push bc
  ld c,(hl)
  inc hl
  ld b,(hl)
  push bc
  ld c,e
  ld b,d
  ld e,l
  ld d,h
  inc de
  dec hl
  call move_block_upwards.1
  pop hl
  pop bc
  ex (sp),hl
  jp next

if control_flow_stack_extensions

; -ROLL  ( xu .. xu+1 x0 u -- x0 xu .. xu+1 )

  _header _public,'-ROLL'
minus_roll_:
  pop hl
  add hl,hl
  ex de,hl
  ld hl,0
  add hl,sp
  push bc
  ld c,(hl)
  inc  hl
  ld b,(hl)
  push bc
  ld c,e
  ld b,d
  ld e,l
  ld d,h
  dec  de
  inc  hl
  call move_block_downwards
  pop hl
  pop bc
  ex de,hl
  jp store_.de_into_hl_pointer

endif

; PICK  ( xu .. x1 x0 u -- xu .. x1 x0 xu )

  _header _public,'PICK'
pick_:
  pop hl
  add hl,hl
  add hl,sp
  jp fetch_.1

; NIP  ( x1 x2 -- x2 )

  _header _public,'NIP'
nip_:
  pop hl
  inc sp
  inc sp
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; TUCK  ( x1 x2 -- x2 x1 x2 )

  _header _public,'TUCK'
tuck_:
  pop hl
  pop de
  push hl
  jp push_de_hl

; 2DUP  ( x1 x2 -- x1 x2 x1 x2 )

  _header _public,'2DUP'
two_dup_:
  pop hl
  pop de
  push de
  push hl
  jp push_de_hl

; 2SWAP  ( x1 x2 x3 x4 -- x3 x4 x1 x2 )

  _header _public,'2SWAP'
two_swap_:
; XXX OLD -- DX-Forth 4.00
;;  pop de
;;  pop hl
;;  inc sp
;;  inc sp
;;  ex (sp),hl
;;  dec sp
;;  dec sp
;;  ex de,hl
;;  ex (sp),hl
;;  jp pushde
; XXX NEW -- DX-Forth 4.09
  pop hl
  pop de
  ex (sp),hl
  push hl
  ld hl,5
  add hl,sp
  ld a,(hl)
  ld (hl),d
  ld d,a
  dec  hl
  ld a,(hl)
  ld (hl),e
  ld e,a
  pop hl
  jp push_de_hl

; 2OVER  ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )

  _header _public,'2OVER'
two_over_:
  ld hl,4
  add hl,sp
  jp two_fetch_.hl

; 2ROT  ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
;  5 roll 5 roll

  _header _public,'2ROT'
two_rot_:
  call do_colon
  dw c_lit_
  db 5
  dw roll_
  dw c_lit_
  db 5
  dw roll_
  dw paren_exit_

; 2NIP  ( x1 x2 x3 x4 -- x3 x4 )

  _header _public,'2NIP'
two_nip_:
  pop hl
  pop de
  inc  sp
  inc  sp
  inc  sp
  inc  sp
push_de_hl: ; XXX this is DX-Forth's dpush
  push de
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; DEPTH  ( -- u )
;   sp@ s0 @ swap - 2/

  _header _public,'DEPTH'
depth_:
  call do_colon
  dw sp_fetch_
  dw s0_,fetch_
  dw swap_,minus_
  dw two_slash_
  dw paren_exit_

; MAXDEPTH-.S  ( -- a )
; XXX NEW -- after Gforth
; max items shown by '.s'
  ; XXX TODO -- make it optional

  _header _public,'MAXDEPTH-.S'
maxdepth_dot_s_:
  call do_create
  dw 9 ; default

; .S  ( -- )
; XXX NEW -- after Gforth

  ; XXX TODO -- make it optional
  _header _public,'.S'
dot_s_:
  call do_colon
;  ; show the depth:
  dw depth_
  dw c_lit_
  db '<'
  dw emit_,zero_,dot_r_
  dw c_lit_
  db '>'
  dw emit_,space_
;  ; calculate the items to show:
  dw depth_,zero_,max_,maxdepth_dot_s_,fetch_,min_
;  ; do it:
  dw dup_,zero_
  dw paren_question_do_,dot_s_.end
dot_s_.do:
  dw dup_,i_,minus_,pick_,dot_
  dw paren_loop_,dot_s_.do
dot_s_.end:
  dw drop_
  dw paren_exit_

; }}} **********************************************************
; Memory operations {{{

; @  ( aa -- x )

  _header _public,'@'
fetch_:
  pop hl
fetch_.1:
  ld e,(hl)
  inc hl
  ld d,(hl)
  if size_optimization
    jp push_de
  else
    push de
    jp next
  endif

; 2!  ( x1 x2 aa -- )

  _header _public,'2!'
two_store_:
  pop hl
two_store_.into_hl_pointer:
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  jp store_.into_hl_pointer

; !  ( x aa -- )

  _header _public,'!'
store_:
  pop hl
store_.into_hl_pointer:
  pop de
store_.de_into_hl_pointer:
  ld (hl),e
  inc hl
  ld (hl),d
  jp next

; C@  ( ca -- c )

  _header _public,'C@'
c_fetch_:
  pop hl
  ld l,(hl)
  ld h,0
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; C!  ( c ca -- )

  _header _public,'C!'
c_store_:
  pop hl
  pop de
  ld (hl),e
  jp next

; 2@  ( aa -- x1 x2 )

  _header _public,'2@'
two_fetch_:
  pop hl
two_fetch_.hl:
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  ex de,hl
  jp push_de_hl

; +!  ( x aa -- )

  _header _public,'+!'
plus_store_:
  pop hl
  pop de
plus_store_.de_into_hl:
  ld a,(hl)
  add a,e
  ld (hl),a
  inc hl
  ld a,(hl)
  adc a,d
  ld (hl),a
  jp next

; MOVE  ( a1 a2 u -- )

  _header _public,'MOVE'
move_:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
  call move_block
  pop bc
  jp next

; ERASE  ( a u -- )

  _header _public,'ERASE'
erase_:
  ld e,0
  jp fill_.1

; FILL  ( ca u c -- )

  _header _public,'FILL'
fill_:
  pop de
fill_.1:
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
  jp fill_.3

fill_.2:
  ld (hl),e
  inc hl
  dec bc
fill_.3:
  ld a,c
  or b
  jp nz,fill_.2
  pop bc
  jp next

; ON  ( a -- )
;   -1 swap !

  _header _public,'ON'
on_:
  pop hl
on_.hl:
  ld de,-1
  jp store_.de_into_hl_pointer

; OFF  ( a -- )
;   0 swap !

  _header _public,'OFF'
off_:
  pop hl
off_.hl:
  ld de,0
  jp store_.de_into_hl_pointer

; XXX OLD -- DX-Forth 4.00
;;; TOGGLE  ( ca x -- )
;;
;;  header public,'TOGGLE'
;;toggle:
;;  pop de
;;  pop hl
;;toggle.1:
;;  ld a,(hl)
;;  xor e
;;  ld (hl),a
;;  jp next

; XXX NEW -- DX-Forth 4.09
; CTOGGLE  ( x ca -- )

  _header _public,'CTOGGLE'
c_toggle_:
  pop hl
c_toggle_.hl:
  pop de
  ld a,(hl)
  xor e
  ld (hl),a
  jp next

; CHAR+  ( ca1 -- ca2 )
;   aka 1+ char+

  _header _public,'CHAR+',,one_plus_
char_plus_: equ one_plus_

; CHARS  ( n1 -- n2 )
;   aka noop chars immediate

  _header _public,'CHARS',_immediate,noop_
chars_: equ next

; CELL+  ( a1 -- a2 )
;   aka 2+ cell+

  _header _public,'CELL+',,two_plus_
cell_plus_: equ two_plus_

; CELL-  ( a1 -- a2 )
;   aka 2- cell-

  _header _public,'CELL-',,two_minus_
cell_minus_: equ two_minus_

; CELLS  ( n1 -- n2 )
;   aka 2* cells

  _header _public,'CELLS',,two_star_
cells_: equ two_star_

; ALIGN  ( -- )
;   aka noop align immediate

  _header _public,'ALIGN',_immediate,noop_
align_: equ next

; ALIGNED  ( a -- aa )
;   aka noop aligned immediate

  _header _public,'ALIGNED',_immediate,noop_
aligned_: equ next

; }}} **********************************************************
; Arithmetic and logical {{{

; ><  ( x1 -- x2 )

  _header _public,'><'
byte_swap_:
  pop de
  ld h,e
  ld l,d
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; AND  ( x1 x2 -- x3 )

  _header _public,'AND'
and_:
  pop de
  pop hl
  ld a,e
  and l
  ld l,a
  ld a,d
  and h
  ld h,a
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; OR  ( x1 x2 -- x3 )

  _header _public,'OR'
or_:
  pop de
  pop hl
  ld a,e
  or l
  ld l,a
  ld a,d
  or h
  ld h,a
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; XOR  ( x1 x2 -- x3 )

  _header _public,'XOR'
xor_:
  pop de
  pop hl
  ld a,e
  xor l
  ld l,a
  ld a,d
  xor h
  ld h,a
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

abs_hl:
  ld a,h
  or a
  ret p

negate_hl:
  dec hl    ; two's complement
negate_hl.1:
  ld a,l
  cpl
  ld l,a
  ld a,h
  cpl
  ld h,a
  ret

sra_hl:
  ld a,h   ; shift arithmetic right
  rlca
  rrca
sra_hl.1:
  rra
  ld h,a
  ld a,l
  rra
  ld l,a
  ret

abs_hlde:
  ld a,h
  or a
  ret p

negate_hlde:
  sub a   ; 16 bit two's complement
  sub e
  ld e,a
  ld a,0
  sbc a,d
  ld d,a
  ld a,0
  sbc a,l
  ld l,a
  ld a,0
  sbc a,h
  ld h,a
  ret

; INVERT  ( x1 -- x2 )
;   one's complement

  _header _public,'INVERT'
invert_:
  pop hl
  call negate_hl.1
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; S>D  ( n -- d )

  _header _public,'S>D'
s_to_d_:
  ld hl,0
  pop de
  ld a,d
  or a
  jp p,push_de_hl
  dec hl
  jp push_de_hl

; D>S  ( d -- n )
;   aka drop d>s

  _header _public,'D>S',,drop_
d_to_s_: equ drop_

; NEGATE  ( n1 -- n2 )

  _header _public,'NEGATE'
negate_:
  pop hl
  call negate_hl
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; ABS  ( n -- +n )

  _header _public,'ABS'
abs_:
  pop hl
  call abs_hl
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; DNEGATE  ( d1 -- d2 )

  _header _public,'DNEGATE'
d_negate_:
  pop hl
  pop de
  call negate_hlde
  jp push_de_hl

; DABS  ( d -- +d )

  _header _public,'DABS'
d_abs_:
  pop hl
  pop de
  call abs_hlde
  jp push_de_hl

; +  ( x1 x2 -- x3 )

  _header _public,'+'
plus_:
  pop de
plus_de:
  pop hl
  add hl,de
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif


; -  ( x1 x2 -- x3 )

  _header _public,'-'
minus_:
  pop de
  pop hl
  call hl_minus_de_to_hl
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif


; D+  ( xd1 xd2 -- xd3 )

  _header _public,'D+'
d_plus_:
  ld hl,6
  add hl,sp
  ld e,(hl)
  ld (hl),c
  inc hl
  ld d,(hl)
  ld (hl),b
  pop bc
  pop hl
  add hl,de
  ex de,hl
  pop hl
  ld a,l
  adc a,c
  ld l,a
  ld a,h
  adc a,b
  ld h,a
  pop bc
  jp push_de_hl

; D-  ( xd1 xd2 -- xd3 )
;   dnegate d+

  _header _public,'D-'
d_minus_:
  call do_colon
  dw d_negate_,d_plus_
  dw paren_exit_

; M+  ( xd1 n -- xd2 )
;   s>d d+

  _header _public,'M+'
m_plus_:
  call do_colon
  dw s_to_d_,d_plus_
  dw paren_exit_

; 1+  ( x1 -- x2 )

  _header _public,'1+'
one_plus_:
  pop hl
  inc hl
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif


; 2+  ( x1 -- x2 )

  _header _public,'2+'
two_plus_:
  pop hl
  inc hl
  inc hl
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif


; 1-  ( x1 -- x2 )

  _header _public,'1-'
one_minus_:
  pop hl
  dec hl
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif


; 2-  ( x1 -- x2 )

  _header _public,'2-'
two_minus_:
  pop hl
  dec hl
  dec hl
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif


; ------------------------------
; Multiplication primitives

; AHL <- A * DE

a_by_de_to_ahl:
  ld hl,0
  ld c,8
a_by_de_to_ahl.1:
  add hl,hl
  rla
  jp nc,a_by_de_to_ahl.2
  add hl,de
  adc a,0
a_by_de_to_ahl.2:
  dec c
  jp nz,a_by_de_to_ahl.1
  ret

; Unsigned 16*16 multiply, 32 bit result

; HLDE <- HL * DE

hl_by_de_to_hlde_unsigned:
  push bc    ; save IP
  ld b,h
  ld a,l
  call a_by_de_to_ahl
  push hl
  ld h,a
  ld a,b
  ld b,h
  call a_by_de_to_ahl
  pop de
  ld c,d
  add hl,bc
  adc a,0
  ld d,l
  ld l,h
  ld h,a
  pop bc    ; restore IP
  ret

; Signed 16*16 multiply, 32 bit result

; HLDE <- HL * DE

hl_by_de_to_hlde_signed:
  ld a,d
  xor h
  rla
  push af
  call abs_hl
  ex de,hl
  call abs_hl
  call hl_by_de_to_hlde_unsigned
  pop af
  ret nc
  jp negate_hlde

; UM*  ( u1 u2 -- ud )

  _header _public,'UM*'
umstr_:
  pop de
  pop hl
  call hl_by_de_to_hlde_unsigned
  jp push_de_hl

; M*  ( n1 n2 -- d )
; 2dup xor >r abs swap abs um* r> ?dnegate

  _header _public,'M*'
mstar_:
  pop de
  pop hl
  call hl_by_de_to_hlde_signed
  jp push_de_hl

; *  ( x1 x2 -- x3 )
; um* drop

  _header _public,'*'
star_:
  pop de
  pop hl
  call hl_by_de_to_hlde_unsigned
  if size_optimization
    jp push_de
  else
    push de
    jp next
  endif

; ------------------------------
; Division primitives

usl.1:
  sub c
  ld h,a
  ld a,e
  sbc a,b
usl.2:
  inc l
  dec d
  ret z

usl.3:
  add hl,hl
  rla
  ld e,a
  ld a,h
  jp c,usl.1
  sub c
  ld h,a
  ld a,e
  sbc a,b
  jp nc,usl.2
  ld a,h
  add a,c
  ld h,a
  ld a,e
  dec d
  jp nz,usl.3
  ret

usl:
  ld a,h
  ld h,l
  ld l,d
  ld d,8   ; loop counter
  push de
  call usl.3
  pop de
  push hl
  ld l,e
  call usl.3
  ld d,a
  ld e,h
  ld a,l
  pop hl
  ld h,l
  ld l,a
  ret

; Unsigned 32/16 divide
;
; entry HLDE = dividend, BC = divisor
; exit  HL = quotient, DE = remainder

mum:
  ld a,l   ; if overflow
  sub c
  ld a,h
  sbc a,b
  jp c,usl
  ld hl,-1   ; set rem & quot to max
  ld de,-1
  ret

; UM/MOD  ( ud u1 -- u2 u3 )

  _header _public,'UM/MOD'
umslm_:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
  ex de,hl
  call mum
  pop bc
  jp push_de_hl

; Signed 32/16 divide - floored
;
; entry HLDE = dividend, BC = divisor
; exit  HL = quotient, DE = remainder

msm:
  push bc    ; save divisor
  ld a,b
  xor h
  push af    ; save quot sign
  push hl    ; save dividend
  push hl
  ld l,c
  ld h,b
  call abs_hl
  ld c,l
  ld b,h
  pop hl
  call abs_hlde
  call mum
  pop af    ; sign remainder
  or a
  ex de,hl
  call m,negate_hl
  ex de,hl
  pop af
  pop bc    ; restore divisor
  or a   ; sign quot
  jp p,msm.1
  jp negate_hl

msm.1:
  pop bc    ; discard return
msm.2:
  pop bc
  if size_optimization
    jp push_de
  else
    push de
    jp next
  endif

; SM/REM  ( d n1 -- n2 n3 )

  _header _public,'SM/REM'
s_m_slash_rem_:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
  ex de,hl
s_m_slash_rem_.1:
  call msm
  jp msm.2

; FM/MOD  ( d n1 -- n2 n3 )

  _header _public,'FM/MOD'
fm_slash_mod_:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
  ex de,hl
fm_slash_mod_.1:
  call msm
  ld a,d
  or e
  jp z,msm.2    ; skip_ if remainder = 0
  dec hl    ; floor_
  push hl
  ex de,hl
  add hl,bc
  ex de,hl
  pop hl
  jp msm.2

; M/MOD  ( d n1 -- n2 n3 )
;   fm/mod or sm/rem

; XXX OLD -- DX-Forth 4.00 -- but kept
  _header _hidden,'M/MOD',,m_slash_mod_

if floored_division
  m_slash_mod_: equ fm_slash_mod_
else
  m_slash_mod_: equ s_m_slash_rem_
endif

; /MOD  ( n1 n2 -- n3 n4 )
;   >r s>d r> m/mod

; XXX NEW -- DX-Forth 4.09 -- instead of 'M/MOD'
  _header _public,'/MOD'
slash_mod_:
  call do_colon
  dw to_r_,s_to_d_
  dw from_r_,m_slash_mod_
  dw paren_exit_

; /  ( n1 n2 -- n3 )
;   /mod nip

  _header _public,'/'
slash_:
  call do_colon
  dw slash_mod_,nip_
  dw paren_exit_

; MOD  ( n1 n2 -- n3 )
;   /mod drop

  _header _public,'MOD'
modd_:
  call do_colon
  dw slash_mod_,drop_
  dw paren_exit_

; */MOD  ( n1 n2 n3 -- n4 n5 )
;   >r m* r> sm/rem

  _header _public,'*/MOD'
star_slash_mod_:
  call do_colon
  dw to_r_,mstar_
  dw from_r_
  dw s_m_slash_rem_ ; DX-Forth 4.00 used 'm_slash_mod' here instead
  dw paren_exit_

; */  ( n1 n2 n3 -- n4 )
;   */mod nip

  _header _public,'*/'
star_slash_:
  call do_colon
  dw star_slash_mod_,nip_
  dw paren_exit_

; M*/  ( d1 n1 +n2 -- d2 )
;   abs >r 2dup xor swap abs >r -rot
;         dabs swap r@ um* rot r> um* rot 0 d+
;         r@ um/mod -rot r> um/mod nip swap
;         rot 0< if dnegate then

  _header _public,'M*/'
m_star_slash_:
  call do_colon
  dw abs_,to_r_
  dw two_dup_,xor_
  dw swap_,abs_,to_r_
  dw minus_rot_,d_abs_
  dw swap_,r_fetch_,umstr_
  dw rot_,from_r_,umstr_
  dw rot_,zero_,d_plus_
  dw r_fetch_,umslm_
  dw minus_rot_,from_r_
  dw umslm_,nip_
  dw swap_,rot_,zero_less_
  dw question_branch_,m_star_slash_.end
  dw d_negate_
m_star_slash_.end:
  dw paren_exit_

; 2*  ( x1 -- x2 )

  _header _public,'2*'
two_star_:
  pop hl
  add hl,hl
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif


; 2/  ( n1 -- n2 )

  _header _public,'2/'
two_slash_:
  pop hl
  call sra_hl
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif


; U2/  ( x1 -- x2 )

  _header _public,'U2/'
u_two_slash_:
  pop hl
  or a
  ld a,h
  call sra_hl.1
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif


; D2*  ( xd1 -- xd2 )

  _header _public,'D2*'
d_two_star_:
  pop de
  pop hl
  add hl,hl
  ld a,e
  rla
  ld e,a
  ld a,d
  rla
  ld d,a
  ex de,hl
  if size_optimization
    jp push_de
  else
    push de
    jp next
  endif

; D2/  ( d1 -- d2 )

  _header _public,'D2/'
d_two_slash_:
  pop hl
  pop de
  call sra_hl
  ld a,d
  rra
  ld d,a
  ld a,e
  rra
  ld e,a
  if size_optimization
    jp push_de
  else
    push de
    jp next
  endif

; LSHIFT  ( x1 u -- x2 )

  _header _public,'LSHIFT'
lshift_:
  pop de
  pop hl
  inc e
lshift_.1:
  dec e
  jp z,push_hl
  add hl,hl
  jp lshift_.1

; RSHIFT  ( x1 u -- x2 )

  _header _public,'RSHIFT'
rshift_:
  pop de
  pop hl
  inc e
rshift_.1:
  dec e
  jp z,push_hl
  or a
  ld a,h
  call sra_hl.1
  jp rshift_.1

; }}} **********************************************************
; Comparison {{{ 

; 0=  ( x -- flag )

  _header _public,'0='
zero_equals_:
  pop hl
zero_equals_hl:
  ld a,l
  or h
  if size_optimization
    jr true_if_z
  else
    jp z,true_
    jp false_
  endif

; 0<>  ( x -- flag )

  _header _public,'0<>'
zero_not_equals_:
  pop hl
zero_not_equals_hl:
  ld a,l
  or h
  jp z,false_
  jp true_

; =  ( x1 x2 -- flag )
;   - 0=

  _header _public,'='
equals_:
  pop de
  pop hl
equals_.de_hl:
  call compare_de_hl_unsigned
true_if_z:
  jp z,true_
  jp false_

; <>  ( x1 x2 -- flag ) - 0= 0=

  _header _public,'<>'
not_equals_:
  pop de
  pop hl
  call compare_de_hl_unsigned
  jp z,false_
  jp true_

; 0<  ( n -- flag )

  _header _public,'0<'
zero_less_:
  pop hl
zero_less_.hl:
  add hl,hl
true_if_cy: ; XXX TODO macro for this jump
  jp c,true_
  jp false_

; 0>  ( n -- flag )

  _header _public,'0>'
zero_greater_:
  pop de
  ld hl,0
zero_greater_.1:
  call compare_de_hl_signed
  if size_optimization
    jp true_if_cy
  else
    jp c,true_
    jp false_
  endif

; <  ( n1 n2 -- flag )

  _header _public,'<'
less_:
  pop de
  pop hl
  jp zero_greater_.1

; >  ( n1 n2 -- flag )

  _header _public,'>'
greater_:
  pop hl
  pop de
  jp zero_greater_.1

; U<  ( u1 u2 -- flag )

  _header _public,'U<'
u_less_:
  pop de
  pop hl
u_less_.de_hl:
  call compare_de_hl_unsigned
  if size_optimization
    jp true_if_cy
  else
    jp c,true_
    jp false_
  endif

; U>  ( u1 u2 -- flag )

  _header _public,'U>'
u_greater_:
  pop hl
u_greater_.hl:
  pop de
  jp u_less_.de_hl

; 0MAX  ( n1 -- n2 )
;   0 max

  _header _hidden,'0MAX'
zero_max_:
  ld de,0
  jp max_de

; MAX  ( n1 n2 -- n1 | n2 )
;   2dup < if swap then drop

  _header _public,'MAX'
max_:
  pop de
max_de:
  pop hl
  call compare_de_hl_signed
max_.1:
  ccf
max_.2:
  jp c,max_.3
  ex de,hl
max_.3:
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif


; MIN  ( n1 n2 -- n1 | n2 )
;   2dup > if swap then drop

  _header _public,'MIN'
min_:
  pop de
  pop hl
  call compare_de_hl_signed
  jp max_.2

; UMAX  ( u1 u2 -- u1 | u2 )
;   2dup u< if swap then drop

  _header _public,'UMAX'
u_max_:
  pop de
  pop hl
  call compare_de_hl_unsigned
  jp max_.1

; UMIN  ( u1 u2 -- u1 | u2 )
;   2dup u> if swap then drop

  _header _public,'UMIN'
u_min_:
  pop de
  pop hl
  call compare_de_hl_unsigned
  jp max_.2

; WITHIN  ( n1|u1 n2|u2 n3|u3 -- flag )
;   over - >r - r> u<
; XXX checked

  _header _public,'WITHIN'
within_:
  pop hl
  pop de
  call hl_minus_de_to_hl
  ex (sp),hl
  call hl_minus_de_to_hl
  jp u_greater_.hl

; BETWEEN  ( n1|u1 n2|u2 n3|u3 -- flag )
;   over - -rot - u< 0=

  _header _public,'BETWEEN'
between_:
  pop hl
  pop de
  call hl_minus_de_to_hl
  ex (sp),hl
  call hl_minus_de_to_hl
  pop de
  call compare_de_hl_unsigned
  jp z,true_
  if size_optimization
    jp true_if_cy
  else
    jp c,true_
    jp false_
  endif

; D0=  ( d -- flag )
;   or 0=

  _header _public,'D0='
d_zero_equals_:
  call do_colon
  dw or_,zero_equals_
  dw paren_exit_

; D=  ( d1 d2 -- flag )

  _header _public,'D='
d_equals_:
  pop de
  pop hl
  ex (sp),hl
  call compare_de_hl_unsigned
  pop de
  pop hl
  jp nz,false_
  jp equals_.de_hl

; D0<  ( d -- flag )
;   swap drop 0<

  _header _public,'D0<'
d_zero_less_:
  pop hl
  pop de
  jp zero_less_.hl

; D<  ( d1 d2 -- flag ) rot 2dup = if 2drop u< exit then 2nip >

  _header _public,'D<'
d_less_:
  pop de
  pop hl
  ex (sp),hl
  call compare_de_hl_unsigned
  jp z,u_less_
  inc sp
  inc sp
  inc sp
  inc sp
  jp zero_greater_.1

; DU<  ( ud1 ud2 -- flag )
;   rot swap 2dup u< if 2drop 2drop -1 exit
;         then - if 2drop 0 exit then u<

  _header _public,'DU<'
d_u_less_:
  pop de
  pop hl
  ex (sp),hl
  call compare_de_hl_unsigned
  pop de
  pop hl
  jp c,true_
  jp nz,false_
  jp u_less_.de_hl

; DMIN  ( d1 d2 -- d1 | d2 )
;   2over 2over d< 0= if 2swap then 2drop

  _header _public,'DMIN'
d_min_:
  call do_colon
  dw two_over_,two_over_
  dw d_less_,zero_equals_
d_min_.1:
  dw question_branch_,d_min_.2
  dw two_swap_
d_min_.2:
  dw two_drop_
  dw paren_exit_

; DMAX  ( d1 d2 -- d1 | d2 )
;   2over 2over d< if 2swap then 2drop

  _header _public,'DMAX'
d_max_:
  call do_colon
  dw two_over_,two_over_
  dw d_less_
  dw branch_,d_min_.1

; }}} **********************************************************
; Numeric conversion {{{ 

; DECIMAL  ( -- )
;   10 base !

  _header _public,'DECIMAL'
decimal_:
  call do_colon
  dw c_lit_
  db 10
  dw base_,store_
  dw paren_exit_

; HEX  ( -- )
;   16 base !

  _header _public,'HEX'
hex_:
  call do_colon
  dw c_lit_
  db 16
  dw base_,store_
  dw paren_exit_

; BINARY  ( -- )
;   2 base !

  _header _public,'BINARY'
binary_:
  call do_colon
  dw c_lit_
  db 2
  dw base_,store_
  dw paren_exit_

; DIGIT  ( c base -- u -1 | 0 )

  _header _hidden,'DIGIT'
digit_:
  pop hl
  pop de
  ld a,e
  call uppercase_a
  sub  '0'
  jp m,false_
  cp 10
  jp m,digit_.1
  sub  7
  cp 10
  jp m,false_
digit_.1:
  cp l
  jp p,false_
  ld e,a
  push de
  jp true_

; >NUMBER  ( d1 a1 u1 -- d2 a2 u2 )
;        begin dup while over c@ base @ digit while
;        >r 2swap r> swap base @ um* drop rot base @
;        um* d+ 2swap 1 /string 1 dpl +! repeat then

  _header _public,'>NUMBER'
to_number_:
  call do_colon
to_number_.1:
  dw dup_    ; begin_
  dw question_branch_,to_number_.end  ; while_
  dw over_,c_fetch_
  dw base_,fetch_
  dw digit_
  dw question_branch_,to_number_.end  ; while_
  dw to_r_
  dw two_swap_,from_r_
  dw swap_
  dw base_,fetch_
  dw umstr_,drop_
  dw rot_
  dw base_,fetch_
  dw umstr_
  dw d_plus_
  dw two_swap_
  dw one_,slash_string_
  dw one_,dpl_,plus_store_
  dw branch_,to_number_.1  ; repeat_
to_number_.end:
  dw paren_exit_    ; then_

; NUMBER?  ( ca u -- d true | false )
; Convert a string to a double number.
;        over c@ [char] - = over 0> and dup >r 1
;        and /string over c@ [char] . > and 0 0
;        2swap ?dup if >number dpl on dup if 1-
;        over c@ [char] . - or dpl off then while
;        then r> 2drop 2drop false else drop r> if
;        dnegate then true then

  _header _public,'NUMBER?'
number_question_:
  call do_colon
  if debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'number_question: '
    dw two_dup_,dot_,dot_,cr_
  endif
  dw over_,c_fetch_
  dw c_lit_
  db '-'
  dw equals_
  dw over_,zero_greater_
  dw and_
  dw dup_,to_r_
  dw one_,and_
  dw slash_string_
  dw over_,c_fetch_
  dw c_lit_
  db '.'
  dw greater_,and_
  dw zero_,zero_
  dw two_swap_
  dw question_dup_
  dw question_branch_,number_question_.2
  dw to_number_
  dw dpl_,on_
  dw dup_
  dw question_branch_,number_question_.1
  dw one_minus_
  dw over_,c_fetch_
  dw c_lit_
  db '.'
  dw minus_,or_
  dw dpl_,off_
number_question_.1:
  dw question_branch_,number_question_.3
number_question_.2:
  dw from_r_
  dw two_drop_,two_drop_
  dw false_
  dw branch_,number_question_.end
number_question_.3:
  dw drop_
  dw from_r_
  dw question_branch_,number_question_.4
  dw d_negate_
number_question_.4:
  dw true_
number_question_.end:
  dw paren_exit_

; <#  ( -- )
;   pad hld !

  _header _public,'<#'
less_number_sign_:
  call do_colon
  dw pad_
  dw hld_,store_
  dw paren_exit_

; #>  ( d -- ca u )
;   2drop hld @ pad over -

  _header _public,'#>'
number_sign_greater_:
  call do_colon
  dw two_drop_
  dw hld_,fetch_
  dw pad_
  dw over_
  dw minus_
  dw paren_exit_

; +HLD  ( +n -- ca )
;   negate hld +! hld @ dup dp @ u<
;        abort" HOLD buffer overflow"

  _header _hidden,'+HLD'
phld_:
  call do_colon
  dw negate_,hld_,plus_store_
  dw hld_,fetch_,dup_
  dw dp_,fetch_,u_less_
  dw paren_abort_quote_
  _dcs 'HOLD buffer overflow'
  dw paren_exit_

; HOLD  ( c -- )
;   1 +hld c!

  _header _public,'HOLD'
hold_:
  call do_colon
  dw one_,phld_
  dw c_store_
  dw paren_exit_

; SIGN  ( n -- )
;   0< if [char] - hold then

  _header _public,'SIGN'
sign_:
  call do_colon
  dw zero_less_
  dw question_branch_,sign_.end
  dw c_lit_
  db '-'
  dw hold_
sign_.end:
  dw paren_exit_

; #  ( ud1 -- ud2 )
;   0 base @ um/mod >r base @ um/mod r>
;        rot 9 over < if 7 + then [char] 0 + hold

  _header _public,'#'
number_sign_:
  call do_colon
  dw zero_
  dw base_,fetch_
  dw umslm_
  dw to_r_
  dw base_,fetch_
  dw umslm_
  dw from_r_
  dw rot_
  dw c_lit_
  db 9
  dw over_,less_
  dw question_branch_,number_sign_.end
  dw c_lit_
  db 7
  dw plus_
number_sign_.end:
  dw c_lit_
  db '0'
  dw plus_
  dw hold_
  dw paren_exit_

; #S  ( +d -- 0 0 )
;   begin # 2dup d0= until

  _header _public,'#S'
number_sign_s_:
  call do_colon
number_sign_s_.begin:
  dw number_sign_,two_dup_,d_zero_equals_
  dw question_branch_,number_sign_s_.begin
  dw paren_exit_

; SHOLD  ( ca u -- )
;   dup +hld swap move

  _header _public,'SHOLD'  ; hold_ string
s_hold_:
  call do_colon
  dw dup_,phld_
  dw swap_,move_
  dw paren_exit_

; NHOLD  ( n c -- )
;   over +hld -rot fill

  _header _public,'NHOLD'  ; hold_ n characters
n_hold_:
  call do_colon
  dw over_,phld_
  dw minus_rot_,fill_
  dw paren_exit_

; DECIMAL?  ( -- flag )
;   base @ 10 =

  _header _public,'DECIMAL?'
decimal_question_:
  call do_colon
  dw base_,fetch_    ; decimal_ base_?
  dw c_lit_
  db 10
  dw equals_
  dw paren_exit_

; }}} **********************************************************
; Strings {{{ 

; CMOVE  ( ca1 ca2 u -- )

  _header _public,'CMOVE'
cmove_:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
cmove_.1:
  call move_block_downwards
  pop bc
  jp next

; CMOVE>  ( ca1 ca2 u -- )

  _header _public,'CMOVE>'
cmovu_:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
cmovu_.1:
  call move_block_upwards
  pop bc
  jp next

; BLANK  ( ca u -- )
;   bl fill

  _header _public,'BLANK'
blank_:
  ld e,' '
  jp fill_.1

; COUNT  ( ca1 -- ca2 u )
;   dup 1+ swap c@

  _header _public,'COUNT'
count_:
  pop de
;;count.1: ; XXX OLD
  ld a,(de)
  inc de
  push de
  jp push_a

; PACKED  ( ca1 u ca2 -- ca2 )
;            2dup 2>r 1+ swap move 2r> tuck c!

  _header _public,'PACKED'
packed_:
  ld l,c
  ld h,b
  pop de
  pop bc
  ex (sp),hl
  push bc
  push de
  inc  de
  call move_block
  pop hl
  pop de
  ld (hl),e
  pop bc
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif


; PLACE  ( ca1 u ca2 -- )
;   packed drop

  _header _public,'PLACE'
place_:
  call do_colon
  dw packed_,drop_
  dw paren_exit_

; XXX OLD -- DX-Forth 4.00
;;; PLACE  ( ca1 u ca2 -- )  2dup 2>r 1+ swap move 2r> c!
;;
;;  header 1,'PLACE'
;;place:
;;  call docolon
;;  dw twodup
;;  dw twotor
;;  dw oneplus,swap
;;  dw move
;;  dw twofromr
;;  dw cstore
;;  dw parenexit

; AFFIX  ( ca c -- ca )
;   over count + c!

;  ; append char_ to counted string
;  ; count unchanged
  _header _hidden,'AFFIX'
affix_:
  call do_colon
  dw over_
  dw count_,plus_
  dw c_store_
  dw paren_exit_

; SCAN  ( ca1 u1 c -- ca2 u2 )

  _header _public,'SCAN'
scan_:
  pop de
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
scan_.1:
  ld a,c
  or b
  if size_optimization
    jr z,scan_.2
  else
    jp z,scan_.2
  endif
  ld a,e
  cp (hl)
  if size_optimization
    jr z,scan_.2
  else
    jp z,scan_.2
  endif
  inc hl
  dec bc
  jp scan_.1

scan_.2:
  ex (sp),hl
scan_.3:
  push bc
  ld c,l
  ld b,h
  jp next

; SKIP  ( ca1 u1 c -- ca2 u2 )

  _header _public,'SKIP'
skip_:
  pop de
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
skip_.1:
  ld a,c
  or b
  jp z,scan_.2
  ld a,e
  cp (hl)
  jp nz,scan_.2
  inc hl
  dec bc
  jp skip_.1

; -TRAILING  ( ca u1 -- ca u2 )

  _header _public,'-TRAILING'
minus_trailing_:
  pop de
  pop hl
  push hl
  add hl,de
  ex de,hl
minus_trailing_.1:
  dec de
  ld a,l
  or h
  jp z,push_hl
  ld a,(de)
  cp ' '
  jp nz,push_hl
  dec hl
  jp minus_trailing_.1

; /STRING  ( ca1 u1 n -- ca2 u2 )
;   rot over + -rot -

  _header _public,'/STRING'
slash_string_:
  pop de ; n
  pop hl ; u1
  call hl_minus_de_to_hl ; hl=u2
  ex (sp),hl ; (sp)=u2 hl=ca1
  add hl,de ; hl=ca2
  ex (sp),hl ; (sp)=ca2 hl=u2
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif


; XXX OLD 
;;; CAPS  ( -- )
;;; enable caps COMPARE/SEARCH
;;; XXX TODO use a user variable instead
;;  header public,'CAPS'
;;caps:
;;  ld a,1
;;  jp dcaps.1
;;
;;; -CAPS  ( -- )
;;;   disable caps COMPARE/SEARCH
;;; XXX TODO use a user variable instead
;;  header hidden,'-CAPS'
;;dcaps:
;;  xor a
;;dcaps.1:
;;  ld (scaps),a
;;  jp next

patch_compare_strings:

;  ; Patch an address with the address of the routine 'compare' and 'search' use_
;  ; to_ compare_ strings, which depends on_ a user variable.
  ;
;  ; This routine is_ called at the start of 'compare' and 'search', in order to_
  ; patch themselves.

  ; Input:
;  ;   DE = address to patch with the routine address

  push bc
  ld hl,(user_data_pointer)
  ld bc,case_sensitive_search_user_variable
  add hl,bc
  ld a,(hl)
  inc hl
  ld l,(hl)
  or l ; case_ sensitive search_?
  ld hl,compare_strings_case_insensitive ; routine
  if size_optimization
    jr z,patch_compare_strings.end
  else
    jp z,patch_compare_strings.end
  endif
  ld hl,compare_strings_case_sensitive ; routine
patch_compare_strings.end:
  ex de,hl
  ld (hl),e
  inc hl
  ld (hl),d
  pop bc
  ret

compare_strings_case_insensitive:
  ; Used by 'compare' and 'search'.
  ; Input:
  ;   HL = a1
  ;   BC = a2
  ;   DE = len
  ; Output:
  ;   Z = match?
  ld a,e
  or d
  ret z
  push bc
  ld a,(bc)
  call uppercase_a
  ld c,a
  ld a,(hl)
  call uppercase_a
  cp c
  pop bc
  ret nz
  inc hl
  inc bc
  dec de
  jp compare_strings_case_insensitive

; XXX OLD -- substituted by 'patchcomparestrings'
;;comparestrings:
;;  ; Input:
;;  ;   HL = a1
;;  ;   BC = a2
;;  ;   DE = len
;;  ; Output:
;;  ;   Z = match?
;;  push hl
;;  push de
;;  ld hl,(userdatapointer)
;;  ld de,casesensitivesearchuservariable
;;  add hl,de
;;  ld a,(hl) ; XXX TODO -- check the whole cell?
;;  or a
;;  pop de
;;  pop hl
;;  jp nz,comparestringscaseinsensitive

compare_strings_case_sensitive:
  ; Used by 'compare' and 'search'.
  ; Input:
  ;   HL = a1
  ;   BC = a2
  ;   DE = len
  ; Output:
  ;   Z = match?
  ld a,e
  or d
  ret z
  ld a,(bc)
  cp (hl)
  ret nz
  inc hl
  inc bc
  dec de
  jp compare_strings_case_sensitive

; COMPARE  ( ca1 u1 ca2 u2 -- -1 | 0 | 1 )

  _header _public,'COMPARE'
compare_:
  ld de,compare_.compare_strings
  call patch_compare_strings
  pop de
  pop hl
  ex (sp),hl
  ld a,d
  cp h
  jp nz,compare_.1
  ld a,e
  cp l
compare_.1:
  jp c,compare_.2
  ex de,hl
compare_.2:
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
  push af
compare_.compare_strings: equ $+1
  call 0 ; modifed
  if size_optimization
    jr z,compare_.4
  else
    jp z,compare_.4
  endif
  pop bc
compare_.3:
  pop bc
; XXX OLD -- Why this?:
;;  ld a,0
;;  ld (scaps),a
  jp c,one_
  jp z,false_
  jp true_

compare_.4:
  pop af
  jp compare_.3

; SEARCH  ( ca1 u1 ca2 u2 -- ca3 u3 -1 | ca1 u1 0 )

  _header _public,'SEARCH'
search_:
  ld de,search_.compare_strings
  call patch_compare_strings
  call do_colon
  dw $+2
  pop hl
  ld (string_2_len),hl
  ld a,l
  or h
  pop bc
  pop hl
  ld (string_1_len),hl
  ex de,hl
  pop hl
  ld (string_1_addr),hl
  jp z,search_.2
  dec hl
  inc de
search_.1:
  inc hl
  dec de
  ld a,e
  or d
  jp z,search_.4
; XXX commented out in DX-Forth:
; ld a,(bc)
; CP  (hl)
; jp nz,search.1
  push de
  push bc
  push hl
  ex de,hl
string_2_len equ $+1
  ld hl,0  ; length of_ the second string
  ex de,hl
search_.compare_strings: equ $+1
  call 0 ; modified
  pop hl
  pop bc
  pop de
  jp nz,search_.1

search_.2:
  ld bc,-1
search_.3:
  push hl
  push de
  push bc
; XXX OLD -- Why this?
;;  xor a
;;  ld (scaps),a
  jp paren_exit_

search_.4:
  ld bc,0
string_1_len equ $+1
  ld hl,0  ; length of_ the first string
  ex de,hl
string_1_addr equ $+1
  ld hl,0  ; address of_ the first string
  jp search_.3

;;; +STRING  ( ca1 u1 ca2 u2 -- ca2 u3)
;;;         2swap swap 2over + 2 pick cmove +
;;
;;  header 1,'+STRING'
;;pstr:
;;  call docolon
;;  dw twoswap,swap
;;  dw twoover,plus
;;  dw two,pick
;;  dw cmove,plus
;;  dw parenexit

; XXX NEW -- DX-Forth 4.09
; +STRING  ( ca1 u1 ca2 u2 -- ca2 u3)
;          2swap swap 2over + 2 pick cmove +

  _header _public,'+STRING'  ; uses temps 1-3
pstr_:
  ld l,c
  ld h,b
  ld (t3),hl    ; bsave
  pop de
  pop hl
  ld (t2),hl    ; a2
  add hl,de
  ex de,hl
  pop bc
  add hl,bc
  ld (t1),hl    ; u3
  pop hl
  call move_block_downwards
  ld hl,(t3)    ; bsave
  ld c,l
  ld b,h
  ld hl,t1
  jp two_fetch_.hl

; XXX TMP
t1: ds cw
t2: ds cw
t3: ds cw

; XXX NEW -- DX-Forth 4.09
; S.R  ( ca n1 n2 -- )
;   over - spaces type

  _header _public,'S.R'    ; type_ string right-justified
s_dot_r_:
  call do_colon
  dw over_,minus_
  dw spaces_
  dw type_
  dw paren_exit_

; UPCASE  ( c1 -- c2 )

  ; XXX FIXME repeated
  _header _public,'UPCASE'  ; make char_ uppercase
upcas_:
  pop hl
  ld a,l
  call uppercase_a
  jp push_a

; UPPER  ( ca u -- )

  _header _public,'UPPER' ; make string uppercase
upper_:
  pop de
  pop hl
upper_.1:
  ld a,d
  or e
  jp z,next
  ld a,(hl)
  call uppercase_a
  ld (hl),a
  inc hl
  dec de
  jp upper_.1

; XXX NEW -- after Gforth
; TOUPPER  ( c1 -- c2 )

  _header _public,'TOUPPER' ; make char_ uppercase

toupper_:
  pop hl
  ld a,l
  call uppercase_a
  jp next

uppercase_a:
  cp 'a'
  ret c
  cp 'z'+1
  ret nc
  xor 0x20
  ret

; XXX NEW -- after UPPER
; LOWER  ( ca u -- )

  _header _public,'LOWER' ; make string lowercase
lower_:
  pop de
  pop hl
lower_.1:
  ld a,d
  or e
  jp z,next
  ld a,(hl)
  call lowercase_a
  ld (hl),a
  inc hl
  dec de
  jp lower_.1

; XXX NEW -- after TOUPPER
; TOLOWER  ( c1 -- c2 )

  _header _public,'TOLOWER' ; make char_ lowercase

tolower_:
  pop hl
  ld a,l
  call lowercase_a
  jp next

lowercase_a:
  cp 'A'
  ret c
  cp 'Z'+1
  ret nc
  xor 0x20
  ret

; }}} **********************************************************
; Control structures {{{

; (OF)  ( n1 n2 -- n1 | )

  _header _hidden,'(OF)'
paren_of_:
  pop hl ; n2
  pop de ; n1
  call hl_minus_de_to_hl
  ld a,l
  or h ; n1=n2?
  jp z,question_branch_.1
  push de ; n1
  jp branch_

; BRANCH  ( -- )

  _header _hidden,'BRANCH'
branch_:
  ld h,b
  ld l,c
  ld c,(hl)
  inc hl
  ld b,(hl)
  jp next

; <>0BRANCH  ( flag -- )

  _header _hidden,'<>0BRANCH'
not_equals_0_branch_:
branch_if_not_0:
branch_if_not_false:
branch_if_not_zero:
branch_if_true:
  pop hl
  ld a,l
  or h
  jp nz,branch_
  if size_optimization
    jr question_branch_.1
  else
    inc bc
    inc bc
    jp next
  endif

; ?BRANCH  ( flag -- )

  _header _hidden,'?BRANCH'
question_branch_:
zero_branch:
branch_if_0:
branch_if_false:
branch_if_zero:
  pop hl
  ld a,l
  or h
  if size_optimization
    jr z,branch_
  else
    jp z,branch_
  endif
question_branch_.1:
  inc bc
  inc bc
  jp next

; (LOOP)  ( -- )

  _header _hidden,'(LOOP)'
paren_loop_:
  ld hl,(return_stack_pointer)
  inc (hl)
  jp nz,branch_
  inc hl
  inc (hl)
  jp nz,branch_
paren_loop_.1:
  inc bc    ; skip_ over_ branch_
  inc bc
  jp unloop_

; UNLOOP  ( -- )
; XXX FIXME add to the glossary

  _header _public,'UNLOOP'
unloop_:
  ld hl,(return_stack_pointer)  ; discard loop_ parameters
  ld de,cw*2
  add hl,de
  ld (return_stack_pointer),hl
  jp next

; (+LOOP)  ( n -- )

  _header _hidden,'(+LOOP)'
paren_plus_loop_:
  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  pop hl
  ld a,h
  or a
  jp m,paren_plus_loop_.2
  add hl,de
  jp c,paren_loop_.1
paren_plus_loop_.1:
  ex de,hl
  ld hl,(return_stack_pointer)
  ld (hl),e
  inc hl
  ld (hl),d
  jp branch_

paren_plus_loop_.2:
  add hl,de
  jp c,paren_plus_loop_.1
  jp paren_loop_.1

; (LEAVE)  ( -- )

  _header _hidden,'(LEAVE)'
paren_leave_:
  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a
  ld c,(hl)
  inc hl
  ld b,(hl)
  jp unloop_

; (?DO)  ( n1 n2 -- ) 2dup = if 2drop r> @ >r exit then (do.hl)

  _header _hidden,'(?DO)'
paren_question_do_:
  call do_colon
  dw two_dup_,equals_
  dw question_branch_,paren_do_.1
  dw two_drop_
  dw from_r_,fetch_,to_r_
  dw paren_exit_

; (DO)  ( n1 n2 -- )
;   over - r> cell+ -rot 2>r >r

  _header _hidden,'(DO)'
paren_do_:
  call do_colon
paren_do_.1: ; '(?do_)' jumps here_
  dw over_,minus_
  dw from_r_,cell_plus_
  dw minus_rot_
  dw two_to_r_
  dw to_r_
  dw paren_exit_

; BAL  ( -- a )

  _header _hidden,'BAL'
bal_:
  call do_create
bal_.variable:
  ds cw

; +BAL  ( -- )
;   1 bal +!

  _header _public,'+BAL'
plus_bal_:
  ld de,1
plus_bal_.1:
  ld hl,bal_.variable
  jp plus_store_.de_into_hl

; -BAL  ( -- )
;   -1 bal +!

  _header _public,'-BAL'
minus_bal_:
  ld de,-1
  jp plus_bal_.1

; ?BAL  ( flag -- )
;   checking @ 0<> and
;         abort" definition unbalanced"

  _header _public,'?BAL'
question_bal_:
  call do_colon
  dw checking_,fetch_
  dw zero_not_equals_,and_
  dw paren_abort_quote_
  _dcs 'definition unbalanced'
  dw paren_exit_

; ?DEPTH  ( x -- x )
;   ?comp depth 0= ?bal

  _header _hidden,'?DEPTH'
question_depth_:
  call do_colon
  dw question_comp_
  dw depth_,zero_equals_
  dw question_bal_
  dw paren_exit_

; ?ORIG  ( orig -- orig )
;   ?depth dup @ ?bal

  _header _hidden,'?ORIG'
question_orig_:
  call do_colon
  dw question_depth_
  dw dup_,fetch_
  dw question_bal_
  dw paren_exit_

; ?DEST  ( dest -- dest )
;   ?depth dup @ 0= ?bal

  _header _hidden,'?DEST'
qdest_:
  call do_colon
  dw question_depth_
  dw dup_,fetch_
  dw zero_equals_
  dw question_bal_
  dw paren_exit_

; BEGIN  ( -- dest )
;   ?comp here +bal ; immediate

  _header _public,'BEGIN',_immediate
begin_:
  call do_colon
  dw question_comp_
  dw here_
  dw plus_bal_
  dw paren_exit_

; >MARK  ( -- orig )
;   postpone begin 0 ,

  _header _public,'>MARK'
forward_mark_:
  call do_colon
  dw begin_
  dw zero_
  dw comma_
  dw paren_exit_

; <RESOLVE  ( dest -- )
;   ?dest , -bal

  _header _public,'<RESOLVE'
backward_resolve_:
  call do_colon
  dw qdest_
  dw comma_
  dw minus_bal_
  dw paren_exit_

; THEN  ( orig -- )
;   ?orig here swap ! -bal ; immediate

  _header _public,'THEN',_immediate
then_:
  call do_colon
  dw question_orig_
  dw here_
  dw swap_,store_
  dw minus_bal_
  dw paren_exit_

; IF  ( -- orig )
;   postpone ?branch >mark
;         ; immediate

  _header _public,'IF',_immediate
iff_:
  call do_colon
  dw compile_,question_branch_
  dw forward_mark_
  dw paren_exit_

; AHEAD  ( -- orig )
;   postpone branch >mark
;         ; immediate

  _header _public,'AHEAD',_immediate
ahead_:
  call do_colon
  dw compile_,branch_
  dw forward_mark_
  dw paren_exit_

; ELSE  ( orig1 -- orig2 )
;   ?orig postpone ahead swap postpone then ; immediate

  _header _public,'ELSE',_immediate
else_:
  call do_colon
  dw question_orig_
  dw ahead_
  dw swap_
  dw then_
  dw paren_exit_

; UNTIL  ( dest -- )
;   postpone ?branch <resolve
;         ; immediate

  _header _public,'UNTIL',_immediate
until_:
  ld hl,question_branch_
until_.1:
  push hl
  call do_colon
  dw compile_comma_
  dw backward_resolve_
  dw paren_exit_

; AGAIN  ( dest -- )
;   postpone branch <resolve ; immediate

  _header _public,'AGAIN',_immediate
again_:
  ld hl,branch_
  jp until_.1

; WHILE  ( x -- orig x )
;   ?depth postpone if swap ; immediate

  _header _public,'WHILE',_immediate
while_:
  call do_colon
  dw question_depth_
  dw iff_
  dw swap_
  dw paren_exit_

; REPEAT  ( orig dest -- )
;   postpone again postpone then
;         ; immediate

  _header _public,'REPEAT',_immediate
repeat_:
  call do_colon
  dw again_
  dw then_
  dw paren_exit_

; LV  ( -- a )
;   0 value lv

  _header _hidden,'LV'
lv_:
  call do_value
  dw 0

; DO  ( -- orig dest )
;   postpone (do) lv >mark dup to lv
;         postpone begin ; immediate

  _header _public,'DO',_immediate
do_:
  ld hl,paren_do_
do_.hl:
  push hl
  call do_colon
  dw compile_comma_
  dw lv_
  dw forward_mark_
  dw dup_
  dw paren_to_,lv_
  dw begin_
  dw paren_exit_

; ?DO  ( -- orig dest )
;   postpone (?do) lv >mark dup to lv
;         postpone begin ; immediate

  _header _public,'?DO',_immediate
question_do_:
  ld hl,paren_question_do_
  jp do_.hl

; I  ( -- x )

  _header _public,'I'
i_:
  ld hl,(return_stack_pointer)
i_.1:
  ld e,(hl)
  inc hl
  ld d,(hl)
i_.2:
  inc hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  add hl,de
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif


if 0 ; XXX commented out in DX-Forth_

; I'  ( -- x )

  _header _public,"I'"
i_tick_:
  ld hl,(return_stack_pointer)
  inc hl
  ld de,0
  jp i_.2

endif

; J  ( -- x )

  _header _public,'J'
j_:
  ld hl,(return_stack_pointer)
  ld de,cw*2
  add hl,de
  jp i_.1

; LEAVE  ( -- )
;   postpone (leave) lv ?orig ,
;         ; immediate

  _header _public,'LEAVE',_immediate
leave_:
  call do_colon
  dw compile_,paren_leave_
  dw lv_
  dw question_orig_
  dw comma_
  dw paren_exit_

; LOOP  ( a1 a2 -- )
;   postpone (loop) <resolve
;         postpone then to lv ; immediate

  _header _public,'LOOP',_immediate
loop_:
  ld hl,paren_loop_
loop_.1:
  push hl
  call do_colon
  dw compile_comma_
  dw backward_resolve_
  dw then_
  dw paren_to_,lv_
  dw paren_exit_

; +LOOP  ( a1 a2 -- )
;   postpone (+loop) <resolve
;   postpone then to lv ; immediate

  _header _public,'+LOOP',_immediate
plus_loop_:
  ld hl,paren_plus_loop_
  jp loop_.1

if control_flow_stack_extensions

; CS-PICK
;   pick +bal

  _header _public,'CS-PICK'
cs_pick_:
  call do_colon
  dw pick_
  dw plus_bal_
  dw paren_exit_

; CS-ROLL
;   aka roll cs-roll

  _header _public,'CS-ROLL',,roll_
cs_roll_: equ roll_

; CS-DROP
;   drop -bal

  _header _public,'CS-DROP'
cs_drop_:
  pop hl
  jp minus_bal_

; CS0  ( -- a )
; control flow stack base

  _header _hidden,'CS0'
cs0_:
  call do_create
cs0_.variable:
  ds cw

; #CS  ( -- cells )
;   sp@ cs0 @ - negate 2/ 1- 0 max

  _header _hidden,'#CS'
ncs_:
  ld hl,(cs0_.variable)
  call negate_hl
  add hl,sp
  call negate_hl
  call sra_hl
  dec hl
  push hl
  jp zero_max_

; CS-PUSH
;   #cs -roll

  _header _public,'CS-PUSH'
cs_push_:
  call do_colon
  dw ncs_
  dw minus_roll_
  dw paren_exit_

; CS-POP        #cs roll

  _header _public,'CS-POP'
cs_pop_:
  call do_colon
  dw ncs_
  dw roll_
  dw paren_exit_

; CS-MARK
;   0 +bal

  _header _public,'CS-MARK'
cs_mark_:
  ld hl,0
  push hl
  jp plus_bal_

; CS-TEST
;   ?depth dup 0<>

  _header _public,'CS-TEST'
cs_test_:
  call do_colon
  dw question_depth_
  dw dup_
  dw zero_not_equals_
  dw paren_exit_

; COND
;   ?comp cs-mark ; immediate

  _header _public,'COND',_immediate
cond_:
  call do_colon
  dw question_comp_
  dw cs_mark_
  dw paren_exit_

; THENS       ?comp begin cs-test while postpone
;         then repeat cs-drop ; immediate

  _header _public,'THENS',_immediate
thens_:
  call do_colon
  dw question_comp_
thens_.1:
  dw cs_test_
  dw question_branch_,thens_.2
  dw then_
  dw branch_,thens_.1
thens_.2:
  dw cs_drop_
  dw paren_exit_

else ; no control_flow_stack_extensions

; COND        ?comp 0 +bal ; immediate

  _header _public,'COND',_immediate
cond_:
  call do_colon
  dw question_comp_
  dw zero_
  dw plus_bal_
  dw paren_exit_

; THENS   
;   ?comp begin ?depth ?dup while
;   postpone then repeat -bal ; immediate

  _header _public,'THENS',_immediate
thens_:
  call do_colon
  dw question_comp_
thens_.1:
  dw question_depth_
  dw question_dup_
  dw question_branch_,thens_.2
  dw then_
  dw branch_,thens_.1
thens_.2:
  dw minus_bal_
  dw paren_exit_

endif ; control_flow_stack_extensions

; Eaker/ANS CASE support
;
; N.B. OF may be used in the form:  COND .. OF .. ELSE .. THENS

; OF  ( -- a )
;   postpone (of) >mark ; immediate

  _header _public,'OF',_immediate
of_:
  call do_colon
  dw compile_,paren_of_
  dw forward_mark_
  dw paren_exit_

; ENDOF  ( a1 -- a2 )
;   aka else endof

  _header _public,'ENDOF',_immediate,else_
endof_: equ else_

; CASE  ( -- sys )
;   aka cond case

  _header _public,'CASE',_immediate,cond_
case_: equ cond_

; ENDCASE  ( sys -- )
;   postpone drop postpone thens
;   ; immediate

  _header _public,'ENDCASE',_immediate
endcase_:
  call do_colon
  dw compile_,drop_
  dw thens_
  dw paren_exit_

; [ELSE]  ( -- )
;   1
;   begin
;     token 2dup upper dup if
;       2dup s" [IF]" compare if
;         2dup s" [ELSE]" compare if
;           s" [THEN]" compare 0=
;         else
;           2drop dup 1 =
;         then
;       else
;         2drop 1
;       then +
;     else
;       2drop refill and
;     then
;     ?dup 0=
;   until
; ; immediate

  _header _public,'[ELSE]',_immediate
bracket_else_:
  call do_colon
  dw one_
bracket_else_.1:
  dw token_
  if case_insensitive_names
    dw two_dup_,upper_
  endif
  dw dup_
  dw question_branch_,bracket_else_.6
  dw two_dup_
  dw paren_s_quot_
  _dcs '[IF]'
  dw compare_
  dw question_branch_,bracket_else_.4
  dw two_dup_
  dw paren_s_quot_
  _dcs '[ELSE]'
  dw compare_
  dw question_branch_,bracket_else_.2
  dw paren_s_quot_
  _dcs '[THEN]'
  dw compare_,zero_equals_
  dw branch_,bracket_else_.3
bracket_else_.2:
  dw two_drop_
  dw dup_,one_,equals_
bracket_else_.3:
  dw branch_,bracket_else_.5
bracket_else_.4:
  dw two_drop_,one_
bracket_else_.5:
  dw plus_
  dw branch_,bracket_else_.7
bracket_else_.6:
  dw two_drop_
  dw refill_,and_
bracket_else_.7:
  dw question_dup_,zero_equals_
  dw question_branch_,bracket_else_.1
  dw paren_exit_

; [IF]  ( flag -- )
; 0= if [compile] [else] then ; immediate

  _header _public,'[IF]',_immediate
bracket_if_:
  pop hl
  ld a,l
  or h
  jp z,bracket_else_
  jp next

; [THEN]  ( -- )
;   aka noop [then] immediate

  _header _public,'[THEN]',_immediate,noop_
bracket_then_: equ next

; }}} **********************************************************
; Numeric output {{{

; (D.)  ( d -- ca u )
;   tuck dabs <# #s rot sign #>

  _header _public,'(D.)'
paren_d_dot_:
  call do_colon
  dw tuck_
  dw d_abs_
  dw less_number_sign_
  dw number_sign_s_
  dw rot_,sign_
  dw number_sign_greater_
  dw paren_exit_

; U.R  ( u1 u2 -- ) 0 swap d.r

  _header _public,'U.R'
udotr_:
  ld hl,0
  ex (sp),hl
  push hl
  jp d_dot_r_

; XXX OLD -- DX-Forth 4.00
;;; D.R  ( d u -- )   >r (d.) r> over - spaces type
;;
;;  header 1,'D.R'
;;ddotr:
;;  call docolon
;;  dw tor
;;  dw parenddot
;;ddotr.1:
;;  dw fromr
;;  dw over,minus
;;  dw spaces
;;  dw type
;;  dw parenexit

; XXX NEW -- DX-Forth 4.09
; D.R  ( d n -- )
;   >r (d.) r> s.r

  _header _public,'D.R'
d_dot_r_:
  call do_colon
  dw to_r_
  dw paren_d_dot_
d_dot_r_.1:
  dw from_r_
  dw s_dot_r_
  dw paren_exit_

; .R  ( n u -- )
;   >r s>d r> d.r

  _header _public,'.R'
dot_r_:
  call do_colon
  dw to_r_
  dw s_to_d_
  dw from_r_,d_dot_r_
  dw paren_exit_

; U.  ( u -- )
;   0 d.

  _header _public,'U.'
u_dot_:
  ld hl,0
  push hl
  jp d_dot_

; D.  ( d -- )
;   0 d.r space

  _header _public,'D.'
d_dot_:
  call do_colon
  dw zero_,d_dot_r_
  dw space_
  dw paren_exit_

; XXX OLD -- DX-Forth 4.00
;;; ?  ( a -- )    @ .
;;
;;  header 1,'?'
;;ques:
;;  call docolon
;;  dw fetch,dot
;;  dw parenexit

; XXX NEW -- DX-Forth 4.09
; ?  ( a -- )

  _header _public,'?'
ques_:
  pop hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  jp dot_

; XXX OLD -- DX-Forth 4.00
;;; .  ( n -- )   s>d d.
;;
;;  header 1,'.'
;;dot:
;;  call docolon
;;  dw stod,ddot
;;  dw parenexit

; XXX NEW -- DX-Forth 4.09
; .  ( n -- )
;   decimal? if s>d d. exit then u.

  _header _public,'.'
dot_:
  call do_colon
  dw decimal_question_
  dw branch_if_false,dot_.not_decimal_base
;  ; decimal base_
  dw s_to_d_,d_dot_
  dw paren_exit_
dot_.not_decimal_base:
  dw u_dot_
  dw paren_exit_

; }}} **********************************************************
; DOS {{{

get_current_drive:
  ld a,0xff

set_current_drive:
;  ; a = drive (ASCII 'A'..'P' to_ set it; 0xff to get it)
  ld ix,dos_set_drive
  jr do_dos

get_current_user:
  ld a,0xff

set_current_user:
;  ; a = user_ (0x00..0x0f to_ set it; 0xff to get it)
  ld ix,dos_set_user

do_dos:
;  ; ix = DOS routine to run
  push bc
  call dos
  pop bc
  ret

dos:
 
  ; Adapted from the ZX Spectrum +3 manual.
  
;  ; IX holds the address of_ the DOS routine to be run. All other registers are
;  ; passed intact to the DOS routine and are returned from it.
  
;  ; Stack must be somewhere in central 32K (conforming to DOS requirements), so
  ; saved AF and BC will not be switched out.
  
  push af
  push bc                  ; temp save_ registers while_ switching
  ld   a,(sys_bankm)       ; RAM/ROM switching system_ variable_
  or   7                   ; want RAM page_ 7
  res  4,a                 ; and DOS ROM
  ld   bc,bank1_port       ; port used for horiz ROM switch and RAM paging
  di
  ld   (sys_bankm),a       ; keep system_ variables up to_ date
  out  (c),a               ; RAM page_ 7 to_ top and DOS ROM
  ei
  pop  bc
  pop  af

  call call_dos.ix         ; go sub routine address in IX

  push af
  push bc
  ld   a,(sys_bankm)
  and  0F8h                ; reset_ bits for page_ 0
  set  4,a                 ; switch to_ ROM 3 (48 BASIC)
  ld   bc,bank1_port
  di
  ld   (sys_bankm),a
  out  (c),a               ; switch back to_ RAM page_ 0 and 48 BASIC
  ei
  pop  bc
  pop  af
  ret

call_dos.ix:

  jp   (ix)                ; standard way to_ CALL (IX), by calling this jump

; DOS-VERSION  ( -- minor major )

  _header _public,'DOS-VERSION'
dos_version_:
  ld ix,dos_version
  call do_dos
push_version:
  ; d=issue = major
;  ; e=version (within issue) = minor
  xor a
  ld h,a
  ld l,e
  ld e,d
  ld d,a
  jp push_de_hl

; UNUSED-DISK ( c -- u )

  _header _public,'UNUSED-DISK'
unused_disk_:
  pop hl
  ld a,l
  ld ix,dos_free_space
  call do_dos
  jp nc,dos_error_.a
  jp push_hl

; DOS-ERROR ( +n -- )

  _header _public,'DOS-ERROR'

dos_error_:
  ; XXX TMP entry
  pop hl
  ld a,l

dos_error_.a:
  ; XXX TMP entry
;  ; a = DOS error code
  ld h,0
  ld l,a
  ld de,-1000
  sbc hl,de
  push hl
  jp throw_

; FDOS  ( DE u -- HL A )

  _header _public,'FDOS'
fdos_:
  ; XXX OLD
;;  pop hl
;;  ld a,l
;;  pop de
;;  call dodos
;;  push hl
;;  jp pusha
  ; XXX TODO
  jp next

; BDOS  ( DE u -- A )

  _header _public,'BDOS'
bdos_:
  ; XXX TODO
  call do_colon
  ; XXX OLD
;;  dw fdos,nip
  dw paren_exit_

; BIOS  ( BC u -- A )

  _header _public,'BIOS'
bios_:
  jp next
; XXX OLD
;;  pop  de
;;  ld a,e
;;  ld (biosparameterblock),a
;;  pop  hl
;;  ld (biosparameterblock+1),hl
;;  push  bc
;;  call biosj
;;  pop  bc
;;  jp pusha

; BIOSHL  ( DE BC u -- HL )

  _header _public,'BIOSHL'
;biosh:
; XXX OLD
;;  pop  de
;;  ld a,e
;;  ld (biosparameterblock),a
;;  pop  hl
;;  ld (biosparameterblock+1),hl
;;  pop  hl
;;  ld (biosparameterblock+3),hl
;;  push  bc
;;  call biosj
;;  pop  bc
;;  push hl
  jp next

; PC@  ( pa -- x )

  _header _public,'PC@'    ; FIG P@
p_c_fetch_:
  pop hl
  ld a,l
  ld (p_c_fetch_.1),a
  in  a,(0)    ; modified
p_c_fetch_.1  equ  $-1
  jp push_a

; PC!  ( x pa -- )

  _header _public,'PC!'    ; FIG P!
p_c_store_:
  pop hl
  pop de
  ld a,l
  ld (p_c_store_.1),a
  ld a,e
  out  (0),a    ; modified
p_c_store_.1  equ  $-1
  jp next

; ?TERMINAL  ( -- flag )

  _header _hidden,'?TERMINAL'
qterm_:
  call do_colon
; XXX OLD
;;  dw zero,two
;;  dw bios
; XXX TODO
  dw paren_exit_

; CONIN  ( -- c )
;
;       begin key? until 0 3 bios
;       (iofn+cw) @ over = if 0 bdos then

  _header _hidden,'CONIN'
conin_:
  call do_colon    ; console_ input
conin_.1:
; XXX TODO
;;  dw keyquestion
;;  dw questionbranch,conin.1
;;  dw zero,three
;;  dw bios
;;  dw lit,iofn+cw  ; ctl-C check
;;  dw fetch
;;  dw over,equals
;;  dw questionbranch,conin.end
;;  dw zero,bdos  ; exit to CP/M
conin_.end:
  dw paren_exit_

dcono:
  call do_colon
  dw two_
  dw bdos_,drop_
  dw paren_exit_

bcono:
  call do_colon
  ; XXX OLD
;;  dw clit
;;  db 4
;;  dw bios,drop
  ; XXX TODO
  dw paren_exit_

; CONOUT  ( c -- )

  _header _hidden,'CONOUT'
conout_:
; XXX TODO
;;  pop  de
;;  ld a,e
;;  cp  ff
;;  jp z,cls
;;  push  de
;;  ld hl,(iofn)
;;  jp (hl)
  jp next

; LSTOUT  ( c -- )

  _header _hidden,'LSTOUT'
lstout_:
  call do_colon
  dw c_lit_
  db 5
  dw bios_,drop_
  dw paren_exit_

; XXX OLD
;;;  ZENV  ( -- a )  return Z-System address (0=none)
;;
;;  header  1,'ZENV'
;;zenv:
;;  ld hl,(z3eadr)
;;  jp pushhl

; }}} **********************************************************
; Facility {{{

; (MS)  ( ms -- )

  _header _hidden,'(MS)'
paren_ms_:
  pop de
paren_ms_.1:
  ld a,e
  or d
  jp z,next
  ld hl,(speed)
  add hl,hl
  add hl,hl
  add hl,hl
paren_ms_.2:
  ex (sp),hl    ; 19T
  ex (sp),hl    ; 19T
  ex (sp),hl    ; 19T
  ex (sp),hl    ; 19T
  push hl    ; 11T
  pop hl    ; 10T
  dec  hl    ; 6T
  ld a,0    ; 7T
  ld a,l    ; 4T
  or h    ; 4T
  jp nz,paren_ms_.2    ; 10T
  dec  de
  jp paren_ms_.1

; MS  ( ms -- )

  _header _public,'MS'
ms_:
  call fetch_execute_
  dw paren_ms_

; }}} **********************************************************
; Sound {{{

; SOUND  ( freq ms -- )
;
;  header  1,'SOUND'
;sound:  call fetchexecute
;  dw sound0

; (BEEP)  ( -- )

  _header _hidden,'(BEEP)'
paren_beep_:
  call do_colon
  ; XXX TODO
  dw paren_exit_

; BEEP  ( -- )

  _header _public,'BEEP'
beep_:
  call fetch_execute_
  dw paren_beep_

cpbuf:
  ds 16

; }}} **********************************************************
; Input/output {{{

; PAUSE  ( -- )

  _header _public,'PAUSE' ; multitasking support
pause_:
;  ; XXX TODO -- use a self-modifing JP instead?
  call fetch_execute_
pause_.action: ; XXX TODO rename this label
  dw noop_   ; patched by COLD_

; KEY?  ( -- flag )

  ; XXX FIXME
  _header _public,'KEY?'
key_question_:
  ld hl,0 ; false_
  ld a,(sys_last_k)
  and a
  jp z,push_hl
  dec hl  ; true_
  jp push_hl

if 0 ; XXX TODO -- alternative
key_question_:
  ld hl,0 ; false_
  ld a,(sys_last_k)
  and a
  jp z,push_hl
  dec hl  ; true_
  jp push_hl
endif

; XXX OLD
;;  call docolon
;;  dw lit,vkeyq   ; (vkeyq)
;;  dw fetchexecute       ; @execute
;;  dw pause       ; pause
;;  dw parenexit

; KEY  ( -- c )

  _header _public,'KEY'
key_:
  ld a,(sys_last_k)
  ld (previous_key),a
key_.1
;  call pause ; XXX FIXME this causes trouble because of the way 'pause' calls 'fetchexecute'
;  ; call rom_keyboard ; XXX TODO not needed if system interrupts are on_
  ld a,(sys_last_k)
previous_key equ $+1
  cp 0 ; a different key_?
  jp z,key_.1
  ld l,a ; save_ the key_
  xor a
  ld (sys_last_k),a ; delete the last_ key_
  jp push_l

; XXX OLD
;;  call docolon
;;  dw lit,vkey
;;  dw fetchexecute
;;  dw pause
;;  dw parenexit

;;; INKEY  ( -- c ) ; XXX OLD -- try
  
;;  header public,'INKEY'
;;inkey:

;  ; XXX OLD Unfinished convertion from Benschop's Forth-83:
;;  push de
;;  call romkeyboard
;;  jp nz,noinkey
;;  call romkeytest
;;  jp nc,noinkey
;;  ld c,0
;;  dec d
;;  call romkeydecode
;;  pop de
;;  ; jr continue ; XXX in 'pkey'
;;noinkey
;;  pop de
;;  ld hl,0
;;  push hl
;;  jp next

; XXX unfinished conversion from Boriel's ZX BASIC; moved to 'KEY'
;;  call romkeyscan
;;  jp z,inkey
;;  call romkeytest
;;  jp nc,inkey
;;  dec d   ; D is expected to be FLAGS so set bit 3 $FF
;;          ; 'L' Mode so no keywords
;;  ld e, a ; main key to A
;;          ; C is MODE 0 'KLC' from above still
;;  call romkeydecode
;;  jp pusha

; SPACE  ( -- )

  _header _public,'SPACE'
space_:
  if fast_emit
    ld a,sp_char
    jp paren_emit_a
  else
    ld hl,sp_char
    push hl
    jp emit_
  endif

; (EMIT)  ( c -- )

  _header _public,'(EMIT)'
paren_emit_:
  pop hl
paren_emit_l:
  ld a,l
paren_emit_a:
  rst 0x10
  jp pause_

; EMIT  ( c -- )

  _header _public,'EMIT'
emit_:
  call fetch_execute_
  dw paren_emit_

; XXX OLD
;;;   (vemit) @execute 1 out +! pause
;;  call docolon
;;  dw lit,vemit
;;  dw fetchexecute
;;  dw one,out,plusstore
;;  dw pause
;;  dw parenexit

; TYPE  ( ca u -- )
; 0max 0 ?do count emit loop drop
; XXX TODO use ROM call instead
  _header _public,'TYPE'
type_:

; XXX OLD
;;  call docolon
;;  dw zeromax,zero
;;  dw parenquestiondo,type.2
;;type.do:
;;  dw count,emit
;;  dw parenloop,type.do
;;type.2:
;;  dw drop
;;  dw parenexit

  _save_ip
  call rom_chan_s ; set print to_ screen
  pop bc ; length
  pop de ; address
  call rom_print_string
restore_ip_next: equ $
saved_ip: equ $+1
  ld bc,0 ; restore IP
  jp next

; SPACES  ( +n -- )

  _header _public,'SPACES'
spaces_:
  call do_colon
  dw zero_max_,zero_ ; 0max 0
  dw paren_question_do_,spaces_.end ; ?do_
spaces_.do:
  dw space_
  dw paren_loop_,spaces_.do ; loop_
spaces_.end:
  dw paren_exit_

; CR  ( -- )

  _header _public,'CR'
cr_:
;  ; XXX TODO -- printer_ too? lfchar?
  if fast_emit
    ld a,cr_char
    jp paren_emit_a
  else
    ld hl,cr_char
    push hl
    jp emit_
  endif

; CONSOLE  ( -- )
;   (vcon) @ (vemit) !
;  ; set EMIT_ to terminal

  _header _public,'CONSOLE'
console_:
  ; XXX TODO
; XXX OLD
;;  ld hl,(vcon)
;;  ld (vemit),hl
  jp next

; PRINTER  ( -- )
;  ; set EMIT_ to printer_
  _header _public,'PRINTER'
printer_:
  ; XXX TODO
; XXX OLD
;;  ld hl,(vlst)
;;  ld (vemit),hl
  jp next

; }}} **********************************************************
; Compiler {{{

; WORDLIST-FIND  ( ca wid -- 0 | xt nfa -1 | xt nfa 1 )

  _header _public,'WORDLIST-FIND'
wordlist_find_:
  call do_colon   ; save_ IP
  dw $+2
  pop hl
  ld a,l
  or h
  jp z,wordlist_find_.2  ; wid=0
  ld e,(hl)
  inc hl
  ld d,(hl)
wordlist_find_.1:
  pop hl    ; string
  push hl
  ld a,e   ; end of_ list?
  or d
  ex de,hl
  jp nz,wordlist_find_.3
wordlist_find_.2:
  pop de    ; discard string
  jp wordlist_find_.6    ; no match

wordlist_find_.3:
  push hl    ; save_ nfa
  ld c,(hl)
  ld a,c
  and 0x1f
  ld b,a   ; dict name length
  ld a,(de)    ; string length
  xor c   ; check lengths/smudge_ bit
  and 0x3f
  jp z,wordlist_find_.5
  inc hl    ; to_ link
wordlist_find_.4:
  inc hl
  dec b
  jp nz,wordlist_find_.4
  ld e,(hl)    ; next nfa
  inc hl
  ld d,(hl)
  pop hl    ; discard old
  jp wordlist_find_.1

wordlist_find_.5:
  inc hl    ; check each char_
  inc de
  ld a,(de)
  if case_insensitive_names
    call uppercase_a
  endif
  ld c,a
  ld a,(hl)
  if case_insensitive_names
    call uppercase_a
  endif
  xor c
  jp nz,wordlist_find_.4 ; no match
  dec b
  jp nz,wordlist_find_.5
  inc hl    ; to_ link
  inc hl    ; to_ cfa pointer
  inc hl
  ld e,(hl)    ; get xt
  inc hl
  ld d,(hl)
  pop hl    ; nfa
  pop bc    ; discard string
  push de
  push hl
  ld a,(hl)
  and immediate_mask   ; immediate_?
  ld hl,-1
  jp z,wordlist_find_.6
  inc hl
  inc hl
wordlist_find_.6:
  push hl
  jp paren_exit_    ; restore IP

; (FIND)  ( ca -- ca 0 | xt -1 | xt 1 )
; searches CONTEXT CURRENT FORTH
;       0 3 0 do
;         over i cells context + @
;         wordlist-find ?dup if  nip 2nip leave  then
;       loop

  _header _hidden,'(FIND)'
paren_find_:
  call do_colon
  dw zero_,three_,zero_
  dw paren_do_,paren_find_.end
paren_find_.do:
  if 0 ;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'paren_find.do',cr_char
    dw key_,drop_
  endif
  dw over_
  dw i_,cells_
  dw context_,plus_,fetch_
  dw wordlist_find_,question_dup_
  dw question_branch_,paren_find_.loop
  dw nip_,two_nip_
  dw paren_leave_,paren_find_.do-cw
paren_find_.loop:
  if 0 ;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'paren_find.loop',cr_char
    dw key_,drop_
  endif
  dw paren_loop_,paren_find_.do
paren_find_.end:
  if 0 ;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'paren_find.end',cr_char
    dw key_,drop_
  endif
  dw paren_exit_

; FIND  ( ca -- ca 0 | xt -1 | xt 1 )

  _header _public,'FIND'
find_:
  call fetch_execute_
  dw paren_find_

if 0 ; XXX TODO -- commented out in DX-Forth_

; SEARCH-WORDLIST  ( ca u wid -- 0 | xt -1 | xt 1 )
;       >r wpack r> wordlist-find dup if nip then

  _header _public,'SEARCH-WORDLIST'
search_wordlist_:
  call do_colon
  dw to_r_,wpack_,from_r_
  dw wordlist_find_,dup_
  dw question_branch_,search_wordlist_.end
  dw nip_
search_wordlist_.end:
  dw paren_exit_

endif

if warning_options

; -?  ( -- ) ; XXX OLD
; disable warnings for next definition only
; warning @ $fffe and warning !

  _header _public,'-?'
minus_question_:
  ld hl,warning_.variable
  ld a,(hl)
  and 0xfe    ; clear bit 0
  ld (hl),a
  jp next

; WARNING?  ( -- 0|1 )
; get warning flag and apply mask
;
;     warning @ dup if dup 1 and tuck if -1
;     else $7fff and 1 then or warning ! then

  _header _hidden,'WARNING?'
warning_question_:
  call do_colon
  dw warning_,fetch_
  dw dup_
  dw question_branch_,warning_question_.end
  dw dup_,one_,and_ ; test bit 0
  dw tuck_
  dw question_branch_,warning_question_.1
  dw true_    ; enable all warnings
  dw branch_,warning_question_.2
warning_question_.1:
  dw lit_,0x7fff  ; disable compile_ warning_
  dw and_
  dw one_   ; enable redefinition warning_
warning_question_.2:
  dw or_
  dw warning_,store_
warning_question_.end:
  dw paren_exit_

endif

; IMMEDIATE  ( -- )

  _header _public,'IMMEDIATE'
immediate_:
  ld e,immediate_mask
  jp smudge_.1

; SMUDGE  ( -- )
;   $20 xnfa

  _header _public,'SMUDGE'
smudge_:
  ld e,smudge_mask
smudge_.1:
  push de
;  jp xnfa ; XXX OLD -- already commented out in DX-Forth

; XNFA  ( x -- )
;   toggle nfa bit

xnfa:
  ld hl,(last_.nfa)
  jp c_toggle_.hl

; HEADER  ( xt|0 "name" -- )

;       warning? 2>r
;       bl-word  ( ca )
;       dup c@ 32 1 within abort" invalid name"
;       dup find nip r> and 
;       if  dup count type ."  is redefined"  then
;       dup count tuck +
;       get-current wordlist>name over ! cell+ swap
;       5 + dph @ over dph +!  dup
;       get-current ! rot r>
;       ?dup 0= if  here  then
;       dup rot ! over last 2! swap
;       cmove

  _header _public,'HEADER'
header_:
  call do_colon
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'header',cr_char
  endif
  if warning_options
    dw warning_question_
  else
    dw warning_,fetch_
  endif
  ; ( xt|0 f1 "name" )
  dw two_to_r_
  dw bl_word_
  dw dup_,c_fetch_ ; name length
  dw c_lit_
  db 32
  dw one_,within_ ; not 1..32?
  dw paren_abort_quote_
  _dcs 'invalid name'
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'header after invalid name',cr_char
  endif
  ; ( ca )
  dw dup_,find_,nip_ ; ( ca f ) found?
  dw from_r_       ; ( ca f f1 ) is_ 'warning' on_?
  dw and_         ; ( ca wf )
  dw branch_if_zero,header_.1
;  ; the name was found and 'warning' is on_
  ; ( ca )
  dw dup_,count_,type_
  dw paren_dot_quote_
  _dcs ' is redefined'
header_.1:
;  ; the name was not found or 'warning' is off_
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'header.1',cr_char
  endif
  dw dup_,count_ ; ( ca ca1 len1 )
  dw tuck_      ; ( ca len1 ca1 len1 )
  dw plus_      ; ( ca len1 ca1+len1 )
  dw get_current_,wordlist_to_name_ ; ( ca len1 ca1+len1 nfa )
  dw over_,store_ ; ( ca len1 ) store_ nfa after the name
  dw cell_plus_,swap_ ; ( len1+cell ca )
  dw c_lit_
  db 5
  dw plus_ ; ( len1+cell ca+5 )
  dw dph,fetch_ ; ( len1+cell ca+5 dp_ )
;  ; XXX TODO -- keep on_ studying from here:
  dw over_,dph,plus_store_
  dw dup_
  dw get_current_
  dw store_   ; CP/M version
  dw rot_
  dw from_r_,question_dup_,zero_equals_
  dw question_branch_,header_.2
  dw here_
header_.2:
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'header.2',cr_char
  endif
  dw dup_,rot_,store_
  dw over_,last_,two_store_
  dw swap_,cmove_
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'header end',cr_char
  endif
  dw paren_exit_

; ,CALL ( a -- )  $CD c, ,

  _header _hidden,',CALL'
comma_call_:
  call do_colon
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'comma_call',cr_char
    dw key_,drop_
  endif
  dw c_lit_
  db 0xcd    ; Z80 'call' opcode
  dw c_comma_
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'comma_call after c_comma',cr_char
    dw key_,drop_
  endif
  dw comma_
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'comma_call at the end',cr_char
    dw key_,drop_
  endif
  dw paren_exit_

; BUILD ( xt "name" -- )

  _header _public,'BUILD'
build_:
  call do_colon
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'build',cr_char
    dw key_,drop_
  endif
  dw zero_,header_
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'build after header',cr_char
    dw key_,drop_
  endif
  dw comma_call_
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'build after comma_call',cr_char
    dw key_,drop_
  endif
  dw paren_exit_

; :  ( "name" -- )
;
;       (docolon) build smudge bal off !csp
;       sp@ cs0 ! ]

  _header _public,':'
colon_:
  call do_colon
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'colon',cr_char
    _show_depth
  endif
  dw lit_,do_colon
  dw build_
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'colon after build',cr_char
    _show_depth
  endif
  dw smudge_
colon_.1:
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'colon.1',cr_char
    _show_depth
  endif
  dw bal_,off_
  dw store_csp_
  if control_flow_stack_extensions
    dw sp_fetch_,cs0_,store_
  endif
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'colon after control flow',cr_char
    _show_depth
  endif
  dw right_bracket_
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'at colon exit',cr_char
    _show_depth
    dw dup_,dot_,cr_,cr_
  endif
  dw paren_exit_

; EXIT  ( -- )
;   postpone (exit) ; immediate

  _header _public,'EXIT',_immediate
exit_: ; XXX TODO rename 'exit'
  if  0;debug ; XXX INFORMER
    push af
    ld a,2
    out (254),a
    pop af
    ;jr $
  endif

  call do_colon

  if  0;debug ; XXX INFORMER
    ; XXX FIXME this resets the machine:
;    ;dw lit,2,border_
;    ;dw paren_dotquote_
;    ;_dcs 'exit',crchar
  endif

  dw compile_,paren_exit_
  if  0;debug ; XXX INFORMER
    ; XXX FIXME this resets the machine
;    ;dw lit,3,border_
;    ;dw paren_dotquote_
;    ;_dcs 'exit',crchar
  endif
  dw paren_exit_

; XXX TMP NEW layout
; : ;  ( -- )
;   postpone exit  bal @ ?bal ?csp smudge
;   postpone [
;   ; immediate

  _header _public,';',_immediate
semicolon_:
  call do_colon
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'semicolon',cr_char
    _show_depth
    dw dup_,dot_,cr_
  endif
  dw exit_
  if 0;debug ; XXX INFORMER
;    ;dw lit,2,border_
    ; XXX FIXME this resets the machine:
;    ;dw paren_dotquote_
;    ;_dcs 'semicolon after compiling (exit)',crchar
  endif
  dw bal_,fetch_
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'semicolon after bal@',cr_char
  endif
  dw question_bal_
  dw question_csp_
  dw smudge_
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'semicolon after smudge',cr_char
  endif
  dw left_bracket_
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'semicolon exit',cr_char
    _show_depth
    dw dup_,dot_,cr_
  endif
  dw paren_exit_

; :NONAME  ( -- xt )
;   warning? drop here dup (dummynfa) last 2!
;       (docolon) ,call bal off !csp sp@ cs0 ! ]

  _header _public,':NONAME'
nonam_:
  call do_colon
  if warning_options
    dw warning_question_,drop_  ; allow -?
  endif
  dw here_
  dw dup_    ; allow RECURSE_ etc
  dw lit_,dummy_nfa  ; allow IMMEDIATE_ etc
  dw last_,two_store_
  dw lit_,do_colon
  dw comma_call_
  dw branch_,colon_.1

; (;CODE)     r> last cell+ @ 1+ !

  _header _public,'(;CODE)'
paren_semicolon_code_:
  ld hl,(last_.xt)
  inc hl
  ld (hl),c
  inc hl
  ld (hl),b
  jp paren_exit_

; DOES>

  _header _public,'DOES>',_immediate
does_:
  call do_colon
  dw compile_,paren_semicolon_code_   ; postpone (;code)
  dw lit_,do_colon                   ; do_colon
  dw comma_call_                     ; ,call
  dw paren_exit_

; CREATE  ( -- a ) 'next build

  _header _public,'CREATE'
create_:
  ld hl,next
  push hl
  jp build_

; VARIABLE  ( -- a ) create 2 allot

  _header _public,'VARIABLE'
variable_:
  call do_colon
  dw create_
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'variable',cr_char
    dw key_,drop_
  endif
  dw two_,allot_
  dw paren_exit_

; VALUE  ( -- x )
;   (dovalue) build ,

  _header _public,'VALUE'
value_:
  call do_colon
value_.1:
  dw lit_,do_value
  dw build_
  dw comma_
  dw paren_exit_

; CONSTANT  ( -- x )
;   char? if (dobyteconstant) build c,
;       else value then

  _header _public,'CONSTANT'
constant_:
  call do_colon
  dw char_question_ ; 8-bit number?
  dw branch_if_false,value_.1 ; no
  ; yes
  dw lit_,do_byte_constant
  dw build_
  dw c_comma_
  dw paren_exit_

; 2VARIABLE  ( -- a )
;   create 4 allot

  _header _public,'2VARIABLE'
two_variable_:
  call do_colon
  dw create_
  dw c_lit_
  db 4
  dw allot_
  dw paren_exit_

; 2CONSTANT  ( -- x2 x1 )
;   (dotwoconstant) build , ,

  _header _public,'2CONSTANT'
two_constant_:
  call do_colon
  dw lit_,do_two_constant
  dw build_
  dw comma_,comma_
  dw paren_exit_

; USER  ( -- a )

  _header _public,'USER'
user_:
  call do_colon
  dw lit_,do_user_variable
  dw build_
  dw comma_
  dw paren_exit_

; ADDR  ( "name" -- a )
; Note: immediate, state-smart

  _header _public,'ADDR',_immediate
addr_:
  call do_colon
  dw tick_,to_body_           ; ' >body
  dw compiling_question_         ; state_?
  dw question_branch_,addr_.1 ; if
  dw literal_                ;   postpone literal_
addr_.1:                     ; then_
  dw paren_exit_

; (TO)  ( x -- )
;   r> dup cell+ >r @ >body !

  _header _hidden,'(TO)'
paren_to_:
  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a
  inc bc
  inc hl
  inc hl
  inc hl
  jp store_.into_hl_pointer

; TO  ( x "name" -- )
;
;   ' state? if postpone (to) , else >body !  then ; immediate
; Note: state-smart

  _header _public,'TO',_immediate
to_:
  call do_colon
  dw tick_
  dw compiling_question_
  dw question_branch_,to_.1
  dw compile_,paren_to_,comma_
  dw branch_,to_.end
to_.1:
  dw to_body_,store_
to_.end:
  dw paren_exit_

; (DEFER-DEFAULT)  ( -- )

  _header _public,'(DEFER-DEFAULT)'
paren_defer_default_:
  call do_colon
  dw one_
  dw paren_abort_quote_
  _dcs 'deferred word is uninitialized'
  dw paren_exit_

; DEFER-DEFAULT  ( -- )  gforth

  _header _public,'DEFER-DEFAULT'
defer_default_:
  call fetch_execute_
  dw paren_defer_default_

; DEFER  ( "name" -- )

;  ; XXX TODO simpler: use_ 'JP deferdefault' instead?
  ; It would be faster, but the xt would not be stored in the body.
  _header _public,'DEFER'
defer_:
  call do_colon
  dw lit_,fetch_execute_
  dw build_
  dw lit_,defer_default_,comma_
  dw paren_exit_

; IS  ( xt "name" -- )
;
; Note: state-smart

  ; XXX TODO simpler: see note in 'defer'
  _header _public,'IS',_immediate,to_
is_: equ to_

paren_is: equ paren_to_

; ALIAS  ( xt "newname" -- )

; XXX NEW -- after Gforth; alias don't copy the precedence bit of the xt
; XXX TODO -- test

  _header _public,'ALIAS'
alias_:
  call do_colon
  dw lit_,-1 ; flag for a not immediate_ word_
  dw branch_,aka_.alias

; AKA  ( "oldname" "newname" -- )
;   defined tuck ?defined (header)
;   $80 xnfa 0> if immediate then
  
  _header _public,'AKA'
aka_:
  call do_colon
  dw defined_         ; ( ca|xt -1|0|1 )
  dw tuck_             ; save_ for later
  dw question_defined_ ; abort_ if not defined
aka_.alias:
  ; ( -1|1 xt "newname" )
  dw header_           ; ( -1|1 )
  dw c_lit_
  db alias_mask
  dw xnfa             ; set the alias_ mask of_ the header_
  dw zero_greater_     ; is_ the old word_ immediate_?
  dw branch_if_false,aka_.end
  dw immediate_        ; make the new word_ immediate_
aka_.end:
  dw paren_exit_

; }}} **********************************************************
; Constants {{{

; TRUE  ( -- true )

  _header _public,'TRUE'
true_:
  ld hl,-1
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; FALSE  ( -- false )

  _header _public,'FALSE'
false_:
  ld hl,0
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; -1  ( -- -1 )
;   aka true -1

  _header _public,'-1',,true_
minus_one_: equ true_

; 0  ( -- 0 )
;   aka false 0

  _header _public,'0',,false_
zero_: equ false_

; 1  ( -- 1 )

  _header _public,'1'
one_:
  call do_byte_constant
  db 1

; 2  ( -- 2 )

  _header _public,'2'
two_:
  call do_byte_constant
  db 2

; 3  ( -- 3 )

  _header _public,'3'
three_:
  call do_byte_constant
  db 3

; BL  ( -- 32 )
;   ascii value for space character

  _header _public,'BL'
bl_:
  call do_byte_constant
  db sp_char

; B/BUF  ( -- u )
;   bytes per screen buffer

  _header _public,'B/BUF'
bytes_per_buffer_:
  call do_value
bytes_per_buffer_.value:
  dw 1024 ; default

; C/L  ( -- u )
;   chars per screen line

  _header _public,'C/L'
chars_per_line_:
  call do_value
chars_per_line_.value:
  dw 64 ; default

; For applications, LIMIT is the upper limit of available memory.
; In Forth, it is the beginning of the area which holds the screen file
; buffer, word headers and system definitions.

; LIMIT  ( -- a ) ; XXX OLD

  _header _public,'LIMIT'
limit_:
  call do_value   ; application_ word_ - used by BUF_
limit_.1:
  ds cw    ; patched by COLD_

; HBUF  ( -- a ) handle r/w buffer

  _header _hidden,'HBUF'
hbuf_:
  call do_value
hbuf_.1:
  ds cw    ; patched by COLD_

; 'NEXT  ( -- a )
;   address of NEXT

  _header _public,"'NEXT"
tick_next_:
  call do_constant
tick_next_.variable:
  dw next

; #FCB  ( -- u )
;   number of file handles

  _header _public,'#FCB'
nfcb_:
  call do_value
nfcb_.1:
  dw max_open_file_handles

; SYS-VEC  ( -- a )
;   system vector table

; XXX -- This word is not used in DX-Forth.
; It appears only in <misc.fs>, but commented out.
; XXX TODO -- The useful values could be converted to variables.

  _header _public,'SYS-VEC'
sysvec_:
  call do_create

vkeyq:
  dw qterm_   ;  0 KEY_?
vkey:
  dw conin_   ;  2 KEY_
vemit:
  dw conout_    ;  4 EMIT_
vcon:
  dw conout_    ;  6 CONSOLE_ out
vlst:
  dw lstout_    ;  8 PRINTER_ out
ainit:
  dw do_f_init_patch   ; 10 FINIT patch
aident:
  dw do_f_identify_patch   ; 12 FIDENTIFY patch
afnumb:
  dw interpret_.f_number_patch    ; 14 FNUMBER patch
nfps:
  dw f_stack_size   ; 16 floating point stack size (bytes)
anumb:
  dw interpret_.number_question_patch   ; 18 NUMBER? patch ; XXX FIXME not used to_ patch the code?
nfpm:
  dw f_stack_items*fw    ; 20 fp-stack min_ (bytes)
nrts:
  dw return_stack_size   ; 22 return_ stack (bytes)
nus:
  dw user_data_size    ; 24 user_ area (bytes)
npno:
  dw pictured_numeric_buffer_size   ; 26 HOLD_ buffer_ size (bytes)
;nmscon: ; XXX OLD
;  dw -2386   ; 28 MS timing constant 
;ntmode: ; XXX OLD
;  dw 3   ; 30 Timer 0 mode

; }}} **********************************************************
; Variables {{{

; UDP  ( -- a )
; user data pointer

  _header _public,'UDP'
udp_:
  call do_constant
  dw user_data_pointer

; FSP  ( -- a )
;   fp stack pointer

  _header _public,'FSP'
fsp_:
  call do_create
fsp_.variable:
  ds cw

; BOOT  ( -- xt )

  _header _hidden,'BOOT'
boot_:
  call do_create
boot_xt:
  dw 0

; SYS  ( -- a )
; compile system or application
; application word - used by HERE, UNUSED
; XXX OLD
  _header _public,'SYS'
sys_:
  call do_create
sys_.variable:
  dw 0

; LAST  ( -- a )
; occupies 2 cells
; XXX TODO separate:
; In Gforth: LATESTXT and LATEST

  _header _hidden,'LAST'
last_:
  call do_create
last_.nfa:
  ds cw
last_.xt:
  ds cw

; BLK

  _header _public,'BLK'
blk_:
  call do_create
blk_.variable:
  ds cw

; >IN

  _header _public,'>IN'
in_:
  call do_create
in_.variable:
  ds cw

; SCR
; occupies 2 cells

  _header _public,'SCR'
scr_:
  call do_create
  ds 2*cw

; STATE

  _header _public,'STATE'
state_:
  call do_create
state_.variable:
  ds cw

; 'SOURCE     occupies 2 cells

  _header _public,"'SOURCE"
tick_source_:
  call do_create
tick_source_.variable:
  ds 2*cw

; WARNING

  _header _public,'WARNING'
warning_:
  call do_create
warning_.variable:
  ds cw

; CSP

  _header _public,'CSP'
csp_:
  call do_create
csp_.variable:
  ds cw

; CHECKING

  _header _public,'CHECKING'
checking_:
  call do_create
checking_.variable:
  ds cw

; ERRMSG  ( -- a )
; message holder for abort"

  _header _hidden,'ERRMSG'
errmsg_:
  call do_create
  ds 2*cw

; CONTEXT  ( -- a )

  _header _public,'CONTEXT'
context_:
  call do_create
context_.variable:
  ds cw    ; context_
current.variable:
  ds cw    ; current
  dw forth_.1    ; Forth

; GET-CONTEXT  ( -- wid )

  _header _hidden,'GET-CONTEXT'
get_context_:
  ld hl,(context_.variable)
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; GET-CURRENT  ( -- wid )

  _header _public,'GET-CURRENT'
get_current_:
  ld hl,(current.variable)
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif
  

; SET-CURRENT  ( wid -- )

  _header _public,'SET-CURRENT'
set_current_:
  ld hl,current.variable
  jp store_.into_hl_pointer

; ZBUF  ( -- a )
; filename buffer pointers

  _header _hidden,'ZBUF'
zbuf_:
  call do_create
  dw zb.1 ; next buffer_
  dw zb.2 ; last_ buffer_

; }}} **********************************************************
; User variables {{{

; user variables 0, 2, 4 are reserved for multitasking

; S0  ( -- a )

  _header _public,'S0'
s0_:
  call do_user_variable
  dw 6

; R0  ( -- a )

  _header _public,'R0'
r0_:
  call do_user_variable
  dw 8

; DP  ( -- a )

  _header _public,'DP'
dp_:
  call do_user_variable
  dw 10

dph: equ dp_ ; XXX TMP NEW

; VOC-LINK  ( -- a )

  _header _public,'VOC-LINK'
voc_link_:
  call do_user_variable
  dw 14

; FS0  ( -- a )

  _header _public,'FS0'
fs0_:
  call do_user_variable
  dw 16

; user variable 18 reserved for future expansion

; End of boot-up literals

; DPL  ( -- a )

  _header _public,'DPL'
dpl_:
  call do_user_variable
  dw 20

; HLD  ( -- a )

  _header _hidden,'HLD'
hld_:
  call do_user_variable
  dw 22

; BASE  ( -- a )

  _header _public,'BASE'
base_:
  call do_user_variable
  dw 24

; bytes 26-27   reserved for locals

; OUT  ( -- a )

  _header _public,'OUT'
out_:
  call do_user_variable
  dw 28

; bytes 30-33   reserved

; CATCHER  ( -- a )

  _header _public,'CATCHER'
catcher_:
  call do_user_variable
  dw 34

; bytes 36-43   reserved

; XXX NEW -- this substitutes the old 'scaps', 'caps' and '-caps'
; CASE-SENSITIVE-SEARCH  ( -- a )
; case flag for 'compare' and 'search'

  _header _public,'CASE-SENSITIVE-SEARCH'
case_sensitive_search_:
  call do_user_variable
case_sensitive_search_user_variable: equ 44
  dw case_sensitive_search_user_variable

; User area bytes 46 onwards are available for user applications

; }}} **********************************************************
; Forth system {{{

; SYS?  ( -- flag ) sys@ 0<>

  ; XXX OLD
  _header _hidden,'SYS?'
sys_question_:
  ld hl,sys_.variable
sys_question_.1: ; XXX TODO rename, because it's used by other words
  ; XXX TODO -- faster method
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  jp zero_not_equals_

; COMPILING?  ( -- flag )
;   state @ 0<>

  _header _public,'COMPILING?'
compiling_question_:
  if 0 ; XXX OLD -- original method
    ld hl,state_.variable
    jp sys_question_.1
  else
    ; XXX NEW -- faster
    ld a,(state_.variable)
    ld l,a
    ld a,(state_.variable+1)
    ld h,a
    jp zero_not_equals_hl
  endif

; EXECUTING?  ( -- flag )
;   state @ 0<>

  _header _public,'EXECUTING?'
executing_question_:
  if 0 ; XXX OLD -- original method
    ld hl,state_.variable
    ld e,(hl)
    inc hl
    ld d,(hl)
    push de
    jp zero_equals_
  else
    ; XXX NEW -- faster
    ld a,(state_.variable)
    ld l,a
    ld a,(state_.variable+1)
    ld h,a
    jp zero_equals_hl
  endif

; CHECK?  ( -- flag ) checking @ 0<>

  _header _hidden,'CHECK?'
check_question_:
  ld hl,checking_.variable
  jp sys_question_.1

; APPLICATION  ( -- ) sys off

  _header _public,'APPLICATION'
application_:
  ld hl,sys_.variable
  jp off_.hl

; SYSTEM  ( -- )
;   sys on

  _header _public,'SYSTEM'
system_:
  ld hl,sys_.variable
  jp on_.hl

; XXX OLD
;;; h  ( -- a )    sys@ if dph else dp then
;;
;;  header hidden,'H'
;;hh:
;;  ld hl,(sys.variable)
;;  ld a,l
;;  or h
;;  jp z,dp
;;  jp dph

; ALLOT  ( n -- )
;   here over 0max dup unused u>
;       abort" no data space" erase h +!

  _header _public,'ALLOT'
allot_:
  call do_colon
  dw here_,over_
  dw zero_max_,dup_
  dw unused_,u_greater_
  dw paren_abort_quote_
  _dcs 'no data space'
  dw erase_
  dw dp_,plus_store_
  dw paren_exit_

; HERE  ( -- a )

  _header _public,'HERE'
here_:
  call do_colon
  dw dp_,fetch_
  dw paren_exit_

; C,  ( c -- )

  _header _public,'C,'
c_comma_:
  call do_colon
  dw here_,one_,allot_,c_store_
  dw paren_exit_

; ,  ( n -- )

  _header _public,','
comma_:
  call do_colon
  dw here_,two_,allot_,store_
  dw paren_exit_

; >BODY  ( xt -- pfa )

  _header _public,'>BODY'
to_body_:
  ld de,3
  jp plus_de

; BODY>  ( a -- xt ) 3 -
;
; XXX -- this word was commented out in DX-Forth, why?
  _header _hidden,'BODY>'
fbody_:
  ld de,-3
  jp plus_de

; XXX NEW -- DX-Forth 4.09
; N>COUNT  ( nfa -- ha len )
;   aka (name) n>count

  _header _hidden,'N>COUNT',,paren_name_
ncnt_: equ  paren_name_

; XXX OLD -- DX-Forth 4.00
;;; n>link  ( nfa -- lfa )
;;
;;  header x,'N>LINK',,1
;;nlnk:
;;  pop hl
;;  ld a,(hl)  ; name length and flags
;;  and 0x1f    ; name length only
;;  ld e,a
;;  ld d,0
;;  add hl,de
;;  inc hl
;;  jp pushhl

; XXX NEW -- DX-Forth 4.09
; N>LINK  ( nfa -- lfa )
;   n>count +

  _header _public,'N>LINK'
nlnk_:
  call do_colon
  dw ncnt_,plus_
  dw paren_exit_

; N>NAME  ( nfa1 -- nfa2 | 0 )

  _header _public,'N>NAME'
ntnam_:
  call do_colon
  dw nlnk_,fetch_  ; n>link @
  dw paren_exit_

; NAME>  ( nfa -- xt )

  _header _public,'NAME>'
namef_:
  call do_colon
  dw nlnk_,cell_plus_,fetch_ ; n>link cell+ @
  dw paren_exit_

; WORDLIST>NAME  ( wid -- nfa | 0 )
;   aka @ wordlist>name

  _header _public,'WORDLIST>NAME',,fetch_
wordlist_to_name_: equ fetch_

; -ALIAS  ( nfa -- nfa flag )
; false if alias
; XXX TODO rename
;   dup c@ $80 <

  _header _hidden,'-ALIAS'
minus_alias_:
  pop hl
  push hl
  ld a,(hl)
  cp alias_mask
  if size_optimization
    jp true_if_cy
  else
    jp c,true_
    jp false_
  endif

; XXX OLD -- DX-Forth 4.00
;;; >name  ( xt -- nfa | 0 )
;;;       voc-link begin @ dup while tuck 2-
;;;       wordlist>name begin ?dup while -alias if 2dup
;;;       name> = if -rot 2drop exit then then
;;;       n>name repeat swap repeat nip
;;
;;  header x,'>NAME',,1
;;toname:
;;  call docolon
;;  dw voclink
;;toname.1:
;;  dw fetch
;;  dw dup
;;  dw questionbranch,toname.5
;;  dw tuck
;;  dw twominus
;;  dw wordlisttoname
;;toname.2:
;;  dw questiondup
;;  dw questionbranch,toname.4
;;  dw minusalias    ; skip if alias
;;  dw questionbranch,toname.3
;;  dw twodup,namef
;;  dw equals
;;  dw questionbranch,toname.3
;;  dw minusrot,twodrop
;;  dw parenexit
;;toname.3:
;;  dw ntnam
;;  dw branch,toname.2
;;toname.4:
;;  dw swap
;;  dw branch,toname.1
;;toname.5:
;;  dw nip
;;  dw parenexit    ; not found

; XXX NEW -- DX-Forth 4.09
; >NAME  ( xt -- nfa | 0 )
;        voc-link begin @ dup while tuck cell- wordlist>name
;        begin ?dup while -alias if 2dup name> = if
;        -rot 2drop exit then then n>name repeat swap
;        repeat nip

  _header _public,'>NAME'
to_name_:
  call do_colon
  dw voc_link_
to_name_.1:
  dw fetch_
  dw dup_
  dw question_branch_,to_name_.5
  dw tuck_
  dw cell_minus_
  dw wordlist_to_name_
to_name_.2:
  dw question_dup_
  dw question_branch_,to_name_.4
  dw minus_alias_    ; skip_ if alias_
  dw question_branch_,to_name_.3
  dw two_dup_,namef_
  dw equals_
  dw question_branch_,to_name_.3
  dw minus_rot_,two_drop_
  dw paren_exit_
to_name_.3:
  dw ntnam_
  dw branch_,to_name_.2
to_name_.4:
  dw swap_
  dw branch_,to_name_.1
to_name_.5:
  dw nip_
  dw paren_exit_    ; not found

; XXX OLD -- DX-Forth 4.00
;;; (NAME)  ( nfa -- ca u ) count 31 and
;;
;;  header 1,'(NAME)',,1
;;parenname:
;;  call docolon
;;  dw count
;;  dw clit
;;  db 31
;;  dw and
;;  dw parenexit

; XXX NEW -- DX-Forth 4.09
; (NAME)  ( nfa -- ca u )
;   count 31 and

  _header _public,'(NAME)'
paren_name_:
  pop de
  ld a,(de)
  inc  de
  and 0x1f
  ld l,a
  ld h,0
  jp push_de_hl

; .ID  ( nfa | 0 -- )
;   ?dup if (name) type exit then
;         ." [noname]"

  _header _public,'.ID'
dotid_:
  call do_colon
  dw question_dup_
  dw question_branch_,dotid_.1
  dw paren_name_
  dw type_
  dw paren_exit_
dotid_.1:
  dw paren_dot_quote_
  _dcs '[noname]'
  dw paren_exit_

; .NAME  ( xt -- )
;   >name .id

  _header _public,'.NAME'
dot_name_:
  call do_colon
  dw to_name_,dotid_
  dw paren_exit_

; .WID  ( wid -- )
;   cell+ cell+ @ .id
; XXX Renamed to '.VOC' in DX-Forth 4.09
  _header _public,'.WID'
dotwid_:
  call do_colon
  dw cell_plus_,cell_plus_
  dw fetch_,dotid_
  dw paren_exit_

; !CSP  ( -- )
;   sp@ csp !

  _header _public,'!CSP'
store_csp_:
  ld hl,0
  add hl,sp
  ld (csp_.variable),hl
  jp next

; ?CSP  ( -- )
;   sp@ csp @ - ?bal

  _header _public,'?CSP'
question_csp_:
  call do_colon
  dw sp_fetch_
  dw csp_,fetch_
  dw minus_
  dw question_bal_
  dw paren_exit_

; ?COMP  ( -- )
;   state? 0= abort" compilation only'
; XXX TODO rename '?compiling'

  _header _public,'?COMP'
question_comp_:
  call do_colon
  dw compiling_question_,zero_equals_
  dw paren_abort_quote_
  _dcs 'compilation only'
  dw paren_exit_

; ?EXEC  ( -- )
;   compiling? abort" execution only'
; XXX TODO rename '?executing'

  _header _public,'?EXEC'
question_exec_:
  call do_colon
  dw compiling_question_
  dw paren_abort_quote_
  _dcs 'execution only'
  dw paren_exit_

; ?STACK  ( -- )
; XXX TODO finish
;       sp@ s0 @ u< abort" stack ?"
;       r0 @ rp@ u< rp@ fs0 @ u< or abort" r-stack?"
;       fs0 @ fsp @ u< fsp @ fs0 @ (nfpm) @ - u< or abort" f-stack?"

  _header _public,'?STACK'
question_stack_:
  call do_colon
;  dw parenexit ; XXX TMP
  dw sp_fetch_
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'SP = '
    dw dup_,u_dot_,cr_
  endif
  dw s0_,fetch_
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'S0 = '
    dw dup_,u_dot_,cr_
  endif
  dw u_greater_
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'result = '
    dw dup_,dot_,cr_
  endif
  dw paren_abort_quote_
  _dcs 'stack underflow'
  ; XXX TODO
;  dw spfetch,s0,fetch,uless
;  dw parenabortquote
;  dcs 'stack overflow'
  dw rp_fetch_,r0_,fetch_,u_greater_
  dw paren_abort_quote_
  _dcs 'return stack underflow'
  ; XXX TODO
;  dw rpfetch,r0,fetch,uless
;  dw parenabortquote
;  dcs 'return stack overflow'
;  XXX TODO -- fp stack, if separated
  dw paren_exit_

; ?DEFINED  ( flag -- )
;   0= abort" is undefined"

  _header _hidden,'?DEFINED'
question_defined_:
  call do_colon
  dw zero_equals_
  dw paren_abort_quote_
  _dcs 'undefined word'
  dw paren_exit_

; [ ( -- )
;   state off ; immediate

  _header _public,'[',_immediate
left_bracket_:
  ld hl,state_.variable
  jp off_.hl

; ] ( -- )
;   state on

  _header _public,']'
right_bracket_:
  ld hl,state_.variable
  jp on_.hl

; COMPILE,  ( xt -- )

  _header _public,'COMPILE,',,comma_
compile_comma_:  equ comma_
; XXX OLD
;compilecomma:
;  call docolon
;  dw warning,fetch
;  if warningoptions
;    dw zeroless
;  endif
;  dw questionbranch,compilecomma.end
;  dw dup,limit
;  dw uless
;  dw sysquestion
;  dw dzeroequals
;  dw questionbranch,compilecomma.end
;  dw dup
;  dw dotname
;  dw parendotquote
;  dcs ' is system '
;compilecomma.end:
;  dw comma
;  dw parenexit

; COMPILE  ( -- )
;   ?comp r> dup cell+ >r @ compile,

  _header _public,'COMPILE'
compile_:
  if  0;debug ; XXX INFORMER
    push af
    ld a,2
    out (254),a
    pop af
    ;jr $
  endif
  call do_colon
  dw question_comp_   ; prevent crash if interpreting
  dw from_r_
  dw dup_,cell_plus_
  dw to_r_
  dw fetch_
  dw compile_comma_
  dw paren_exit_

; POSTPONE  ( "name" -- )
;   defined dup ?defined 0< if compile
;   compile then compile, ; immediate

  _header _public,'POSTPONE',_immediate
postp_:
  call do_colon
  dw defined_
  dw dup_,question_defined_
  dw zero_less_
  dw question_branch_,postp_.1
  dw compile_,compile_
postp_.1:
  dw compile_comma_
  dw paren_exit_

; -CURSOR ( n -- ) ; XXX NEW
;   delete the cursor

  _header _hidden,'-CURSOR'

minus_cursor_:
  call do_colon
  dw space_
  dw c_lit_
  db left_char
  dw emit_
  dw paren_exit_

; BACKSPACES  ( +n -- )
;   delete +n chars at the left of the cursor

  _header _hidden,'BACKSPACES'

backspaces_:
  call do_colon
backspaces_.do:
  dw c_lit_
  db left_char
  dw dup_,emit_,space_,emit_
  dw one_minus_,dup_
  dw branch_if_not_false,backspaces_.do
  dw drop_
  dw paren_exit_

; (ACCEPT-CONTROL-CHAR)  ( ca len len2 c -- ca len len2' )

  _header _hidden,'(ACCEPT-CONTROL-CHAR)'

paren_accept_control_char_:

  call do_colon

  ; check the delete key_
  dw dup_,c_lit_
  db delete_char
  dw equals_ ; delete?
  dw branch_if_false,paren_accept_control_char_.edit
;  ; delete the last char_
  dw drop_ ; c
  dw dup_ ; something to_ delete?
  dw branch_if_zero,paren_accept_control_char_.end
;  ; do it
  dw minus_cursor_,one_minus_,one_,backspaces_
  dw paren_exit_

paren_accept_control_char_.edit:
  ; check the edit key_
  dw c_lit_
  db edit_char
  dw equals_ ; edit?
  dw branch_if_false,paren_accept_control_char_.end
  ; delete the whole input
  dw dup_ ; something to_ delete?
  dw branch_if_zero,paren_accept_control_char_.end
;  ; do it
  dw minus_cursor_,zero_,swap_,backspaces_

paren_accept_control_char_.end:
  dw paren_exit_

; (ACCEPT-CHAR)  ( ca len len2 c -- ca len len2' )

  _header _hidden,'(ACCEPT-CHAR)'

paren_accept_ascii_char_:
  call do_colon ; XXX entry not used

paren_accept_ascii_char_.0:
  dw to_r_,two_dup_,minus_,from_r_,swap_ ; space_ left
  dw branch_if_0,paren_accept_ascii_char_.no

;  ; there's space left for the char_
  if 0 ; debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs '{space left}'
  endif
  dw dup_,emit_,over_
  dw c_lit_
  db 4
  dw pick_,plus_,c_store_,one_plus_
  dw paren_exit_

paren_accept_ascii_char_.no:
;  ; no space left for the char_
  if 0 ; debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs '{no space left!}'
  endif
  dw drop_
  dw paren_exit_


; (ACCEPT-KEY)  ( ca len len2 c -- ca len len2' )

  _header _hidden,'(ACCEPT-KEY)'

paren_accept_key_:
  call do_colon
  dw dup_,bl_,less< ; control char
  dw branch_if_true,paren_accept_control_char
  dw branch_if_true,paren_accept_ascii_char_.0 ; ASCII
  ; not ASCII
  dw paren_accept_control_char_
  dw paren_exit_


; (ACCEPT)  ( ca len -- len2 )

  _header _hidden,'(ACCEPT)'
paren_accept_:
  call do_colon
  if 0 ; debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs '(ACCEPT)',cr_char
  endif
  dw zero_ ; len2
paren_accept_.do:
  dw c_lit_
  db 143 ; XXX TMP cursor
  dw emit_
  dw c_lit_
  db bs_char
  dw emit_
  dw key_,dup_
  dw c_lit_
  db cr_char
  dw equals_  ; enter key_?
  dw branch_if_true,paren_accept_.end
  dw paren_accept_key_
  dw branch_,paren_accept_.do
paren_accept_.end:
  dw minus_cursor_,space_
  dw drop_,nip_,nip_
  dw paren_exit_

; ACCEPT  ( ca +n1 -- +n2 )

  _header _public,'ACCEPT'
accept_:
  call fetch_execute_
  dw paren_accept_

if tib_words

; TIB  ( -- a )
; address of the terminal input buffer

  _header _public,'TIB'

tib_:
  ld hl,tib_address
  jp push_hl

; #TIB  ( -- u )
; characters in the terminal input buffer

  _header _public,'#TIB'

number_tib_:
  call do_variable
  dw 0

endif

; PAD  ( -- a )
;   dp @ (npno) @ +

  _header _public,'PAD'
pad_:
  call do_colon
  dw dp_,fetch_
  dw lit_,npno
  dw fetch_
  dw plus_
  dw paren_exit_

; SOURCE  ( -- ca u )
;   'source 2@

  _header _public,'SOURCE'
source_:
  ld hl,tick_source_.variable
  jp two_fetch_.hl

; PARSE  ( c -- ca u )
;   0 (parse)

  _header _public,'PARSE'
parse_:
  ld hl,0
  push hl
  jp paren_parse_

; (PARSE)  ( c f -- ca u )
;         2>r source >in @ /string r> if tuck
;         r@ skip over - >in +! then 2dup r>
;         scan nip tuck - dup rot 0<> - >in +!

  _header 0,'(PARSE)'
paren_parse_:
  call do_colon
  dw two_to_r_
  dw source_
  dw in_,fetch_,slash_string_
  dw from_r_
  dw question_branch_,paren_parse_.1
  dw tuck_
  dw r_fetch_,skip_
  dw rot_,over_,minus_
  dw in_,plus_store_
paren_parse_.1:
  dw two_dup_
  dw from_r_
  dw scan_,nip_
  dw tuck_
  dw minus_,dup_
  dw rot_,zero_not_equals_
  dw minus_
  dw in_,plus_store_
  dw paren_exit_

; +PSB  ( a1 n1 n2 -- n3 )
;   >r (parsedstringbuffersize) r@ - umin r> 2dup + >r
;   (parsedstringbuffer) + swap cmove r>

  _header _hidden,'+PSB'
ppsb_:
  call do_colon
  dw to_r_
  dw lit_,parsed_string_buffer_size
  dw r_fetch_,minus_
  dw u_min_
  dw from_r_
  dw two_dup_,plus_
  dw to_r_
  dw lit_,parsed_string_buffer
  dw plus_
  dw swap_
  dw cmove_
  dw from_r_
  dw paren_exit_

; PARSE$  ( c "ccc" -- a n )
;         0 begin >r dup parse 2dup r> +psb >r
;         1+ + dup source + u< while 2dup c@ =
;         while 1 dup >in +! r> +psb repeat
;         then 2drop (parsedstringbuffer) r>

  _header _public,'PARSE$'
parse_dollar_:
  call do_colon
  dw zero_
parse_dollar_.1:
  dw to_r_
  dw dup_,parse_
  dw two_dup_
  dw from_r_,ppsb_
  dw to_r_
  dw one_plus_,plus_
  dw dup_
  dw source_,plus_
  dw u_less_
  dw question_branch_,parse_dollar_.2
  dw two_dup_,c_fetch_
  dw equals_
  dw question_branch_,parse_dollar_.2
  dw one_,dup_
  dw in_,plus_store_
  dw from_r_,ppsb_
  dw branch_,parse_dollar_.1
parse_dollar_.2:
  dw two_drop_
  dw lit_,parsed_string_buffer
  dw from_r_
  dw paren_exit_

; PWA  ( -- adr )
; parsed word address

  _header _hidden,'PWA'
pwa_:
  call do_value
  ds cw

; WPACK  ( ca1 +n -- ca2 )
;   255 min (hm-5) over - dup to pwa packed
;   bl affix

  _header _hidden,'WPACK'
  ; pack string in WORD's buffer_
wpack_:
  call do_colon
  dw c_lit_
  db 255          ; 255
  dw min_          ; min_
  if  classic_Forth_behaviours
    dw dp_,fetch_     ; dp_ @
  else
    dw lit_,hm-5     ; (hm) 5 -
    dw over_,minus_   ; over_ -
  endif
  dw dup_
  dw paren_to_,pwa_ ; to_ pwa_
  dw packed_
  dw bl_,affix_     ; bl_ affix_ \ add a trailing blank_
  dw paren_exit_

; WORD  ( c -- ca )

  _header _public,'WORD'
word_:
  call do_colon
  dw true_,paren_parse_,wpack_
  dw paren_exit_

; BL-WORD  ( -- ca )

  _header _public,'BL-WORD'
bl_word_:
  ld hl,sp_char
  push hl     ; bl_
  jp word_     ; word_

; TOKEN  ( "name" -- ca u )

  _header _public,'TOKEN'
token_:
  call do_colon
  dw bl_word_,count_ ; bl_-word_ count_
  dw paren_exit_

; DEFINED  ( -- ca 0 | xt -1 | xt 1 )

  _header _hidden,'DEFINED'
defined_:
  call do_colon
  dw bl_word_,find_ ; bl_-word_ find_
  dw paren_exit_

; '  ( -- a )

  _header _public,"'"
tick_:
  call do_colon
  dw defined_,question_defined_ ; defined ?defined
  dw paren_exit_

; [UNDEFINED]  ( -- flag )
;   defined nip 0= ; immediate

  _header _public,'[UNDEFINED]',_immediate
budef_:
  call do_colon
  dw defined_
  dw nip_
  dw zero_equals_
  dw paren_exit_

; [DEFINED]  ( -- flag )
;   postpone [undefined] 0= ; immediate

  _header _public,'[DEFINED]',_immediate
bdef_:
  call do_colon
  dw budef_,zero_equals_
  dw paren_exit_

; (  ( "ccc<delim>" ) [char] ) parse 2drop ; immediate

  _header _public,'(',_immediate
paren_:
  call do_colon
  dw c_lit_
  db ')'
  dw parse_,two_drop_
  dw paren_exit_

; .(  ( "ccc<delim>" )
;   [char] ) parse$ type ; immediate

  _header _public,'.(',_immediate
dot_paren_:
  call do_colon
  dw c_lit_
  db ')'
  dw parse_dollar_,type_
  dw paren_exit_

; \  ( "ccc" -- )
;   source nip blk @ if c/l >in @ over / 1+ *
;       min then >in ! ; immediate

  _header _public,'\',_immediate
back_slash_:
  call do_colon
  dw source_,nip_
  dw blk_,fetch_
  dw question_branch_,back_slash_.1
  dw chars_per_line_
  dw in_,fetch_
  dw over_,slash_
  dw one_plus_,star_
  dw min_
back_slash_.1:
  dw in_,store_
  dw paren_exit_

; \\  ( "ccc" -- )
;   source nip >in ! ; immediate

  _header _public,'\\',_immediate
back_slashes_:
  call do_colon
  dw source_,nip_,in_,store_
  dw paren_exit_

; XXX NEW -- DX-Forth 4.09
; LINK,  ( a -- )
;   here over @ , swap !

  _header _public,'LINK,'
link_comma_:
  call do_colon
  dw here_
  dw over_,fetch_
  dw comma_
  dw swap_,store_
  dw paren_exit_

; XXX OLD -- DX-Forth 4.00
;;; WORDLIST  ( -- wid )  $2001 , here 0 , here dup voc-link @ , !
;;;       0 ,
;;
;;  header 0,'WORDLIST'
  ; nameless wordlists not supported
;;wordlist:
;;  call docolon
;;  dw lit,0x2001
;;  dw comma
;;  dw here
;;  dw zero    ; nfa of top word in vocabulary
;;  dw comma
;;  dw here,voclink
;;  dw dup,fetch   ; link to previous vocabulary
;;  dw comma
;;  dw store
;;  dw zero,comma  ; null name
;;  dw parenexit

; XXX NEW -- DX-Forth 4.09
; WORDLIST  ( -- wid )
;   $2001 , here 0 , voc-link link, 0 ,

  _header _hidden,'WORDLIST'
wordlist_:
  call do_colon
  dw lit_,0x2001
  dw comma_
  dw here_
  dw zero_    ; nfa of_ top word_ in vocabulary_
  dw comma_
  dw voc_link_,link_comma_  ; link in wordlist_
  dw zero_,comma_  ; null name
  dw paren_exit_

; VOCABULARY  ( "name" )
;       sys? system wordlist
;       ;;  create dup ,  ;; XXX OLD -- DX-Forth 4.00
;       dup value  ;; XXX NEW -- DX-Forth 4.09
;       last @
;       swap cell+ cell+ ! sys ! does> @ context !

  _header _public,'VOCABULARY'
vocabulary_:
  call do_colon
  dw sys_question_
  dw system_
  dw wordlist_
;;  dw create,dup,comma ; XXX OLD -- DX-Forth 4.00
  dw dup_,value_ ; XXX NEW -- DX-Forth_ 4.09
  dw last_,fetch_   ; set name field in wordlist_ struct
  dw swap_
  dw cell_plus_,cell_plus_
  dw store_
  dw sys_,store_
  dw paren_semicolon_code_
do_vocabulary:
  call do_colon
  dw fetch_
  dw context_,store_
  dw paren_exit_

; DEFINITIONS  ( -- ) get-context set-current

  _header _public,'DEFINITIONS'
definitions_:
  call do_colon
  dw get_context_
  dw set_current_
  dw paren_exit_

; wordlist structure

; XXX TODO -- study how this works

forth_.3: defl previous_nfa

  dw 0x2001    ; dummy nfa for vocabulary_ chaining
forth_.1: ; XXX TODO rename this label
  dw top_nfa    ; nfa of_ top word_ in vocabulary_
forth_.2: ; XXX TODO rename this label
  dw 0   ; previous vocabulary_
  dw forth_.3    ; vocabulary_ nfa

; FORTH  ( -- )
; Forth vocabulary 

  _header _public,'FORTH'
forth_:
  call do_vocabulary
  dw forth_.1

; UNUSED  ( -- u )
;
; Free memory in bytes.

  _header _public,'UNUSED'
unused_:
  call do_colon
  dw lit_,0xffff,here_,minus_
  dw paren_exit_

; INTERPRET  ( -- )

  _header _public,'INTERPRET'
interpret_:
  call do_colon
interpret_.begin:
  if debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'interpret.begin',cr_char
  endif
  dw bl_word_
  if debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'interpret after bl_word',cr_char
  endif
  dw dup_,c_fetch_
  dw branch_if_0,interpret_.end  ; while_ not end of_ input stream
  if debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'interpret before find',cr_char
  endif
  dw find_
  if debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'interpret after find',cr_char
;    ;dw dot_,dot,bye_
  endif
  dw question_dup_
  dw branch_if_0,interpret_.not_found

  ; found
  ; ( xt 1 | xt -1 )
  if debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'interpret -- found',cr_char
;    ;dw dot_,dot,bye_
  endif
  dw compiling_question_,equals_ ; compiling an immediate_ word_?
  dw branch_if_false,interpret_.execute

  ; compiling and not immediate_
  dw compile_comma_
  dw branch_,interpret_.repeat

interpret_.execute:
  ; executing or immediate_
  if debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'interpret.execute ',cr_char
  endif
  dw execute_
  dw branch_,interpret_.repeat

interpret_.not_found:
  ; ( ca )
  if debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'interpret.not_found ',cr_char
  endif
  dw base_,fetch_,to_r_ ; save_ the current base_
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'interpret: the string address is '
;    ;dw decimal_,dot_,cr,bye_
  endif
  dw count_,over_,c_fetch_ ; get the string and its first char_
  ; ( ca len c )
  if 0; debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'interpret: the first char is '
    dw dup_,decimal_,dot_,cr_,bye_
  endif

;  ; XXX TODO -- factor out to_ a new word the number recognition with prefixes
  ; -- see Gforth's '>number', 'number?', 'snumber?'...

;  ; XXX TODO recognize also chars: 'c'

  ; ( ca len c )
  dw c_lit_
  db '$'
  dw paren_of_,interpret_.check_binary
;  ; it's "$" -- hex number
  if debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'interpret: hex prefix found',cr_char
  endif
  dw hex_,one_
  dw branch_,interpret_.remove_the_prefix

interpret_.check_binary:
  ; ( ca len c )
  dw c_lit_
  db '%'
  dw paren_of_,interpret_.check_decimal
;  ; it's "%" -- binary number
  if debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'interpret: binary prefix found',cr_char
  endif
  dw binary_,one_
  dw branch_,interpret_.remove_the_prefix

interpret_.check_decimal:
  ; ( ca len c )
  dw c_lit_
  db '#'
  dw paren_of_,interpret_.check_char
;  ; it's "#" -- decimal number
  if debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'interpret: decimal prefix found',cr_char
  endif
  dw decimal_,one_
  dw branch_,interpret_.remove_the_prefix

interpret_.check_char:
;  ; there is no number prefix.
;  ; does_ the string represent_ a char?
;  ; this check is done at the end, because it's easier not
;  ; to_ use_ '(of)' with it.
  ; ( ca len c )
  if 1;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'interpret.check_char',cr_char
;    ; dw dup_,dot_ ; case selector
  endif
  dw c_lit_
  db "'"
  dw equals_ ; is_ the first char_ a single quote?
  dw branch_if_false,interpret_.number_question ; no
;  ; the first char_ is a single quote
  if 1;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'interpret.check_char first quote',cr_char
;    ; dw dup_,dot_ ; case selector
  endif
  dw dup_,three_,equals_ ; len is_ 3?
  dw branch_if_false,interpret_.number_question ; no
;  ; len is 3
  if 1;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'interpret.check_char len 3',cr_char
;    ; dw dup_,dot_ ; case selector
  endif
  dw two_dup_,plus_,one_minus_,c_fetch_
  dw c_lit_
  db "'"
  dw equals_ ; is_ the last_ char_ a single quote?
  dw branch_if_false,interpret_.number_question ; no
;  ; the last_ char_ is a single quote
  if 1;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'interpret.check_char last quote',cr_char
;    ; dw dup_,dot_ ; case selector
  endif
  dw drop_,one_plus_,c_fetch_
  if 1;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'interpret.check_char char_='
    dw dup_,dot_,cr_ ; case_ selector
  endif
  dw branch_,interpret_.single_number

interpret_.remove_the_prefix:
  ; ( ca len n )
  if debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'interpret.remove_the_prefix',cr_char
;    ;dw dot_,dot_,dot,bye_
  endif
  dw slash_string_

interpret_.number_question:
  ; The number prefix, if any, has been removed.
;  ; Is_ the string a number in the current base?
  ; ( ca len )
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'interpret.number_question',cr_char
    dw cr_,two_dup_,type_,cr_
  endif
  dw two_dup_
interpret_.number_question_patch: ; XXX not used
  dw number_question_       ; NUMBER? patch ; XXX not patched
  if 0;debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'after number_question',cr_char
  endif
  dw branch_if_false,interpret_.f_number_patch
  if debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'it is a number!',cr_char
  endif
  dw two_nip_
  dw dpl_,fetch_,zero_less_ ; single number?
  dw branch_if_false,interpret_.double_number
  dw drop_
interpret_.single_number:
  dw compiling_question_ ; compiling?
;  dw branchiffalse,interpret.9 ; XXX OLD
  dw branch_if_false,interpret_.number_done ; XXX NEW
  dw literal_
;interpret.9: ; XXX OLD
;  dw branch,interpret.notanumber ; XXX why?
  dw branch_,interpret_.number_done ; XXX NEW

interpret_.double_number:
  dw compiling_question_ ; compiling?
;  dw questionbranch,interpret.notanumber ; XXX why?
  dw branch_if_false,interpret_.number_done ; XXX NEW
  dw two_literal_
  dw branch_,interpret_.number_done ; XXX NEW

;interpret.notanumber:
;  dw true
;  dw branch,interpret.questiondefined

interpret_.f_number_patch:
  ; ( ca len )
  dw f_number_patch       ; XXX patched
  ; ( flag )
  if debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'after interpret_.f_number_patch',cr_char
  endif

; XXX OLD
;interpret.questiondefined:
  ; ( flag -- )
;  ; abort if flag<>0
  if 0; debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'before question_defined',cr_char
  endif
  dw question_defined_
  if 0; debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'after question_defined',cr_char
  endif

interpret_.number_done:
  dw from_r_,base_,store_

interpret_.repeat:
  if debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'interpret.repeat',cr_char
  endif
  dw question_stack_
  dw branch_,interpret_.begin

interpret_.end:
  if debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'interpret.end ',cr_char
  endif
  dw drop_
;  dw branch,$ ; XXX TMP
  dw paren_exit_

; (EVALUATE)  ( ca u blk -- )
;
; does not restore block contents
;
;         blk @ >in @ 2>r source 2>r blk !
;         'source 2! >in off interpret 2r>
;         'source 2! 2r> >in ! blk !

  _header _hidden,'(EVALUATE)'
paren_evaluate_:
  call do_colon
  dw blk_,fetch_
  dw in_,fetch_
  dw two_to_r_
  dw source_,two_to_r_
  dw blk_,store_
  dw tick_source_,two_store_
  dw in_,off_     ; reset_ >IN
  dw interpret_
  dw two_from_r_,tick_source_,two_store_
  dw two_from_r_
  dw in_,store_
  dw blk_,store_
  dw paren_exit_

; ?BLOCK   ( -- )
; reload block
; blk @ ?dup if block drop then

  _header _hidden,'?BLOCK'
question_block_:
  call do_colon
  dw blk_,fetch_,question_dup_
  dw question_branch_,question_block_.end
  dw block_,drop_
question_block_.end:
  dw paren_exit_

; EVALUATE  ( ca u -- ) 0 (evaluate) ?block

  _header _public,'EVALUATE'
evaluate_:
  call do_colon
  dw zero_,paren_evaluate_
  dw question_block_
  dw paren_exit_

; (REFILL)  ( -- flag )
; doesn't correctly handle source

; blk @ ?dup if
;   1+ dup #screens u< and dup
;   while
;     dup blk ! block b/buf
; else
;   tib dup 80 accept space
; then
; 'source 2! >in off true then

  _header _hidden,'(REFILL)'
paren_refill_:
  call do_colon
  if 0 ; debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs '(REFILL_) '
  endif
  dw blk_,fetch_,question_dup_
  dw question_branch_,paren_refill_.1
  dw one_plus_,dup_
  dw nscr_,u_less_
  dw and_,dup_
  dw question_branch_,paren_refill_.end
  dw dup_,blk_,store_
  dw block_,bytes_per_buffer_
  dw branch_,paren_refill_.2
paren_refill_.1:
  if tib_words
    dw tib_
  else
    dw lit_,tib_address
  endif
  dw dup_
  dw c_lit_
  db 32*2-1 ; XXX TMP -- ZX Spectrum's chars_ per line; XXX TODO use_ a variable_ instead?
  dw cr_,accept_
  if tib_words
    dw dup_,number_tib_,store_ ; update_ '#tib'
  endif
paren_refill_.2:
  dw tick_source_,two_store_
  dw in_,off_
  dw true_
paren_refill_.end:
  dw paren_exit_

; REFILL  ( -- flag )

  _header _public,'REFILL'
refill_:
  call fetch_execute_
  dw paren_refill_

; RESET  ( -- )

  _header _hidden,'RESET'
reset_:
  call do_colon
  dw catcher_,off_   ; reset_ error_ handler
  ;; dw dcaps ; XXX OLD
  dw case_sensitive_search_,off_ ; XXX NEW
  dw console_      ; set EMIT_ vector
  dw paren_exit_

; RESET-INTERPRETER  ( -- )
;   blk off >in off postpone [

  _header _hidden,'RESET-INTERPRETER'
reset_interpreter_:
  ld hl,0
  ld (blk_.variable),hl
  ld (in_.variable),hl
  jp left_bracket_

; RESET-FORTH  ( -- )
;       0 set-limit empty warning on checking
;       on (filedescriptorblocks) (filedescriptorsize*maxopensourcefiles) erase empty-buffers
;       reset-interpreter 'source off bl-word drop

  _header _hidden,'RESET-FORTH'
reset_forth_:
  call do_colon
; XXX TODO
; XXX OLD
;;  dw zero
;;  dw setlimit
  dw empty_   ; reset_ vocabulary_ pointers
  dw warning_,on_  ; enable warnings
  dw checking_,on_  ; enable checking_
;;  dw lit,filedescriptorblocks  ; clear files
;;  dw lit,filedescriptorsize*maxopensourcefiles ;
;;  dw erase   ;
;;  dw emptybuffers   ; mark screen buffer as empty
;;  dw resetinterpreter   ; reset interpreter
;;  dw ticksource,off  ; clear parsed word buffer
;;  dw blword,drop ;
  dw decimal_ ; XXX NEW -- moved here_ from cold_boot
  dw case_sensitive_search_,off_
  dw paren_exit_

; QUIT  ( -- )

  _header _public,'QUIT'
quit_:
  call do_colon
quit_.start:
  dw r0_,fetch_,rp_store_
  dw reset_
;** dw vnorm ; XXX OLD
  dw reset_interpreter_
quit_.begin:
  dw paren_refill_,drop_
  if 0 ; debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'QUIT '
  endif
  dw interpret_
  dw executing_question_
  dw branch_if_false,quit_.begin
  dw paren_dot_quote_
  _dcs ' ok'
  dw branch_,quit_.begin

; RETURN  ( u -- )
; Exit to BASIC with return code u.
; The return code is used as line number for disk operations.

  _header _public,'RETURN'
return_:
  pop bc
  ld iy,sys_err_nr ; XXX TODO -- check if needed
  ld sp,(system_stack_pointer)
  ret

; BYE  ( -- )
; Exit to the BASIC command line.

  _header _public,'BYE'
bye_:
;  im 1 ; XXX TODO ?
  ld sp,(system_stack_pointer)
  ld iy,sys_err_nr ; XXX TODO -- check if needed
  rst 0x08     ; error_
  db 0xff      ; 0: "OK"

if 0
;  ; XXX TODO -- Code from Benschop's ZX Spectrum Forth-83
  ld sp,(sys_err_sp) 
  pop bc
  ld bc,0x1303 
  push bc
  im 1
  ld (IY+31),2 ; update_ sys_e_line
  rst 0x08     ; error_
  db 0xff      ; error_ 0: OK
endif

; XXX OLD
;;; BOOT?  ( -- xt )
;;
;;  ; XXX TODO -- convert this into a variable that holds an xt?
;;  ; XXX TODO -- combine with 'boot'
;;  header hidden,'BOOT?'
;;bootquestion:
;;  ld hl,(initbootxt)
;;  push hl
;;  jp next

; (ABORT)  ( -- )
;   s0 @ sp! fs0 @ fsp ! boot? if 1 return then
;       quit

  _header _hidden,'(ABORT)'
paren_abort_:
  call do_colon
  dw s0_,fetch_,sp_store_
  if floating_point_support and separated_f_stack
    dw fs0_,fetch_,fsp_,store_
  endif
;;  dw bootquestion ; XXX OLD
  if debug
;;   dw questionbranch,parenabort.1
    ; XXX OLD
;;    dw one
;;    dw return
    paren_abort_.1:
      dw paren_dot_quote_
      _dcs ' (ABORT_) '
;;    dw quit
  else
;;    dw questionbranch,quit.start
;;    dw one
;;    dw return
  endif
  dw branch_,quit_.start
;  dw next ; XXX NEW TMP -- needed?

; .ERROR  ( -- )
;       cr blk @ ?dup if file? and if filename type
;       >in @ 2- 0max blk @ 2dup scr 2! ."  Scr "
;       u. c/l / ." Line " . cr then then ." Error: "
;       [char] " dup emit pwa count 31 min type emit

  _header _hidden,'.ERROR'
dot_error_:
  call do_colon
  dw cr_
  dw blk_,fetch_
  dw question_dup_
  dw question_branch_,dot_error_.1
  dw file_question_
  dw and_    ; screen file open_ and loading from block_?
  dw question_branch_,dot_error_.1
  dw current_block_file_,type_
  dw in_,fetch_
  dw two_minus_    ; adjust pointer
  dw zero_max_
  dw blk_,fetch_
  dw two_dup_    ; set error_ block_, offset
  dw scr_,two_store_
  dw paren_dot_quote_
  _dcs ' Screen '
  dw u_dot_
  dw chars_per_line_
  dw slash_
  dw paren_dot_quote_
  _dcs 'Line '
  dw dot_
  dw cr_
dot_error_.1:
  dw paren_dot_quote_
  _dcs 'Error: '
  dw c_lit_
  db '"'
  dw dup_,emit_
  dw pwa_,count_
  dw c_lit_
  db 31
  dw min_
  dw type_
  dw emit_
  dw paren_exit_

; : ERROR  ( n -- )
;       -1 of (abort) then
;       -2 of boot cell+ @ 0= if  .error  then
;       space errmsg 2@ type (abort) then
;       ."  exception = " . (abort)
;   ;

  ; XXX -- used only by 'throw'; I don't understand it yet

  _header _hidden,'ERROR'
error_:
  call do_colon
  if debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'error',cr_char
  endif
  dw true_    ; -1
  dw paren_of_,error_.1
  dw paren_abort_
error_.1:
  if debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'error.1',cr_char
  endif
  dw lit_,-2
  dw paren_of_,error_.3
  dw boot_,cell_plus_,fetch_
  dw zero_equals_
  dw question_branch_,error_.2
  dw dot_error_    ; skipped by applications
error_.2:
  if debug ; XXX INFORMER
    dw paren_dot_quote_
    _dcs 'error.2',cr_char
  endif
  dw space_
  dw errmsg_,two_fetch_
  dw type_
  dw paren_abort_
error_.3:
  dw paren_dot_quote_
  _dcs ' exception = '
  dw dot_
  dw paren_abort_
  dw paren_exit_

; XXX TMP NEW layout
; : CATCH  ( xt -- n | 0 )
;   sp@ >r fsp @ >r catcher @ >r rp@ catcher
;   ! execute r> catcher ! 2r> 2drop 0
;   ;

  _header _public,'CATCH'
catch_:
  call do_colon
  dw sp_fetch_,to_r_
  dw fsp_,fetch_
  dw to_r_
  dw catcher_,fetch_,to_r_
  dw rp_fetch_,catcher_,store_
  dw execute_
  dw from_r_,catcher_,store_
  dw two_from_r_,two_drop_
  dw zero_
  dw paren_exit_

; XXX TMP NEW layout
; : THROW  ( n -- )
;   ?dup if
;     catcher @ ?dup 0= if  error  then
;     rp! r> catcher ! r> fsp ! r> swap >r sp! drop r>
;   then
;   ;
; XXX FIXME -- it's not in theh glossary

  _header _public,'THROW'
throw_:
  call do_colon
  dw question_dup_
  dw branch_if_0,throw_.end
  dw catcher_,fetch_
  if debug
    dw paren_dot_quote_
    _dcs ' THROW_:'
    dw over_,dot_
    dw paren_dot_quote_
    _dcs 'CATCHER:'
    dw dup_,u_dot_,space_,space_
  endif
  dw question_dup_,zero_equals_
  dw branch_if_false,throw_.no_error
  dw error_
throw_.no_error:
  dw rp_store_
  dw from_r_,catcher_,store_
  dw from_r_,fsp_,store_
  dw from_r_,swap_,to_r_
  dw sp_store_
  dw drop_,from_r_
throw_.end:
  dw paren_exit_

; XXX TMP NEW layout
; : ABORT  ( -- )
;   -1 throw
;   ;

  _header _public,'ABORT'
abort_:
  ld hl,-1
  push hl
  jp throw_

; XXX TMP NEW layout
; : (ABORT")  ( n -- )
;   r> count rot if  errmsg 2! -2 throw  then + >r
;   ;

  _header _hidden,'(ABORT")'
paren_abort_quote_:
  call do_colon
  if 0;debug ; XXX INFORMER -- because of_ the problem in '?stack'
    ; XXX FIXME this debug code breaks something
    dw paren_dot_quote_
    _dcs 'abort" parameter = '
    dw dot_s_,cr_
;    ; dw dup_,dot,cr_
  endif
  dw from_r_,count_,rot_
  dw branch_if_false,paren_abort_quote_.noop
  dw errmsg_,two_store_
  dw lit_,-2,throw_
paren_abort_quote_.noop:
  dw plus_,to_r_
  dw paren_exit_

; XXX TMP NEW layout
; : ABORT"  ( compilation: "ccc<quote>" -- )
;   postpone (abort") ,"
;   ; immediate

  _header _public,'ABORT"',_immediate
abort_quote_:
  call do_colon
  dw compile_,paren_abort_quote_,comma_quote_
  dw paren_exit_

; Cold boot

cold_boot:

  ; XXX TODO
;  ; save default drive and user_
;  call getcurrentdrive
;  ld (defaultdrive),a
;  call getcurrentuser
;  ld (defaultuser),a


;;cldd.1:
;  ; Save_ the system stack pointer
  ld hl,0
  add hl,sp
  ld (system_stack_pointer),hl
;;  sub 8     ; skip over CCP
;;
;;cldd.2:
;;  ld sp,tmpstack
;;  ld h,a
;;  ld l,0
;;  ld (esm),hl    ; patch end of memory value
;;  ex de,hl
;;
;;  ld hl,(boot.1)    ; get BOOT word
;;  ld (initbootxt),hl    ; save it
;;  ld a,h
;;  or  l
;;  ld l,a
;;  ld a,(boot.2)
;;  and l
;;  jp z,cldd.3     ; need Forth system
;;
;;  ld hl,noop
;;  ld (cold.1),hl
;;  ld hl,(ulimit)
;;  ld a,l
;;  or  h
;;  jp nz,cldd.6
;;  ex de,hl
;;  jp cldd.6
;;
;;cldd.3:
;;
;;  ld hl,(colddph)   ; move system segment into place
;;  ld de,hm
;; XXX Some changes here in DX-Forth 4.09
;;  call hlminusdetohl
;;cldd.4:
;;  ld b,0     ; later patched to LD B,H
;;cldd.5:
;;  ld c,0     ; later patched to LD C,L
;;  ld hl,(colddp)
;;  call moveblockupwards
;;  ld de,start
;;
;;cldd.6:
;;  ex de,hl
;;  ld (limit.1),hl   ; patch LIMIT
;;
;;  db 0xc3      ; 'jmp'
;;cldd.7:
;;  dw movpat      ; later patched to 'cold'

  jp cold_ ; XXX TMP

; (BOOT-MESSAGE)  ( -- )

paren_boot_message:
  call do_colon
  dw paren_dot_quote_
  db paren_boot_message.end-$-1  ; length
  db "DZX-Forth_ "
  db cr_char,"Version "
  version
  db cr_char,copy_char," 2014,2015 Marcos Cruz",cr_char
  db "(programandala.net)",cr_char
  db "DZX-Forth_ comes with",cr_char
  db "ABSOLUTELY NO WARRANTY;",cr_char
  db "for details see the license",cr_char
;  db "Type 'bye' to exit.",crchar
paren_boot_message.end
  dw paren_exit_

; BOOT-MESSAGE  ( -- )

boot_message:
  call fetch_execute_
  dw paren_boot_message

; COLD ( -- )

  _header _public,'COLD'
cold_:
; XXX TODO
; XXX OLD
;;  ld sp,tmpstack
;;  ld hl,(limit.1)   ; get LIMIT
;;  ld de,-recsiz    ; file r/w buffer size
;;  add hl,de
;;  ld (hbuf.1),hl    ; patch HBUF
;;  push  hl
;;  ld hl,(nfcb.1)    ; #fcb
;;  ld de,-filehandlesize    ; handle size
;;  call hlbydetohldeunsigned
;;  pop hl
;;  add hl,de
;;  ex de,hl
;;  ld hl,(nus)    ; user area size
;;  call deminushltohl
;;  ld (userdatapointer),hl    ; patch UP
;;  ld (coldr0),hl    ; patch R0
;;  ld (returnstackpointer),hl    ; patch RP
;;  ex de,hl
;;  ld hl,(nrts)   ; return stack size
;;  call deminushltohl
;;  ld (fsp.variable),hl   ; init fp stack
;;  ld (coldfs0),hl   ; patch FS0
;;; XXX These lines were commented out in the original source:
;;; ex de,hl
;;; ld hl,(nfps)   ; fp stack size
;;; call deminushltohl
;;  ld sp,hl     ; set cpu stack pointer
;;  ld (colds0),hl    ; patch S0
;;   if controlflowstackextensions
;;  ld (cs0.variable),hl   ; init CS0 with safe value
;;   endif


  ld sp,(cold_s0) ; XXX NEW

; XXX INFORMER -- this works:
;  ld hl,1001
;  push hl
;  jp return

;  ; init the user data
  ld hl,(user_data_pointer)
  ex de,hl
  ld hl,init_user_variables
  ld bc,init_user_variables.end-init_user_variables
  call move_block_upwards

; XXX INFORMER -- this works:
;  ld hl,1002
;  push hl
;  jp return

; XXX INFORMER -- this works:
;  jp bye

;  ; patch 'pause' to_ do nothing
  ld hl,noop_
  ld (pause_.action),hl

;  ; delete the last key_
  ; XXX needed by 'key?'?
  xor a
  ld (sys_last_k),a

  call do_colon
;;  dw zfh     ; reset handles
;;  dw sys,off     ; default is APPLICATION

  dw reset_     ; general reset_
cold_.1:
  dw reset_forth_
do_f_init_patch:
  dw f_init_patch

; XXX TODO -- user boot
;;  dw bootquestion
;;  dw dup,boot,store     ; restore BOOT
;;  dw questiondup
;;  dw questionbranch,cold.3
;;  dw execute      ; run application
;;  dw zero,return  ; exit to DOS

cold_.3:

;;cold.4:
;;  dw interpret      ; interpret
;;cold.5:
;;;;  dw invid     ; terminal init sequence ; XXX OLD
;;  dw cr,page
;;  dw parendotquote
;;  db cold.8-$-1

;;cold.6:
  dw page_,boot_message

;;cold.7:
;;cold.8:
;;  dw parendotquote
;;  db dofidentifypatch-$-1
;;  db crchar,lfchar
do_f_identify_patch:
  dw f_identify_patch
  dw cr_
;;  dw filequestion
;;  dw questionbranch,cold.10
;;  dw cr
;;  dw parendotquote
;;  dcs 'Using '
;;  dw currentblockfile,type
;;  dw cr
;;cold.10:

; XXX TMP for debugging
;  dw dots
;  dw bye

; vvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
; XXX TMP for debugging
;  dw lit,101,dot,bye
;  dw s0,fetch,lit,50000,store,bye
;  dw spfetch,lit,50000,store,bye
  
;  dw depth,lit,50000,store,bye

;  dw lit,101
;  dw lit,102
;  dw lit,103
;  dw lit,104
;  dw lit,105
;  dw dots

;  dw lit,104,dot
;  dw lit,105,dot

;  dw key,drop ; XXX INFORMER
;  dw bye
if 0 ; XXX INFORMER
  dw lit_,34257
  dw lit_,34259
  dw u_greater_
  dw dot_
  dw bye_
endif
; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


  dw quit_      ; jump to_ interpreter
;  dw bye ; XXX TMP


; XXX OLD 
;;; SET-LIMIT  ( a -- )  $fff0 and (ulimit) !
;;
;;  header  1,'SET-LIMIT'
;;setlimit:
;;  pop hl
;;  ld a,l
;;  and 0x00f0
;;  ld l,a
;;  ld (ulimit),hl
;;  jp next

; LITERAL  ( n -- ) char? if postpone clit c, exit then
;       postpone lit , ; immediate

  _header _public,'LITERAL',_immediate
literal_:
  call do_colon
  dw char_question_ ; 8-bit number?
  dw branch_if_false,literal_.cell
  ; 8-bit number
  dw compile_,c_lit_
  dw c_comma_
  dw paren_exit_
literal_.cell:
  ; 16-bit number
  dw compile_,lit_
  dw comma_
  dw paren_exit_

; 2LITERAL  ( d -- )
;   postpone 2lit , , ; immediate

  _header _public,'2LITERAL',_immediate
two_literal_:
  call do_colon
  dw compile_,two_lit_
  dw comma_,comma_
  dw paren_exit_

; [']     ' [compile] literal  ; immediate

  _header _public,"[']",_immediate
bracket_tick_:
  call do_colon
  dw tick_
  dw literal_
  dw paren_exit_

; [COMPILE]   ' compile,  ; immediate

  _header _public,'[COMPILE]',_immediate
bracket_compile_:
  call do_colon
  dw tick_
  dw compile_comma_
  dw paren_exit_

; RECURSE  ( -- )
; last cell+ @ compile, ; immediate

  _header _public,'RECURSE',_immediate
recurse_:
  ld hl,(last_.xt)
  push hl
  jp compile_comma_

; }}} **********************************************************
; Dictionary support {{{

; FREEZE  ( -- )

  _header _public,'FREEZE'
freeze_:
  call do_colon
  dw udp_,fetch_ ; from
  dw lit_,init_user_variables ; to_
  dw lit_,init_user_variables.end-init_user_variables ; count_
  dw cmove_
  dw paren_exit_

; XXX OLD
;;;  'prune      variable 'prune  'prune off
;;
;;  header hidden,"'PRUNE"
;;tprun:
;;  call docreate
;;  dw topprunes    ; 0=end

; XXX OLD
;;;  REMEMBER  ( xt -- )  'prune link, ,
;;; add xt to prunes
;;
;;  header public,'REMEMBER'
;;remember:
;;  call docolon
;;  dw tprun,linkcomma
;;  dw comma
;;  dw parenexit

; XDP  ( adr -- adr xdp )
;   dup limit u< if dp else dph then

  _header _hidden,'XDP'
xdp_:
  pop de
  push de
  ld hl,limit_.1
  ex de,hl
  call compare_de_hl_unsigned
  jp nc,dph
  jp dp_

; XXX OLD
;;;  prunes  ( -- )    begin 'prune @ dup while dup xdp @ u< 0=
;;;        while 2@ 'prune ! execute repeat then drop
;;
;;  header hidden,'PRUNES'
;;pruns:
;;  call docolon
;;pruns.1:
;;  dw tprun,fetch
;;  dw dup
;;  dw questionbranch,pruns.2
;;  dw dup
;;  dw xdp,fetch
;;  dw uless,zeroequals
;;  dw questionbranch,pruns.2
;;  dw twofetch
;;  dw tprun,store
;;  dw execute
;;  dw branch,pruns.1
;;pruns.2:
;;  dw drop
;;  dw parenexit

; NAME?  ( "name" -- xt nfa )
; find name in context wordlist
;         bl-word get-context wordlist-find ?defined

  _header _hidden,'NAME?'
name_question_:
  call do_colon
  dw bl_word_
  dw get_context_
  dw wordlist_find_,question_defined_
  dw paren_exit_

; LFIND  ( wid nfa -- lfa |0 )
;   swap begin 2dup @ - while @
;          dup while n>link repeat then nip

;  ; find link field containing nfa, 0=none

  _header _hidden,'LFIND'
lfind_:
  call do_colon
  dw swap_
lfind_.1:
  dw two_dup_,fetch_
  dw minus_
  dw question_branch_,lfind_.end
  dw fetch_,dup_
  dw question_branch_,lfind_.end
  dw nlnk_
  dw branch_,lfind_.1
lfind_.end:
  dw nip_
  dw paren_exit_

; BEHEAD  ( "name1" "name2" -- )
;   name? nip name? nip 2dup u< if swap
;   then n>name get-context rot lfind !

;  ; unlink word heads
  _header _public,'BEHEAD'
behead_:
  call do_colon
  dw name_question_,nip_
  dw name_question_,nip_
  dw two_dup_,u_less_
  dw question_branch_,behead_.1
  dw swap_
behead_.1:
  dw ntnam_
  dw get_context_
  dw rot_,lfind_
  dw store_
  dw paren_exit_

; ?VOC  ( flag -- )
;   abort" invalid vocabulary"

  _header _hidden,'?VOC'
question_voc_:
  call do_colon
  dw paren_abort_quote_
  _dcs  'invalid vocabulary'
  dw paren_exit_

;  CHAIN   ( "name" -- )    get-current postpone addr @ 2dup =
;          ?voc cell- $2001 over @ - ?voc
;          2dup lfind ?voc swap 0 lfind
;          2dup u> ?voc !

  _header _public,'CHAIN'
chain_:
  call do_colon
  dw get_current_
  dw addr_,fetch_
  dw two_dup_,equals_  ; same wordlist_
  dw question_voc_
  dw cell_minus_
  dw lit_,0x2001
  dw over_,fetch_,minus_  ; not a wordlist_
  dw question_voc_
  dw two_dup_,lfind_  ; already chained
  dw question_voc_
  dw swap_
  dw zero_,lfind_
  dw two_dup_,u_greater_  ; forward reference
  dw question_voc_
  dw store_
  dw paren_exit_

; (FORGET)  ( nfa dp -- )
;   dp ! >r voc-link begin @ dup cell+ @ r@
;   u< until dup voc-link ! begin dup cell-
;   dup @ begin dup r@ u< 0= while -alias if
;   dup name> dp @ umin dp ! then n>name
;   repeat swap ! @ ?dup 0= until r> dup dp
;   cell+ ! (colddph) @ u< if freeze then prunes

; XXX TODO study the parameters and adapt

  _header _hidden,'(FORGET)'
paren_forget_:
  call do_colon
  dw dp_,store_  ; starting maximums
  dw to_r_
  dw voc_link_    ; trim vocs > nfa
paren_forget_.1:
  dw fetch_
  dw dup_,cell_plus_,fetch_
  dw r_fetch_,u_less_
  dw question_branch_,paren_forget_.1
  dw dup_,voc_link_,store_
paren_forget_.2:
  dw dup_,cell_minus_  ; scan_ remaining vocs
  dw dup_
  dw fetch_
paren_forget_.3:
  dw dup_,r_fetch_  ; for each word_ >= nfa
  dw u_less_,zero_equals_
  dw question_branch_,paren_forget_.5
  dw minus_alias_    ; not an alias_
  dw question_branch_,paren_forget_.4
  dw dup_,namef_  ; get its xt
  dw dp_,fetch_
  dw u_min_,dp_,store_  ; trim dict
paren_forget_.4:
  dw ntnam_
  dw branch_,paren_forget_.3
paren_forget_.5:
  dw swap_,store_
  dw fetch_
  dw question_dup_,zero_equals_
  dw question_branch_,paren_forget_.2  ; until_ all vocs done
  dw from_r_
  dw dup_,dp_
  dw cell_plus_,store_
  dw lit_,cold_dph  ; below fence?
  dw fetch_,u_less_
  dw question_branch_,paren_forget_.6
  dw freeze_    ; fix bootup values
paren_forget_.6:
;;  dw pruns    ; run prunes chain ; XXX OLD
  dw paren_exit_

; EMPTY  ( -- )
;   forth definitions (colddp) 2@ (forget)

  _header _public,'EMPTY'
empty_:
  call do_colon
  dw forth_,definitions_  ; switch to_ a safe vocabulary_
  dw lit_,cold_dp
  dw two_fetch_ ; XXX FIXME cold_dph is_ still used by '(forget_)'
  dw paren_forget_
  dw paren_exit_

; FORGET  ( "name" -- )
;   get-current context ! name? -alias 0=
;        abort" is alias" swap limit over u> if
;        drop dp @ then (forget)

  _header _public,'FORGET'
forget_:
  call do_colon
  dw get_current_
  dw context_,store_
  dw name_question_
  dw minus_alias_,zero_equals_  ; alias_?
  dw paren_abort_quote_
  _dcs 'is alias'
  dw swap_
  dw limit_
  dw over_,u_less_
  dw question_branch_,forget_.1
  dw drop_
  dw dp_,fetch_
forget_.1:
  dw paren_forget_
  dw paren_exit_

; MARKER  ( "name" -- )
;   sys? system create sys !

  _header _public,'MARKER'
marker_:
  call do_colon
  dw sys_question_
  dw system_
  dw create_
  dw sys_,store_
  dw paren_exit_

; }}} **********************************************************
; Strings {{{

; S,  ( ca u -- )
;   255 min 0max here over 1+ allot place

  _header _hidden,'S,'
s_comma_:
  call do_colon
  dw c_lit_
  db 255
  dw min_
  dw zero_max_
  dw here_,over_
  dw one_plus_,allot_
  dw place_
  dw paren_exit_

; ,"  ( "ccc" -- )
;   [char] " parse$ s,

  _header _public,',"'
comma_quote_:
  call do_colon
  dw c_lit_
  db '"'
  dw parse_dollar_
  dw s_comma_
  dw paren_exit_

; (S")  ( -- ca u )
;   r> count 2dup + >r

  _header _hidden,'(S")'
paren_s_quot_:
  ld a,(bc)
  ld l,a
  ld h,0
  inc bc
  push bc
  push hl
  add hl,bc
  ld c,l
  ld b,h
  jp next

; SLITERAL  ( ca u -- )
;   postpone (s") s, ; immediate

  _header _public,'SLITERAL',_immediate
s_literal_:
  call do_colon
  dw compile_,paren_s_quot_
  dw s_comma_
  dw paren_exit_

; S"  ( -- ca u )
;
;   [char] " parse$ state? if postpone sliteral
;   then ; immediate
;
; Note: this word is state-smart

  _header _public,'S"',_immediate
s_quote_:
  call do_colon
  dw c_lit_
  db '"'
  dw parse_dollar_
  dw compiling_question_
  dw branch_if_false,s_quote_.end
  dw s_literal_
s_quote_.end:
  dw paren_exit_

; XXX OLD -- DX-Forth 4.00
;;; (.")      r> count 2dup + >r type
;;
;;  header x,'(.")'
;;parendotquote:
;;  call docolon
;;  dw fromr,count
;;  dw twodup,plus,tor
;;  dw type
;;  dw parenexit

; XXX NEW -- DX-Forth 4.09
; (.")      r> count 2dup + >r type

  _header _hidden,'(.")'
paren_dot_quote_:
  ld a,(bc)  ; length of_ the string
  ld h,0
  ld l,a
  inc bc      ; address of_ the first char_
  push bc     ; address
  push hl     ; length
  add hl,bc   ; calculate the new IP
  ld b,h
  ld c,l      ; update_ the IP
  jp type_

; ."      compile (.") ," ; immediate

  _header _public,'."',_immediate
dot_quote_:
  call do_colon
  dw compile_,paren_dot_quote_
  dw comma_quote_
  dw paren_exit_

; CHAR?  ( x -- x flag )
;
; Is x an 8-bit number?
; XXX TODO make this word public and make it consume x.

  _header _hidden,'CHAR?'
char_question_:
  pop hl
  push hl
  ld l,h
  jp zero_equals_hl

; CHAR  ( -- c ) bl word 1+ c@

  _header _public,'CHAR'
char_:
  call do_colon
  dw bl_,word_
  dw one_plus_,c_fetch_
  dw paren_exit_

; [CHAR]  ( -- c ) char [compile] literal

  _header _public,'[CHAR]',_immediate
bracket_char_:
  call do_colon
  dw char_
  dw literal_
  dw paren_exit_

; }}} **********************************************************
; Misc {{{

; Y/N  ( -- flag )
;   ." (y/n) N\bs" key upcase [char] Y = dup
;       if [char] Y else [char] N then emit space

  _header _public,'Y/N'
yn_:
  call do_colon
  dw paren_dot_quote_
  _dcs '(y/n) N',bs_char
  dw key_,upcas_
  dw c_lit_
  db 'Y'
  dw equals_,dup_
  dw question_branch_,yn1
  dw c_lit_
  db 'Y'
  dw branch_,yn2
yn1:
  dw c_lit_
  db 'N'
yn2:
  dw emit_,space_
  dw paren_exit_

; DZX-FORTH  ( -- minor major )

  _header _public,'DZX-FORTH'
dzx_forth_:
  ld de,version.major shl 8 + version.minor
  jp push_version

; }}} **********************************************************
; Files {{{

; XXX OLD
;;; RESET-DISKS  ( -- )
;;
;;  header public,'RESET-DISKS'
;;resetdisks:
;;  ld a,25
;;  call dodos
;;  push af
;;  ld a,13
;;  call dodos
;;  pop af
;;  ld e,a
;;  ld a,14
;;  call dodos
;;  jp next

; >DRIVE  ( u1 -- u2 )
;   ?dup if 1- else 0 25 bdos then

  _header _public,'>DRIVE'
to_drive_:
  pop de
  ld a,e
  dec  a
  call m,get_current_drive
  jp push_a

; PATH  ( u1 -- ca u2 ior )
;        255 32 bdos 0 <# [char] : hold #s rot >drive
;        [char] A + hold #> 0

  _header _public,'PATH'  ; uses numeric buffer_
path_:
  call do_colon
  dw c_lit_
  db 255
  dw c_lit_
  db 32
  dw bdos_
  dw zero_,less_number_sign_
  dw c_lit_
  db ':'
  dw hold_
  dw number_sign_s_
  dw rot_,to_drive_
  dw c_lit_
  db 'A'
  dw plus_
  dw hold_,number_sign_greater_
  dw zero_
  dw paren_exit_

; -PATH  ( a1 u1 -- a2 u2 )
;        2dup [char] : scan dup if 1 /string 2swap
;        then 2drop

;  ; XXX TODO simpler, because ':' always is at the same position

  _header _public,'-PATH'
minus_path_:
  call do_colon
  dw two_dup_
  dw c_lit_
  db ':'
  dw scan_,dup_
  dw question_branch_,minus_path_.1
  dw one_,slash_string_
  dw two_swap_
minus_path_.1:
  dw two_drop_
  dw paren_exit_

; FILETYPE?  ( a1 u1 -- u2 )
;   -path [char] . scan nip

  _header _hidden,'FILETYPE?'  ; get filetype length
filetype_question_:
  call do_colon
  dw minus_path_ ; XXX why?
  dw c_lit_
  db '.'
  dw scan_,nip_
  dw paren_exit_

; +EXT  ( a1 u1 a2 u2 -- a3 u3 )
;        2over filetype? if 2drop exit then 3 min
;        s" ." 2rot -trailing (filenamesize-5) min zbuf
;        @ 1+ 0 +string +string +string

  _header _public,'+EXT'  ; uses filename buffer_
plus_ext_:
  call do_colon
  dw two_over_,filetype_question_
  dw question_branch_,plus_ext_.1
  dw two_drop_,paren_exit_
plus_ext_.1:
  dw three_,min_
  dw paren_s_quot_
  _dcs '.'
  dw two_rot_
  dw minus_trailing_
  dw c_lit_
  db filename_size-5 ; XXX why -5?
  dw min_
  dw zbuf_,fetch_    ; unused_
  dw one_plus_
  dw zero_
  dw pstr_
  dw pstr_
  dw pstr_
  dw paren_exit_

; -EXT  ( a1 u1 -- a2 u2 )
;   2dup filetype? -

  _header _public,'-EXT'
minus_ext_:
  call do_colon
  dw two_dup_,filetype_question_
  dw minus_
  dw paren_exit_

; SET-FCB  ( a u fcb-a -- user# )

  ; XXX TODO -- rewrite for +3DOS
  _header _public,'SET-FCB'
set_fcb_:
  call get_current_user    ; current user_
  ld (set_fcb_.10+1),a
  call get_current_drive    ; current drive
  inc  a
  pop de
  ld (de),a
  ld (set_fcb_.5+1),a
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
  ex de,hl
  jp set_fcb_.2

set_fcb_.1:
  inc  de
  dec  c
set_fcb_.2:
  call set_fcb_.12    ; skip_ blanks
  cp ' '
  jp z,set_fcb_.1

  push de
  push bc
  cp '9'+1    ; user_ number
  jp c,set_fcb_.3
  sub  'A'-1    ; drive A-P
  jp c,set_fcb_.6
  cp 16+1
  jp nc,set_fcb_.6
  ld (set_fcb_.5+1),a
  call set_fcb_.11
  cp ':'
  jp z,set_fcb_.5

set_fcb_.3:
  ld b,0
set_fcb_.4:
  sub  '0'
  jp c,set_fcb_.6
  cp 9+1
  jp nc,set_fcb_.6
  push bc
  ld c,a
  ld a,b
  add a,a
  add a,a
  add a,b
  add a,a
  add a,c
  pop bc
  ld b,a
  call set_fcb_.11
  cp ':'
  jp nz,set_fcb_.4

  ld a,b
  cp 31+1    ; user_ 0-31
  jp nc,set_fcb_.6
  ld (set_fcb_.10+1),a

set_fcb_.5:
  ld (hl),0    ; modified
  pop af
  pop af
  call set_fcb_.11
  jp set_fcb_.7

set_fcb_.6:
  pop bc    ; not du:
  pop de
set_fcb_.7:
  ld b,8
  call set_fcb_.15

  cp '.'
  jp z,set_fcb_.8
  ld c,1
set_fcb_.8:
  inc  de
  dec  c

  ld b,3
  call set_fcb_.15

  ld b,21    ; clear EX..CR fields
set_fcb_.9:
  inc  hl
  ld (hl),0
  dec  b
  jp nz,set_fcb_.9

  pop bc
set_fcb_.10:
  ld a,0    ; modified
  jp push_a

set_fcb_.11:
  inc  de    ; get next
  dec  c
set_fcb_.12:
  inc  c    ; get char_
  dec  c
  ld a,c
  ret  z
  ld a,(de)
  call uppercase_a
  and a
  ret

set_fcb_.13:
  call set_fcb_.12    ; test delimiter
  cp ' '+1
  jp c,set_fcb_.14
  cp ','
  ret  z
  cp '_'
;  ret  z
  jp nc,set_fcb_.14
  cp '.'
  ret  z
  cp ':'
  ret  c
  cp '>'
  ret  nc
set_fcb_.14:
  cp a
  ret

set_fcb_.15:
  call set_fcb_.13    ; fill_ field
  jp z,set_fcb_.19
  inc  hl
  cp '*'
  jp nz,set_fcb_.16
  ld (hl),'?'
  jp set_fcb_.17

set_fcb_.16:
  ld (hl),a
  inc  de
  dec  c
set_fcb_.17:
  dec  b
  jp nz,set_fcb_.15

set_fcb_.18:
  call set_fcb_.13    ; scan_ delimiter
  ret  z
  inc  de
  dec  c
  jp set_fcb_.18

set_fcb_.19:
  inc  hl
  ld (hl),' '
  dec  b
  jp nz,set_fcb_.19
  ret

; GET-USER  ( -- u )

  _header _public,'GET-USER'
get_user_:
  call get_current_user
  jp nc,dos_error_.a ; XXX TODO needed? when this could fail?
  jp push_a

; SET-USER  ( u -- )

  _header _public,'SET-USER'
set_user_:
  call get_current_user
  ld (old_user),a  ; save_ current user_
  pop hl
  ld a,l
set_user_.a:
  cp 255
  call nz,set_current_user
  jp nc,dos_error_.a
  jp next

; RESTORE-USER  ( -- )

  _header _public,'RESTORE-USER'
restore_user_:
old_user: equ $+1
  ld a,0xff  ; old user_ (0xff = ignore)
  jp set_user_.a

; GET-DRIVE  ( -- u )

  _header _public,'GET-DRIVE'
get_drive_:
  call get_current_drive
  jp nc,dos_error_.a
  jp push_a

; SET-DRIVE  ( u -- )
;
; Set the default drive (i.e. the drive implied by all filenames that do not
; specify a drive).
;
; u = drive (ASCII 'A'..'P')

  _header _public,'SET-DRIVE'
set_drive_:
  pop hl
  ld a,l
set_drive_.a:
  call set_current_drive
  jp nc,dos_error_.a
  jp next

; REC@  ( a -- +d )
;   dup >r @ r> 2+ c@ 7 0 do d2* loop

  _header _public,'REC@'
rec_fetch_:
  pop hl
  inc  hl
  inc  hl
  xor a
  ld a,(hl)
  rra
  ld d,a
  dec  hl
  ld a,(hl)
  rra
  ld e,a
  dec  hl
  ld a,(hl)
  rra
  ld h,a
  ld a,0
  rra
  ld l,a
  ex de,hl
  jp push_de_hl

; REC!  ( +d a -- )
;   >r 7 0 do d2/ loop r@ 2+ c! r> !

  _header _public,'REC!'
rec_store_:
  pop de
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
  ex de,hl
  ld a,e
  rla
  ld a,d
  rla
  ld (hl),a
  inc  hl
  ld a,c
  rla
  ld (hl),a
  inc  hl
  ld a,b
  rla
  ld (hl),a
  pop bc
  jp next

; >FNAME  ( a1 u -- a2 )
;
;   (filenamesize-1) min zbuf @ packed 0 affix
;   zbuf 2@ swap zbuf 2!

  _header _public,'>FNAME'
tfnam_:
  call do_colon
  dw c_lit_
  db filename_size-1
  dw min_
  dw zbuf_,fetch_
  dw packed_
  dw zero_,affix_  ; trailing null ; XXX OLD
  dw zbuf_,two_fetch_
  dw swap_
  dw zbuf_,two_store_
  dw paren_exit_

; FH  ( -- a )

  _header _hidden,'FH'
fh_:
  call do_value    ; current file handle
fh_.variable:
  dw 0

; /FH  ( -- )
;   #fcb (filehandlesize) * hbuf over - swap erase

  _header _hidden,'/FH'
zfh_:
  ld hl,(nfcb_.1)
  ld de,file_handle_size
  call hl_by_de_to_hlde_unsigned
  ld hl,(hbuf_.1)
  call hl_minus_de_to_hl
  push hl
  push de
  jp erase_

; USE  ( -- a )
; fh (filehandlesize) negate * hbuf +
; XXX TODO rename, to free the name for 'using'

  _header _hidden,'USE'
use_:
  ld hl,(fh_.variable)
  ld de,-file_handle_size
  call hl_by_de_to_hlde_unsigned
  ld hl,(hbuf_.1)
  add hl,de
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; UID  ( -- a )
;   use 1+
; user number

  _header _hidden,'UID'
uid_:
  call do_colon
  dw use_,one_plus_
  dw paren_exit_

; FCB  ( -- a )
;   use 6 +

  _header _hidden,'FCB'
fcb_:
  call do_colon    ; FCB_ address
  dw use_
  dw c_lit_
  db 6
  dw plus_
  dw paren_exit_

; RWP@  ( -- ud )
;   use 2+ 2@

  _header _hidden,'RWP@'
rwp_fetch_:
  call do_colon
  dw use_,two_plus_
  dw two_fetch_
  dw paren_exit_

; RWP!  ( ud -- )
;   use 2+ 2! ;

  _header _hidden,'RWP!'
rwpst_:
  call do_colon
  dw use_,two_plus_
  dw two_store_
  dw paren_exit_

; >IOR  ( err# -- ior )
;   dup if $fe00 or then

  _header _public,'>IOR'
ior_:
  pop hl
  ld a,h
  or l
  if size_optimization
    jr z,ior_.end
  else
    jp z,ior_.end
  endif
  ld h,0xfe
ior_.end:
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; ?IOR  ( flag err# -- ior )
;   and ior ;

  _header _hidden,'?IOR'
qior_:
  call do_colon
  dw and_
  dw ior_
  dw paren_exit_

; GETFH  ( -- fid | 0 )
; get free handle, 0 if none
;
;   #fcb 1+ begin
;     1- dup while
;     dup to fh
;   use c@ 0= until then

  _header _hidden,'GETFH'
getfh_:
  call do_colon
  dw nfcb_
  dw one_plus_
getfh_.1:
  dw one_minus_
  dw dup_
  dw question_branch_,getfh_.end
  dw dup_
  dw paren_to_,fh_
  dw use_,c_fetch_
  dw zero_equals_
  dw question_branch_,getfh_.1
getfh_.end:
  dw paren_exit_

; SETFH  ( fid mask -- 0 | err )
; select/check handle
;
;   swap dup 1- 0 #fcb within if to fh
;          use c@ and 0= 5 and exit then 2drop
;          6

  _header _hidden,'SETFH'
stfh_:
  call do_colon
  dw swap_    ; mode mask: 1=read 2=write 3=r/w
  dw dup_,one_minus_
  dw zero_
  dw nfcb_
  dw within_
  dw question_branch_,stfh_.1
  dw paren_to_,fh_
  dw use_,c_fetch_
  dw and_,zero_equals_
  dw c_lit_
  db 5
  dw and_
  dw paren_exit_
stfh_.1:
  dw two_drop_
  dw c_lit_
  db 6
  dw paren_exit_

; FILE-POSITION  ( fideid -- ud ior )
;   3 setfh rwp@ rot ior

  _header _public,'FILE-POSITION'
fpos_:
  call do_colon
  dw three_,stfh_
  dw rwp_fetch_
  dw rot_
  dw ior_
  dw paren_exit_

; REPOSITION-FILE  ( ud fid -- ior )
;   3 setfh dup >r if 2drop else
;              rwp! then r> ior

  _header _public,'REPOSITION-FILE'
reposf_:
  call do_colon
  dw three_,stfh_
  dw dup_,to_r_
  dw question_branch_,reposf_.1
  dw two_drop_
  dw branch_,reposf_.2
reposf_.1:
  dw rwpst_
reposf_.2:
  dw from_r_
  dw ior_
  dw paren_exit_

; XF5  ( -- )
;  $80 fcb 5 + ctoggle

  _header _hidden,'XF5'
xf5_:
  call do_colon
  dw c_lit_
  db 0x80
  dw fcb_
  dw c_lit_
  db 5
  dw plus_
  dw c_toggle_
  dw paren_exit_

; FILE-SIZE  ( fid -- ud ior )
;   3 setfh dup 0= if uid c@ set-user
;          xf5 fcb 16 bdos drop xf5 fcb 35
;          bdos drop restore-user then fcb 33 +
;          rec@ rot ior

  _header _public,'FILE-SIZE'
file_size_:
  call do_colon
; XXX TODO
; XXX OLD
;;  dw three,stfh
;;  dw dup,zeroequals
;;  dw questionbranch,fsiz.1
;;  dw uid,cfetch
;;  dw setuser
;;  dw xf5
;;  dw fcb
;;  dw clit
;;  db 16
;;  dw bdos,drop
;;  dw xf5
;;  dw fcb
;;  dw clit
;;  db 35
;;  dw bdos,drop
;;  dw restoreuser
;;fsiz.1:
;;  dw fcb
;;  dw clit
;;  db 33
;;  dw plus
;;  dw recfetch
;;  dw rot
;;  dw ior
  dw paren_exit_

; CLOSE-FILE  ( fid -- ior )
;   3 setfh dup if ior exit then use c!
;          uid c@ set-user fcb 16 bdos restore-user 255
;          = 2 ?ior

  _header _public,'CLOSE-FILE'
close_file_:
  call do_colon
; XXX TODO
; XXX OLD
;;  dw three,stfh
;;  dw dup
;;  dw questionbranch,closefile.1
;;  dw ior
;;  dw parenexit
;;closefile.1:
;;  dw use,cstore
;;  dw uid,cfetch
;;  dw setuser
;;  dw fcb
;;  dw clit
;;  db 16
;;closefile.2:
;;  dw bdos
;;  dw restoreuser
;;  dw clit
;;  db 255
;;  dw equals
;;  dw two
;;  dw qior
  dw paren_exit_

; R/O  ( -- fam )
;   aka 0 r/o

  _header _public,'R/O',,one_
read_only_: equ one_

; W/O  ( -- fam )
;   aka 1 w/o

  _header _public,'W/O',,two_
write_only_: equ two_

; R/W  ( -- fam )
;   aka 2 r/w

  _header _public,'R/W',,three_
read_write_: equ three_

; BIN  ( fam1 -- fam2 )
;   aka noop bin immediate

  _header _public,'BIN',_immediate,noop_
bin_: equ  next

; OPEN1  ( a u fam -- | x ior )
;          getfh 0= if 2drop 4 ior unnest exit
;          then 1+ use c! >fname count fcb
;          set-fcb dup uid c! set-user 0 0 rwp!

  _header _hidden,'OPEN1'
open1_:
  call do_colon
  ; XXX TODO
  ; XXX OLD
;;  dw getfh,zeroequals
;;  dw questionbranch,open1.1
;;  dw twodrop
;;  dw clit
;;  db 4
;;  dw ior
;;  if  debug
;;    dw parendotquote
;;    dcs 'UNNESTOPEN1'
;;  endif
;;  dw unnest
;;  dw parenexit
;;open1.1:
;;  dw oneplus
;;  dw use,cstore
;;  dw tfnam,count
;;  dw fcb
;;  dw setfcb
;;  dw dup
;;  dw uid,cstore
;;  dw setuser
;;  dw zero,zero
;;  dw rwpst
  dw paren_exit_

; OPEN2  ( fn# -- fid flag )
;   fh fcb rot bdos 255 = restore-user

  _header _hidden,'OPEN2'
open2_:
  call do_colon
; XXX TODO
; XXX OLD
;;  dw fh
;;  dw fcb
;;  dw rot
;;  dw bdos
;;  dw clit
;;  db 255
;;  dw equals
;;  dw restoreuser
  dw paren_exit_

; OPEN3  ( flag err -- | ior )
;   ?ior ?dup if 0 use c! unnest then

  _header _hidden,'OPEN3'
open3_:
  call do_colon
  dw qior_
  dw question_dup_
  dw question_branch_,open3_.end
  dw zero_
  dw use_,c_store_
  if  debug
    dw paren_dot_quote_
    _dcs 'UNNEST_OPEN3'
  endif
  dw unnest_
open3_.end:
  dw paren_exit_

; OPEN-FILE  ( a u fam -- fid ior )
;          open1 15 open2 2 open3 fcb 9 + c@
;          6 rshift use c@ and 1 > 5 open3 0

  _header _public,'OPEN-FILE'
open_file_:
  call do_colon
  dw open1_
  dw c_lit_
  db 15
  dw open2_
  dw two_,open3_
  dw fcb_    ; test if file R/O and mode=write
  dw c_lit_
  db 9
  dw plus_,c_fetch_
  dw c_lit_
  db 6
  dw rshift_
  dw use_,c_fetch_,and_
  dw one_,greater_
  dw c_lit_
  db 5
  dw open3_,zero_
  dw paren_exit_

; CREATE-FILE  ( a u fam -- fid ior )
;          open1 fcb 19 bdos drop 22 open2
;          5 open3 0

  _header _public,'CREATE-FILE'
create_file_:
  call do_colon
  dw open1_
  dw fcb_
  dw c_lit_
  db 19
  dw bdos_,drop_
  dw c_lit_
  db 22
  dw open2_
  dw c_lit_
  db 5
  dw open3_
  dw zero_
  dw paren_exit_

; >FCB  ( a u -- fcb usr )
;   2dup >fname 18 + -rot 2 pick set-fcb

  _header _public,'>FCB'
tfcb_:
  call do_colon
  dw two_dup_,tfnam_
  dw c_lit_
  db 18
  dw plus_
  dw minus_rot_
  dw two_,pick_
  dw set_fcb_
  dw paren_exit_

; DELETE-FILE  ( a u -- ior )
;   >fcb set-user 19 bdos restore-user 255 = 2
;          ?ior

  _header _public,'DELETE-FILE'
delete_file_:
  ret
; XXX TODO
; XXX OLD
;;  call docolon
;;  dw tfcb,setuser
;;  dw clit
;;  db 19
;;  dw branch,closefile.2

; RENAME-FILE  ( a1 u1 a2 u2 -- ior )
;          2swap >fcb set-user >r >fcb drop r@ c@
;          over c! dup 15 bdos 255 = if r@ 16 +
;          16 cmove r> 23 bdos 255 = 2 ?ior else
;          16 bdos r> 2drop 5 ior then restore-user

  _header _public,'RENAME-FILE'
rename_file_:
  call do_colon
; XXX TODO
; XXX OLD
;;  dw twoswap
;;  dw tfcb,setuser,tor
;;  dw tfcb,drop
;;  dw rfetch,cfetch
;;  dw over,cstore
;;  dw dup
;;  dw clit
;;  db 15
;;  dw bdos
;;  dw clit
;;  db 255
;;  dw equals
;;  dw questionbranch,renamefile.1
;;  dw rfetch
;;  dw clit
;;  db 16
;;  dw plus
;;  dw clit
;;  db 16
;;  dw cmove,fromr
;;  dw clit
;;  db 23
;;  dw branch,closefile.2
;;renamefile.1:
;;  dw clit
;;  db 16
;;  dw bdos
;;  dw fromr,twodrop
;;  dw clit
;;  db 5
;;  dw ior
;;  dw restoreuser
  dw paren_exit_

; OFFS  ( -- x )
;   0 value offs

  _header _hidden,'OFFS'
offs_:
  call do_value
  dw 0

; SETSIZ  ( -- size )
;   rwp@ over $7F and to offs fcb 33 +
;          rec! (recsiz) offs -

  _header _hidden,'SETSIZ'
setsiz_:
  call do_colon
  ; XXX TODO
  ; XXX OLD
;  ; dw rwp_fetch,over_
;  ; dw clit_
  ; db 0x7f
  ; dw and_
;  ; dw paren_to,offs_
  ; dw fcb_
;  ; dw clit_
  ; db 33
;  ; dw plus_,recstore_
;  ; dw clit_
  ; db recsiz
;  ; dw offs,minus_
  dw paren_exit_

; SETDMA  ( a -- )
;   26 bdos drop

  _header _public,'SETDMA'
setdma_:
  pop de
  ld a,26
  call do_dos
  jp next

; RANRW  ( a size fn# -- a size | a u' )
;          fcb swap bdos if drop unnest r> then

  _header _hidden,'RANRW'
ranrw_:
  call do_colon
  dw fcb_,swap_,bdos_
  dw question_branch_,ranrw_.end
  dw drop_
  if  debug
    dw paren_dot_quote_
    _dcs 'UNNEST_RW'
  endif
  dw unnest_
  dw from_r_
ranrw_.end:
  dw paren_exit_

; RDINI  ( a u fid mask -- u a u | u ior )
;          setfh ?dup if nip ior unnest exit
;          then tuck

  _header _hidden,'RDINI'
rdini_:
  call do_colon
  dw stfh_,question_dup_
  dw question_branch_,rdini_.1
  dw nip_
  dw ior_
  if  debug
    dw paren_dot_quote_
    _dcs 'UNNEST_RDINI'
  endif
  dw unnest_
  dw paren_exit_
rdini_.1:
  dw tuck_
  dw paren_exit_

; FREAD  ( a u1 -- a u2 )
;   begin dup while >r setsiz r@ umin
;          dup (recsiz) = if over setdma 33
;          ranrw else hbuf setdma 33 ranrw 2dup
;          hbuf offs + -rot cmove then dup >r +
;          rwp@ r@ m+ rwp! 2r> - repeat

  _header _hidden,'FREAD'
fread_:
  call do_colon
fread_.1:
  dw dup_
  dw question_branch_,fread_.end
  dw to_r_
  dw setsiz_
  dw r_fetch_,u_min_
  dw dup_
  dw c_lit_
  db recsiz
  dw equals_
  dw question_branch_,fread_.2
  dw over_,setdma_
  dw c_lit_
  db 33
  dw ranrw_
  dw branch_,fread_.3
fread_.2:
  dw hbuf_,setdma_
  dw c_lit_
  db 33
  dw ranrw_
  dw two_dup_,hbuf_
  dw offs_,plus_
  dw minus_rot_,cmove_
fread_.3:
  dw dup_,to_r_
  dw plus_
  dw rwp_fetch_
  dw r_fetch_,m_plus_
  dw rwpst_
  dw two_from_r_,minus_
  dw branch_,fread_.1
fread_.end:
  dw paren_exit_

; WRINI  ( a u fid mask -- a u | ior )
;          setfh ?dup if nip nip ior unnest          then

  _header _hidden,'WRINI'
wrini_:
  call do_colon
  dw stfh_,question_dup_
  dw question_branch_,wrini_.end
  dw nip_,nip_
  dw ior_
  if  debug
    dw paren_dot_quote_
    _dcs 'UNNEST_WRINI'
  endif
  dw unnest_
wrini_.end:
  dw paren_exit_

; FWRITE  ( a u1 -- a u2 )
;   begin dup while >r setsiz r@ umin dup
;          (recsiz) = if over setdma else hbuf
;          (recsiz) $1A fill hbuf setdma fcb 33
;          bdos drop 2dup hbuf offs + swap cmove
;          then 34 ranrw dup >r + rwp@ r@ m+
;          rwp! 2r> - repeat

  _header _hidden,'FWRITE'
fwrit_:
  ; XXX TODO
  ; XXX TMP -- 2drop
  pop hl
  pop hl
  jp next
; XXX OLD
;;  call docolon
;;fwrit.1:
;;  dw dup
;;  dw questionbranch,fwrit.4
;;  dw tor
;;  dw setsiz
;;  dw rfetch,umin
;;  dw dup
;;  dw clit
;;  db recsiz
;;  dw equals
;;  dw questionbranch,fwrit.2
;;  dw over,setdma
;;  dw branch,fwrit.3
;;fwrit.2:
;;  dw hbuf
;;  dw clit
;;  db recsiz
;;  dw clit
;;  db ctlz
;;  dw fill
;;  dw hbuf,setdma
;;  dw fcb
;;  dw clit
;;  db 33
;;  dw bdos,drop
;;  dw twodup
;;  dw hbuf
;;  dw offs,plus
;;  dw swap
;;  dw cmove
;;fwrit.3:
;;  dw clit
;;  db 34
;;  dw ranrw
;;  dw dup,tor
;;  dw plus
;;  dw rwpfetch
;;  dw rfetch,mplus
;;  dw rwpst
;;  dw twofromr,minus
;;  dw branch,fwrit.1
;;fwrit.4:
;;  dw parenexit

; READ-FILE  ( a u1 fid -- u2 ior )
;   1 rdini uid c@ set-user fread
;          restore-user nip - 0

  _header _public,'READ-FILE'
read_file_:
  call do_colon
; XXX TODO
; XXX OLD
;;  dw one,rdini
;;  dw uid,cfetch
;;  dw setuser
;;  dw fread
;;  dw restoreuser
;;  dw nip
;;  dw minus
;;  dw zero
  dw paren_exit_

; WRITE-FILE  ( a u fid -- ior )
;   2 wrini uid c@ set-user fwrite
;          restore-user nip 0<> 255 ?ior

  _header _public,'WRITE-FILE'
write_file_:
  call do_colon
; XXX TODO
; XXX OLD
;;  dw two,wrini
;;  dw uid,cfetch
;;  dw setuser
;;  dw fwrit
;;  dw restoreuser
;;  dw nip
;;  dw zeronotequals
;;  dw clit
;;  db 255
;;  dw qior
  dw paren_exit_

; WRITE-LINE  ( ca u fileid -- ior )
;        dup >r write-file ?dup if r> drop exit
;        then s" \r" r> write-file

  _header _public,'WRITE-LINE'
write_line_:
  call do_colon
  dw dup_,to_r_
  dw write_file_,question_dup_
  dw question_branch_,write_line_.end_of_line
  dw from_r_,drop_
  dw paren_exit_
write_line_.end_of_line:
  _dcs cr_char
  dw from_r_
  dw write_file_
  dw paren_exit_

; EOL?  ( a -- 2|1|0 )
;   c@ $0D of 2 exit then $0A of 1 exit
;          then drop 0

  _header _hidden,'EOL?'
eol_question_:
  pop hl
  ld a,(hl)
  cp cr_char
  jp z,two_
  cp lf_char
  jp z,one_
  jp zero_

; READ-LINE  ( a u1 fid -- u2 flag ior )
;   >r over swap r> read-file
;          ?dup if exit then 2dup over + swap
;          ?do i dup c@ $1A = if rot - fh
;          file-size drop rwp! leave then eol?
;          ?dup if i + >r over + r> swap - dup
;          0<> rwp@ d+ rwp! i swap - -1 0 unloop
;          exit then loop nip dup 0<> 0

  _header _public,'READ-LINE'
read_line_:
; XXX TODO
  pop hl
  pop hl
  pop hl
  jp next
; XXX OLD -- DX-Forth 4.00
;;  call docolon
;;  dw tor,over,swap,fromr
;;  dw readfile,questiondup
;;  dw questionbranch,readline.1
;;  dw parenexit
;;readline.1:
;;  dw twodup,over,plus,swap
;;  dw parenquestiondo,readline.5
;;readline.do:
;;  dw i
;;  dw dup,cfetch
;;  dw clit
;;  db ctlz
;;  dw equals
;;  dw questionbranch,readline.3
;;  dw rot,minus
;;  dw fh,filesize,drop,rwpst
;;  dw parenleave,readline.do-cw
;;readline.3:
;;  dw eolquestion,questiondup
;;  dw questionbranch,readline.4
;;  dw i,plus,tor
;;  dw over,plus
;;  dw fromr
;;  dw swap,minus
;;  dw dup,zeronotequals  ; handle buffer > 32K
;;  dw rwpfetch,dplus,rwpst
;;  dw i,swap,minus
;;  dw true,zero
;;  dw unloop,parenexit
;;readline.4:
;;  dw parenloop,readline.do
;;readline.5:
;;  dw nip
;;  dw dup,zeronotequals,zero
;;  dw parenexit

; SFP  ( -- a )
; screen file selector

  _header _hidden,'SFP'
sfp_:
  call do_create
  dw file_descriptor_blocks_table    ; current
  dw file_descriptor_blocks_table+cw  ; swap_-file

; SWAP-FILE  ( -- )
;   scr @ scr# ! sfp 2@ swap sfp 2!
;        scr# @ scr ! empty-buffers

  _header _public,'SWAP-FILE'
swap_file_:
  call do_colon
  dw scr_,fetch_
  dw scr_number_,store_
  dw sfp_,two_fetch_
  dw swap_
  dw sfp_,two_store_
  dw scr_number_,fetch_
  dw scr_,store_
  dw empty_buffers_
  dw paren_exit_

; FDB  ( -- a )
;   (filedescriptorblockstable) (maxopensourcefiles) 0 do dup @ @ 0= if unloop exit
;        then cell+ loop abort" too many files"

  _header _public,'FDB'
  ; get a free slot
fdb_:
  call do_colon
  dw lit_,file_descriptor_blocks_table
  dw c_lit_
  db max_open_source_files
  dw zero_
  dw paren_do_,fdb_.3
fdb_.do:
  dw dup_,fetch_,fetch_
  dw zero_equals_
  dw question_branch_,fdb_.2
  dw unloop_
  dw paren_exit_
fdb_.2:
  dw cell_plus_
  dw paren_loop_,fdb_.do
fdb_.3:
  dw paren_abort_quote_
  _dcs 'too many files'
  dw paren_exit_

; file descriptor fields
;
;  FD  cell    status 0=closed
;  FID  cell    file handle
;  BLKS  cell    file size (blocks)
;  SCR#  cell    current SCR#
;  FNB  'filenamesize' bytes  file name

; FD  ( -- a )

  _header _hidden,'FD'
fd_:
  call do_colon    ; file descriptor field
  dw sfp_,fetch_,fetch_
  dw paren_exit_

; FID  ( -- a )

  _header _hidden,'FID'
fid_:
  ld e,cw    ; file handle field
fid_.1:
  ld d,0
  push de
  call do_colon
  dw fd_,plus_
  dw paren_exit_

; BLKS  ( -- a )

  _header _hidden,'BLKS'
blks_:
  ld e,cw*2    ; file size field
  jp fid_.1

; SCR#  ( -- a )

  _header _hidden,'SCR#'
scr_number_:
  ld e,cw*3    ; current SCR_# field
  jp fid_.1

; FNB  ( -- a )

  _header _hidden,'FNB'
fnb_:
  ld e,cw*4    ; file name field
  jp fid_.1

; BUF  ( -- a )
; file buffer address

  _header _hidden,'BUF'
buf_:
  call do_constant
  dw block_buffer

; BLK#  ( -- a )
; update flag

  _header _hidden,'BLK#'
blk_number_:
  call do_create
blk_number_.variable:
  ds cw

; FILE?  ( -- flag )

  _header _public,'FILE?'
file_question_:
  call do_colon
  dw fd_,fetch_ ; fd_ @
  dw zero_not_equals_ ; 0<>
  dw paren_exit_

; CURRENT-BLOCK-FILE  ( -- ca u )
;   fnb count

  _header _public,'CURRENT-BLOCK-FILE'
current_block_file_:
  call do_colon
  dw fnb_,count_
  dw paren_exit_

; ?OPEN  ( -- )
;   file? 0= abort" no file open"

  _header _hidden,'?OPEN'
question_open_:
  call do_colon
  dw file_question_
  dw zero_equals_
  dw paren_abort_quote_
  _dcs 'no file open'
  dw paren_exit_

; #SCREENS  ( -- +n )
;   ?open blks @

  _header _public,'#SCREENS'
nscr_:
  call do_colon
  dw question_open_
  dw blks_,fetch_
  dw paren_exit_

; EMPTY-BUFFERS  ( -- )
;   $7fff blk# !

  _header _public,'EMPTY-BUFFERS'
empty_buffers_:
  ld hl,block_number_mask
  ld (blk_number_.variable),hl
  jp next

; UPDATE  ( -- )
;   ?open blk# @ $8000 or blk# !

  _header _public,'UPDATE'
update_:
  call do_colon
  dw question_open_
  dw blk_number_,fetch_
  dw lit_,block_updated_mask
  dw or_
  dw blk_number_,store_
  dw paren_exit_

; BLKERR  ( flag -- )
;   abort" block r/w error"

  _header _hidden,'BLKERR'
blkerr_:
  call do_colon
  dw paren_abort_quote_
  _dcs 'block r/w error'
  dw paren_exit_

; BLK-RW  ( +n mode -- )
;   >r b/buf um* fid @ reposition-file blkerr
;   buf b/buf fid @ r> if write-file else
;   read-file blkerr b/buf < then blkerr

  _header _hidden,'BLK-RW'
blk_rw_:
  call do_colon
  dw to_r_
  dw bytes_per_buffer_,umstr_
  dw fid_,fetch_
  dw reposf_
  dw blkerr_
  dw buf_,bytes_per_buffer_
  dw fid_,fetch_
  dw from_r_
  dw question_branch_,blk_rw_.1
  dw write_file_
  dw branch_,blk_rw_.2
blk_rw_.1:
  dw read_file_
  dw blkerr_
  dw bytes_per_buffer_,less_
blk_rw_.2:
  dw blkerr_
  dw paren_exit_

; ?BLK  ( +n -- +n )
;   dup #screens 0 within
;   abort" block out of range"

  _header _hidden,'?BLK'
question_blk_:
  call do_colon
  dw dup_
  dw nscr_,zero_
  dw within_    ; block_ in range?
  dw paren_abort_quote_
  _dcs 'block out of range'
  dw paren_exit_

; SAVE-BUFFERS  ( -- )
;   ?open blk# @ 0< if blk# @ $7fff and
;        dup blk# ! ?blk 1 blk-rw then

  _header _public,'SAVE-BUFFERS'
save_buffers_:
  call do_colon
  dw question_open_
  dw blk_number_,fetch_,zero_less_
  dw question_branch_,save_buffers_.end
  dw blk_number_,fetch_
  dw lit_,block_number_mask,and_
  dw dup_,blk_number_,store_
  dw question_blk_    ; block_ in range?
  dw one_,blk_rw_
save_buffers_.end:
  dw paren_exit_

; FLUSH  ( -- )
;   save-buffers empty-buffers

  _header _public,'FLUSH'
flush_:
  call do_colon
  dw save_buffers_,empty_buffers_
  dw paren_exit_

; BUFFER  ( +n -- a )
;   save-buffers ?blk blk# ! buf

  _header _public,'BUFFER'
buffer_:
  call do_colon
  dw save_buffers_
  dw question_blk_
  dw blk_number_,store_
  dw buf_
  dw paren_exit_

; BLOCK  ( +n -- a )
;   ?open blk# @
;   $7fff and \ block number mask
;   over - if dup
;   buffer drop 0 blk-rw else drop then buf

  _header _public,'BLOCK'
block_:
  call do_colon
  dw question_open_
  dw blk_number_,fetch_
  dw lit_,block_number_mask
  dw and_,over_,minus_
  dw question_branch_,block_.1
  dw dup_,buffer_,drop_
  dw zero_,blk_rw_
  dw branch_,block_.2
block_.1:
  dw drop_
block_.2:
  dw buf_
  dw paren_exit_

; -->  ( -- )
;   blk @ 0= abort" loading only" (refill) drop
;        ; immediate

  _header _public,'-->',_immediate
next_block_:
  call do_colon
  dw blk_,fetch_,zero_equals_
  dw paren_abort_quote_
  _dcs 'loading only'
  dw paren_refill_,drop_
  dw paren_exit_

; (THRU)  ( +n1 +n2 -- )
;   1+ swap ?do i block b/buf i (evaluate) loop

  _header _hidden,'(THRU)'
paren_thru_:
  call do_colon
  dw one_plus_,swap_
  dw paren_question_do_,paren_thru_.end
paren_thru_.do:
  dw i_,block_
  dw bytes_per_buffer_
  dw i_,paren_evaluate_
  dw paren_loop_,paren_thru_.do
paren_thru_.end:
  dw paren_exit_

; THRU  ( +n1 +n2 -- )
;   (thru) ?block

  _header _public,'THRU'
thru_:
  call do_colon
  dw paren_thru_
  dw question_block_
  dw paren_exit_

; LOAD  ( +n -- )
;   dup thru

  _header _public,'LOAD'
load_:
  pop hl
  push hl
  push hl
  jp thru_

; FNBUF  ( -- a )

  _header _hidden,'FNBUF'
fnbuf_:
  call do_create    ; current file handle
  ds filename_size

; (FBK)  ( +n -- )
;   #screens 2dup u< if drop dup current-block-file -ext
;        s" $$$" +ext fnbuf place fnbuf count w/o
;        create-file throw over 0 ?do dup i block
;        b/buf rot write-file throw loop close-file
;        throw fid @ close-file throw current-block-file
;        delete-file throw fnbuf count current-block-file
;        rename-file throw current-block-file r/w open-file
;        throw fid ! then over blks ! ?do i buffer
;        b/buf blank update save-buffers loop

  _header _hidden,'(FBK)'
pfbk_:
  call do_colon
  dw nscr_    ; tests if file open_
  dw two_dup_,u_less_
  dw question_branch_,pfbk_.3
  dw drop_,dup_
  dw current_block_file_,minus_ext_
  dw paren_s_quot_
  _dcs '$$$'
  dw plus_ext_
  dw fnbuf_,place_
  dw fnbuf_,count_
  dw write_only_,create_file_,throw_
  dw over_,zero_
  dw paren_question_do_,pfbk_.2
pfbk_.do.1:
  dw dup_
  dw i_,block_
  dw bytes_per_buffer_
  dw rot_,write_file_,throw_
  dw paren_loop_,pfbk_.do.1
pfbk_.2:
  dw close_file_,throw_
  dw fid_,fetch_
  dw close_file_,throw_
  dw current_block_file_,delete_file_,throw_
  dw fnbuf_,count_
  dw current_block_file_,rename_file_,throw_
  dw current_block_file_
  dw read_write_,open_file_,throw_
  dw fid_,store_
pfbk_.3:
  dw over_
  dw blks_,store_  ; update_ max_ block_
  dw paren_question_do_,pfbk_.end
pfbk_.do.2:
  dw i_,buffer_
  dw bytes_per_buffer_,blank_
  dw update_,save_buffers_
  dw paren_loop_,pfbk_.do.2
pfbk_.end:
  dw paren_exit_

; FILEBLOCKS  ( +n -- )
;   ['] (fbk) catch abort" can't resize file"

  _header _public,'FILEBLOCKS'
fbloc_:
  call do_colon
  dw lit_,pfbk_
  dw catch_
  dw paren_abort_quote_
  _dcs "can't resize file"
  dw paren_exit_

; CLOSE  ( -- )
;  file? if flush fid @ close-file drop
;        fd off then empty-buffers
;
; close current file
; NOTE: errors are NOT reported with this function

  _header _public,'CLOSE'
close_:
  call do_colon
  dw file_question_
  dw question_branch_,close_.1
  dw flush_
  dw fid_,fetch_
  dw close_file_,drop_
  dw fd_,off_
close_.1:
  dw empty_buffers_
  dw paren_exit_

; CLOSE-ALL  ( -- )
;   close (filedescriptorblockstable) maxopensourcefiles 0 do dup sfp ! close
;        cell+ loop drop

  _header _public,'CLOSE-ALL'
close_all_:
  call do_colon
  dw close_    ; ensure buffer_ flushed
  dw lit_,file_descriptor_blocks_table
  dw c_lit_
  db max_open_source_files
  dw zero_
  dw paren_do_,close_all_.end
close_all_.do:
  dw dup_
  dw sfp_,store_
  dw close_
  dw cell_plus_
  dw paren_loop_,close_all_.do
close_all_.end:
  dw drop_
  dw paren_exit_

; LASTFILE  ( -- ca u )
;   zbuf cell+ @ count

  _header _hidden,'LASTFILE'
lastfile_:
  call do_colon    ; last_ named file used by open_-file etc
  dw zbuf_,cell_plus_
  dw fetch_,count_
  dw paren_exit_

; .LASTFILE  ( -- )
;   beep cr lastfile type space

  _header _hidden,'.LASTFILE'
dot_lastfile_:
  call do_colon
  dw beep_,cr_
  dw lastfile_,type_
  dw space_
  dw paren_exit_

; ?CREATE  ( ca u -- fileid )
;        r/o open-file 0= tuck if close-file then
;        drop if .lastfile ." exists - delete it? "
;        y/n 0= if abort then then lastfile r/w
;        create-file abort" can't create file"

  _header _hidden,'?CREATE'
question_create_:
  call do_colon
  dw read_only_,open_file_  ; test if file exists
  dw zero_equals_,tuck_
  dw question_branch_,question_create_.1
  dw close_file_
question_create_.1:
  dw drop_
  dw question_branch_,question_create_.2
  dw dot_lastfile_
  dw paren_dot_quote_
  _dcs 'exists - delete it? '
  dw yn_,zero_equals_
  dw question_branch_,question_create_.2
  dw abort_
question_create_.2:
  dw lastfile_,read_write_,create_file_
  dw paren_abort_quote_
  _dcs "can't create_ file"
  dw paren_exit_

; INIT-SCR  ( fileid ior -- )
;   if drop exit then fdb sfp ! fd on
;          dup fid ! file-size drop b/buf
;          um/mod nip blks ! lastfile fnb
;          place current-block-file upper empty-buffers

  _header _hidden,'INIT-SCR'
init_scr_:
  call do_colon    ; init screenfile
  dw branch_if_0,init_scr_.no_error
  dw drop_
  dw paren_exit_
init_scr_.no_error:
  dw fdb_,sfp_,store_
  dw fd_,on_
  dw dup_,fid_,store_
  dw file_size_,drop_
  dw bytes_per_buffer_,umslm_,nip_  ; overflow stores $FFFF
  dw blks_,store_
  dw lastfile_,fnb_,place_
  dw current_block_file_
;  dw upper  ; XXX OLD -- why DX-Forth does this without an option?
  dw empty_buffers_
  dw paren_exit_

; OPEN  ( ca u fam -- ior )
; open a screen file
;         fdb drop >r s" scr" +ext r>
;         open-file tuck init-scr

  _header _public,'OPEN'
open_:
  call do_colon
  dw fdb_,drop_  ; free slot?
  dw to_r_
  dw paren_s_quot_
  _dcs 'fb'
  dw plus_ext_
  dw from_r_,open_file_
  dw tuck_
  dw init_scr_
  dw paren_exit_

; (OPEN)  ( ca u -- )
;   r/w open abort" can't open file"

  _header _hidden,'(OPEN)'
paren_open_:
  call do_colon
  dw read_write_,open_
  dw paren_abort_quote_
  _dcs "can't open_ file"
  dw paren_exit_

; PARSE-FILENAME  ( "filename" -- ca u )
;   token dup 0= abort" specify filename"

  _header _public,'PARSE-FILENAME'
parse_filename_:
  call do_colon
  dw token_
  dw dup_,zero_equals_
  dw paren_abort_quote_
  _dcs 'specify filename'
  dw paren_exit_

; USING  ( "filename[.fb]" -- )
;         close parsefilename r/w open ?dup if
;          .lastfile -507 = if ." access denied"
;          0 else ." not found - create it? "
;          y/n then 0= if abort then lastfile
;          ?create 0 init-scr then 0 0 scr 2!
; open/make a screen file

;  ; XXX TODO rename to 'use' (rename 'use' first)
  ; XXX TODO write non-parsing version 'used'
  _header _public,'USING'
using_:
  call do_colon
  dw close_
  dw parse_filename_
  dw read_write_,open_,question_dup_
  dw question_branch_,using_.4
  dw dot_lastfile_
  dw lit_,-507,equals_
  dw question_branch_,using_.1
  dw paren_dot_quote_
  _dcs 'access denied'
  dw zero_
  dw branch_,using_.2
using_.1:
  dw paren_dot_quote_
  _dcs 'not found - create it? ' ; XXX OLD remove this!, use_ other word_ to_ create_ it.
  dw yn_
using_.2:
  dw zero_equals_
  dw question_branch_,using_.3
  dw abort_
using_.3:
  dw lastfile_,question_create_
  dw zero_,init_scr_
using_.4:
  dw zero_,zero_,scr_,two_store_
  dw paren_exit_

; LOADED  ( +n1 +n2 ca u -- )
;   sfp @ >r (open) (thru) close r>
;          sfp ! ?block

  _header _public,'LOADED'
loaded_:
  call do_colon
  dw sfp_,fetch_
  dw to_r_
  dw paren_open_
  dw paren_thru_
  dw close_
  dw from_r_
  dw sfp_,store_
  dw question_block_
  dw paren_exit_

; LOAD-FILE  ( +n "filename[.fb]" -- )
;   dup parsefilename loaded

  _header _public,'LOAD-FILE'
load_file_:
  call do_colon
  dw dup_
  dw parse_filename_
  dw loaded_
  dw paren_exit_

; SAVE  ( "filename[.COM]" -- )
;        0 0 freeze parsefilename s" com" +ext
;        ?create >r over swap boot 2! (cold.6) (zb1)
;        dup (zbsize*2) erase (cold.7-cold.6) cmove
;        $100 dp @ over - r@ write-file boot cell+
;        off ?dup 0= if (hm) dph @ over - rot 0=
;        and r@ write-file then r> close-file or
;        abort" can't save file"

  _header _public,'SAVE'
save_:
  call do_colon
  ; XXX TODO
  ; XXX OLD
;;  dw zero,zero
;;save.1:
;;  dw freeze
;;  dw parsefilename
;;  dw parensquot
;;  dcs 'bin'
;;  dw plusext
;;  dw questioncreate
;;  dw tor    ; fid
;;  dw over,swap  ; set boot flags
;;  dw boot,twostore
;;  dw lit,cold.6  ; insert compiler logo
;;  dw lit,zb1
;;  dw dup
;;  dw clit
;;  db zbsize*2
;;  dw erase
;;  dw clit
;;  db cold.7-cold.6
;;  dw cmove
;;  dw lit,0x0100
;;  dw dp,fetch
;;  dw over,minus
;;  dw rfetch,writefile  ; save application
;;  dw boot,cellplus,off  ; reset Forth flag
;;  dw questiondup,zeroequals
;;  dw questionbranch,save.2
;;  dw lit,hm
;;  dw dph,fetch
;;  dw over,minus
;;  dw rot,zeroequals,and  ; system size
;;  dw rfetch,writefile  ; save system
;;save.2:
;;  dw fromr,closefile,or
;;  dw parenabortquote
;;  dcs  "can't save file"
  dw paren_exit_

; TURNKEY  ( "bootword" "filename[.COM]" -- )

  _header _public,'TURNKEY'
turnkey_:
  call do_colon
  ; XXX TODO
  dw paren_exit_
  ; XXX OLD
;;  dw true
;;turnkey.1:
;;  dw tick
;;  dw branch,save.1

; TURNKEY-SYSTEM  ( "bootword" "filename[.COM]" -- )

  _header _public,'TURNKEY-SYSTEM'
turnkey_system_:
  call do_colon
  call do_colon
  ; XXX TODO
  dw paren_exit_
  ; XXX OLD
;;  dw zero
;;  dw branch,turnkey.1

; }}} **********************************************************
; Screen and graphics {{{

; AT-XY  ( u1 u2 -- )
;   position cursor at col u1, row u2

  _header _public,'AT-XY'
at_xy_:
  ; XXX TODO
  jp next ; XXX TMP
;;  pop  de
;;  pop  hl
;;  ld d,l
;;  push  bc
;;  push  de
;;  ld hl,tgxy
;;  ld de,cpbuf
;;  ld a,16
;;  call amovd
;;  pop  de
;;  ld a,(txpos)
;;  ld c,a
;;  ld a,(txofs)
;;  add  a,d
;;  push  de
;;  call atxy.3
;;  pop  de
;;  ld a,(typos)
;;  ld c,a
;;  ld a,(tyofs)
;;  add  a,e
;;  call atxy.3
;;  pop  bc
;;  ld de,tgxyd
;;  ld hl,cpbuf
;;atxy.1:
;;  push  de
;;  push  hl
;;atxy.2:
;;  call docolon
;;  dw count,tuck
;;  dw type    ; send string
;;  dw zeronotequals
;;  dw swap,fetch
;;  dw and,ms    ; delay only if string not empty
;;  dw parenexit
;;
;;atxy.3:
;;  ld hl,cpbuf
;;  ld b,0
;;  add  hl,bc
;;  ex de,hl
;;  ld hl,tisbin
;;  inc  (hl)
;;  dec  (hl)
;;  jp z,atxy.4
;;  ld (de),a
;;  ret
;;
;;atxy.4:
;;  dec  de
;;  dec  de
;;  ld hl,atxy.8-1
;;  ld b,3
;;atxy.5:
;;  inc  hl
;;  ld c,'0'-1
;;atxy.6:
;;  inc  c
;;  sub  (hl)
;;  jp nc,atxy.6
;;  add  a,(hl)
;;  push  af
;;  ld a,c
;;  cp  '0'
;;  jp z,atxy.7
;;  ld (de),a
;;atxy.7:
;;  inc  de
;;  pop  af
;;  dec  b
;;  jp nz,atxy.5
;;  ret
;;
;;atxy.8:
;;  db 100,10,1

; PAGE  ( -- )
  _header _public,'PAGE'

page_:
  _save_ip
  call rom_cl_all
  ld a,2
  call rom_chan_open
  jp restore_ip_next

; NORMAL  ( -- )

  _header _public,'NORMAL'
vnorm_:
; XXX TODO
  jp next
;;  ld hl,tlovid
;;vnorm.1:
;;  ld de,tceold
;;  jp atxy.1

; HIGHLIGHT  ( -- )

  _header _public,'HIGHLIGHT'
hilit_:
; XXX TODO
  jp next
;;  ld hl,thivid
;;  jp vnorm.1

; CLEAR-LINE  ( -- )

  _header _public,'CLEAR-LINE'
cleol_:
; XXX TODO
  jp next
;;  ld hl,tceol
;;  jp vnorm.1

; INSERT-LINE  ( -- )

  _header _public,'INSERT-LINE'
insln_:
; XXX TODO
  jp next
;;  ld hl,tinsln
;;insln.1:
;;  ld de,tclsd
;;  jp atxy.1

; DELETE-LINE  ( -- )

  _header _public,'DELETE-LINE'
delln_:
; XXX TODO
  jp next
;;  ld hl,tdelln
;;  jp insln.1

; XXX OLD
;;;  INIT-VIDEO  ( -- )
;;
;;  header  1,'INIT-VIDEO'
;;invid:  ld hl,tinit
;;  jp insln.1
;;
;;;  EXIT-VIDEO  ( -- )
;;
;;  header  1,'EXIT-VIDEO'
;;exvid:  ld hl,texit
;;  jp insln.1
; BORDER  ( n -- )

  _header _public,'BORDER'
border_:
;  ; Code based on_ Benschop's Forth-83:
;  ;   : BORDER  ( n -- )
;  ;     DUP_ DUP_ 4 < 7 AND SWAP 8 * + 23624 C! 254 P! ;
;  ; And this is the translation in Z80:
  pop hl
border_.l:
  if 0
    ; XXX OLD -- the screen will be used as a whole, not like Sinclair BASIC
;    ; Set the paper_ of the bottom screen
    ld a,l
    cp 4 ; dark color?
    jp nc,border_.a
    ; dark color
    sla a
    sla a
    sla a ; *8 (converted to_ paper_)
    add a,7 ; white ink_
    ld (sys_bordcr),a
  endif
  ld a,l
border_.a:
  out (254),a
  jp next

; PAPER  ( n -- )
  _header _public,'PAPER'
paper_:
  ; XXX TODO
  jp next

; INK  ( n -- )
  _header _public,'INK'
ink_:
  ; XXX TODO
  jp next

; GOVER ( n -- )
  _header _public,'GOVER'
gover_:
;  ; XXX TODO -- Benschop's Forth_-83 does this:
;  ; 23697 DUP_ C@ 252 AND ROT_ 3 * OR SWAP C!
  jp next

; INVERSE  ( n -- )
  _header _public,'INVERSE'
inverse_:
;  ; XXX TODO -- Benschop's Forth_-83 does this:
;  ; 23697 DUP_ C@ 243 AND ROT_ 12 * OR SWAP C!
  jp next

; NORMAL  ( -- )
  _header _public,'NORMAL'
normal_:
;  ; XXX TODO -- Benschop's Forth_-83 does this:
;  ; 0 INK_ 7 PAPER_ 0 FLASH 0 BRIGHT 7 BORDER_ 0 GOVER 0 INV
  jp next

; }}} **********************************************************
; Floating point {{{

  if floating_point_support

; -FP  ( -- a )
;   marker -FP

  _header _public,'-FP'
dfp_:
  call next

; FLOAT+  ( f-a1 -- f-a2 )
;   4 +

  _header _public,'FLOAT+'
floatp_:
  pop hl
  ld de,fw
  add hl,de
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; FLOATS  ( n1 -- n2 )
;   4 *

  _header _public,'FLOATS'
floats_:
  pop hl
  add hl,hl
  add hl,hl
  if size_optimization
    jp push_hl
  else
    push hl
    jp next
  endif

; FALIGN  ( -- )
;   aka noop falign immediate

  _header _public,'FALIGN',_immediate,noop_
falign_: equ  next

; FALIGNED  ( a -- fa )
;   aka noop faligned immediate

  _header _public,'FALIGNED',_immediate,noop_
f_aligned_: equ  next

; F,  (F: r -- ) or ( r -- )  , ,

  _header _public,'F,'
f_comma_:
  call do_colon
  dw comma_,comma_
  dw paren_exit_

; FLITERAL  ( -- r )
;   aka fliteral 2literal immediate

  _header _public,'FLITERAL',_immediate,two_literal_
f_literal_ equ  two_literal_
f_lit_:    equ  two_lit_

; FCONSTANT  ( -- r )
;   aka 2constant fconstant

  _header _public,'FCONSTANT',,two_constant_
f_constant_: equ  two_constant_

do_f_constant: equ  two_fetch_

; FVARIABLE  ( -- fa )
;   aka 2variable fvariable

  _header _public,'FVARIABLE',,two_variable_
f_variable_: equ  two_variable_

; FDEPTH   ( -- +n )
;   depth 2/

  _header _public,'FDEPTH'
f_depth_:
  call do_colon
  dw depth_,two_slash_
  dw paren_exit_

; FDROP  ( r -- )
;   aka 2drop fdrop

  _header _public,'FDROP',,two_drop_
f_drop_: equ  two_drop_

; FDUP  ( r -- r r )
;   aka 2dup fdup

  _header _public,'FDUP',,two_dup_
f_dup_: equ  two_dup_

; FSWAP  ( r1 r2 -- r2 r1 )
;   aka 2swap fswap

  _header _public,'FSWAP',,two_swap_
f_swap_: equ  two_swap_

; FOVER  ( r1 r2 -- r1 r2 r1 )
;   aka 2over fover

  _header _public,'FOVER',,two_over_
f_over_: equ  two_over_

; FROT  ( r1 r2 r3 -- r2 r3 r1 )
;   aka 2rot frot

  _header _public,'FROT',,two_rot_
f_rot_: equ  two_rot_

; F@  ( fa -- r )
;   aka 2@ f@

  _header _public,'F@',,two_fetch_
f_fetch_: equ  two_fetch_

; F!  ( r fa -- )
;   aka 2! f!

  _header _public,'F!',,two_store_
f_store_: equ  two_store_

; FPICK  ( +n -- r )
;   floats sp@ cell+ + f@

  _header _public,'FPICK'
fpick_:
  call do_colon
  dw floats_
  if  separated_f_stack
    dw fsp_,fetch_
  else
    dw sp_fetch_,cell_plus_
  endif
  dw plus_,f_fetch_
  dw paren_exit_

; floating point accumulator

accumulator_exponent:     ds 1
accumulator_sign:         ds 1
accumulator_1st_fraction  ds 1
accumulator_2nd_fraction  ds 1
accumulator_3rd_fraction  ds 1

substraction_flag:        ds 1

float_tmp_1:
  ds fw    ; temp float storage
float_tmp_2:
  ds fw    ;

f_ten:
  call do_f_constant    ; fconstant
fp10:
  db 0x84,0x20,0,0  ; 10.0

; save/load temp fp registers

savf.1:
  ld hl,float_tmp_1    ; save_ regs to_ float_tmp_1
  jp str

savf.2:
  ld hl,float_tmp_2    ; save_ regs to_ float_tmp_2
  jp str

lodf.1:
  ld hl,float_tmp_1    ; load_ accum/regs from float_tmp_1
  jp lod

lodf.2:
  ld hl,float_tmp_2    ; load_ accum/regs from float_tmp_2
  jp lod

; pop float from stack to accum, saving bc

ldop:
  pop de
  pop hl
  ld (float_tmp_1),hl
  pop hl
  ld (float_tmp_1+2),hl
  push bc
  push de
  ld hl,float_tmp_1
  jp lod

; pop 2 float from stack to hl (floattmp2) and accum, saving bc

ld2op:
  pop hl
  ld (ld2op1),hl
  pop hl
  ld (float_tmp_2),hl
  pop hl
  ld (float_tmp_2+2),hl
  call ldop
  ld hl,(ld2op1)
  push hl
  ld hl,float_tmp_2
  ret

ld2op1:
  ds 2

; push float registers to stack, restore bc and exit

svop:
  ld l,a
  ld h,b
  ld e,c
  pop bc
  jp push_de_hl

; str  store registers to accum

strr:
  ld hl,accumulator_exponent
  ld (hl),e
  inc  hl

; entry - hl=adr, a=exp, bcd (packed)
; exit  - none

str:
  ld (hl),a
str.1:
  inc  hl    ; entry when hl=accumulator_sign
  ld (hl),b
  inc  hl
  ld (hl),c
  inc  hl
  ld (hl),d
  ret

; zero - set accum and regs to zero

zro:
  xor a
  ld (accumulator_exponent),a
  ld b,a
  ld c,a
  ld d,a
  ret

; overflow - set regs to maximum, set cy

ovf:
  ld bc,0x7fff
  ld a,c
  ld d,c
  scf
  ret

; chs  change sign of accumulator
; entry - none
; exit  - bcd (packed), a=exp, flags set

chs:
  ld a,0x80
  jp fab.1

; change sign of accumulator and again on result
; (when calling routine completes)

chss:
  call chs
  ld hl,chs
  ex (sp),hl
  jp (hl)

; fab  set acc to absolute
;
; entry - none
; exit  - bcd (packed), a=exp, flags set

fab:
  xor a
fab.1:
  ld hl,accumulator_sign
  and (hl)
  xor 0x80
  ld (hl),a    ; fall thru_ tst

; tst  load registers from acc and test
; exit  - bcd (packed), a=exp, flags set

tst:
  ld hl,accumulator_exponent
  ld a,(hl)
  and a
  jp z,zro
  ld e,a    ; e exp
  inc  hl
  ld a,(hl)    ; accumulator_sign
  inc  hl
  xor (hl)    ; pack msb with sign_
  inc  hl
  ld c,(hl)
  inc  hl
  ld d,(hl)
  jp tst.1

; lod  load float (hl) to accum and regs, set flags
; entry - hl=adr
; exit  - bcd (packed), a=exp, flags set

lod:
  ld a,(hl)
  and a
  jp z,zro
  ld e,a
  inc  hl
  ld a,(hl)
  inc  hl
  ld c,(hl)
  inc  hl
  ld d,(hl)
  ld l,a
  or 0x80
  ld b,a
  xor l
lod.2:
  call strr
  xor b

; entry - acd (packed), e=exp
; exit  - bcd (packed), a=exp, flags set

tst.1:
  ld b,a
tst.2:
  or 1    ; test sign_, clear Z C flags
  ld a,e
  ret

; entry - a=exp
; exit  - e=exp  Z=zero M=negative

tstr:
  ld e,a
tstr.1:
  or a
  ret  z
tstr.2:
  ld a,b
  jp tst.2

; fcmp  compare registers with (hl), return M if regs < (hl)

fcmp:
  ld e,a
  ld a,(hl)
  or a
  ld a,e
  jp z,tstr.1    ; hl zero_, test sign_ regs
  or a
  inc  hl
  ld a,(hl)
  cpl
  jp z,tst.2    ; regs zero_, test sign_ hl
  xor b
  jp p,tstr.2    ; signs differ
  call fcmp.1
  rra
  xor b    ; complement sign_ for neg values
  ld a,e
  ret

fcmp.1:
  dec  hl
  ld a,e
  cp (hl)
  ret  nz
  inc  hl
  ld a,b
  cp (hl)
  ret  nz
  inc  hl
  ld a,c
  cp (hl)
  ret  nz
  inc  hl
  ld a,d
  cp (hl)
  ret  nz
  pop hl
  ld a,e
  ret

; right shift bcd by a bits
;
; entry - bcd, a=shift count
; exit  - bcde

shr_:
  ld e,0
  ld l,8    ; shift 8 bits by moving registers
shr_.1:
  cp l
  jp m,shr_.2    ; less_ than 8
  ld e,d
  ld d,c
  ld c,b
  ld b,0
  sub  l
  jp nz,shr_.1
shr_.2:
  and a
  ret  z    ; done
  ld l,a
shr_.3:
  and a    ; clear carry
  ld a,b
  rra
  ld b,a
  ld a,c
  rra
  ld c,a
  ld a,d
  rra
  ld d,a
  ld a,e
  rra
  ld e,a
  dec  l
  jp nz,shr_.3
  ret

; left shift bcde one bit
;
; entry - bcde
; exit  - bcde

shl_:
  ld a,e
  rla
  ld e,a
  ld a,d
  rla
  ld d,a
  ld a,c
  rla
  ld c,a
  ld a,b
  adc  a,a
  ld b,a
  ret

; Complement bcde adjust accumulatorsign, return sign flag

fcpl:
  ld hl,accumulator_sign    ; change accum sign_
  ld a,(hl)
  xor 0x80
  ld (hl),a
  xor a    ; complement fraction
  ld l,a
  sub  e
  ld e,a
  ld a,l
  sbc a,d
  ld d,a
  ld a,l
  sbc a,c
  ld c,a
  ld a,l
  sbc a,b
  ld b,a
  ret

; Normalize bcde registers, adjust accumulatorexponent
;
; entry - bcde
; exit  - bcde, z= bcde=0 or accumulatorexponent=0

norm:
  ld l,32    ; max_ shift
norm.1:
  ld a,b
  and a
  jp nz,norm.3
  ld b,c
  ld c,d
  ld d,e
  ld e,a
  ld a,l
  sub  8
  ld l,a
  jp nz,norm.1
  ret     ; bcde = zero_

norm.2:
  dec  l    ; shl until_ bit 31 set
  call shl_
norm.3:
  jp p,norm.2

  ld a,l    ; adjust accum exp
  sub  32
  ld hl,accumulator_exponent
  add a,(hl)
  ld (hl),a
  ret  z    ; if zero_ exp
  rra      ; move_ borrow bit to_ sign_
  and a    ; set sign_ to_ indicate underflow
  ret

; Round the bcde registers, save to acc
;
; entry - bcde
; exit  - bcd, a=packed msb, e=exp, cy=ovf

rondr:
  ld a,e    ; lsb
  and a    ; test sign_ and clear cy
  ld hl,accumulator_exponent    ; exp
  ld e,(hl)
  call m,rondr.1
  ret  c    ; rounder overflow
  ld a,b
  inc  hl    ; accumulator_sign
  xor (hl)    ; a=packed_ msb
  jp str.1    ; save_ bcd to_ acc

; round up bcd e=exp, cy=ovf

rondr.1:
  inc  d
  ret  nz
  inc  c
  ret  nz
  inc  b
  ret  nz
  ld b,0x80    ; new 1st fraction
  ld a,e    ; inc exp
  add a,1    ; adjust cy
  ld e,a
  ld (accumulator_exponent),a  ; new acc exp
  ret

; fsu  floating point subtract subroutine

fsu:
  ld a,0x80    ; mask to_ change operand sign_
  jp fad.1

; fad  floating point add subroutine

fad:
  xor a
fad.1:
  ld e,(hl)    ; load_ operand to_ abcd
  inc  hl
  xor (hl)
  ld b,a
  inc  hl
  ld c,(hl)
  inc  hl
  ld d,(hl)
  ld a,e
  and a
  jp z,tst    ; operand zero_

  ld l,b    ; unpack
  ld a,b
  or 0x80
  ld b,a
  xor l    ; generate subtraction flag
  ld hl,accumulator_sign
  xor (hl)
  ld (substraction_flag),a

; determine relative magnitudes of operand and accum

  dec  hl    ; accumulator_exponent
  ld a,(hl)
  and a
  jp z,fad.8    ; accum zero_

  sub  e    ; get difference of_ exponents
  jp c,fad.2    ; accum smaller

; check for insignificant operand

  jp m,tst
  cp 25    ; compare_ shift count_ to_ 25
  jp c,fad.3
  jp tst

; check for insignificant accum, exchange accum and operand

fad.2:
  jp p,fad.8
  cp 0-25    ; compare_ shift count_ to_ -25
  jp c,fad.8

  ld (hl),e    ; set accumulator_exponent

  ld e,a    ; save_ shift count_

  ld a,(substraction_flag)    ; set accum sign_
  inc  hl    ; accumulator_sign
  xor (hl)
  ld (hl),a

  xor a    ; complement shift count_
  sub  e

  inc  hl    ; exchange fraction
  ld e,(hl)
  ld (hl),b
  ld b,e
  inc  hl
  ld e,(hl)
  ld (hl),c
  ld c,e
  inc  hl
  ld e,(hl)
  ld (hl),d
  ld d,e

; position the operand, check if add or subtract

fad.3:
  call shr_
  ld hl,accumulator_3rd_fraction
  ld a,(substraction_flag)
  and a
  jp m,fad.4

  ld a,(hl)    ; add
  add a,d
  ld d,a
  dec  hl
  ld a,(hl)
  adc  a,c
  ld c,a
  dec  hl
  ld a,(hl)
  adc  a,b
  ld b,a
  jp nc,fpack

  rra      ; got carry, so rshift_ fraction
  ld b,a
  ld a,c
  rra
  ld c,a
  ld a,d
  rra
  ld d,a
  rra
  ld e,a
  ld hl,accumulator_exponent    ; and adjust exponent
  ld a,(hl)
  add a,1
  ld (hl),a
  jp c,ovf    ; overflow
  jp fpack

fad.4:
  xor a    ; subtract
  sub  e
  ld e,a
  ld a,(hl)
  sbc a,d
  ld d,a
  dec  hl
  ld a,(hl)
  sbc a,c
  ld c,a
  dec  hl
  ld a,(hl)
  sbc a,b
  ld b,a

; complement bcde if carry

cnpack:
  call c,fcpl

; normalize and pack bcde

npack:
  ld a,b
  and a
  call p,norm
  jp p,zro    ; underflow or zero_

; pack bcde

fpack:
  call rondr    ; round bcde
  jp c,ovf
  jp tst.1

; move operand to accumulator

fad.8:
  ld a,(substraction_flag)
  ld hl,accumulator_sign
  xor (hl)
  jp lod.2

; read the operand at (hl), check the accum exponent

mdex:
  ld b,a
  inc  hl
  ld c,(hl)
  inc  hl
  ld d,(hl)
  inc  hl
  ld e,(hl)

  ld hl,accumulator_exponent    ; accum exp
  ld a,(hl)
  and a
  ret  z    ; is_ zero_

  add a,b    ; result exp plus_ bias
  ld b,a
  rra      ; carry to_ sign_
  xor b    ; carry and sign_ must differ
  ld a,b    ; result exp plus_ bias
  ld b,0x80    ; exp bias, sign_ mask, most sig bit
  jp p,mdex.1    ; if over_ or underflow
  sub  b    ; remove excess exp bias
  ret  z    ; return_ if underflow
  ld (hl),a    ; result exp
  inc  hl    ; address accum sign_
  ld a,(hl)
  xor c    ; result sign_ in sign_ bit
  and b    ; result sign_
  ld (hl),a    ; store_ it
  ld a,c    ; operand sign_ and 1st fraction
  or b    ; operand first fraction
  ret

mdex.1:
  rlca      ; set carry bit if overflow
  ret  c
  xor a    ; clear a register
  ret      ; return_ if underflow

; fmu  floating point multiplication subroutine

fmu:
  ld a,(hl)    ; operand exponent
  and a
  push hl
  call nz,mdex    ; read operand
  pop hl
  jp z,zro    ; zero_ or underflow
  jp c,ovf    ; overflow
  call mulx    ; fixed mult
  ld a,b    ; normalize if necessary
  and a
  jp m,fpack

  ld hl,accumulator_exponent    ; dec accum exp
  dec  (hl)
  ret  z    ; underflow
  call shl_
  jp fpack

; fixed point multiply subroutine

mulx:
  ld hl,mulx.4
  ld (hl),e    ; 3rd multiplicand
  inc  hl
  ld (hl),d    ; 2nd multiplicand
  inc  hl
  ld (hl),a    ; 1st multiplicand

  xor a    ; clear 6th product
  ld e,a    ; clear 5th product
  ld d,a    ; clear 4th product

; multiply  by each accumulator fraction in turn

  ld hl,accumulator_3rd_fraction
  call mulx.2    ; multiply by accum 3rd fraction
  ld hl,accumulator_2nd_fraction
  call mulx.1    ; multiply by accum 2nd fraction
  ld hl,accumulator_1st_fraction

; multiply by one accumulator byte

mulx.1:
  ld a,d    ; 5th partial product
  ld e,c    ; 4th partial prod
  ld d,b    ; 3rd partial prod
mulx.2:
  ld b,(hl)    ; multiplier
  ld l,a    ; 5th partial prod
  xor a    ; zero_ a register
  ld c,a    ; 2nd partial prod
  sub  b    ; set carry bit for exit_ flag
  jp c,mulx.3    ; if multiplier is_ not zero_
  ld c,d    ; 2nd partial product
  ld d,e    ; 3rd partial prod
  ret

; loop for each bit of multiplier byte

mulx.3:
  ld a,l    ; 5th partial product, exit_ flag
  adc  a,a    ; shift exit_ flag out if done
  ret  z    ; exit_ if multiplication done
  ld l,a    ; 5th partial prod, exit_ flag
  ld a,e    ; 4th partial prod
  rla      ; shift 4th partial prod
  ld e,a    ; 4th partial prod
  ld a,d    ; 3rd partial prod
  rla
  ld d,a
  ld a,c    ; 2nd partial prod
  rla
  ld c,a
  ld a,b    ; 1st partial prod and multiplier
  rla
  ld b,a
  jp nc,mulx.3  ; if no addition required

; add the multiplicand to the product if the multiplier bit is one

  ld a,(mulx.4)  ; operand 3rd fraction
  add a,e
  ld e,a    ; 4th partial prod
  ld a,(mulx.4+1)  ; operand 2nd fraction
  adc  a,d
  ld d,a    ; 3rd partial prod
  ld a,(mulx.4+2)  ; operand 1st fraction
  adc  a,c
  ld c,a    ; 2nd partial prod
  jp nc,mulx.3  ; if no carry to_ 1st prod
  inc  b    ; add carry to_ 1st prod
  and a    ; clear carry bit
  jp mulx.3

mulx.4:
  ds 3

; fdi  floating point division subroutine

fdi:
  xor a
  sub  (hl)    ; complement of_ divisor exponent
  cp 1    ; set carry if division by zero_
  push hl
  call nc,mdex    ; read operand if not zero_
  pop hl
  jp c,ovf    ; overflow or division by zero_
  jp z,zro    ; underflow or zero_
  ld c,a
  call divx    ; fixed division
  jp nc,ovf
  jp fpack

; fixed point divide subroutine

; subtract divisor from accum to obtain 1st remainder

divx:
  ld hl,accumulator_3rd_fraction
  ld a,(hl)    ; accum 3rd fraction
  sub  e
  ld (hl),a
  dec  hl
  ld a,(hl)    ; accum 2nd fraction
  sbc a,d
  ld (hl),a
  dec  hl
  ld a,(hl)    ; accum 1st fraction
  sbc a,c
  ld (hl),a

; halve the divisor and store for addition or subtraction

  ld a,c    ; get carry bit
  rla
  ld a,c    ; divisor 1st fraction
  rra
  ld (divx.4+3),a
  ld a,d    ; divisor 2nd fraction
  rra
  ld (divx.4+2),a
  ld a,e    ; divisor 3rd fraction
  rra
  ld (divx.4+1),a  ; 3rd subtract divisor
  ld b,0    ; init quot 1st fraction
  ld a,b    ; divisor 4th fraction is_ zero_
  rra
  ld (divx.4),a  ; 4th subtract divisor

; load 1st remainder

  ld a,(hl)    ; 1st fraction
  inc  hl
  ld d,(hl)    ; 2nd fraction
  inc  hl
  ld e,(hl)    ; 3rd fraction

; position remainder, initialise quotient, check sign

  ex de,hl    ; remainder 3rd fraction
        ; remainder 2nd fraction
  ld e,a    ; remainder 1st fraction
  ld c,b    ; init quot 2nd fraction
  ld d,b    ; init quot 3rd fraction
  and a
  jp m,divx.3    ; if remainder is_ negative

; adjust exponent

  ld a,(accumulator_exponent)  ; increment quotient exp
  inc  a
  ret  z    ; overflow
  ld (accumulator_exponent),a

  inc  d    ; init quot 3rd fraction

; subtract the divisor if remainder positive

divx.1:
  push bc
  ld c,l
  ld b,h
  xor a    ; 4th fraction is_ zero_
  ld hl,divx.4
  sub  (hl)
  ld a,c    ; 3rd fraction
  inc  hl
  sbc a,(hl)
  ld c,a
  ld a,b    ; 2nd fraction
  inc  hl
  sbc a,(hl)
  ld b,a
  ld a,e    ; 1st fraction
  inc  hl
  sbc a,(hl)
  ld e,a
  ld l,c
  ld h,b
divx.2:
  pop bc

  ld a,(divx.4)  ; remainder 4th fraction
  rlca      ; shift remainder 4th fraction to_ carry

; shift the remainder left one bit

  ld a,b
  rla
  ret  c    ; division complete
  rra      ; shift BCDEHL
  ld a,l
  rla
  ld l,a
  ld a,h
  rla
  ld h,a
  call shl_

; branch if subtraction is required

  ld a,d    ; quotient 3rd fraction
  rrca      ; remainder sign_ indic to_ carry bit
  jp c,divx.1    ; to_ sub divisor if remainder positive

; add the divisor if the remainder is negative

divx.3:
  push bc
  ld bc,divx.4+1
  ld a,(bc)    ; 3rd fraction
  add a,l
  ld l,a
  inc  bc
  ld a,(bc)    ; 2nd fraction
  adc  a,h
  ld h,a
  inc  bc
  ld a,(bc)    ; 1st fraction
  adc  a,e
  ld e,a
  jp divx.2

divx.4:
  ds fw

; convert 32 bit signed integer to float
; entry - abcd (int)

flt:
  ld e,d
  ld d,c
  ld c,b
  ld b,a

; convert 32 bit signed integer to float
; entry - bc:de (int)

flt0:
  ld a,32    ; scaling factor
flt.1:
  xor 0x80    ; apply exponent bias
  ld hl,accumulator_exponent
  ld (hl),a
  inc  hl
  ld (hl),0x80  ; assume positive accum sign_
  ld a,b    ; set cy if integer negative
  and a
  rla
  jp cnpack    ; complete the conversion

; convert signed integer A to float

flta:
  ld de,0
  ld c,e
  ld b,a
  ld a,8
  jp flt.1

; fix  convert float in acc to 32 bit integer
;
; exit  - abcd (int)

fix:
  ld e,32    ; scaling factor
  ld hl,accumulator_exponent
  ld a,(hl)
  and a
  jp z,zro    ; zero_
  ld a,e
  add a,0x80-1    ; add bias-1
  sub  (hl)    ; shift count_ -1
  ret  c    ; accum too large
  cp 31    ; compare_ to_ large shift
  jp nc,zro    ; accum too small
  add a,1    ; shift count_
  ld hl,accumulator_1st_fraction
  ld b,(hl)
  inc  hl
  ld c,(hl)
  inc  hl
  ld d,(hl)
  call shr_    ; position the fraction
  ld a,(accumulator_sign)  ; complement if negative
  and a
  call p,fcpl
  ld a,1    ; set flags
  or b
  ld a,b
  ld b,c
  ld c,d
  ld d,e
  ret

; Floor accum to integer
;
; entry - abcd
; exit  - abcd e=signed integer

flr:
  ld e,d
  cp 0x80+24
  ret  nc    ; no fraction
flr.1:
  ld e,a
  ld a,0x80    ; unpack b
  or b
  ld b,a
  ld a,(accumulator_sign)
  rla
  push af
  jp c,flr.3    ; positive
  ld a,d    ; decr bcd
  or a
  jp nz,flr.2
  dec  bc
flr.2:
  dec  d
flr.3:
  ld a,0x80+24
  sub  e
  call shr_
  pop af
  call nc,rondr.1  ; incr bcd
  ld a,0x80+24
  ld (accumulator_exponent),a
  ld a,d
  jp c,flr.4
  cpl
  inc  a
flr.4:
  push af
  ld e,0
  call npack    ; normalise and pack
  pop hl
  ld e,h
  ret

; Round accum to integer

rnd:
  call tstr
  call m,chss
  cp 0x80+24
  ret  nc    ; no fraction
  ld hl,fp50    ; 0.5
  call fad
  jp flr.1

; FABS  ( r1 -- r2 )

  _header _public,'FABS'
f_abs_:
  call ldop
  call fab
  jp svop

; FNEGATE  ( r1 -- r2 )

  _header _public,'FNEGATE'
fneg_:
  call ldop
  call chs
  jp svop

; D>F  ( d -- r )

  _header _public,'D>F'
d_to_f_:
  pop hl
  pop de
  push bc
  ld c,l
  ld b,h
  call flt0
  jp svop

; F>D  ( r -- d )

  _header _public,'F>D'
f_to_d_:
  call ldop
  call fix
  ld e,d
  ld d,c
  ld l,b
  ld h,a
  pop bc
  jp push_de_hl

; S>F  ( n -- r )
;   s>d d>f

  _header _public,'S>F'
s_to_f_:
  call do_colon
  dw s_to_d_,d_to_f_
  dw paren_exit_

; F>S  ( r -- n )
;   f>d d>s

  _header _public,'F>S'
f_to_s_:
  call do_colon
  dw f_to_d_,d_to_s_
  dw paren_exit_

; F0=  ( r -- flag )

  _header _public,'F0='
f_zero_equals_:
  pop hl
  ld h,l
  ex (sp),hl
  jp zero_equals_

; F=  ( r1 r2 -- flag )

  _header _public,'F='
f_equals_:
  call ld2op
  call fcmp
  pop bc
  jp nz,false_
  jp true_

; F0<  ( r -- flag )

  _header _public,'F0<'
f_zero_less_:
  pop hl
  pop de
  ld a,l
  or a
  jp z,false_    ; zero_
  ld a,h
  rla
  jp c,true_    ; negative
  jp false_

; F<  ( r1 r2 -- flag )

  _header _public,'F<'
f_less_:
  call ld2op
  call fcmp
  pop bc
  jp m,true_
  jp false_

; F0>  ( r -- flag )

  _header _public,'F0>'
f_zero_greater_:
  call ldop
f_zero_greater_.1:
  pop bc
  jp z,false_
  jp m,false_
  jp true_

; F>  ( r1 r2 -- flag )

  _header _public,'F>'
f_greater_:
  call ld2op
  call fcmp
  jp f_zero_greater_.1

; FMIN  ( r1 r2 -- r1 | r2 )
;   fover fover f< 0= if fswap then fdrop

  _header _public,'FMIN'
f_min_:
  call ld2op
  push hl
  call fcmp
  pop hl
  call p,lod    ; r1 >= r2
  jp svop

; FMAX  ( r1 r2 -- r1 | r2 )
;   fover fover f< if fswap then fdrop

  _header _public,'FMAX'
f_max_:
  call ld2op
  push hl
  call fcmp
  pop hl
  call m,lod    ; r1 < r2
  jp svop

; FLOOR  ( r1 -- r2 )

  _header _public,'FLOOR'
floor_:
  call ldop
  call flr
  jp svop

; FROUND  ( r1 -- r2 )

  _header _public,'FROUND'
f_round_:
  call ldop
  call rnd
  jp svop

; F+  ( r1 r2 -- r3 )

  _header _public,'F+'
f_plus_:
  call ld2op
  call fad
  jp svop

; F-  ( r1 r2 -- r3 )

  _header _public,'F-'
f_minus_:
  call ld2op
  call fsu
  jp svop

; F*  ( r1 r2 -- r3 )

  _header _public,'F*'
f_star_:
  call ld2op
  call fmu
  jp svop

; F/  ( r1 r2 -- r3 )

  _header _public,'F/'
f_slash_:
  call ld2op
  call fdi
  jp svop

; FRANDOM  ( r1 -- r2 )

  _header _public,'FRANDOM'
f_random_:
  call ldop
  jp m,f_random_.1    ; seed generator
  push af
  ld hl,f_random_.4
  call lod
  ld e,a
  pop af
  ld a,e
  jp z,svop    ; return_ last_ value_
  ld hl,f_random_.2  ; get next value_
  call fmu
  ld hl,f_random_.3
  call fad
f_random_.1:
  ld hl,accumulator_3rd_fraction
  ld b,(hl)    ; swap_ msb lsb
  dec  hl
  ld c,(hl)
  dec  hl
  ld d,(hl)
  dec  hl
  ld (hl),0x80  ; make positive
  dec  hl
  ld e,(hl)
  ld (hl),0x80  ; fix exponent
  call npack    ; normalise
  ld hl,f_random_.4
  call str
  jp svop

f_random_.2:
  db 0x98,0x35,0x44,0x7a
f_random_.3:
  db 0x68,0x28,0xb1,0x46
f_random_.4:
  db 0x80,0x31,0x41,0x59    ; seed

finstr:
  ds 3  ; string address, count_
finsgn:
  ds 1  ; sign_
finpt:
  ds 1  ; decimal_ point flag
finexp:
  ds 1  ; decimal_ exponent
fincvt:
  ds 1  ; converted digits

; fin  convert character string to float
; entry - hl=adr, a=len
; exit  - result in accum, cy=error

fin:
  dec  hl    ; init string adr, count_
  ld (finstr),hl
  inc  a
  ld (finstr+2),a

  ld a,0x80    ; set sign_ positive
  ld (finsgn),a
  xor a
  ld (finpt),a  ; clear decimal_ point flag
  ld (finexp),a  ; set decimal_ exponent = 0
  ld (fincvt),a  ; zero_ converted digits
  ld (accumulator_exponent),a  ; zero_ accum

  call fin.17    ; get 1st char_
  jp z,fin.14    ; treat zero_ length as zero_ blanks

  cp ' '
  jp nz,fin.2
fin.1:
  call fin.17    ; treat all blanks as zero_
  jp z,fin.14
  cp ' '
  jp z,fin.1
  scf
  ret

fin.2:
  cp '+'    ; check for sign_
  jp z,fin.3
  cp '-'
  jp nz,fin.4
  xor a    ; set negative flag
  ld (finsgn),a
fin.3:
  call fin.17    ; get char_ after sign_
  scf
  ret  z    ; none

fin.4:
  cp '.'    ; check for decimal_ point
  jp nz,fin.7
  ld hl,finpt
  xor (hl)
  ld (hl),a
  jp nz,fin.8
fin.5:
  scf      ; 2nd decimal_ point
  ret

fin.6:
  ld a,(fincvt)
  or a
  jp z,fin.5
  jp fin.14

; process char

fin.7:
  call fin.18    ; convert char_ to_ digit_
  ret  c    ; bad

  ld hl,fincvt
  inc  (hl)
  push af
  ld hl,fp10    ; mult old value_ by 10
  call fmu
  call savf.1
  pop af    ; convert digit_ to_ floating point
  call flta
  ld hl,float_tmp_1    ; add to_ old value_
  call fad

  ld a,(finpt)  ; if decimal_ point
  and a
  jp z,fin.8
  ld hl,finexp  ; decrement exponent
  dec  (hl)

; get next char

fin.8:
  ld b,0    ; zero_ exponent
  call fin.17
  jp z,fin.6    ; done

; check for exponent

  cp '+'
  jp z,fin.10
  cp '-'
  jp z,fin.10
  call uppercase_a
  cp 'E'
  jp z,fin.9
  cp 'D'
  jp nz,fin.4

; process exponent

fin.9:
  call fin.17    ; next char_
  jp z,fin.6    ; done

fin.10:
  ld b,a    ; save_ 1st char_
  sub  '-'    ; compare_ minus_ sign_
  ld e,a
  jp z,fin.11
  add a,'-'-'+'  ; compare_ plus_ sign_
  ld a,b
  jp nz,fin.12

fin.11:
  call fin.17    ; got sign_, get 1st digit_

fin.12:
  ld b,0    ; possible decimal_ exponent
  jp z,fin.6    ; none - assume zero_ exponent

fin.13:
  call fin.18
  ret  c    ; not digit_
  ld c,a    ; accumulate exponent
  ld a,b
  add a,a
  add a,a
  add a,b
  add a,a
  add a,c
  ld b,a
  call fin.17    ; get next
  jp nz,fin.13

  ld a,e    ; test exponent sign_
  and a
  jp nz,fin.14
  sub  b    ; complement if neg
  ld b,a

fin.14:
  ld a,(finsgn)  ; store_ accum sign_
  ld (accumulator_sign),a

; adjust exponent

  ld a,b
fin.15:
  ld hl,finexp
  add a,(hl)
  jp z,tst    ; done
  ld (hl),a
  ld hl,fp10
  jp p,fin.16
  call fdi    ; div by 10
  ld a,1
  jp fin.15

fin.16:
  call fmu    ; mul by 10
  ret  c    ; overflow
  ld a,0xff
  jp fin.15

; get next char, return z if end reached

fin.17:
  ld hl,finstr+2
  dec  (hl)
  ld hl,(finstr)
  inc  hl
  ld (finstr),hl
  ld a,(hl)
  ret

; convert ascii char (a) to digit, return cy if not in range 0-9

fin.18:
  sub  '0'
  ret  c
  cp 10
  ccf
  ret

; >FLOAT  ( ca u -- r true | false )

  _header _public,'>FLOAT'
to_float_:
  pop hl
  ld a,l    ; assume u <= 255
  pop hl
  push bc
  call fin
  ld e,c
  ld h,b
  ld l,a
  pop bc
  jp c,false_
  push de
  push hl
  jp true_

  _header _public,'MAX-PRECISION'
max_precision_:
  call do_byte_constant    ; max_ precision_
  db maxsig

  _header _hidden,'EXSN'
exsn_:
  call do_create    ; exponent, sign_
  ds 2*cw

; REPRESENT  ( r ca n -- exp sign flag )
;        2dup max-precision max [char] 0 fill
;        max-precision min 2>r fdup f0< 0 exsn 2!
;        fabs fdup f0= 0= if begin fdup 1.0e f<
;        0= while 10.0e f/ 1 exsn +! repeat begin
;        fdup 0.1e f< while 10.0e f* -1 exsn +!
;        repeat then r@ 0 max 0 ?do 10.0e f* loop
;        fround f>d 2dup <# #s #> dup r@ - exsn +!
;        2r> rot min 1 max cmove d0= if 1 0 else
;        exsn 2@ swap then true

  _header _public,'REPRESENT'
represent_:
  call do_colon
  dw two_dup_
  dw max_precision_,max_
  dw c_lit_
  db '0'
  dw fill_
  dw max_precision_,min_
  dw two_to_r_
  dw f_dup_,f_zero_less_
  dw zero_,exsn_,two_store_
  dw f_abs_
  dw f_dup_,f_zero_equals_
  dw zero_equals_
  dw question_branch_,represent_.3
represent_.1:
  dw f_dup_    ; begin_
  dw f_lit_
  db 0x81,0,0,0
  dw f_less_,zero_equals_
  dw question_branch_,represent_.2  ; while_
  dw f_ten,f_slash_
  dw one_,exsn_,plus_store_
  dw branch_,represent_.1  ; repeat_
represent_.2:
  dw f_dup_    ; begin_
  dw f_lit_
  db 0x7d,0x4c,0xcc,0xcd
  dw f_less_
  dw question_branch_,represent_.3  ; while_
  dw f_ten,f_star_
  dw true_,exsn_,plus_store_
  dw branch_,represent_.2  ; repeat_
represent_.3:
  dw r_fetch_
  dw zero_,max_,zero_
  dw paren_question_do_,represent_.5
represent_.do:
  dw f_ten,f_star_
  dw paren_loop_,represent_.do
represent_.5:
  dw f_round_,f_to_d_
  dw two_dup_
  dw less_number_sign_,number_sign_s_,number_sign_greater_
  dw dup_
  dw r_fetch_,minus_  ; handle overflow
  dw exsn_,plus_store_
  dw two_from_r_
  dw rot_,min_
  dw one_,max_
  dw cmove_
  dw d_zero_equals_
  dw question_branch_,represent_.6
  dw one_,zero_  ; 0.0E fixup
  dw branch_,represent_.7
represent_.6:
  dw exsn_,two_fetch_
  dw swap_
represent_.7:
  dw true_
  dw paren_exit_

; PRECISION  ( -- u )

  _header _public,'PRECISION'
precision_:
  call do_value
  dw maxsig    ; default

; SET-PRECISION  ( u -- )
;   1 max max-precision min to precision

  _header _public,'SET-PRECISION'
set_precision_:
  call do_colon
  dw one_,max_
  dw max_precision_,min_
  dw paren_to_,precision_
  dw paren_exit_

  _header _public,'FDP'
fdp_:
  call do_create    ; decimal_ point display
  dw -1    ; set by FINIT
  ds 2

  _header _hidden,'FBUF'
fbuf_:
  call do_create    ; fp string buffer_
  ds maxsig

  _header _hidden,'EX#'
exn_:
  call do_value    ; exponent
  ds cw

  _header _hidden,'SN#'
snn_:
  call do_value    ; sign_
  ds cw

  _header _hidden,'EF#'
efn_:
  call do_value    ; exponent factor
  ds cw

  _header _hidden,'PL#'
pln_:
  call do_value    ; places after decimal_ point
  ds cw

; (F1)  ( r -- r exp )
;        fdup fbuf max-precision represent 2drop

  _header _hidden,'(F1)'  ; get exponent
paren_f1_:
  call do_colon
  dw f_dup_
  dw fbuf_,max_precision_
  dw represent_,two_drop_  ; never error_
  dw paren_exit_

; (F2)  ( exp -- offset exp' )
;   s>d ef# fm/mod ef# *

  _header _hidden,'(F2)'  ; apply exponent factor
paren_f2_:
  call do_colon
  dw s_to_d_
  dw efn_,fm_slash_mod_
  dw efn_,star_
  dw paren_exit_

; (F3)  ( r places -- ca u )
;                               dup to pl# 0< if precision else (f1) ef# 0>
;                               if 1- (f2) drop 1+ then pl# + max-precision
;                               min then fbuf swap represent drop to sn# to
;                               ex# fbuf max-precision -trailing <# ;

  _header _hidden,'(F3)'  ; float to_ ascii
paren_f3_:
  call do_colon
  dw dup_
  dw paren_to_,pln_
  dw zero_less_
  dw question_branch_,paren_f3_.1
  dw precision_
  dw branch_,paren_f3_.3
paren_f3_.1:
  dw paren_f1_
  dw efn_,zero_greater_
  dw question_branch_,paren_f3_.2
  dw one_minus_
  dw paren_f2_,drop_
  dw one_plus_
paren_f3_.2:
  dw pln_,plus_
  dw max_precision_,min_
paren_f3_.3:
  dw fbuf_,swap_
  dw represent_
  dw drop_    ; never error_
  dw paren_to_,snn_
  dw paren_to_,exn_
  dw fbuf_
  dw max_precision_
  dw minus_trailing_
  dw less_number_sign_
  dw paren_exit_

; (F4)  ( exp -- )
;   pl# 0< >r dup abs s>d r@ 0= if # then #s
;        2drop dup sign 0< r> d0= if [char] + hold
;        then [char] E hold

  _header _hidden,'(F4)'  ; insert exponent
paren_f4_:
  call do_colon
  dw pln_,zero_less_
  dw to_r_
  dw dup_
  dw abs_,s_to_d_
  dw r_fetch_,zero_equals_
  dw question_branch_,paren_f4_.1
  dw number_sign_
paren_f4_.1:
  dw number_sign_s_
  dw two_drop_
  dw dup_,sign_
  dw zero_less_
  dw from_r_
  dw d_zero_equals_
  dw question_branch_,paren_f4_.2
  dw c_lit_
  db '+'
  dw hold_
paren_f4_.2:
  dw c_lit_
  db 'E'
  dw hold_
  dw paren_exit_

; (F5)  ( n -- +n|0 )
;   0max dup fdp 2+ +!

  _header _hidden,'(F5)'  ; conditionally set flag
paren_f5_:
  call do_colon
  dw zero_max_
  dw dup_
  dw fdp_,two_plus_
  dw plus_store_
  dw paren_exit_

; (F6)  ( ca u -- )
;   (f5) shold

  _header _hidden,'(F6)'  ; insert string
paren_f6_:
  call do_colon
  dw paren_f5_,s_hold_
  dw paren_exit_

; (F7)  ( n -- )
;   (f5) [char] 0 nhold

  _header _hidden,'(F7)'  ; insert '0's
paren_f7_:
  call do_colon
  dw paren_f5_
  dw c_lit_
  db '0'
  dw n_hold_
  dw paren_exit_

; (F8)  ( -- )
;   sn# sign 0 0 #>

  _header _hidden,'(F8)'  ; insert sign_
paren_f8_:
  call do_colon
  dw snn_,sign_
  dw zero_,zero_
  dw number_sign_greater_
  dw paren_exit_

; (F9)  ( ca u1 -- ca u2 )
;        pl# 0< if begin dup while 1- 2dup
;        + c@ [char] 0 - until 1+ then then

  _header _hidden,'(F9)'  ; trim trailing '0's
paren_f9_:
  call do_colon
  dw pln_,zero_less_
  dw question_branch_,paren_f9_.end
paren_f9_.1:
  dw dup_
  dw question_branch_,paren_f9_.end
  dw one_minus_,two_dup_
  dw plus_,c_fetch_
  dw c_lit_
  db '0'
  dw minus_
  dw question_branch_,paren_f9_.1
  dw one_plus_
paren_f9_.end:
  dw paren_exit_

; (FA)  ( u1 -- u1 u2 )
;   pl# 0< if dup else pl# then

  _header _hidden,'(FA)'
paren_fa_:
  call do_colon
  dw pln_,zero_less_
  dw question_branch_,paren_fa_.1
  dw dup_
  dw branch_,paren_fa_.end
paren_fa_.1:
  dw pln_
paren_fa_.end:
  dw paren_exit_

; (FB)  ( ca u n -- )
;   fdp cell+ off >r (f9) r@ + (fa) over -
;        (f7) (fa) min r@ - (f6) r> (fa) min (f7)
;        fdp 2@ or if [char] . hold then

  _header _hidden,'(FB)'  ; insert fraction n places right of_ dec. pt
paren_fb_:
  call do_colon
  dw fdp_,two_plus_
  dw off_
  dw to_r_
  dw paren_f9_
  dw r_fetch_,plus_
  dw paren_fa_
  dw over_,minus_
  dw paren_f7_
  dw paren_fa_,min_
  dw r_fetch_,minus_
  dw paren_f6_
  dw from_r_
  dw paren_fa_,min_
  dw paren_f7_
  dw fdp_,two_fetch_,or_
  dw question_branch_,paren_fb_.end
  dw c_lit_
  db '.'
  dw hold_
paren_fb_.end:
  dw paren_exit_

; (FC)  ( ca u n -- )
;        >r 2dup r@ min 2swap r> /string 0 (fb) (f6)

  _header _hidden,'(FC)'  ; split into int/frac and insert
paren_fc_:
  call do_colon
  dw to_r_
  dw two_dup_
  dw r_fetch_,min_
  dw two_swap_
  dw from_r_,slash_string_
  dw zero_,paren_fb_
  dw paren_f6_
  dw paren_exit_

; (FD)  ( r n factor -- ca u )
;        to ef# (f3) ex# 1- (f2) (f4) 1+ (fc) (f8)

  _header _hidden,'(FD)'  ; exponent form
paren_fd_:
  call do_colon
  dw paren_to_,efn_
  dw paren_f3_
  dw exn_,one_minus_
  dw paren_f2_
  dw paren_f4_
  dw one_plus_,paren_fc_
  dw paren_f8_
  dw paren_exit_

; (FS.)  ( r n -- ca u )
;   1 (fd)

  _header _public,'(FS.)'
paren_fs_dot_:
  ld hl,1
  push hl
  jp paren_fd_

; FS.R  ( r n1 n2 -- )
;        >r (fs.) r> s.r

  _header _public,'FS.R'
fs_dot_r_:
  call do_colon
  dw to_r_
  dw paren_fs_dot_
  dw branch_,d_dot_r_.1

; FS.  ( r -- )
;   -1 0 fs.r space

  _header _public,'FS.'
fs_dot_:
  call do_colon
  dw true_
  dw zero_,fs_dot_r_
  dw space_
  dw paren_exit_

if  fp_engineering_output_functions

; (FE.)  ( r -- ca u )
;   3 (fd)

  _header _public,'(FE.)'
paren_fe_dot_:
  ld hl,3
  push hl
  jp paren_fd_

; FE.R  ( r n1 n2 -- )
;   >r (fe.) r> s.r

  _header _public,'FE.R'
fe_dot_r_:
  call do_colon
  dw to_r_
  dw paren_fe_dot_
  dw branch_,d_dot_r_.1

; FE.  ( r -- )
;   -1 0 fe.r space

  _header _public,'FE.'
fe_dot_:
  call do_colon
  dw true_
  dw zero_,fe_dot_r_
  dw space_
  dw paren_exit_

endif ; fp_engineering_output_functions

; (F.)  ( r n -- ca u )
;        0 to ef# (f3) ex# dup max-precision > if
;        fbuf 0 0 (fb) max-precision - (f7) (f6)
;        else dup 0> if (fc) else abs (fb) 1 (f7)
;        then then (f8)

  _header _public,'(F.)'
paren_f_dot_:
  call do_colon
  dw zero_
  dw paren_to_,efn_
  dw paren_f3_
  dw exn_,dup_
  dw max_precision_,greater_
  dw question_branch_,paren_f_dot_.1  ; if
  dw fbuf_,zero_
  dw zero_,paren_fb_
  dw max_precision_,minus_
  dw paren_f7_
  dw paren_f6_
  dw branch_,paren_f_dot_.3  ; else
paren_f_dot_.1:
  dw dup_,zero_greater_
  dw question_branch_,paren_f_dot_.2
  dw paren_fc_
  dw branch_,paren_f_dot_.3  ; else
paren_f_dot_.2:
  dw abs_
  dw paren_fb_
  dw one_,paren_f7_
paren_f_dot_.3:
  dw paren_f8_    ; then_ then_
  dw paren_exit_

; F.R  ( r n1 n2 -- )
;   >r (f.) r> s.r

  _header _public,'F.R'
f_dot_r_:
  call do_colon
  dw to_r_
  dw paren_f_dot_
  dw branch_,d_dot_r_.1

; F.  ( r -- )
;   -1 0 f.r space

  _header _public,'F.'
f_dot_:
  call do_colon
  dw true_
  dw zero_,f_dot_r_
  dw space_
  dw paren_exit_

; (G.)  ( r n -- ca u )
;   >r (f1) -3 7 within  r> swap if (f.) else
;        (fs.) then

  _header _public,'(G.)'
paren_g_dot_:
  call do_colon
  dw to_r_
  dw paren_f1_
  dw lit_,-3
  dw c_lit_
  db 7
  dw within_
  dw from_r_,swap_
  dw question_branch_,paren_g_dot_.1  ; if
  dw paren_f_dot_
  dw branch_,paren_g_dot_.end  ; else
paren_g_dot_.1:
  dw paren_fs_dot_
paren_g_dot_.end:
  dw paren_exit_    ; then_

; G.R  ( r n1 n2 -- )
;   >r (g.) r> s.r

  _header _public,'G.R'
g_dot_r_:
  call do_colon
  dw to_r_,paren_g_dot_
  dw branch_,d_dot_r_.1

; G.  ( r -- )
;   -1 0 g.r space

  _header _public,'G.'
g_dot_:
  call do_colon
  dw true_
  dw zero_,g_dot_r_
  dw space_
  dw paren_exit_

;  sqr

sqr:
  call tstr
  ret  z    ; zero_
  jp m,ovf    ; neg
  call savf.1
  and a
  rra
  add a,0x40
  call savf.2
  ld d,5
sqr.1:
  push de
  call lodf.1
  ld hl,float_tmp_2
  call fdi
  ld hl,float_tmp_2
  call fad
  sub  1
  call savf.2
  pop de
  dec  d
  jp nz,sqr.1
  ld hl,float_tmp_2
  jp lod

;  poly

poly:
  push hl
  call savf.1
  pop hl
  ld a,(hl)
  ld (poly.3),a
  inc  hl
  push hl
  call lod
  jp poly.2

poly.1:
  ld hl,poly.3
  dec  (hl)
  pop hl
  ret  z
  push hl
  ld hl,float_tmp_1
  call fmu
  pop hl
  push hl
  call fad
poly.2:
  pop hl
  inc  hl
  inc  hl
  inc  hl
  inc  hl
  push hl
  jp poly.1

poly.3:
  ds 1

;  polx

polx:
  push hl
  call savf.2
  ld hl,float_tmp_2
  call fmu
  pop hl
  call poly
  ld hl,float_tmp_2
  jp fmu

;  exp

exp:
  ld hl,ln2
  call fdi
  cp 0x88
  jp nc,ovf
  cp 0x68
  ld hl,fp1
  jp c,lod
  call savf.2
  call flr
  call savf.1
  ld a,e
  add a,0x81
  jp z,exp.1
  push af
  call lodf.2
  ld hl,float_tmp_1
  call fsu
  ld hl,exp.4
  call poly
  pop af
  ld bc,0
  ld d,b
  call savf.1
  ld hl,float_tmp_1
  jp fmu

exp.1:
  call tst
  jp m,zro
  jp ovf

exp.4:
  db 7
  db 0x74,0x59,0x88,0x7c
  db 0x77,0x26,0x97,0x00e0
  db 0x7a,0x1e,0x1d,0xc4
  db 0x7c,0x63,0x50,0x5e
  db 0x7e,0x75,0xfe,0x1a
ln2:
  db 0x80,0x31,0x72,0x18    ; ln2
fp1:
  db 0x81,0,0,0    ; 1.0

;  log

log:
  call tstr
  jp m,ovf    ; neg
  jp z,ovf    ; zero_
  xor 0x80
  push af
  ld a,0x80
  ld hl,log.2
  call poly
  call savf.1
  pop af
  call flta
  ld hl,float_tmp_1
  call fad
  ld hl,ln2
  jp fmu

log.2:
  db 9
  db 0x82,0x94,0xee,0xd8
  db 0x84,0x7d,0xaa,0xa9
  db 0x86,0xbf,0x99,0x7d
  db 0x87,0x28,0xe5,0x7b
  db 0x87,0x00c0,0x71,0x8a
  db 0x87,0x14,0x95,0x6e
  db 0x86,0x00a0,0x1e,0xb2
  db 0x85,0x02,0x7a,0xad
  db 0x83,0x8d,0x9d,0x09

;  sin / cos

cos:
  ld hl,fpi.2
  call fad
sin:
  or a
  ret  z
  cp 0x80+25
  jp nc,ovf
  ld hl,f2pi
  call fdi
  call savf.1
  call flr
  or a
  push af
  ld hl,float_tmp_2
  call nz,str
  call lodf.1
  pop af
  ld hl,float_tmp_2
  call nz,fsu
  ld hl,fp25    ; 0.25
  call fsu
  push af
  jp m,sin.1
  ld hl,fp50    ; 0.5
  call fsu
  call p,chs
sin.1:
  ld hl,fp25    ; 0.25
  call fad
  ld e,a
  pop af
  ld a,e
  call p,chs
  ld hl,sin.7
  jp polx

sin.7:
  db 5
  db 0x86,0x1e,0xd7,0xfb
  db 0x87,0x99,0x26,0x64
  db 0x87,0x23,0x34,0x58
  db 0x86,0xa5,0x5d,0xe1
f2pi:
  db 0x83,0x49,0x0f,0xdb ; 2pi

fpi.2:
  db 0x81,0x49,0x0f,0xdb ; pi/2

fp50:
  db 0x80,0,0,0  ; 0.5
fp25:
  db 0x7f,0,0,0  ; 0.25

;  atan

atan:
  call tstr
  call m,chss    ; make positive
  cp 0x81
  jp c,atan.1    ; < 1
  ld hl,atan.3
  push hl
  call savf.1
  ld hl,fp1
  call lod
  ld hl,float_tmp_1
  call fdi
atan.1:
  ld hl,atan.9
  call fcmp
  jp m,atan.2
  ld hl,atan.4
  push hl
  call savf.1
  ld hl,atan.7
  call fad
  ld hl,atan.11
  call str
  call lodf.1
  ld hl,atan.6
  call poly
  ld hl,atan.11
  call fdi
atan.2:
  ld hl,atan.8
  jp polx

atan.3:
  ld hl,fpi.2
  call fsu
  jp chs

atan.4:
  ld hl,atan.10
  jp fad

atan.6:
  db 2
atan.7:
  db 0x81,0x5d,0xb3,0xd7
  db 0x81,0x80,0,0    ; -1.0

atan.8:
  db 4
  db 0x7e,0x83,0x35,0x62
  db 0x7e,0x4c,0x24,0x50
  db 0x7f,0xaa,0xa9,0x79
  db 0x81,0,0,0

atan.9:
  db 0x7f,0x09,0x38,0xa3
atan.10:
  db 0x80,0x06,0x0a,0x92

atan.11:
  ds fw

; FSQRT  ( r1 -- r2 )

  _header _public,'FSQRT'
fsqr_:
  call ldop
  call sqr
  jp svop

; FEXP  ( r1 -- r2 )

  _header _public,'FEXP'
f_exp_:
  call ldop
  call exp
  jp svop

; FLN  ( r1 -- r2 )

  _header _public,'FLN'
f_ln_:
  call ldop
  call log
  jp svop

; F**  ( r1 r2 -- r3 )
;   fswap fln f* fexp

  _header _public,'F**'
f_star_star_:
  call do_colon
  dw f_swap_,f_ln_
  dw f_star_,f_exp_
  dw paren_exit_

; FSIN  ( r1 -- r2 )

  _header _public,'FSIN'
f_sin_:
  call ldop
  call sin
  jp svop

; FCOS  ( r1 -- r2 )

  _header _public,'FCOS'
f_cos_:
  call ldop
  call cos
  jp svop

; FATAN  ( r1 -- r2 )

  _header _public,'FATAN'
f_atan_:
  call ldop
  call atan
  jp svop

; PI  ( -- r )

  _header _public,'PI'
f_pi_:
  call do_f_constant
  db 0x82,0x49,0x0f,0xdb  ; pi

; FINIT  ( -- )
;   max-precision set-precision fdp on

  _header _hidden,'FINIT'
f_init_:
  call do_colon
  dw max_precision_,set_precision_
  dw fdp_,on_
  dw paren_exit_

; FIDENTIFY  ( -- )

  _header _hidden,'FIDENTIFY'
f_identify_:
  call do_colon
  dw cr_
  dw paren_dot_quote_
  db f_identify_.end-$-1
  db 'Software floating-point ('
  if  separated_f_stack
    db 'separate'
  else
    db 'common'
  endif
  db ' stack)'
f_identify_.end:
  dw paren_exit_

; FNUMBER  ( ca u -- [r] flag )
;        2dup s" E" caps search -rot 2drop decimal?
;        and if >float else 2drop 0 then dup >r
;        state? and if postpone fliteral then r>

  _header _hidden,'FNUMBER'
f_number_:
  call do_colon
  dw two_dup_    ; scan_ 'E'
  dw paren_s_quot_
  _dcs 'E'
  if  case_insensitive_names
;    ; XXX FIXME -- the logic is wrong, because conditional compilation
;    ; sets a user_ variable_ to be modifed.
    ;; dw caps ; XXX OLD
    dw case_sensitive_search_,off_ ; XXX NEW
  endif
  dw search_
  dw minus_rot_,two_drop_
  dw decimal_question_ ; decimal_ base_?
  dw and_
  dw question_branch_,f_number_.2
f_number_.1:
  dw to_float_
  dw branch_,f_number_.3
f_number_.2:
  dw two_drop_,zero_
f_number_.3:
  dw dup_,to_r_
  dw compiling_question_
  dw and_
  dw question_branch_,f_number_.4
  dw f_literal_
f_number_.4:
  dw from_r_
  dw paren_exit_

;   ( -- )
;        :noname ['] noop dup (dofinitpatch) ! (dofidentifypatch) !
;        ['] false (interpret.fnumberpatch) ! (nfps) off (nfpm) off
;        ; remember

  _header _hidden,'(-FP)'
paren_minus_fp_:
  ld hl,noop_
  ld (do_f_init_patch),hl    ; INIT
  ld (do_f_identify_patch),hl    ; INDENTIFY
  ld hl,false_
  ld (interpret_.f_number_patch),hl    ; FNUMBER
;  ld hl,0
;  ld (nfps),hl
;  ld (nfpm),hl
  jp next

paren_minus_fp_.1:
  dw 0    ; link
  dw paren_minus_fp_    ; xt

  endif ; floating_point_support

; }}} **********************************************************
; End {{{

; XXX TODO it seems these 'last' labels could be renamed
; to 'top' instead:

top_nfa:  equ last_nfa   ; nfa of_ top word_ in FORTH_ vocabulary_
top_xt:   equ last_xt   ; xt of_ top word_ in FORTH_ vocabulary_ ; XXX OLD -- not used

init_dp:   equ $

  end start
