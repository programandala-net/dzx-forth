\ READ-LINE (second test)

\ 2015-02-18: Second test. It works!

( read-line )
2variable read-line-position variable read-line-fid
: READ-LINE  ( ca1 len1 fid -- len2 flag ior )
  dup read-line-fid !
  dup file-position  ( ca1 len1 fid ud ior )
  ?dup if  >r 2drop 2drop 0 0 r> exit  then
  ( ca1 len1 fid ud )
  read-line-position 2! ( ca1 len1 fid )
  >r  ( ca1 len1 )
  over swap ( ca1 ca1 len1 )
  r> ( ca1 ca1 len1 fid )
  read-file ( ca1 len1' ior ) ?dup if  exit  then
  \ no error ( ca1 len1' )
  2dup bounds -->
( ? do )
  ?do ( ca1 len1' )
    i ( ca1 len1' ca1' )
    dup c@ $1A = if  \ CTRL-Z?
      \ CTRL-Z found
      rot ( len1' ca1' ca1 )
      -   ( len1' len2 )
      read-line-fid @ file-size drop
\     ( len1' len2 d )
      read-line-fid @ reposition-file drop
      ( len1' len2 )
      leave  \ leave the loop
    then -->
( eol? )
    ( ca1 len1' ca1' )
    c@ eol? ?dup if      \     -->
      \ EOL found
      ( ca1 len1' eol ) \ + s>d
      i        ( ca1 len1' eol ca' )
      +        ( ca1 len1' eol+ca' )
      >r       ( ca1 len1' )
      over +   ( ca1 len1'+ca1 )
      r>       ( ca1 len1'+ca1 eol+ca' )
      swap     ( ca1 eol+ca' len1'+ca1 )
      -        ( ca1 x )
      dup 0<>  ( ca1 x x<>0 ) \ handle buffers > 32 KiB
      -->
( --- )
      read-line-fid @ file-position drop
      d+
      read-line-fid @ reposition-file
      drop i swap - -1 0 unloop exit
    then
  loop ( ca1 len2 | len1' len2 )
  nip   ( len2 ) dup   ( len2 len2 ) 0<>   ( len2 len2<>0 )
  0     ( len2 len2<>0 0 ) ;
