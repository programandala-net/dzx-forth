; DZX-Forth
; A direct-threaded Forth for ZX Spectrum
;
; A port of DX-Forth v4.00 (2014-07-30) for CP/M
;
; Assemble with Pasmo:
;   pasmo --tapbas dzx-forth.z80s dzx-forth.tap

no  equ 0
yes equ not no

; Date last revised

version macro
  db 'A-00-201412190349'
  endm
  ; XXX NOTE about the version
  ; Just before convert all
  ;   jp push_de/hl
  ; To
  ;   push de/hl
  ;   jp next

; Modification level

; XXX OLD
;;rel   equ 4 ; release #
;;rev   equ 00  ; revision #
;;beta  equ no  ; beta release

; Equates for conditional assembly

debug equ no  ; debugging messages
ucase equ yes ; forth names case insensitive
fpeng equ yes ; engineering output functions
cfs   equ yes ; control flow stack extensions
wopt  equ yes ; warning options
fpx equ no  ; extra f/p functions

;

x       equ no  ; show hidden words
;fstack equ yes ; separate floating point stack XXX TODO -- try
floord  equ no  ; integer division method
float   equ yes ; floating point
nfd     equ 6 ; max open source files (min = 2)
retro   equ no  ; classic forth behaviours

; Memory sizes

sm  equ 0x8000 ; start of system memory

cw  equ 2   ; cell size (bytes)
fw  equ 4 ; float size (bytes)

; Buffer sizes

us  equ 128   ; user variable space
rts equ 256   ; return stack space

tib_size  equ 80    ; TIB buffer size
;block_size                    equ 10*128    ; max block size (multiple of 128) ; XXX OLD
block_size                    equ 1024      ; max block size
file_handle_size              equ 6+36      ; file handle size (keep even)
filename_size                 equ 10        ; max path/filename size
word_buffer_size              equ 31+5      ; min WORD buffer size
parsed_string_buffer_size     equ 255       ; max parsed string buffer size
file_descriptor_size          equ filename_size+(4*cw)  ; file descriptor size ; XXX OLD
pictured_numeric_buffer_size  equ 68        ; pictured numeric buffer size

; DOS and memory equates

dosfcb  equ 0x005c   ; default file control block
dosbuf  equ 0x0080   ; default DTA and command-line buffer
tpa     equ 0x0100   ; program start
recsiz  equ 128   ; CP/M record size

; Equates

fhno  equ 10  ; max open handles

init  defl  noop  ; INIT
ident defl  noop  ; IDENT
fnu   defl  false ; FNUMBER
fnum  defl  0 ; fp-stack items
fps   defl  0 ; fp-stack size

toppru  defl  0 ; top prunes

; Float

   if float

maxsig  equ 7 ; max significant digits

init  defl  fpini
ident defl  fiden
fnu   defl  fnumb

;  if fstack
;fnum defl  6
;fps  defl  (fnum+5)*fw ; allow extra for fp display etc
;  endif

toppru  defl  fprun1

   endif

; ZX Spectrum

  include zx_spectrum_system_variables.z80s
  include zx_spectrum_rom_routines.z80s

; ASCII characters
; XXX TODO adapt
;; bel equ 0x07 ; bell ; XXX OLD
bs_char  equ 0x08 ; backspace
tab_char equ 0x09 ; tab
lf_char  equ 0x0a ; line feed
ff_char  equ 0x0c ; form feed
cr_char  equ 0x0d ; carriage return
;;can equ 0x18 ; ctl-x 
ctrl_z_char  equ 0x1a ; ctl-z ;; XXX OLD -- still used in old code
esc_char  equ 0x1b ; escape
sp_char  equ 0x20 ; space

; }}} **********************************************************
; Description {{{

; Forth Registers
;
; FORTH 8080  Forth preservation rules
; ----- ----  ------------------------
; IP    BC    Interpretive pointer. Should be preserved across
;             forth words.
; SP    SP    Data stack pointer. Should be used only as data
;             stack across forth words. May be used within forth
;             words if restored before NEXT.
;       DE    Input only when push_de called.
;       HL    Input only when push_hl called.
;
; comment conventions:
;
; a = address
; c = 8b character
; u = 16b unsigned number
; n = 16b signed number
; x = 16b signed or unsigned number
; d = 32b signed double number
; ud  = 32b unsigned double number
; xd  = 32b signed or unsigned number
; cfa,xt  = addr of code field (execution token)
; lfa = addr of link field
; nfa = addr of name field
; pfa = addr of parameter field (body)
;
; non Forth-83 Standard word definitions:
;
; FIG Fig-FORTH model
; ANS ANS FORTH Standard (document dpANS-6, June 1993)

; Memory allocation ; XXX OLD

; The memory above LIMIT is used only by the interpreter.  This space
; is not wasted for turnkey applications as LIMIT, user variables and
; stacks are relocated to EM giving applications more free ram (as
; indicated by UNUSED).

; EM  |-------------  end of memory
; |
; DPH |-------------
; |   word headers & system dictionary
; HM  |-------------
; |   interpretive string buffer
; |-------------
; |   terminal input buffer
; TIB |-------------
; |   file descriptor blocks
; FDB |-------------
; |   block buffer
; LIMIT |-------------
; |   handle r/w buffer
; HBUF  |-------------
; |   file handles
; |-------------
; |   user variables
; R0  |-------------
; |   return stack
; S0  |-------------
; |   data stack
; PAD |-------------
; |   word and number conversion area
; DP  |-------------
; |   application dictionary
; 0x0100 |-------------

; Header structure

; nfa db length+flags     ; length = 1..31
;     ds length           ; name 
; lfa dw previous_nfa
; cfa dw code_address
; pfa ds ...              ; data or code

; Memory map ; XXX TODO -- in progress

; ----- end of memory
; UDG
; ...
; WORD buffer
; parsed string buffer
; TIB
; file descriptor
; block buffer
; boot jumps
; ---- DZX-Forth's org
; ---- BASIC's RAMTOP
; ...
; BASIC program and variables
; system variables
; screen memory
; ROM

; }}} **********************************************************
; Macros {{{

; ------------------------------
; Macro for generating word headers

previous_nfa defl  0   ; initial link pointer (end of chain)

hdr macro enabled,name,immediate,fl,alias_xt
  ; enabled  = enable the header? (0=disable)
  ; name = name string
  ; immediate  = immediate
  ; fl  = application/system flag ; XXX OLD not used anymore
  ; XXX TODO remove 'fl' from the macro header calls
  ; alias_xt = alias xt
  if enabled

    ; the name field
    last_nfa defl  $ ; link address for next word
    bits  defl  0
    if not nul immediate
      bits  defl  bits+0x40  ; set immediate bit
    endif
    if not nul alias_xt
      bits  defl  bits+0x80  ; set alias bit
    endif
    local _first ; address of the first char of the name
    local _next  ; address after the last char of the name
    db _next-_first+bits    ; count and flags byte
    _first db  name
    _next
    
    ; the link field
    dw  previous_nfa

    ; the code field
    if nul alias_xt
      last_xt defl $+2
    else
      last_xt defl alias_xt
    endif
    dw last_xt
    previous_nfa defl  last_nfa

  endif

  endm

; ------------------------------
; Macro to generate a counted string

dcs macro string1,string2,string3,string4 ; allow comma separated
  local _first,_next
  db _next-_first ; count byte
  _first: db  string1
  if not nul string2
    db  string2
    if not nul string3
      db  string3
      if not nul string4
        db  string4
      endif
    endif
  endif
  _next
  endm

; ------------------------------
; Macro to ignore next 1 bytes

; XXX OLD -- not needed anymore
; XXX TODO -- how does it worked?
;;ignore1  macro
;;  db  0x00fe  ; cp n
;;   endm

; ------------------------------
; Macro to generate fdb table

gfdb   macro
  local _a
_a  defl  fdbs
   rept nfd
  dw  _a
_a  defl  _a+file_descriptor_size
   endm
   endm

; }}} **********************************************************
; Boot {{{

  org sm

  jp  cold_boot
;  jp  warm_boot  ; XXX TODO

; }}} **********************************************************
; Data {{{

sfb:
  ds  block_size    ; block buffer
fdbs:
  ds  file_descriptor_size*nfd ; file descriptor blocks
tib:
  ds  tib_size  ; TIB (terminal input buffer)

psb:
   if retro
  ds  parsed_string_buffer_size   ; buffer S"
   else
  ds  parsed_string_buffer_size+word_buffer_size ; buffer S" WORD
   endif

hm  equ $   ; system definitions and header memory
dnfa:
  db  0   ; dummy nfa - don't remove! ; XXX NEW -- changed its position in DX-Forth 4.09

; If the following byte is non-zero, a warm boot is NOT performed on
; exit to CPM.

; XXX OLD
;;noboot:
;;  db  0   ; no warm boot flag   0110

; Identification and version

;;  dw  0x4683   ; id  ('DXF' in radix 36) 0111
;;dxver:
;;  db  rel   ; release     0113
;;  db  rev   ; revision      0114

;
; XXX OLD
;;  ds  cw    ; reserved    NEXT-8  0115
user_area_pointer:
  ds  cw    ; user area pointer NEXT-6  0117
rpp:
  ds  cw    ; return stack pointer  NEXT-4  0119

; cpu speed (TURBO PASCAL compatible)

speed:
  dw  4   ; 1..8191 MHz

; Boot up variables used by COLD, must be in same order as USER variables

initu equ $   ; <<< beginning data
  ds  3*cw    ; reserved for multitasking
is0:
  ds  cw    ; s0
ir0:
  ds  cw    ; r0
idp:
  dw  initdp    ; dp
idph:
  dw  initdph   ; dph
ivoc:
  dw  forth2    ; voc-link
ifs0:
  ds  cw    ; fs0
  ds  cw    ; reserved
initu2  equ $   ; <<< end data

stack:
  ds  cw    ; CP/M stack pointer
esm:
  ds  cw    ; end of memory pointer
iboot:
  ds  cw    ; initial boot value
defdrv:
  ds  1   ; default drive
defusr:
  ds  1   ; default user
scaps:
  ds  1   ; COMPARE SEARCH case flag
cmdf:
  ds  1   ; command line flag
biospb:
  ds  5   ; bios param block
; XXX OLD 
;;dosv:
;;  ds  cw    ; CP/M version
;;ulimit:
;;  ds  cw    ; LIMIT for turnkey ; XXX NEW -- from DX-Forth 4.09
;;  ds  2   ; spare

; Arrow key codes (default = Wordstar style)

  db  'E'-0x40   ; up arrow      014F
  db  'X'-0x40   ; down arrow      0150
  db  'D'-0x40   ; right arrow     0151
  db  'S'-0x40   ; left arrow      0152

; Scratch buffer - shared by several functions:
; +EXT  DELETE-FILE  RENAME-FILE
;; sbuf equ $ ; XXX OLD ? -- not used

; Buffer for temporary filename/fcb

zbsiz equ filename_size+1+36

zb1:
  ds  zbsiz
zb2:
  ds  zbsiz

tmpstk  equ $-cw ; temp stack for startup

; }}} **********************************************************
; Misc. subroutines

; ------------------------------
; BC is preserved

subd:
  ex  de,hl ; subtract  hl <- de - hl
ssub:
  ld  a,l ; subtract  hl <- hl - de
  sub e
  ld  l,a
  ld  a,h
  sbc a,d
  ld  h,a
  ret

cmpu:
  ld  a,h ; unsigned compare - C if hl < de
  cp  d ;                  - Z if hl = de
  ret nz
  ld  a,l
  cp  e
  ret

cmps:
  ld  a,h ; signed compare - C if hl < de
  xor d
  jp  p,cmpu
  ld  a,h
  or  a
  ret p
  scf
  ret

gdrv:
  ld  a,25  ; get current drive a
  jp  bdoss

gusr:
  ld  a,0xff  ; get current user a

susr:
  ld  e,a ; set current user a
  ld  a,32

bdoss:
  push  bc  ; call bdos a
  ld  c,a
  call  0x0005
  pop bc
  ret

; ------------------------------
; BC is affected

; move block upwards  HL = source, DE = destination, BC = count

bmovu:
  add hl,bc
  ex  de,hl
  add hl,bc
  ex  de,hl
bmovu1:
  ld  a,c
  or  b
  ret z
  dec hl
  dec de
  ld  a,(hl)
  ld  (de),a
  dec bc
  jp  bmovu1

; move block up/down  HL = source, DE = destination, BC = count

bmove:
  call  cmpu
  jp  c,bmovu

; move block downwards  HL = source, DE = destination, BC = count

bmovd:
  ld  a,c
  or  b
  ret z
  ld  a,(hl)
  ld  (de),a
  inc hl
  inc de
  dec bc
  jp  bmovd

; move block downwards  HL = source, DE = destination, A = count

amovd:
  push  bc
  ld  c,a
  ld  b,0
  call  bmovd
  pop bc
  ret

; }}} **********************************************************
; Virtual machine {{{

; runtime for colon definitions

do_colon:
  ld  hl,(rpp)  ; push IP onto return stack
  dec hl
  ld  (hl),b
  dec hl
  ld  (hl),c
  ld  (rpp),hl
  pop bc    ; get new IP from 'call'
  jp  next

; runtime for user variables

do_user_variable:
  pop hl
  ld  e,(hl)
  inc hl
  ld  d,(hl)
  ld  hl,(user_area_pointer)
  add hl,de
  push hl
  jp next

; NOOP  ( -- )

  hdr 1,'NOOP'
noop  equ $

; NEXT  -  Forth Address Interpreter

next:
  ld  a,(bc)    ; 7T      NEXT  011D
  ld  l,a   ; 4T
  inc bc    ; 6T
  ld  a,(bc)    ; 7T
  ld  h,a   ; 4T
  inc bc    ; 6T
  jp  (hl)    ; 4T

; UNNEST  ( -- )

  hdr 1,'UNNEST'
unnest:
  ld  hl,(rpp)
  inc hl
  inc hl
  ld  (rpp),hl
  jp  next

; (EXIT)  ( -- )    exit colon definition

  hdr 1,'(EXIT)'
exit:
  ld  bc,next
exit1:
  push  bc
  ld  hl,(rpp)  ; pop IP from return stack
  ld  c,(hl)
  inc hl
  ld  b,(hl)
  inc hl
  ld  (rpp),hl

; EXECUTE  ( xt -- )

  hdr 1,'EXECUTE'
execute:
  ret

; @EXECUTE  ( a-addr -- )

  hdr 1,'@EXECUTE'
fetch_execute:
  pop hl
  ld  a,(hl)
  inc hl
  ld  h,(hl)
  ld  l,a
  or  h
  jp  z,next
  jp  (hl)

; clit  ( -- char )

  hdr x,'CLIT'  ; FIG
clit:
  ld  a,(bc)
  inc bc

; push A register

push_a:
  ld  l,a
  ld  h,0
push_hl:
  push hl
  jp next

; lit  ( -- n )

  hdr x,'LIT'   ; FIG
lit:
  ld  a,(bc)
  ld  l,a
  inc bc
  ld  a,(bc)
  ld  h,a
  inc bc
  push hl
  jp next

; 2lit  ( -- d )

  hdr x,'2LIT'
tlit:
  ld  a,(bc)
  ld  l,a
  inc bc
  ld  a,(bc)
  ld  h,a
  inc bc
  ld  a,(bc)
  ld  e,a
  inc bc
  ld  a,(bc)
  ld  d,a
  inc bc
  push de
  jp next

; }}} **********************************************************
; Stack functions {{{

; SP@  ( -- addr )

  hdr 1,'SP@'
sp_fetch:
  ld  hl,0
  add hl,sp
  push hl
  jp next

; SP!  ( addr -- )

  hdr 1,'SP!'
sp_store:
  pop hl
  ld  sp,hl
  jp  next

; RP@  ( -- addr )

  hdr 1,'RP@'
rp_fetch:
  ld  hl,(rpp)
  push hl
  jp next

; RP!  ( addr -- )

  hdr 1,'RP!'
rp_store:
  pop hl
  ld  (rpp),hl
  jp  next

; >R  ( x -- )

  hdr 1,'>R'
to_r:
  ld  hl,(rpp)
  pop de
  dec hl
  ld  (hl),d
  dec hl
  ld  (hl),e
  ld  (rpp),hl
  jp  next

; R>  ( -- x )

  hdr 1,'R>'
from_r:
  ld  hl,(rpp)
  ld  e,(hl)
  inc hl
  ld  d,(hl)
  inc hl
  ld  (rpp),hl
  push  de
  jp  next

; R@  ( -- x )

  hdr 1,'R@'
r_fetch:
  ld  hl,(rpp)
  jp  fetch1

; 2>R  ( x1 x2 -- )

  hdr 1,'2>R'
two_to_r:
  ld  hl,(rpp)
  ld  de,-cw*2
  add hl,de
  ld  (rpp),hl
  jp  two_store1

; 2R>  ( -- x1 x2 )

  hdr 1,'2R>'
two_from_r:
  ld  hl,(rpp)
  push  hl
  ld  de,cw*2
  add hl,de
  ld  (rpp),hl
  jp  tat

; 2R@  ( -- x1 x2 )

  hdr 1,'2R@'
two_r_fetch:
  ld  hl,(rpp)
  jp  tat1

; 2DROP  ( x1 x2 -- )

  hdr 1,'2DROP'
two_drop:
  pop hl
  pop hl ; XXX NEW
  jp  next ; XXX NEW -- because headers and code share the same zone

; DROP  ( x -- )

  hdr 1,'DROP'
drop:
  pop hl
  jp  next

; DUP  ( x -- x x )

  hdr 1,'DUP'
dup:
  pop hl
  push  hl
  push hl
  jp next

; ?DUP  ( x -- 0 | x x )

  hdr 1,'?DUP'
qdup:
  pop hl
  ld  a,l
  or  h
  jp  z,qdup1
  push  hl
qdup1:
  push hl
  jp next

; SWAP  ( x1 x2 -- x2 x1 )

  hdr 1,'SWAP'
swap:
  pop hl
  ex  (sp),hl
  push hl
  jp next

; OVER  ( x1 x2 -- x1 x2 x1 )

  hdr 1,'OVER'
over:
  pop de
  pop hl
  push  hl
  push de
  jp next

; ROT  ( x1 x2 x3 -- x2 x3 x1 )

  hdr 1,'ROT'
rot:
  pop de
  pop hl
  ex  (sp),hl
  push de
  jp next

; -ROT  ( x1 x2 x3 -- x3 x1 x2 )

  hdr 1,'-ROT'
drot:
  pop hl
  pop de
  ex  (sp),hl
  ex  de,hl
  push de
  jp next

; ROLL  ( xu xn .. x0 u -- xn .. x0 xu )

  hdr 1,'ROLL'
roll:
  pop hl
  add hl,hl
  ld  e,l
  ld  d,h
  add hl,sp
  push  bc
  ld  c,(hl)
  inc hl
  ld  b,(hl)
  push  bc
  ld  c,e
  ld  b,d
  ld  e,l
  ld  d,h
  inc de
  dec hl
  call  bmovu1
  pop hl
  pop bc
  ex  (sp),hl
  jp  next

   if cfs

; -ROLL  ( xu .. xu+1 x0 u -- x0 xu .. xu+1 )

  hdr 1,'-ROLL'

; XXX OLD -- DX-Forth 4.00
;;droll:
;;  call  do_colon
;;  dw  cells,two_to_r
;;  dw  sp_fetch,sp_fetch,tuck
;;  dw  r_fetch,cmove
;;  dw  sp_fetch,two_from_r
;;  dw  rot,plus,store
;;  dw  exit

; XXX NEW -- DX-Forth 4.09
droll:
  pop  hl
  add  hl,hl
  ex  de,hl
  ld  hl,0
  add  hl,sp
  push  bc
  ld  c,(hl)
  inc  hl
  ld  b,(hl)
  push  bc
  ld  c,e
  ld  b,d
  ld  e,l
  ld  d,h
  dec  de
  inc  hl
  call  bmovd
  pop  hl
  pop  bc
  ex  de,hl
  jp  store2

   endif

; PICK  ( xu .. x1 x0 u -- xu .. x1 x0 xu )

  hdr 1,'PICK'
pick:
  pop hl
  add hl,hl
  add hl,sp
  jp  fetch1

; NIP  ( x1 x2 -- x2 )

  hdr 1,'NIP'
nip:
  pop hl
  inc sp
  inc sp
  push hl
  jp next

; TUCK  ( x1 x2 -- x2 x1 x2 )

  hdr 1,'TUCK'
tuck:
  pop hl
  pop de
  push  hl
  push de
  jp next

; ><  ( x1 -- x2 )

  hdr 1,'><'
bswp:
  pop de
  ld  h,e
  ld  l,d
  push hl
  jp next

;  2DUP  ( x1 x2 -- x1 x2 x1 x2 )

  hdr 1,'2DUP'
tdup:
  pop hl
  pop de
  push  de
  push  hl
  push de
  jp next

;  2SWAP  ( x1 x2 x3 x4 -- x3 x4 x1 x2 )

  hdr 1,'2SWAP'
tswap:
; XXX OLD -- DX-Forth 4.00
;;  pop de
;;  pop hl
;;  inc sp
;;  inc sp
;;  ex  (sp),hl
;;  dec sp
;;  dec sp
;;  ex  de,hl
;;  ex  (sp),hl
;;  jp  push_de
; XXX NEW -- DX-Forth 4.09
  pop  hl
  pop  de
  ex  (sp),hl
  push  hl
  ld  hl,5
  add  hl,sp
  ld  a,(hl)
  ld  (hl),d
  ld  d,a
  dec  hl
  ld  a,(hl)
  ld  (hl),e
  ld  e,a
  pop  hl
  push de
  jp next

;  2OVER  ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )

  hdr 1,'2OVER'
tover:
  ld  hl,4
  add hl,sp
  jp  tat1

;  2ROT  ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
;  5 roll 5 roll

  hdr 1,'2ROT'
trot:
  call  do_colon
  dw  clit
  db  5
  dw  roll
  dw  clit
  db  5
  dw  roll
  dw  exit

;  2NIP  ( x1 x2 x3 x4 -- x3 x4 )

  hdr  1,'2NIP'
tnip:
  pop  hl
  pop  de
  inc  sp
  inc  sp
  inc  sp
  inc  sp
  push de
  jp next

; DEPTH  ( -- u )   sp@ s0 @ swap - 2/

  hdr 1,'DEPTH'
depth:
  call  do_colon
  dw  sp_fetch
  dw  szero,fetch
  dw  swap,subb
  dw  twodiv
  dw  exit

; end

; }}} **********************************************************
; Memory operations {{{

; @  ( a-addr -- x )

  hdr 1,'@'
fetch:
  pop hl
fetch1:
  ld  e,(hl)
  inc hl
  ld  d,(hl)
  push  de
  jp  next

; 2!  ( x1 x2 a-addr -- )

  hdr 1,'2!'
two_store:
  pop hl
two_store1:
  pop de
  ld  (hl),e
  inc hl
  ld  (hl),d
  inc hl
  jp  store1 ; XXX NEW -- because headers and code share the same zone
;  ignore1 ; XXX OLD

; !  ( x a-addr -- )

  hdr 1,'!'
store:
  pop hl
store1:
  pop de
store2:
  ld  (hl),e
  inc hl
  ld  (hl),d
  jp  next

; C@  ( c-addr -- char )

  hdr 1,'C@'
c_fetch:
  pop hl
  ld  l,(hl)
  ld  h,0
  push hl
  jp next

; C!  ( char c-addr -- )

  hdr 1,'C!'
cstor:
  pop hl
  pop de
cstor1:
  ld  (hl),e
  jp  next

; 2@  ( a-addr -- x1 x2 )

  hdr 1,'2@'
tat:
  pop hl
tat1:
  ld  e,(hl)
  inc hl
  ld  d,(hl)
  inc hl
  ld  a,(hl)
  inc hl
  ld  h,(hl)
  ld  l,a
  ex  de,hl
  push de
  jp next

; +!  ( x a-addr -- )

  hdr 1,'+!'
pstor:
  pop hl
  pop de
pstor1:
  ld  a,(hl)
  add a,e
  ld  (hl),a
  inc hl
  ld  a,(hl)
  adc a,d
  ld  (hl),a
  jp  next

; MOVE  ( addr1 addr2 u -- )

  hdr 1,'MOVE'  ; ANS
move:
  ld  l,c
  ld  h,b
  pop bc
  pop de
  ex  (sp),hl
  call  bmove
  pop bc
  jp  next

; ERASE  ( addr u -- )

  hdr 1,'ERASE'
erase:
  ld  e,0
  jp  fill1  ; XXX NEW -- because headers and code share the same zone
;  ignore1 ; XXX OLD

; FILL  ( c-addr u char -- )

  hdr 1,'FILL'
fill:
  pop de
fill1:
  ld  l,c
  ld  h,b
  pop bc
  ex  (sp),hl
  jp  fill3

fill2:
  ld  (hl),e
  inc hl
  dec bc
fill3:
  ld  a,c
  or  b
  jp  nz,fill2
  pop bc
  jp  next

; ON  ( addr -- )   -1 swap !

  hdr 1,'ON'
on:
  pop hl
on1:
  ld  de,-1
  jp  store2

; OFF  ( addr -- )  0 swap !

  hdr 1,'OFF'
off:
  pop hl
off1:
  ld  de,0
  jp  store2

; XXX OLD -- DX-Forth 4.00
; TOGGLE  ( c-addr x -- )

  hdr 1,'TOGGLE'
toggl:
  pop de
  pop hl
toggl1:
  ld  a,(hl)
  xor e
  ld  (hl),a
  jp  next

; XXX NEW -- DX-Forth 4.09
; CTOGGLE  ( x c-addr -- )

  hdr 1,'CTOGGLE'
ctog:
  pop hl
  pop de
ctog1:
  ; XXX TODO jp toggl1
  ld  a,(hl)
  xor e
  ld  (hl),a
  jp  next

; }}} **********************************************************
; Arithmetic and logical {{{

; AND  ( x1 x2 -- x3 )

  hdr 1,'AND'
and_:
  pop de
  pop hl
  ld  a,e
  and l
  ld  l,a
  ld  a,d
  and h
  ld  h,a
  push hl
  jp next

; OR  ( x1 x2 -- x3 )

  hdr 1,'OR'
or_:
  pop de
  pop hl
  ld  a,e
  or  l
  ld  l,a
  ld  a,d
  or  h
  ld  h,a
  push hl
  jp next

; XOR  ( x1 x2 -- x3 )

  hdr 1,'XOR'
xor_:
  pop de
  pop hl
  ld  a,e
  xor l
  ld  l,a
  ld  a,d
  xor h
  ld  h,a
  push hl
  jp next

abs:
  ld  a,h
  or  a
  ret p

negg:
  dec hl    ; two's complement
negg1:
  ld  a,l
  cpl
  ld  l,a
  ld  a,h
  cpl
  ld  h,a
  ret

sar:
  ld  a,h   ; shift arithmetic right
  rlca
  rrca
sar1:
  rra
  ld  h,a
  ld  a,l
  rra
  ld  l,a
  ret

dabss:
  ld  a,h
  or  a
  ret p

dnegg:
  sub a   ; 16 bit two's complement
  sub e
  ld  e,a
  ld  a,0
  sbc a,d
  ld  d,a
  ld  a,0
  sbc a,l
  ld  l,a
  ld  a,0
  sbc a,h
  ld  h,a
  ret

; INVERT  ( x1 -- x2 )  one's complement

  hdr 1,'INVERT'
invert:
  pop hl
  call  negg1
  push hl
  jp next

; NOT  ( x1 -- x2 )   aka 0= not

  hdr 1,'NOT',,,zero_equals    ; F79 NOT
nott  equ zero_equals

; S>D  ( n -- d )

  hdr 1,'S>D'
stod:
  ld  hl,0
  pop de
  ld  a,d
  or  a
  jp  p,stod1
  dec hl
stod1:
  push de
  jp next

; D>S  ( d -- n )     aka drop d>s

  hdr 1,'D>S',,,drop
dtos  equ drop

; NEGATE  ( n1 -- n2 )

  hdr 1,'NEGATE'
negat:
  pop hl
  call  negg
  push hl
  jp next

; ABS  ( n -- +n )

  hdr 1,'ABS'
abss:
  pop hl
  call  abs
  push hl
  jp next

; DNEGATE  ( d1 -- d2 )

  hdr 1,'DNEGATE'
dnegat:
  pop hl
  pop de
  call  dnegg
  push de
  jp next

; DABS  ( d -- +d )

  hdr 1,'DABS'
dabs:
  pop hl
  pop de
  call  dabss
  push de
  jp next

; +  ( x1 x2 -- x3 )

  hdr 1,'+'
plus:
  pop de
plus_de:
  pop hl
  add hl,de
  push hl
  jp next

; -  ( x1 x2 -- x3 )

  hdr 1,'-'
subb:
  pop de
  pop hl
  call  ssub
  push hl
  jp next

; D+  ( xd1 xd2 -- xd3 )

  hdr 1,'D+'
dplus:
  ld  hl,6
  add hl,sp
  ld  e,(hl)
  ld  (hl),c
  inc hl
  ld  d,(hl)
  ld  (hl),b
  pop bc
  pop hl
  add hl,de
  ex  de,hl
  pop hl
  ld  a,l
  adc a,c
  ld  l,a
  ld  a,h
  adc a,b
  ld  h,a
  pop bc
  push de
  jp next

; D-  ( xd1 xd2 -- xd3 )  dnegate d+

  hdr 1,'D-'
dsub:
  call  do_colon
  dw  dnegat,dplus
  dw  exit

; M+  ( xd1 n -- xd2 )  s>d d+

  hdr 1,'M+'    ; ANS
mplus:
  call  do_colon
  dw  stod,dplus
  dw  exit

; 1+  ( x1 -- x2 )

  hdr 1,'1+'
onep:
  pop hl
  inc hl
  push hl
  jp next

; 2+  ( x1 -- x2 )

  hdr 1,'2+'
twop:
  pop hl
  inc hl
  inc hl
  push hl
  jp next

; 1-  ( x1 -- x2 )

  hdr 1,'1-'
onem:
  pop hl
  dec hl
  push hl
  jp next

; 2-  ( x1 -- x2 )

  hdr 1,'2-'
twom:
  pop hl
  dec hl
  dec hl
  push hl
  jp next

; multiplication primitives

; AHL <- A * DE

mpyx:
  ld  hl,0
  ld  c,8
mpyx1:
  add hl,hl
  rla
  jp  nc,mpyx2
  add hl,de
  adc a,0
mpyx2:
  dec c
  jp  nz,mpyx1
  ret

; Unsigned 16*16 multiply, 32 bit result

; HLDE <- HL * DE

umstrr:
  push  bc    ; save IP
  ld  b,h
  ld  a,l
  call  mpyx
  push  hl
  ld  h,a
  ld  a,b
  ld  b,h
  call  mpyx
  pop de
  ld  c,d
  add hl,bc
  adc a,0
  ld  d,l
  ld  l,h
  ld  h,a
  pop bc    ; restore IP
  ret

; Signed 16*16 multiply, 32 bit result

; HLDE <- HL * DE

mstarr:
  ld  a,d
  xor h
  rla
  push  af
  call  abs
  ex  de,hl
  call  abs
  call  umstrr
  pop af
  ret nc
  jp  dnegg

; UM*  ( u1 u2 -- ud )

  hdr 1,'UM*'
umstr:
  pop de
  pop hl
  call  umstrr
  push de
  jp next

; M*  ( n1 n2 -- d )  2dup xor >r abs swap abs um* r> ?dnegate

  hdr 1,'M*'    ; ANS
mstar:
  pop de
  pop hl
  call  mstarr
  push de
  jp next

; *  ( x1 x2 -- x3 )  um* drop

  hdr 1,'*'
star:
  pop de
  pop hl
  call  umstrr
  push  de
  jp  next

; division primitives

usl1:
  sub c
  ld  h,a
  ld  a,e
  sbc a,b
usl2:
  inc l
  dec d
  ret z

usl3:
  add hl,hl
  rla
  ld  e,a
  ld  a,h
  jp  c,usl1
  sub c
  ld  h,a
  ld  a,e
  sbc a,b
  jp  nc,usl2
  ld  a,h
  add a,c
  ld  h,a
  ld  a,e
  dec d
  jp  nz,usl3
  ret

usl:
  ld  a,h
  ld  h,l
  ld  l,d
  ld  d,8   ; loop counter
  push  de
  call  usl3
  pop de
  push  hl
  ld  l,e
  call  usl3
  ld  d,a
  ld  e,h
  ld  a,l
  pop hl
  ld  h,l
  ld  l,a
  ret

; Unsigned 32/16 divide
;
; entry HLDE = dividend, BC = divisor
; exit  HL = quotient, DE = remainder

mum:
  ld  a,l   ; if overflow
  sub c
  ld  a,h
  sbc a,b
  jp  c,usl
  ld  hl,-1   ; set rem & quot to max
  ld  de,-1
  ret

; UM/MOD  ( ud u1 -- u2 u3 )

  hdr 1,'UM/MOD'
umslm:
  ld  l,c
  ld  h,b
  pop bc
  pop de
  ex  (sp),hl
  ex  de,hl
  call  mum
  pop bc
  push de
  jp next

; Signed 32/16 divide - floored
;
; entry HLDE = dividend, BC = divisor
; exit  HL = quotient, DE = remainder

msm:
  push  bc    ; save divisor
  ld  a,b
  xor h
  push  af    ; save quot sign
  push  hl    ; save dividend
  push  hl
  ld  l,c
  ld  h,b
  call  abs
  ld  c,l
  ld  b,h
  pop hl
  call  dabss
  call  mum
  pop af    ; sign remainder
  or  a
  ex  de,hl
  call  m,negg
  ex  de,hl
  pop af
  pop bc    ; restore divisor
  or  a   ; sign quot
  jp  p,msm1
  jp  negg

msm1:
  pop bc    ; discard return
msm2:
  pop bc
  push de
  jp next

; SM/REM  ( d n1 -- n2 n3 )

  hdr 1,'SM/REM'
smrem:
  ld  l,c
  ld  h,b
  pop bc
  pop de
  ex  (sp),hl
  ex  de,hl
smrem1:
  call  msm
  jp  msm2

; FM/MOD  ( d n1 -- n2 n3 )

  hdr 1,'FM/MOD'  ; ANS
fmmod:
  ld  l,c
  ld  h,b
  pop bc
  pop de
  ex  (sp),hl
  ex  de,hl
fmmod1:
  call  msm
  ld  a,d
  or  e
  jp  z,msm2    ; skip if remainder = 0
  dec hl    ; floor
  push  hl
  ex  de,hl
  add hl,bc
  ex  de,hl
  pop hl
  jp  msm2

; M/MOD  ( d n1 -- n2 n3 )  fm/mod or sm/rem

; XXX OLD -- DX-Forth 4.00 -- but kept
  hdr x,'M/MOD',,,msmod

   if floord
msmod equ fmmod
   else
msmod equ smrem
   endif

; /MOD  ( n1 n2 -- n3 n4 )  >r s>d r> m/mod

; XXX NEW -- DX-Forth 4.09 -- instead of 'M/MOD'
  hdr 1,'/MOD'
slmod:
  call  do_colon
  dw  to_r,stod
  dw  from_r,msmod
  dw  exit

; /  ( n1 n2 -- n3 )    /mod nip

  hdr 1,'/'
slash:
  call  do_colon
  dw  slmod,nip
  dw  exit

; MOD  ( n1 n2 -- n3 )    /mod drop

  hdr 1,'MOD'
modd:
  call  do_colon
  dw  slmod,drop
  dw  exit

; XXX OLD -- DX-Forth 4.00
;;; */MOD  ( n1 n2 n3 -- n4 n5 )  >r m* r> m/mod
;;
;;  header 1,'*/MOD'
;;ssmod:
;;  call  do_colon
;;  dw  to_r,mstar
;;  dw  from_r,msmod
;;  dw  exit

; XXX NEW -- DX-Forth 4.09
;  */MOD  ( n1 n2 n3 -- n4 n5 )  >r m* r> sm/rem
  hdr  1,'*/MOD'
ssmod:
  call  do_colon
  dw  to_r,mstar
  dw  from_r,smrem
  dw  exit

; */  ( n1 n2 n3 -- n4 )    */mod nip

  hdr 1,'*/'
ssla:
  call  do_colon
  dw  ssmod,nip
  dw  exit

; M*/  ( d1 n1 +n2 -- d2 )  abs >r 2dup xor swap abs >r -rot
;         dabs swap r@ um* rot r> um* rot 0 d+
;         r@ um/mod -rot r> um/mod nip swap
;         rot 0< if dnegate then

  hdr 1,'M*/'   ; ANS
mssl:
  call  do_colon
  dw  abss,to_r
  dw  tdup,xor_
  dw  swap,abss,to_r
  dw  drot,dabs
  dw  swap,r_fetch,umstr
  dw  rot,from_r,umstr
  dw  rot,zero,dplus
  dw  r_fetch,umslm
  dw  drot,from_r
  dw  umslm,nip
  dw  swap,rot,zless
  dw  zbran,mssl1
  dw  dnegat
mssl1:
  dw  exit

; 2*  ( x1 -- x2 )

  hdr 1,'2*'    ; ANS
tstar:
  pop hl
  add hl,hl
  push hl
  jp next

; 2/  ( n1 -- n2 )

  hdr 1,'2/'
twodiv:
  pop hl
  call  sar
  push hl
  jp next

; U2/  ( x1 -- x2 )

  hdr 1,'U2/'
utdiv:
  pop hl
  or  a
  ld  a,h
  call  sar1
  push hl
  jp next

; D2*  ( xd1 -- xd2 )

  hdr 1,'D2*'   ; ANS
dtstr:
  pop de
  pop hl
  add hl,hl
  ld  a,e
  rla
  ld  e,a
  ld  a,d
  rla
  ld  d,a
  ex  de,hl
  push de
  jp next

; D2/  ( d1 -- d2 )

  hdr 1,'D2/'
dtdiv:
  pop hl
  pop de
  call  sar
  ld  a,d
  rra
  ld  d,a
  ld  a,e
  rra
  ld  e,a
  push de
  jp next

; LSHIFT  ( x1 u -- x2 )

  hdr 1,'LSHIFT'    ; ANS
lsh:
  pop de
  pop hl
  inc e
lsh1:
  dec e
  jp  z,push_hl
  add hl,hl
  jp  lsh1

; RSHIFT  ( x1 u -- x2 )

  hdr 1,'RSHIFT'    ; ANS
rsh:
  pop de
  pop hl
  inc e
rsh1:
  dec e
  jp  z,push_hl
  or  a
  ld  a,h
  call  sar1
  jp  rsh1

; end

; }}} **********************************************************
; Comparison {{{ 

; 0=  ( x -- flag )

  hdr 1,'0='
zero_equals:
  pop hl
zequ1:
  ld  a,l
  or  h
  jp  z,true
  jp  false

; 0<>  ( x -- flag )

  hdr 1,'0<>'
zero_not_equals:
  pop hl
  ld  a,l
  or  h
  jp  z,false
  jp  true

; =  ( x1 x2 -- flag )  - 0=

  hdr 1,'='
equal:
  pop de
  pop hl
equal1:
  call  cmpu
  jp  z,true
  jp  false

; <>  ( x1 x2 -- flag ) - 0= 0=

  hdr 1,'<>'
nequ:
  pop de
  pop hl
  call  cmpu
  jp  z,false
  jp  true

; 0<  ( n -- flag )

  hdr 1,'0<'
zless:
  pop hl
zless1:
  add hl,hl
zless2:
  jp  c,true
  jp  false

; 0>  ( n -- flag )

  hdr 1,'0>'
zgrea:
  pop de
  ld  hl,0
zgrea1:
  call  cmps
  jp  c,true
  jp  false

; <  ( n1 n2 -- flag )

  hdr 1,'<'
less:
  pop de
  pop hl
  jp  zgrea1

; >  ( n1 n2 -- flag )

  hdr 1,'>'
great:
  pop hl
  pop de
  jp  zgrea1

; U<  ( u1 u2 -- flag )

  hdr 1,'U<'
uless:
  pop de
  pop hl
uless1:
  call  cmpu
  jp  c,true
  jp  false

; U>  ( u1 u2 -- flag )

  hdr 1,'U>'
ugrea:
  pop hl
ugrea1:
  pop de
  jp  uless1

; 0max  ( n1 -- n2 )  0 max

  hdr x,'0MAX'
zero_max:
  ld  de,0
  jp max_de

; MAX  ( n1 n2 -- n1 | n2 )  2dup < if swap then drop

  hdr 1,'MAX'
max:
  pop de
max_de:
  pop hl
  call  cmps
max1:
  ccf
max2:
  jp  c,max3
  ex  de,hl
max3:
  push hl
  jp next

; MIN  ( n1 n2 -- n1 | n2 )  2dup > if swap then drop

  hdr 1,'MIN'
min:
  pop de
  pop hl
  call  cmps
  jp  max2

; UMAX  ( u1 u2 -- u1 | u2 )  2dup u< if swap then drop

  hdr 1,'UMAX'
umax:
  pop de
  pop hl
  call  cmpu
  jp  max1

; UMIN  ( u1 u2 -- u1 | u2 )  2dup u> if swap then drop

  hdr 1,'UMIN'
umin:
  pop de
  pop hl
  call  cmpu
  jp  max2

; WITHIN  ( n1|u1 n2|u2 n3|u3 -- flag )  over - >r - r> u<

  hdr 1,'WITHIN'  ; ANS
within:
  pop hl
  pop de
  call  ssub
  ex  (sp),hl
  call  ssub
  jp  ugrea1

; BETWEEN  ( n1|u1 n2|u2 n3|u3 -- flag )  over - -rot - u< 0=

  hdr 1,'BETWEEN'
betw:
  pop hl
  pop de
  call  ssub
  ex  (sp),hl
  call  ssub
  pop de
  call  cmpu
  jp  z,true
  jp  zless2

; D0=  ( d -- flag )  or 0=

  hdr 1,'D0='
dzequ:
  call  do_colon
  dw  or_,zero_equals
  dw  exit

; D=  ( d1 d2 -- flag )

  hdr 1,'D='
dequ:
  pop de
  pop hl
  ex  (sp),hl
  call  cmpu
  pop de
  pop hl
  jp  nz,false
  jp  equal1

; D0<  ( d -- flag )  swap drop 0<

  hdr 1,'D0<'   ; ANS
dzle:
  pop hl
  pop de
  jp  zless1

; D<  ( d1 d2 -- flag ) rot 2dup = if 2drop u< exit then 2nip >

  hdr 1,'D<'
dless:
  pop de
  pop hl
  ex  (sp),hl
  call  cmpu
  jp  z,uless
  inc sp
  inc sp
  inc sp
  inc sp
  jp  zgrea1

; DU<  ( ud1 ud2 -- flag )  rot swap 2dup u< if 2drop 2drop -1 exit
;         then - if 2drop 0 exit then u<

  hdr 1,'DU<'
dules:
  pop de
  pop hl
  ex  (sp),hl
  call  cmpu
  pop de
  pop hl
  jp  c,true
  jp  nz,false
  jp  uless1

; DMIN  ( d1 d2 -- d1 | d2 )  2over 2over d< 0= if 2swap then 2drop

  hdr 1,'DMIN'
dmin:
  call  do_colon
  dw  tover,tover
  dw  dless,zero_equals
dmin1:
  dw  zbran,dmin2
  dw  tswap
dmin2:
  dw  two_drop
  dw  exit

; DMAX  ( d1 d2 -- d1 | d2 )  2over 2over d< if 2swap then 2drop

  hdr 1,'DMAX'
dmax:
  call  do_colon
  dw  tover,tover
  dw  dless
  dw  branch,dmin1

; end

; }}} **********************************************************
; Numeric conversion {{{ 

;  DECIMAL  ( -- )    10 base !

  hdr  1,'DECIMAL'
decimal:
  call  do_colon
  dw  clit
  db  10
  dw  base,store
  dw  exit

;  HEX  ( -- )    16 base !

  hdr  1,'HEX'
hex:
  call  do_colon
  dw  clit
  db  16
  dw  base,store
  dw  exit

;  digit  ( char base -- u -1 | 0 )

  hdr  x,'DIGIT'
digit:
  pop  hl
  pop  de
  ld  a,e
  call  uppercase_a
  sub  '0'
  jp  m,false
  cp  10
  jp  m,digit1
  sub  7
  cp  10
  jp  m,false
digit1:
  cp  l
  jp  p,false
  ld  e,a
  push  de
  jp  true

;  >NUMBER  ( d1 addr1 u1 -- d2 addr2 u2 )
;        begin dup while over c@ base @ digit while
;        >r 2swap r> swap base @ um* drop rot base @
;        um* d+ 2swap 1 /string 1 dpl +! repeat then

  hdr  1,'>NUMBER'
tonum:
  call  do_colon
tonum1:
  dw  dup    ; begin
  dw  zbran,tonum2  ; while
  dw  over,c_fetch
  dw  base,fetch
  dw  digit
  dw  zbran,tonum2  ; while
  dw  to_r
  dw  tswap,from_r
  dw  swap
  dw  base,fetch
  dw  umstr,drop
  dw  rot
  dw  base,fetch
  dw  umstr
  dw  dplus
  dw  tswap
  dw  one,sstr
  dw  one,dpl,pstor
  dw  branch,tonum1  ; repeat
tonum2:
  dw  exit    ; then

;  NUMBER?  ( c-addr u -- d -1 | 0 )
;        over c@ [char] - = over 0> and dup >r 1
;        and /string over c@ [char] . > and 0 0
;        2swap ?dup if >number dpl on dup if 1-
;        over c@ [char] . - or dpl off then while
;        then r> 2drop 2drop false else drop r> if
;        dnegate then true then

  hdr  1,'NUMBER?'
numq:
  call  do_colon    ; convert string to double number
  dw  over,c_fetch
  dw  clit
  db  '-'
  dw  equal
  dw  over,zgrea
  dw  and_
  dw  dup,to_r
  dw  one,and_
  dw  sstr
  dw  over,c_fetch
  dw  clit
  db  '.'
  dw  great,and_
  dw  zero,zero
  dw  tswap
  dw  qdup
  dw  zbran,numq2
  dw  tonum
  dw  dpl,on
  dw  dup
  dw  zbran,numq1
  dw  onem
  dw  over,c_fetch
  dw  clit
  db  '.'
  dw  subb,or_
  dw  dpl,off
numq1:
  dw  zbran,numq3
numq2:
  dw  from_r
  dw  two_drop,two_drop
  dw  false
  dw  branch,numq5
numq3:
  dw  drop
  dw  from_r
  dw  zbran,numq4
  dw  dnegat
numq4:
  dw  true
numq5:
  dw  exit

;  <#  ( -- )    pad hld !

  hdr  1,'<#'
bdigs:
  call  do_colon
  dw  pad
  dw  hld,store
  dw  exit

;  #>  ( d -- c-addr u )  2drop hld @ pad over -

  hdr  1,'#>'
edigs:
  call  do_colon
  dw  two_drop
  dw  hld,fetch
  dw  pad
  dw  over
  dw  subb
  dw  exit

;  +hld  ( +n -- c-addr )  negate hld +! hld @ dup dp @ u<
;        abort" HOLD buffer overflow"

  hdr  x,'+HLD'
phld:
  call  do_colon
  dw  negat,hld,pstor
  dw  hld,fetch,dup
  dw  dpp,fetch,uless
  dw  paren_abort_quote
  dcs  'HOLD buffer overflow'
  dw  exit

;  HOLD  ( char -- )  1 +hld c!

  hdr  1,'HOLD'
hold:
  call  do_colon
  dw  one,phld
  dw  cstor
  dw  exit

;  SIGN  ( n -- )    0< if [char] - hold then

  hdr  1,'SIGN'
sign:
  call  do_colon
  dw  zless
  dw  zbran,sign1
  dw  clit
  db  '-'
  dw  hold
sign1:
  dw  exit

;  #  ( ud1 -- ud2 )  0 base @ um/mod >r base @ um/mod r>
;        rot 9 over < if 7 + then [char] 0 + hold

  hdr  1,'#'
dig:
  call  do_colon
  dw  zero
  dw  base,fetch
  dw  umslm
  dw  to_r
  dw  base,fetch
  dw  umslm
  dw  from_r
  dw  rot
  dw  clit
  db  9
  dw  over,less
  dw  zbran,dig1
  dw  clit
  db  7
  dw  plus
dig1:
  dw  clit
  db  '0'
  dw  plus
  dw  hold
  dw  exit

;  #S  ( +d -- 0 0 )  begin # 2dup d0= until

  hdr  1,'#S'
digs:
  call  do_colon
digs1:
  dw  dig
  dw  tdup,dzequ
  dw  zbran,digs1
  dw  exit

;  SHOLD  ( c-addr u -- )  dup +hld swap move

  hdr  1,'SHOLD'  ; hold string
shold:
  call  do_colon
  dw  dup,phld
  dw  swap,move
  dw  exit

;  NHOLD  ( n char -- )  over +hld -rot fill

  hdr  1,'NHOLD'  ; hold n characters
nhold:
  call  do_colon
  dw  over,phld
  dw  drot,fill
  dw  exit

;  decimal? ( -- flag )  base @ 10 =

  hdr  x,'DECIMAL?'
dcmq:
  call  do_colon
  dw  base,fetch    ; decimal base?
  dw  clit
  db  10
  dw  equal
  dw  exit

; }}} **********************************************************
; String functions {{{ 

; CMOVE  ( c-addr1 c-addr2 u -- )

  hdr 1,'CMOVE'
cmove:
  ld  l,c
  ld  h,b
  pop bc
  pop de
  ex  (sp),hl
cmove1:
  call  bmovd
  pop bc
  jp  next

; CMOVE>  ( c-addr1 c-addr2 u -- )

  hdr 1,'CMOVE>'
cmovu:
  ld  l,c
  ld  h,b
  pop bc
  pop de
  ex  (sp),hl
cmovu1:
  call  bmovu
  pop bc
  jp  next

; BLANK  ( c-addr u -- )  bl fill

  hdr 1,'BLANK'
blank:
  ld  e,' '
  jp  fill1

; COUNT  ( c-addr1 -- c-addr2 u )  dup 1+ swap c@

  hdr 1,'COUNT'
count:
  pop de
;;count1: ; XXX OLD
  ld  a,(de)
  inc de
  push  de
  jp  push_a

;  PACKED  ( c-addr1 u c-addr2 -- c-addr2 )
;            2dup 2>r 1+ swap move 2r> tuck c!

  hdr  1,'PACKED'
packd:
  ld  l,c
  ld  h,b
  pop  de
  pop  bc
  ex  (sp),hl
  push  bc
  push  de
  inc  de
  call  bmove
  pop  hl
  pop  de
  ld  (hl),e
  pop  bc
  push hl
  jp next

;  PLACE  ( c-addr1 u c-addr2 -- )  packed drop

  hdr  1,'PLACE'
place:
  call  do_colon
  dw  packd,drop
  dw  exit

; XXX OLD -- DX-Forth 4.00
;;; PLACE  ( c-addr1 u c-addr2 -- )  2dup 2>r 1+ swap move 2r> c!
;;
;;  header 1,'PLACE'
;;place:
;;  call  do_colon
;;  dw  tdup
;;  dw  two_to_r
;;  dw  onep,swap
;;  dw  move
;;  dw  two_from_r
;;  dw  cstor
;;  dw  exit

; affix  ( c-addr char -- c-addr )  over count + c!

  ; append char to counted string
  ; count unchanged
  hdr x,'AFFIX'
affix:
  call  do_colon
  dw  over
  dw  count,plus
  dw  cstor
  dw  exit

; SCAN  ( c-addr1 u1 char -- c-addr2 u2 )

  hdr 1,'SCAN'
scan:
  pop de
  ld  l,c
  ld  h,b
  pop bc
  ex  (sp),hl
scan1:
  ld  a,c
  or  b
  jp  z,scan2
  ld  a,e
  cp  (hl)
  jp  z,scan2
  inc hl
  dec bc
  jp  scan1

scan2:
  ex  (sp),hl
scan3:
  push  bc
  ld  c,l
  ld  b,h
  jp  next

; SKIP  ( c-addr1 u1 char -- c-addr2 u2 )

  hdr 1,'SKIP'
skip:
  pop de
  ld  l,c
  ld  h,b
  pop bc
  ex  (sp),hl
skip1:
  ld  a,c
  or  b
  jp  z,scan2
  ld  a,e
  cp  (hl)
  jp  nz,scan2
  inc hl
  dec bc
  jp  skip1

; -TRAILING  ( c-addr u1 -- c-addr u2 )

  hdr 1,'-TRAILING'
dtrai:
  pop de
  pop hl
  push  hl
  add hl,de
  ex  de,hl
dtrai1:
  dec de
  ld  a,l
  or  h
  jp  z,push_hl
  ld  a,(de)
  cp  ' '
  jp  nz,push_hl
  dec hl
  jp  dtrai1

; /STRING  ( c-addr1 u1 n -- c-addr2 u2 )   rot over + -rot -

  hdr 1,'/STRING' ; ANS
sstr:
  pop de
  pop hl
  call  ssub
  ex  (sp),hl
  add hl,de
  ex  (sp),hl
  push hl
  jp next

; CAPS  ( -- )    enable caps COMPARE/SEARCH

  hdr 1,'CAPS'
caps:
  ld  a,1
  jp  dcaps1 ; XXX NEW -- because headers and code share the same zone
;  ignore1 ; XXX OLD

; -caps  ( -- )   disable caps COMPARE/SEARCH

  hdr x,'-CAPS'
dcaps:
  xor a
dcaps1:
  ld  (scaps),a
  jp  next

; string match  HL = a1  BC = a2  DE = len  Z if match

cmpnc:
  ld  a,e ; case insensitive
  or  d
  ret z
  push  bc
  ld  a,(bc)
  call  uppercase_a
  ld  c,a
  ld  a,(hl)
  call  uppercase_a
  cp  c
  pop bc
  ret nz
  inc hl
  inc bc
  dec de
  jp  cmpnc

cmpss:
  ld  a,(scaps)
  or  a
  jp  nz,cmpnc

; string match  HL = a1  BC = a2  DE = len  Z if match

cmpsb:
  ld  a,e ; case sensitive
  or  d
  ret z
  ld  a,(bc)
  cp  (hl)
  ret nz
  inc hl
  inc bc
  dec de
  jp  cmpsb

; COMPARE  ( c-addr1 u1 c-addr2 u2 -- -1 | 0 | 1 )

  hdr 1,'COMPARE' ; ANS
cmpp:
  pop de
  pop hl
  ex  (sp),hl
  ld  a,d
  cp  h
  jp  nz,cmpp1
  ld  a,e
  cp  l
cmpp1:
  jp  c,cmpp2
  ex  de,hl
cmpp2:
  ld  l,c
  ld  h,b
  pop bc
  ex  (sp),hl
  push  af
  call  cmpss
  jp  z,cmpp4
  pop bc
cmpp3:
  pop bc
  ld  a,0
  ld  (scaps),a
  jp  c,one
  jp  z,false
  jp  true

cmpp4:
  pop af
  jp  cmpp3

; SEARCH  ( c-addr1 u1 c-addr2 u2 -- c-addr3 u3 -1 | c-addr1 u1 0 )

  hdr 1,'SEARCH'
search:
  call  do_colon
  dw  $+2
  pop hl
  ld  (string_2_len),hl
  ld  a,l
  or  h
  pop bc
  pop hl
  ld  (string_1_len),hl
  ex  de,hl
  pop hl
  ld  (string_1_addr),hl
  jp  z,search2
  dec hl
  inc de
search1:
  inc hl
  dec de
  ld  a,e
  or  d
  jp  z,search4
; XXX commented out in DX-Forth:
; ld  a,(bc)
; cp  (hl)
; jp  nz,search1
  push  de
  push  bc
  push  hl
  ex  de,hl
string_2_len equ $+1
  ld  hl,0  ; length of the second string
  ex  de,hl
  call  cmpss
  pop hl
  pop bc
  pop de
  jp  nz,search1

search2:
  ld  bc,-1
search3:
  push  hl
  push  de
  push  bc
  xor a
  ld  (scaps),a
  jp  exit

search4:
  ld  bc,0
string_1_len equ $+1
  ld  hl,0  ; length of the first string
  ex  de,hl
string_1_addr equ $+1
  ld  hl,0  ; address of the first string
  jp  search3

;;; +STRING  ( c-addr1 u1 c-addr2 u2 -- c-addr2 u3)
;;;         2swap swap 2over + 2 pick cmove +
;;
;;  header 1,'+STRING'
;;pstr:
;;  call  do_colon
;;  dw  tswap,swap
;;  dw  tover,plus
;;  dw  two,pick
;;  dw  cmove,plus
;;  dw  exit

; XXX NEW -- DX-Forth 4.09
;  +STRING  ( c-addr1 u1 c-addr2 u2 -- c-addr2 u3)
;          2swap swap 2over + 2 pick cmove +

  hdr  1,'+STRING'  ; uses temps 1-3
pstr:
  ld  l,c
  ld  h,b
  ld  (t3),hl    ; bsave
  pop  de
  pop  hl
  ld  (t2),hl    ; adr2
  add  hl,de
  ex  de,hl
  pop  bc
  add  hl,bc
  ld  (t1),hl    ; u3
  pop  hl
  call  bmovd
  ld  hl,(t3)    ; bsave
  ld  c,l
  ld  b,h
  ld  hl,t1
  jp  tat1

; XXX TMP
t1: ds cw
t2: ds cw
t3: ds cw

; XXX NEW -- DX-Forth 4.09
;  S.R  ( c-addr n1 n2 -- )  over - spaces type

  hdr  1,'S.R'    ; type string right-justified
sdotr:
  call  do_colon
  dw  over,subb
  dw  spacs
  dw  typee
  dw  exit

; UPCASE  ( char1 -- char2 )

  hdr 1,'UPCASE'  ; make char uppercase
upcas:
  pop hl
  ld  a,l
  call  uppercase_a
  jp  push_a

; UPPER  ( c-addr u -- )

  hdr 1,'UPPER' ; make string uppercase
upper:
  pop de
  pop hl
upper1:
  ld  a,d
  or  e
  jp  z,next
  ld  a,(hl)
  call  uppercase_a
  ld  (hl),a
  inc hl
  dec de
  jp  upper1

; XXX NEW -- after Gforth
; TOUPPER  ( c1 -- c2 )

  hdr 1,'TOUPPER' ; make char uppercase

toupper:
  pop hl
  ld a,l
  call uppercase_a
  jp next

uppercase_a:
  cp  'a'
  ret c
  cp  'z'+1
  ret nc
  xor 0x20
  ret

; XXX NEW -- after UPPER
; LOWER  ( c-addr u -- )

  hdr 1,'LOWER' ; make string lowercase
lower:
  pop de
  pop hl
lower1:
  ld  a,d
  or  e
  jp  z,next
  ld  a,(hl)
  call  lowercase_a
  ld  (hl),a
  inc hl
  dec de
  jp  lower1

; XXX NEW -- after TOUPPER
; TOLOWER  ( c1 -- c2 )

  hdr 1,'TOLOWER' ; make char lowercase

tolower:
  pop hl
  ld a,l
  call lowercase_a
  jp next

lowercase_a:
  cp  'A'
  ret c
  cp  'Z'+1
  ret nc
  xor 0x20
  ret

; }}} **********************************************************
; Control structures {{{

; (of)  ( n1 n2 -- )

  hdr x,'(OF)'
pof:
  pop hl
  pop de
  call  ssub    ; equal?
  ld  a,l
  or  h
  jp  z,zbran1
  push  de
; jp  branch

; branch  ( -- )

  hdr x,'BRANCH'
branch:
  ld  h,b
  ld  l,c
  ld  c,(hl)
  inc hl
  ld  b,(hl)
  jp  next

; ?branch  ( flag -- )

  hdr x,'?BRANCH'
zbran:
  pop hl
  ld  a,l
  or  h
  jp  z,branch
zbran1:
  inc bc
  inc bc
  jp  next

; (loop)  ( -- )

  hdr x,'(LOOP)'
xloop:
  ld  hl,(rpp)
  inc (hl)
  jp  nz,branch
  inc hl
  inc (hl)
  jp  nz,branch
xloop1:
  inc bc    ; skip over branch
  inc bc
; jp  unloo

; UNLOOP  ( -- )

  hdr 1,'UNLOOP'  ; ANS
unloo:
  ld  hl,(rpp)  ; discard loop parameters
  ld  de,cw*2
  add hl,de
  ld  (rpp),hl
  jp  next

; (+loop)  ( n -- )

  hdr x,'(+LOOP)'
xploo:
  ld  hl,(rpp)
  ld  e,(hl)
  inc hl
  ld  d,(hl)
  pop hl
  ld  a,h
  or  a
  jp  m,xploo2
  add hl,de
  jp  c,xloop1
xploo1:
  ex  de,hl
  ld  hl,(rpp)
  ld  (hl),e
  inc hl
  ld  (hl),d
  jp  branch

xploo2:
  add hl,de
  jp  c,xploo1
  jp  xloop1

; (leave)  ( -- )

  hdr x,'(LEAVE)'
pleav:
  ld  a,(bc)
  ld  l,a
  inc bc
  ld  a,(bc)
  ld  h,a
  ld  c,(hl)
  inc hl
  ld  b,(hl)
  jp  unloo

; (?do)  ( n1 n2 -- ) 2dup = if 2drop r> @ >r exit then (xdo1)

  hdr x,'(?DO)'
xqdo:
  call  do_colon
  dw  tdup,equal
  dw  zbran,xdo1
  dw  two_drop
  dw  from_r,fetch,to_r
  dw  exit

; (do)  ( n1 n2 -- )    over - r> cell+ -rot 2>r >r

  hdr x,'(DO)'
xdo:
  call  do_colon
xdo1:
  dw  over,subb
  dw  from_r,cellp
  dw  drot
  dw  two_to_r
  dw  to_r
  dw  exit

; bal  ( -- addr )

  hdr x,'BAL',,1
bal:
  call  do_create
bal1:
  ds  2

; +BAL  ( -- )      1 bal +!

  hdr 1,'+BAL',,1
pbal:
  ld  de,1
pbal1:
  ld  hl,bal1
  jp  pstor1

; -BAL  ( -- )      -1 bal +!

  hdr 1,'-BAL',,1
dbal:
  ld  de,-1
  jp  pbal1

; ?BAL  ( flag -- )   checking @ 0<> and
;         abort" definition unbalanced"

  hdr 1,'?BAL',,1
qbal:
  call  do_colon
  dw  check,fetch
  dw  zero_not_equals,and_
  dw  paren_abort_quote
  dcs 'definition unbalanced'
  dw  exit

; ?depth  ( x -- x )    ?comp depth 0= ?bal

  hdr x,'?DEPTH',,1
qdep:
  call  do_colon
  dw  qcomp
  dw  depth,zero_equals
  dw  qbal
  dw  exit

; ?orig  ( orig -- orig )   ?depth dup @ ?bal

  hdr x,'?ORIG',,1
qorig:
  call  do_colon
  dw  qdep
  dw  dup,fetch
  dw  qbal
  dw  exit

; ?dest  ( dest -- dest )   ?depth dup @ 0= ?bal

  hdr x,'?DEST',,1
qdest:
  call  do_colon
  dw  qdep
  dw  dup,fetch
  dw  zero_equals
  dw  qbal
  dw  exit

; BEGIN  ( -- dest )    ?comp here +bal ;immediate

  hdr 1,'BEGIN',1,1
begin:
  call  do_colon
  dw  qcomp
  dw  here
  dw  pbal
  dw  exit

; >MARK  ( -- orig )    postpone begin 0 ,

  hdr 1,'>MARK',,1
fmark:
  call  do_colon
  dw  begin
  dw  zero
  dw  comma
  dw  exit

; <RESOLVE  ( dest -- )   ?dest , -bal

  hdr 1,'<RESOLVE',,1
bresol:
  call  do_colon
  dw  qdest
  dw  comma
  dw  dbal
  dw  exit

; THEN  ( orig -- )   ?orig here swap ! -bal ;immediate

  hdr 1,'THEN',1,1
then:
  call  do_colon
  dw  qorig
  dw  here
  dw  swap,store
  dw  dbal
  dw  exit

; IF  ( -- orig )     postpone ?branch >mark
;         ;immediate

  hdr 1,'IF',1,1
iff:
  call  do_colon
  dw  comp,zbran
  dw  fmark
  dw  exit

; AHEAD  ( -- orig )    postpone branch >mark
;         ;immediate

  hdr 1,'AHEAD',1,1
ahead:
  call  do_colon
  dw  comp,branch
  dw  fmark
  dw  exit

; ELSE  ( orig1 -- orig2 )  ?orig postpone ahead swap postpone
;         then ;immediate

  hdr 1,'ELSE',1,1
elsee:
  call  do_colon
  dw  qorig
  dw  ahead
  dw  swap
  dw  then
  dw  exit

; UNTIL  ( dest -- )    postpone ?branch <resolve
;         ;immediate

  hdr 1,'UNTIL',1,1
until:
  ld  hl,zbran
until1:
  push  hl
  call  do_colon
  dw  comxt
  dw  bresol
  dw  exit

; AGAIN  ( dest -- )    postpone branch <resolve ;immediate

  hdr 1,'AGAIN',1,1
again:
  ld  hl,branch
  jp  until1

; WHILE  ( x -- orig x )    ?depth postpone if swap ;immediate

  hdr 1,'WHILE',1,1
whilee:
  call  do_colon
  dw  qdep
  dw  iff
  dw  swap
  dw  exit

; REPEAT  ( orig dest -- )  postpone again postpone then
;         ;immediate

  hdr 1,'REPEAT',1,1
repeatt:call  do_colon
  dw  again
  dw  then
  dw  exit

; lv  ( -- addr )     0 value lv

  hdr x,'LV',,1
lvv:
  call  do_value
  dw  0

; DO  ( -- orig dest )    postpone (do) lv >mark dup to lv
;         postpone begin ;immediate

  hdr 1,'DO',1,1
do:
  ld  hl,xdo
do1:
  push  hl
  call  do_colon
  dw  comxt
  dw  lvv
  dw  fmark
  dw  dup
  dw  pto,lvv
  dw  begin
  dw  exit

; ?DO  ( -- orig dest )   postpone (?do) lv >mark dup to lv
;         postpone begin ;immediate

  hdr 1,'?DO',1,1
qdo:
  ld  hl,xqdo
  jp  do1

; I  ( -- x )

  hdr 1,'I'
ido:
  ld  hl,(rpp)
ido1:
  ld  e,(hl)
  inc hl
  ld  d,(hl)
ido2:
  inc hl
  ld  a,(hl)
  inc hl
  ld  h,(hl)
  ld  l,a
  add hl,de
  push hl
  jp next

   if 0

; I'  ( -- x )

  hdr 1,"I'"
idot:
  ld  hl,(rpp)
  inc hl
  ld  de,0
  jp  ido2

   endif

; J  ( -- x )

  hdr 1,'J'
jdo:
  ld  hl,(rpp)
  ld  de,cw*2
  add hl,de
  jp  ido1

; LEAVE  ( -- )     postpone (leave) lv ?orig ,
;         ;immediate

  hdr 1,'LEAVE',1,1
leavee:
  call  do_colon
  dw  comp,pleav
  dw  lvv
  dw  qorig
  dw  comma
  dw  exit

; LOOP  ( addr1 addr2 -- )  postpone (loop) <resolve
;         postpone then to lv ;immediate

  hdr 1,'LOOP',1,1
loopp:
  ld  hl,xloop
loopp1:
  push  hl
  call  do_colon
  dw  comxt
  dw  bresol
  dw  then
  dw  pto,lvv
  dw  exit

; +LOOP  ( addr1 addr2 -- ) postpone (+loop) <resolve
;         postpone then to lv ;immediate

  hdr 1,'+LOOP',1,1
ploop:
  ld  hl,xploo
  jp  loopp1

   if cfs

; CS-PICK       pick +bal

  hdr 1,'CS-PICK',,1
cspic:
  call  do_colon
  dw  pick
  dw  pbal
  dw  exit

; CS-ROLL       aka roll cs-roll

  hdr 1,'CS-ROLL',,,roll
csrol equ roll

; CS-DROP       drop -bal

  hdr 1,'CS-DROP',,1
csdro:
  pop hl
  jp  dbal

; cf0       control flow stack base

  hdr x,'CF0',,1
cfz:
  call  do_create
cfz1:
  ds  2

; #cs  ( -- cells )   sp@ cf0 @ - negate 2/ 1- 0 max

  hdr x,'#CS',,1
ncs:
  ld  hl,(cfz1)
  call  negg
  add hl,sp
  call  negg
  call  sar
  dec hl
  push  hl
  jp  zero_max

; CS-PUSH       #cs -roll

  hdr 1,'CS-PUSH',,1
cspush:
  call  do_colon
  dw  ncs
  dw  droll
  dw  exit

; CS-POP        #cs roll

  hdr 1,'CS-POP',,1
cspop:
  call  do_colon
  dw  ncs
  dw  roll
  dw  exit

; CS-MARK       0 +bal

  hdr 1,'CS-MARK',,1
csm:
  ld  hl,0
  push  hl
  jp  pbal

; CS-TEST       ?depth dup 0<>

  hdr 1,'CS-TEST',,1
cstes:
  call  do_colon
  dw  qdep
  dw  dup
  dw  zero_not_equals
  dw  exit

; COND        ?comp cs-mark immediate

  hdr 1,'COND',1,1
cond:
  call  do_colon
  dw  qcomp
  dw  csm
  dw  exit

; THENS       ?comp begin cs-test while postpone
;         then repeat cs-drop ;immediate

  hdr 1,'THENS',1,1
thens:
  call  do_colon
  dw  qcomp
thens1:
  dw  cstes
  dw  zbran,thens2
  dw  then
  dw  branch,thens1
thens2:
  dw  csdro
  dw  exit

   else

; COND        ?comp 0 +bal ;immediate

  hdr 1,'COND',1,1
cond:
  call  do_colon
  dw  qcomp
  dw  zero
  dw  pbal
  dw  exit

; THENS       ?comp begin ?depth ?dup while
;         postpone then repeat -bal ;immediate

  hdr 1,'THENS',1,1
thens:
  call  do_colon
  dw  qcomp
thens1  dw  qdep
  dw  qdup
  dw  zbran,thens2
  dw  then
  dw  branch,thens1
thens2  dw  dbal
  dw  exit

   endif

; Eaker/ANS CASE support
;
; N.B. OF may be used in the form:  COND .. OF .. ELSE .. THENS

; OF  ( -- addr )     postpone (of) >mark ;immediate

  hdr 1,'OF',1,1
of:
  call  do_colon
  dw  comp,pof
  dw  fmark
  dw  exit

; ENDOF  ( addr1 -- addr2 ) aka else endof

  hdr 1,'ENDOF',1,,elsee
endof equ elsee

; CASE  ( -- sys )    aka cond case

  hdr 1,'CASE',1,,cond
casee equ cond

; ENDCASE  ( sys -- )   postpone drop postpone thens
;         ;immediate

  hdr 1,'ENDCASE',1,1
endc:
  call  do_colon
  dw  comp,drop
  dw  thens
  dw  exit

; [ELSE]  ( -- )    1 begin token 2dup upper dup if 2dup
;       s" [IF]" compare if 2dup s" [ELSE]"
;       compare if s" [THEN]" compare 0= else
;       2drop dup 1 = then else 2drop 1 then +
;       else 2drop refill and then ?dup 0= until
;       ;immediate

  hdr 1,'[ELSE]',1,1
pels:
  call  do_colon
  dw  one
pels1:
  dw  token
   if ucase
  dw  tdup,upper
   endif
  dw  dup
  dw  zbran,pels6
  dw  tdup
  dw  psqot
  dcs '[IF]'
  dw  cmpp
  dw  zbran,pels4
  dw  tdup
  dw  psqot
  dcs '[ELSE]'
  dw  cmpp
  dw  zbran,pels2
  dw  psqot
  dcs '[THEN]'
  dw  cmpp,zero_equals
  dw  branch,pels3
pels2:
  dw  two_drop
  dw  dup,one,equal
pels3:
  dw  branch,pels5
pels4:
  dw  two_drop,one
pels5:
  dw  plus
  dw  branch,pels7
pels6:
  dw  two_drop
  dw  refil,and_
pels7:
  dw  qdup,zero_equals
  dw  zbran,pels1
  dw  exit

; [IF]  ( flag -- ) 0= if [compile] [else] then ;immediate

  hdr 1,'[IF]',1,1  ; ANS
pif:
  pop hl
  ld  a,l
  or  h
  jp  z,pels
  jp  next

; [THEN]  ( -- )    aka noop [then] immediate

  hdr 1,'[THEN]',1,,noop
pthen equ next

; }}} **********************************************************
; XXX {{{

do_create equ next ; XXX this was repeated (and thus commented out) in <compile.z80s>
do_value equ fetch
do_constant equ fetch
do_byte_constant equ c_fetch

; }}} **********************************************************
; Numeric output {{{

; (D.)  ( d -- c-addr u )  tuck dabs <# #s rot sign #>

  hdr 1,'(D.)'
pddot:
  call  do_colon
  dw  tuck
  dw  dabs
  dw  bdigs
  dw  digs
  dw  rot,sign
  dw  edigs
  dw  exit

; U.R  ( u1 u2 -- ) 0 swap d.r

  hdr 1,'U.R'
udotr:
  ld  hl,0
  ex  (sp),hl
  push  hl
  jp  ddotr ; XXX NEW -- because headers and code share the same zone

; XXX OLD -- DX-Forth 4.00
;;; D.R  ( d u -- )   >r (d.) r> over - spaces type
;;
;;  header 1,'D.R'
;;ddotr:
;;  call  do_colon
;;  dw  to_r
;;  dw  pddot
;;ddotr1:
;;  dw  from_r
;;  dw  over,subb
;;  dw  spacs
;;  dw  typee
;;  dw  exit

; XXX NEW -- DX-Forth 4.09
; D.R  ( d n -- )   >r (d.) r> s.r

  hdr 1,'D.R'
ddotr:
  call  do_colon
  dw  to_r
  dw  pddot
ddotr1:
  dw  from_r
  ; dw  sdotr ; XXX FIXME -- not found
  dw  exit

; .R  ( n u -- )    >r s>d r> d.r

  hdr 1,'.R'
dotr:
  call  do_colon
  dw  to_r
  dw  stod
  dw  from_r,ddotr
  dw  exit

; U.  ( u -- )    0 d.

  hdr 1,'U.'
udot:
  ld  hl,0
  push  hl
  jp  ddot ; XXX NEW -- because headers and code share the same zone

; D.  ( d -- )    0 d.r space

  hdr 1,'D.'
ddot:
  call  do_colon
  dw  zero,ddotr
  dw  space
  dw  exit

; XXX OLD -- DX-Forth 4.00
;;; ?  ( addr -- )    @ .
;;
;;  header 1,'?'
;;ques:
;;  call  do_colon
;;  dw  fetch,dot
;;  dw  exit

; XXX NEW -- DX-Forth 4.09
; ?  ( addr -- )

  hdr 1,'?'
ques:
  pop hl
  ld  e,(hl)
  inc hl
  ld  d,(hl)
  push  de
  jp  dot

; XXX OLD -- DX-Forth 4.00
;;; .  ( n -- )   s>d d.
;;
;;  header 1,'.'
;;dot:
;;  call  do_colon
;;  dw  stod,ddot
;;  dw  exit

; XXX NEW -- DX-Forth 4.09
; .  ( n -- )   decimal? if s>d d. exit then u.

  hdr 1,'.'
dot:
  call  do_colon
;  dw  dcmq ; XXX FIXME -- undefined
  dw  zbran,dot1
  dw  stod,ddot
  dw  exit
dot1:
  dw  udot
  dw  exit

; }}} **********************************************************
; DOS functions {{{

; XXX OLD 
;;;  DOSVER  ( -- minor major )
;;
;;  hdr  1,'DOSVER'
;;dosver:
;;  ld  hl,(dosv)
;;dosver1:ld  e,h
;;  xor  a
;;  ld  h,a
;;   ld  d,a
;;  push de
;;  jp next

;  FDOS  ( DE u -- HL A )

  hdr  1,'FDOS'
fdos:
  pop  hl
  ld  a,l
  pop  de
  call  bdoss
  push  hl
  jp  push_a

;  BDOS  ( DE u -- A )

  hdr  1,'BDOS'
bdos:
  call  do_colon
  dw  fdos,nip
  dw  exit

;  subroutine for BIOS call

biosj:
; XXX OLD
  ret
;;  cp  15    ; console or list functions may use CP/M 2
;;  jp  z,biosj2  ; style bios calls (faster than BDOS 50)
;;  cp  2
;;  jp  c,biosj1
;;  cp  6
;;  jp  c,biosj2
;;biosj1:
;;  ld  a,(dosv)
;;  cp  0x30
;;  jp  c,biosj2
;;  ld  de,biospb
;;  ld  c,50    ; CP/M 3 BDOS 50
;;  jp  0005h
;;
;;biosj2:
;;  push  hl    ; CP/M 2 bios call
;;  ld  hl,(biospb+1)
;;  ld  c,l
;;  ld  b,h
;;  ld  hl,(0000h+1)
;;  dec  de    ; fn
;;  add  hl,de
;;  add  hl,de
;;  add  hl,de
;;  pop  de
;;  jp  (hl)

;  BIOS  ( BC u -- A )

  hdr  1,'BIOS'
bios:
  jp next
; XXX OLD
;;  pop  de
;;  ld  a,e
;;  ld  (biospb),a
;;  pop  hl
;;  ld  (biospb+1),hl
;;  push  bc
;;  call  biosj
;;  pop  bc
;;  jp  push_a

;  BIOSHL  ( DE BC u -- HL )

  hdr  1,'BIOSHL'
biosh:
; XXX OLD
;;  pop  de
;;  ld  a,e
;;  ld  (biospb),a
;;  pop  hl
;;  ld  (biospb+1),hl
;;  pop  hl
;;  ld  (biospb+3),hl
;;  push  bc
;;  call  biosj
;;  pop  bc
;;  push hl
  jp next

; Port fetch and store instructions use self-modifying code

;  PC@  ( p-addr -- x )

  hdr  1,'PC@'    ; FIG P@
pcat:
  pop  hl
  ld  a,l
  ld  (pcat1),a
  in  a,(0)    ; modified
pcat1  equ  $-1
  jp  push_a

;  PC!  ( x p-addr -- )

  hdr  1,'PC!'    ; FIG P!
pcsto:
  pop  hl
  pop  de
  ld  a,l
  ld  (pcsto1),a
  ld  a,e
  out  (0),a    ; modified
pcsto1  equ  $-1
  jp  next

;  ?terminal  ( -- flag )  0 2 bios

  hdr  x,'?TERMINAL'
qterm:
  call  do_colon
  dw  zero,two
  dw  bios
  dw  exit

;  conin  ( -- char )  begin key? until 0 3 bios
;        (iofn+cw) @ over = if 0 bdos then

  hdr  x,'CONIN'
conin:
  call  do_colon    ; console input
conin1:
; XXX TODO
;;  dw  keyq
;;  dw  zbran,conin1
;;  dw  zero,three
;;  dw  bios
;;  dw  lit,iofn+cw  ; ctl-C check
;;  dw  fetch
;;  dw  over,equal
;;  dw  zbran,conin2
;;  dw  zero,bdos  ; exit to CP/M
conin2:
  dw  exit

dcono:
  call  do_colon
  dw  two
  dw  bdos,drop
  dw  exit

bcono:
  call  do_colon
  dw  clit
  db  4
  dw  bios,drop
  dw  exit

;  conout  ( char -- )

  hdr  x,'CONOUT'
conout:
; XXX TODO
;;  pop  de
;;  ld  a,e
;;  cp  ff
;;  jp  z,cls
;;  push  de
;;  ld  hl,(iofn)
;;  jp  (hl)
  jp next

;  lstout  ( char -- )

  hdr  x,'LSTOUT'
lstout:
  call  do_colon
  dw  clit
  db  5
  dw  bios,drop
  dw  exit

; XXX OLD
;;;  ZENV  ( -- addr )  return Z-System address (0=none)
;;
;;  header  1,'ZENV'
;;zenv:
;;  ld  hl,(z3eadr)
;;  jp  push_hl

; }}} **********************************************************
; Facility functions

; (MS)  ( ms -- )

  hdr  x,'(MS)'
ms0:
  pop  de
ms01:
  ld  a,e
  or  d
  jp  z,next
  ld  hl,(speed)
  add  hl,hl
  add  hl,hl
  add  hl,hl
ms02:
  ex  (sp),hl    ; 19T
  ex  (sp),hl    ; 19T
  ex  (sp),hl    ; 19T
  ex  (sp),hl    ; 19T
  push  hl    ; 11T
  pop  hl    ; 10T
  dec  hl    ; 6T
  ld  a,0    ; 7T
  ld  a,l    ; 4T
  or  h    ; 4T
  jp  nz,ms02    ; 10T
  dec  de
  jp  ms01

;  (BEEP)  ( -- )

  hdr  x,'(BEEP)'
paren_beep:
  call  do_colon
  ; XXX TODO
  dw  exit

;  MS  ( ms -- )

  hdr  1,'MS'
ms:
  call  fetch_execute
  dw  ms0

;  SOUND  ( freq ms -- )
;
;  header  1,'SOUND'
;sound:  call  fetch_execute
;  dw  sound0

;  BEEP  ( -- )

  hdr  1,'BEEP'
beep:
  call  fetch_execute
  dw  paren_beep

cpbuf:
  ds  16

;  AT-XY  ( u1 u2 -- )  position cursor at col u1, row u2

  hdr  1,'AT-XY'
atxy:
  ; XXX TODO
  jp  next ; XXX TMP
;;  pop  de
;;  pop  hl
;;  ld  d,l
;;  push  bc
;;  push  de
;;  ld  hl,tgxy
;;  ld  de,cpbuf
;;  ld  a,16
;;  call  amovd
;;  pop  de
;;  ld  a,(txpos)
;;  ld  c,a
;;  ld  a,(txofs)
;;  add  a,d
;;  push  de
;;  call  atxy3
;;  pop  de
;;  ld  a,(typos)
;;  ld  c,a
;;  ld  a,(tyofs)
;;  add  a,e
;;  call  atxy3
;;  pop  bc
;;  ld  de,tgxyd
;;  ld  hl,cpbuf
;;atxy1:
;;  push  de
;;  push  hl
;;atxy2:
;;  call  do_colon
;;  dw  count,tuck
;;  dw  typee    ; send string
;;  dw  zero_not_equals
;;  dw  swap,fetch
;;  dw  and_,ms    ; delay only if string not empty
;;  dw  exit
;;
;;atxy3:
;;  ld  hl,cpbuf
;;  ld  b,0
;;  add  hl,bc
;;  ex  de,hl
;;  ld  hl,tisbin
;;  inc  (hl)
;;  dec  (hl)
;;  jp  z,atxy4
;;  ld  (de),a
;;  ret
;;
;;atxy4:
;;  dec  de
;;  dec  de
;;  ld  hl,atxy8-1
;;  ld  b,3
;;atxy5:
;;  inc  hl
;;  ld  c,'0'-1
;;atxy6:
;;  inc  c
;;  sub  (hl)
;;  jp  nc,atxy6
;;  add  a,(hl)
;;  push  af
;;  ld  a,c
;;  cp  '0'
;;  jp  z,atxy7
;;  ld  (de),a
;;atxy7:
;;  inc  de
;;  pop  af
;;  dec  b
;;  jp  nz,atxy5
;;  ret
;;
;;atxy8:
;;  db  100,10,1

; XXX NEW
;  CLS  ( -- )
  hdr  1,'CLS'
;  XXX TODO -- call it from 'PAGE'

cls:
  call rom_cl_all
  ld a,2
  call rom_chan_open
  jp next
; XXX OLD
;;  call  do_colon
;;  dw  lit,tceold
;;  dw  lit,thome
;;  dw  atxy2
;;  dw  lit,tclsd
;;  dw  lit,tcls
;;  dw  atxy2
;;  dw  exit

;  NORMAL  ( -- )

  hdr  1,'NORMAL'
vnorm:
; XXX TODO
  jp next
;;  ld  hl,tlovid
;;vnorm1:
;;  ld  de,tceold
;;  jp  atxy1

;  HIGHLIGHT  ( -- )

  hdr  1,'HIGHLIGHT'
hilit:
; XXX TODO
  jp next
;;  ld  hl,thivid
;;  jp  vnorm1

;  CLEAR-LINE  ( -- )

  hdr  1,'CLEAR-LINE'
cleol:
; XXX TODO
  jp next
;;  ld  hl,tceol
;;  jp  vnorm1

;  INSERT-LINE  ( -- )

  hdr  1,'INSERT-LINE'
insln:
; XXX TODO
  jp next
;;  ld  hl,tinsln
;;insln1:
;;  ld  de,tclsd
;;  jp  atxy1

;  DELETE-LINE  ( -- )

  hdr  1,'DELETE-LINE'
delln:
; XXX TODO
  jp next
;;  ld  hl,tdelln
;;  jp  insln1

; XXX OLD
;;;  INIT-VIDEO  ( -- )
;;
;;  header  1,'INIT-VIDEO'
;;invid:  ld  hl,tinit
;;  jp  insln1
;;
;;;  EXIT-VIDEO  ( -- )
;;
;;  header  1,'EXIT-VIDEO'
;;exvid:  ld  hl,texit
;;  jp  insln1

; }}} **********************************************************
; Input/output functions

; PAUSE  ( -- )

  hdr 1,'PAUSE' ; multitasking support
pause:
  call  fetch_execute
pause1: ; XXX TODO rename this label
  dw  0   ; patched by COLD

; KEY?  ( -- flag )

  hdr 1,'KEY?'
keyq:
  call  do_colon
  dw  lit,vkeyq   ; (vkeyq)
  dw  fetch_execute       ; @execute
  dw  pause       ; pause
  dw  exit

; KEY  ( -- char )  (vkey) @execute pause

  hdr 1,'KEY'
key:
  call  do_colon
  dw  lit,vkey
  dw  fetch_execute
  dw  pause
  dw  exit

; SPACE  ( -- )   bl emit

  hdr 1,'SPACE'
space:
  ld  l,32
  push  hl
  jp  emit ; XXX NEW -- because headers and code share the same zone

; EMIT  ( char -- ) (vemit) @execute 1 out +! pause

  hdr 1,'EMIT'
emit:
  pop hl
emit_l:
  ld a,l
emit_a:
  rst 0x10
  jp next
; XXX OLD
;;  call  do_colon
;;  dw  lit,vemit
;;  dw  fetch_execute
;;  dw  one,outt,pstor
;;  dw  pause
;;  dw  exit

; TYPE  ( c-addr u -- )
; 0max 0 ?do count emit loop drop
; XXX TODO use ROM call instead
  hdr 1,'TYPE'
typee:
  call  do_colon
  dw  zero_max,zero
  dw  xqdo,typee2
typee1:
  dw  count,emit
  dw  xloop,typee1
typee2:
  dw  drop
  dw  exit

; SPACES  ( +n -- ) 0max 0 ?do space loop

  hdr 1,'SPACES'
spacs:
  call  do_colon
  dw  zero_max,zero
  dw  xqdo,spacs2
spacs1:
  dw  space
  dw  xloop,spacs1
spacs2:
  dw  exit

; CR  ( -- )

  hdr 1,'CR'
crr:
  ; XXX TODO
  jp  next
; XXX OLD
;;  call  do_colon
;;  dw  clit
;;  db  cr_char
;;  dw  emit
;;  dw  clit
;;  db  lf_char
;;  dw  emit
;;  dw  outt,off
;;  dw  exit

;  PAGE  ( -- )
;  12 emit

  hdr  1,'PAGE'
page:
  ; XXX FIXME -- this is only for printer
  ld  l,ff_char ; formfeed char
  jp  emit_l

; CONSOLE  ( -- )   (vcon) @ (vemit) !

  hdr 1,'CONSOLE' ; set EMIT to terminal
console:
  ; XXX TODO
; XXX OLD
;;  ld  hl,(vcon)
;;  ld  (vemit),hl
  jp  next

; PRINTER  ( -- )   (vlst) @ (vemit) !

  hdr 1,'PRINTER' ; set EMIT to printer
printer:
  ; XXX TODO
; XXX OLD
;;  ld  hl,(vlst)
;;  ld  (vemit),hl
  jp  next

; }}} **********************************************************
; Compiler functions {{{

; wfind  ( c-addr wid -- 0 | xt nfa -1 | xt nfa 1 )

  hdr x,'WFIND',,1
wfind:
  call  do_colon   ; save IP
  dw  $+2
  pop hl
  ld  a,l
  or  h
  jp  z,wfind2  ; wid=0
  ld  e,(hl)
  inc hl
  ld  d,(hl)
wfind1:
  pop hl    ; string
  push  hl
  ld  a,e   ; end of list?
  or  d
  ex  de,hl
  jp  nz,wfind3
wfind2:
  pop de    ; discard string
  jp  wfind6    ; no match

wfind3:
  push  hl    ; save nfa
  ld  c,(hl)
  ld  a,c
  and 0x1f
  ld  b,a   ; dict name length
  ld  a,(de)    ; string length
  xor c   ; check lengths/smudge bit
  and 0x3f
  jp  z,wfind5
  inc hl    ; to link
wfind4:
  inc hl
  dec b
  jp  nz,wfind4
  ld  e,(hl)    ; next nfa
  inc hl
  ld  d,(hl)
  pop hl    ; discard old
  jp  wfind1

wfind5:
  inc hl    ; check each char
  inc de
  ld  a,(de)
   if ucase
  call  uppercase_a
   endif
  ld  c,a
  ld  a,(hl)
   if ucase
  call  uppercase_a
   endif
  xor c
  jp  nz,wfind4 ; no match
  dec b
  jp  nz,wfind5
  inc hl    ; to link
  inc hl    ; to cfa pointer
  inc hl
  ld  e,(hl)    ; get xt
  inc hl
  ld  d,(hl)
  pop hl    ; nfa
  pop bc    ; discard string
  push  de
  push  hl
  ld  a,(hl)
  and 0x40   ; immediate?
  ld  hl,-1
  jp  z,wfind6
  inc hl
  inc hl
wfind6:
  push  hl
  jp  exit    ; restore IP

; (find)  ( c-addr -- c-addr 0 | xt -1 | xt 1 )
;       0 3 0 do over i cells context + @
;       wfind ?dup if nip 2nip leave then loop

  hdr x,'(FIND)',,1 ; searches CONTEXT CURRENT FORTH
pfind:
  call  do_colon
  dw  zero
  dw  three
  dw  zero
  dw  xdo,pfind3
pfind1:
  dw  over
  dw  ido,cells
  dw  cont,plus,fetch
  dw  wfind,qdup
  dw  zbran,pfind2
  dw  nip,tnip
  dw  pleav,pfind1-cw
pfind2:
  dw  xloop,pfind1
pfind3:
  dw  exit

; FIND  ( c-addr -- c-addr 0 | xt -1 | xt 1 )

  hdr 1,'FIND',,1
find:
  call  fetch_execute
  dw  pfind

   if 0

; SEARCH-WORDLIST  ( c-addr u wid -- 0 | xt -1 | xt 1 )
;       >r wpack r> wfind dup if nip then

  hdr 1,'SEARCH-WORDLIST',,1
swlis:
  call  do_colon
  dw  to_r
  dw  wpack
  dw  from_r
  dw  wfind
  dw  dup
  dw  zbran,swlis1
  dw  nip
swlis1  dw  exit

   endif

   if wopt

; -?  ( -- )    warning @ 0fffe and warning !

  hdr 1,'-?',,1 ; disable warnings for next definition only
dques:
  ld  hl,warnn1
  ld  a,(hl)
  and 0xfe    ; clear bit 0
  ld  (hl),a
  jp next

; warning?  ( -- 0|1 )  warning @ dup if dup 1 and tuck if -1
;       else $7fff and 1 then or warning ! then

  hdr x,'WARNING?',,1 ; get warning flag and apply mask
qwarn:
  call  do_colon
  dw  warnn,fetch
  dw  dup
  dw  zbran,qwarn3
  dw  dup,one,and_ ; test bit 0
  dw  tuck
  dw  zbran,qwarn1
  dw  true    ; enable all warnings
  dw  branch,qwarn2
qwarn1:
  dw  lit,07fffh  ; disable compile warning
  dw  and_
  dw  one   ; enable redefinition warning
qwarn2:
  dw  or_
  dw  warnn,store
qwarn3:
  dw  exit

   endif

; IMMEDIATE  ( -- ) $40 xnfa

  hdr 1,'IMMEDIATE',,1
immed:
  ld  e,0x40
  jp  smudg1

; SMUDGE  ( -- )    $20 xnfa

  hdr 1,'SMUDGE',,1 ; FIG
smudg:
  ld  e,0x20
smudg1:
  push  de
; jp  xnfa

; xnfa  ( x -- )    toggle nfa bit

xnfa:
  ld  hl,(last1)
  jp  ctog1

; header  ( xt|0 "name" -- )
;       warning? 2>r bl-word dup c@ 32 1 within
;       abort" invalid name" dup find nip r> and
;       if dup count type ."  is redefined "
;       then dup count tuck + get-current w>name
;       over ! cell+ swap 5 + dph @ over dph +!
;       dup get-current ! rot r> ?dup 0= if here
;       then dup rot ! over last 2! swap cmove

  hdr x,'HEADER',,1
header:
  call  do_colon
   if wopt
  dw  qwarn
   else
  dw  warnn,fetch
   endif
  dw  two_to_r
  dw  blword
  dw  dup,c_fetch
  dw  clit
  db  32
  dw  one,within
  dw  paren_abort_quote
  dcs 'invalid name'
  dw  dup,find,nip
  dw  from_r,and_
  dw  zbran,header1
  dw  dup,count,typee
  dw  paren_dot_quote
  dcs ' is redefined '
header1:
  dw  dup,count
  dw  tuck
  dw  plus
  dw  getcur,wtnam
  dw  over,store
  dw  cellp,swap
  dw  clit
  db  5
  dw  plus
  dw  dph,fetch
  dw  over,dph,pstor
  dw  dup
  dw  getcur
  dw  store   ; CP/M version
  dw  rot
  dw  from_r,qdup,zero_equals
  dw  zbran,header2
  dw  here
header2:
  dw  dup,rot,store
  dw  over,last,two_store
  dw  swap,cmove
  dw  exit

; ,call  ( addr -- )  $CD c, ,

  hdr x,',CALL',,1
comcall:call  do_colon
  dw  clit
  db  0xcd    ; 'call' opcode
  dw  ccomm
  dw  comma
  dw  exit

; BUILD  ( xt "name" -- )  0 header ,call

  hdr 1,'BUILD',,1
build:
  call  do_colon
  dw  zero,header
  dw  comcall
  dw  exit

; :  ( -- )   (do_colon) build smudge bal off !csp
;       sp@ cf0 ! ]

  hdr 1,':',,1
colon:
  call  do_colon
  dw  lit,do_colon
  dw  build
  dw  smudg
colon1:
  dw  bal,off
  dw  scsp
   if cfs
  dw  sp_fetch
  dw  cfz,store
   endif
  dw  rbrac
  dw  exit

; EXIT  ( -- )    postpone (exit) immediate

  hdr 1,'EXIT',1,1
exitt:
  call  do_colon
  dw  comp,exit
  dw  exit

; ;  ( -- )   postpone exit bal @ ?bal ?csp smudge
;       postpone [ ;immediate

  hdr 1,';',1,1
semic:
  call  do_colon
  dw  exitt
  dw  bal,fetch
  dw  qbal
  dw  qcsp
  dw  smudg
  dw  lbrac
  dw  exit

; :NONAME  ( -- xt )  warning? drop here dup (dnfa) last 2!
;       (do_colon) ,call bal off !csp sp@ cf0 ! ]

  hdr 1,':NONAME',,1
nonam:
  call  do_colon
   if wopt
  dw  qwarn,drop  ; allow -?
   endif
  dw  here
  dw  dup    ; allow RECURSE etc
  dw  lit,dnfa  ; allow IMMEDIATE etc
  dw  last,two_store
  dw  lit,do_colon
  dw  comcall
  dw  branch,colon1

; (;CODE)     r> last cell+ @ 1+ !

  hdr 1,'(;CODE)',,1
pscod:
  ld  hl,(last2)
  inc hl
  ld  (hl),c
  inc hl
  ld  (hl),b
  jp  exit

; DOES>     postpone (;code) (do_colon) ,call ;immediate

  hdr 1,'DOES>',1,1
does:
  call  do_colon
  dw  comp,pscod
  dw  lit,do_colon
  dw  comcall
  dw  exit

; CREATE  ( -- addr ) 'next build

  hdr 1,'CREATE',,1
creat:
  ld  hl,next
  push  hl
  jp  build

; do_create equ next ; XXX OLD repeated

; VARIABLE  ( -- addr ) create 2 allot

  hdr 1,'VARIABLE',,1
var:
  call  do_colon
  dw  creat
  dw  two,allot
  dw  exit

; VALUE  ( -- x )   (dotcon) build ,

  hdr 1,'VALUE',,1
value:
  call  do_colon
value1:
  dw  lit,do_value
  dw  build
  dw  comma
  dw  exit

; CONSTANT  ( -- x )  char? if (do_byte_constant) build c,
;       else value then

  hdr 1,'CONSTANT',,1
con:
  call  do_colon
  dw  charq
  dw  zbran,value1
  dw  lit,do_byte_constant
  dw  build
  dw  ccomm
  dw  exit

; 2VARIABLE  ( -- addr )  create 4 allot

  hdr 1,'2VARIABLE',,1
tvar:
  call  do_colon
  dw  creat
  dw  clit
  db  4
  dw  allot
  dw  exit

dotvar  equ next

; 2CONSTANT  ( -- x2 x1 )  (dotcon) build , ,

  hdr 1,'2CONSTANT',,1
tcon:
  call  do_colon
  dw  lit,dotcon
  dw  build
  dw  comma,comma
  dw  exit

dotcon  equ tat   ; 2@

; USER  ( -- addr ) (do_user_variable) build ,

  hdr 1,'USER',,1 ; FIG
user:
  call  do_colon
  dw  lit,do_user_variable
  dw  build
  dw  comma
  dw  exit

; ADDR  ( -- addr ) ' >body state @ if postpone literal then
;       ;immediate

  hdr 1,'ADDR',1,1  ; state-smart
addr:
  call  do_colon
  dw  tick,tbody
  dw  stateq
  dw  zbran,addr1
  dw  liter
addr1:
  dw  exit

; (to)  ( x -- )    r> dup cell+ >r @ >body !

  hdr x,'(TO)'
pto:
  ld  a,(bc)
  ld  l,a
  inc bc
  ld  a,(bc)
  ld  h,a
  inc bc
  inc hl
  inc hl
  inc hl
  jp  store1

; TO      ' state? if postpone (to) , else >body !
;       then ;immediate

  hdr 1,'TO',1,1  ; state-smart
to:
  call  do_colon
  dw  tick
  dw  stateq
  dw  zbran,to1
  dw  comp,pto
  dw  comma
  dw  branch,to2
to1:
  dw  tbody,store
to2:
  dw  exit

undef:
  call  do_colon
  dw  one
  dw  paren_abort_quote
  dcs 'uninitiated DEFER'

; DEFER  ( -- )   ['] @execute build (undef) ,

  hdr 1,'DEFER',,1
defer:
  call  do_colon
  dw  lit,fetch_execute
  dw  build
  dw  lit,undef
  dw  comma
  dw  exit

; IS      aka to is

  hdr 1,'IS',1,,to  ; state-smart
is  equ to

pis equ pto

; AKA  ( "oldname" "newname" -- )  defined tuck ?defined (header)
;         $80 xnfa 0> if immediate then
; XXX TODO ' alias' too
  hdr 1,'AKA',,1
aka:
  call  do_colon
  dw  defined_
  dw  tuck,qdef
  dw  header   ; equivalent of
  dw  clit    ; ALIAS ( xt "newname" -- )
  db  0x80   ;
  dw  xnfa    ;
  dw  zgrea
  dw  zbran,aka1
  dw  immed
aka1:
  dw  exit

; }}} **********************************************************
; Constants {{{

; TRUE

  hdr 1,'TRUE'
true:
  ld  hl,-1
  push hl
  jp next

; FALSE

  hdr 1,'FALSE'
false:
  ld  hl,0
  push hl
  jp next

; -1  ( -- -1 )   aka true -1

  hdr 1,'-1',,,true

; 0  ( -- 0 )   aka false 0

  hdr 1,'0',,,false
zero  equ false

; 1  ( -- 1 )

  hdr 1,'1'
one:
  call  do_byte_constant
  db  1

; 2  ( -- 2 )

  hdr 1,'2'
two:
  call  do_byte_constant
  db  2

; 3  ( -- 3 )

  hdr 1,'3'
three:
  call  do_byte_constant
  db  3

; BL  ( -- 32 )   ascii value for space character

  hdr 1,'BL'
bl:
  call  do_byte_constant
  db  sp_char

; B/BUF  ( -- u )  bytes per screen buffer

  hdr 1,'B/BUF',,1  ; FIG
bbuf:
  call  do_value
bbuf1:
  dw 128*8 ; default

; C/L  ( -- u )    chars per screen line

  hdr 1,'C/L',,1  ; FIG
csll:
  call  do_value
  dw  64 ; default

; For applications, LIMIT is the upper limit of available memory.
; In forth, it is the beginning of the area which holds the screen file
; buffer, word headers and system definitions.

; LIMIT  ( -- addr )

  hdr 1,'LIMIT' ; FIG
limit:
  call  do_value   ; application word - used by BUF
limit1:
  ds  cw    ; patched by COLD

; hbuf  ( -- addr ) handle r/w buffer

  hdr x,'HBUF'
hbuf:
  call  do_value
hbuf1:
  ds  cw    ; patched by COLD

; 'NEXT  ( -- addr )  address of NEXT

  hdr 1,"'NEXT"
tnext:
  call  do_constant
tnext1:
  dw  next

; #FCB  ( -- u )    number of file handles

  hdr 1,'#FCB'
nfcb:
  call  do_value
nfcb1:
  dw  fhno

; SYS-VEC  ( -- addr )  system vector table

; XXX -- This word is not used in DX-Forth.
; It appears only in <misc.fs>, but commented out.

  hdr 1,'SYS-VEC'
sysvec:
  call  do_create

vkeyq:
  dw  qterm   ;  0 KEY?
vkey:
  dw  conin   ;  2 KEY
vemit:
  dw  conout    ;  4 EMIT
vcon:
  dw  conout    ;  6 CONSOLE out
vlst:
  dw  lstout    ;  8 PRINTER out
ainit:
  dw  cold2   ; 10 INIT patch
aident:
  dw  cold9   ; 12 IDENTIFY patch
afnumb:
  dw  interpret12    ; 14 FNUMBER patch
nfps:
  dw  fps   ; 16 fp-stack size (bytes)
anumb:
  dw  interpret8   ; 18 NUMBER? patch
nfpm:
  dw  fnum*fw    ; 20 fp-stack min (bytes)
nrts:
  dw  rts   ; 22 return stack (bytes)
nus:
  dw  us    ; 24 user area (bytes)
npno:
  dw  pictured_numeric_buffer_size   ; 26 HOLD buffer size (bytes)
;nmscon: ; XXX OLD
;  dw  -2386   ; 28 MS timing constant 
;ntmode: ; XXX OLD
;  dw  3   ; 30 Timer 0 mode

; }}} **********************************************************
; Variables {{{

; UP  ( -- addr )   user area pointer

  hdr 1,'UP'
up:
  call  do_constant
  dw  user_area_pointer

; FSP  ( -- addr )  fp stack pointer

  hdr 1,'FSP'
fsp:
  call  do_create
fspp:
  ds  cw

; boot  ( -- addr ) boot word (holds forth/application xt)

  hdr x,'BOOT'
boot:
  call  do_create
boot1:
  dw  0   ; xt
boot2:
  dw  0   ; 0=forth

; SYS  ( -- addr )  compile system or application

  hdr 1,'SYS'
sys:
  call  do_create   ; application word - used by HERE, UNUSED
sys1:
  dw  0

; last  ( -- addr ) occupies 2 cells

  hdr x,'LAST',,1
last:
  call  do_create
last1:
  dw  top_nfa    ; latest nfa
last2:
  dw  top_xt   ; latest xt

; BLK

  hdr 1,'BLK',,1
blk:
  call  do_create
blk1:
  ds  cw

; >IN

  hdr 1,'>IN',,1
inn:
  call  do_create
inn1:
  ds  cw

; SCR     occupies 2 cells

  hdr 1,'SCR',,1
scr:
  call  do_create
  ds  2*cw

; STATE

  hdr 1,'STATE',,1
state:
  call  do_create
state1:
  ds  cw

; 'SOURCE     occupies 2 cells

  hdr 1,"'SOURCE",,1
tsourc:
  call  do_create
tsour1:
  ds  2*cw

; WARNING

  hdr 1,'WARNING',,1  ; FIG
warnn:
  call  do_create
warnn1:
  ds  cw

; CSP

  hdr 1,'CSP',,1  ; FIG
cspp:
  call  do_create
cspp1:
  ds  cw

; CHECKING

  hdr 1,'CHECKING',,1
check:
  call  do_create
check1:
  ds  cw

; errmsg  ( -- addr ) message holder for abort"

  hdr x,'ERRMSG'
errmsg:
  call  do_create
errmsg1:ds  2*cw

; CONTEXT  ( -- addr )

  hdr 1,'CONTEXT',,1
cont:
  call  do_create
acont:
  ds  cw    ; context
acurr:
  ds  cw    ; current
  dw  forth1    ; forth

; get-context  ( -- wid )

  hdr x,'GET-CONTEXT',,1
getcon:
  ld  hl,(acont)
  push hl
  jp next

; GET-CURRENT  ( -- wid )

  hdr 1,'GET-CURRENT',,1
getcur:
  ld  hl,(acurr)
  push hl
  jp next

; SET-CURRENT  ( wid -- )

  hdr 1,'SET-CURRENT',,1
setcur:
  ld  hl,acurr
  jp  store1

; zbuf  ( -- addr ) filename buffer pointers

  hdr x,'ZBUF'
zbuf:
  call  do_create
zbuf1:
  dw  zb1 ; next buffer
  dw  zb2 ; last buffer

; }}} **********************************************************
; User Variables {{{

; user variables 0, 2, 4 reserved for future expansion

; S0

  hdr 1,'S0'    ; FIG
szero:
  call  do_user_variable
  dw  6

; R0

  hdr 1,'R0'    ; FIG
rzero:
  call  do_user_variable
  dw  8

; DP      application dictionary pointer

  hdr 1,'DP'    ; FIG
dpp:
  call  do_user_variable
  dw  10

; dph     system dictionary pointer

  hdr x,'DPH',,1  ; must follow DP
dph:
  call  do_user_variable
  dw  12

; VOC-LINK

  hdr 1,'VOC-LINK',,1 ; FIG
vocl:
  call  do_user_variable
  dw  14

; FS0

  hdr 1,'FS0'
fszero:
  call  do_user_variable
  dw  16

; user variable 18 reserved for future expansion

; End of boot-up literals

; DPL

  hdr 1,'DPL'   ; FIG
dpl:
  call  do_user_variable
  dw  20

; hld

  hdr x,'HLD'   ; FIG
hld:
  call  do_user_variable
  dw  22

; BASE

  hdr 1,'BASE'
base:
  call  do_user_variable
  dw  24

; bytes 26-27   reserved for locals

; OUT

  hdr 1,'OUT'   ; FIG
outt:
  call  do_user_variable
  dw  28

; bytes 30-33   reserved

; CATCHER

  hdr 1,'CATCHER'
catchr:
  call  do_user_variable
  dw  34

; bytes 36-43   reserved

; User area bytes 44 onwards are available for user applications

; }}} **********************************************************
; Forth system {{{

; sys?  ( -- flag ) sys@ 0<>

  hdr x,'SYS?'
sysq:
  ld  hl,sys1
sysq1:
  ; XXX TODO -- maybe faster: use A, OR and write PUSH_A
  ld  e,(hl)
  inc hl
  ld  d,(hl)
  push  de
  jp  zero_not_equals

; state?  ( -- flag ) state @ 0<>

  hdr x,'STATE?',,1
stateq:
  ld  hl,state1
  jp  sysq1

; check?  ( -- flag ) checking @ 0<>

  hdr x,'CHECK?',,1
chkq:
  ld  hl,check1
  jp  sysq1

; APPLICATION  ( -- ) sys off

  hdr 1,'APPLICATION',,1
app:
  ld  hl,sys1
  jp  off1

; SYSTEM  ( -- )    sys on

  hdr 1,'SYSTEM',,1
system:
  ld  hl,sys1
  jp  on1

; h  ( -- addr )    sys@ if dph else dp then

  hdr x,'H'
hh:
  ld  hl,(sys1)
  ld  a,l
  or  h
  jp  z,dpp
  jp  dph

; ALLOT  ( n -- )   here over 0max dup unused u>
;       abort" no data space" erase h +!

  hdr 1,'ALLOT'
allot:
  call  do_colon
  dw  here,over
  dw  zero_max,dup
  dw  unus,ugrea
  dw  paren_abort_quote
  dcs 'no data space'
  dw  erase
  dw  hh,pstor
  dw  exit

; HERE  ( -- addr ) h @

  hdr 1,'HERE'
here:
  call  do_colon
  dw  hh,fetch
  dw  exit

; C,  ( char -- )   here 1 allot c!

  hdr 1,'C,',,1
ccomm:
  call  do_colon
  dw  here
  dw  one,allot
  dw  cstor
  dw  exit

; ,  ( n -- )   here 2 allot !

  hdr 1,',',,1
comma:
  call  do_colon
  dw  here
  dw  two,allot
  dw  store
  dw  exit

; >BODY  ( xt -- addr ) 3 +

  hdr 1,'>BODY'
tbody:
  ld  de,3
  jp  plus_de

; BODY>  ( addr -- xt ) 3 -
;
; XXX -- this word was commented out in DX-Forth, why?
  hdr x,'BODY>'
fbody:
  ld  de,-3
  jp  plus_de

; XXX NEW -- DX-Forth 4.09
;  n>count  ( nfa -- h-addr len )  aka (name) n>count

  hdr  x,'N>COUNT',,,pname
ncnt  equ  pname

; XXX OLD -- DX-Forth 4.00
;;; n>link  ( nfa -- lfa )
;;
;;  header x,'N>LINK',,1
;;nlnk:
;;  pop hl
;;  ld  a,(hl)  ; name length and flags
;;  and 0x1f    ; name length only
;;  ld  e,a
;;  ld  d,0
;;  add hl,de
;;  inc hl
;;  jp  push_hl

; XXX NEW -- DX-Forth 4.09
;  n>link  ( nfa -- lfa )    n>count +

  hdr  x,'N>LINK',,1
nlnk:
  call  do_colon
  dw  ncnt,plus
  dw  exit

; N>NAME  ( nfa1 -- nfa2 | 0 )

  hdr 1,'N>NAME',,1
ntnam:
  call  do_colon
  dw  nlnk,fetch  ; n>link @
  dw  exit

; name>  ( nfa -- xt )

  hdr x,'NAME>',,1
namef:
  call  do_colon
  dw  nlnk,cellp,fetch ; n>link cell+ @
  dw  exit

; W>NAME  ( wid -- nfa | 0 )  aka @ w>name

  hdr 1,'W>NAME',,,fetch
wtnam equ fetch

; -alias  ( nfa -- nfa flag )  dup c@ $80 <

  hdr x,'-ALIAS',,1 ; false if alias
dalias:
  pop hl
  push  hl
  ld  a,(hl)
  cp  0x80
  jp  zless2

; XXX OLD -- DX-Forth 4.00
;;; >name  ( xt -- nfa | 0 )
;;;       voc-link begin @ dup while tuck 2-
;;;       w>name begin ?dup while -alias if 2dup
;;;       name> = if -rot 2drop exit then then
;;;       n>name repeat swap repeat nip
;;
;;  header x,'>NAME',,1
;;to_name:
;;  call  do_colon
;;  dw  vocl
;;to_name1:
;;  dw  fetch
;;  dw  dup
;;  dw  zbran,to_name5
;;  dw  tuck
;;  dw  twom
;;  dw  wtnam
;;to_name2:
;;  dw  qdup
;;  dw  zbran,to_name4
;;  dw  dalias    ; skip if alias
;;  dw  zbran,to_name3
;;  dw  tdup,namef
;;  dw  equal
;;  dw  zbran,to_name3
;;  dw  drot,two_drop
;;  dw  exit
;;to_name3:
;;  dw  ntnam
;;  dw  branch,to_name2
;;to_name4:
;;  dw  swap
;;  dw  branch,to_name1
;;to_name5:
;;  dw  nip
;;  dw  exit    ; not found

; XXX NEW -- DX-Forth 4.09
;  >name  ( xt -- nfa | 0 )
;        voc-link begin @ dup while tuck cell- w>name
;        begin ?dup while -alias if 2dup name> = if
;        -rot 2drop exit then then n>name repeat swap
;        repeat nip

  hdr  x,'>NAME',,1
to_name:
  call  do_colon
  dw  vocl
to_name1:
  dw  fetch
  dw  dup
  dw  zbran,to_name5
  dw  tuck
  dw  cellm
  dw  wtnam
to_name2:
  dw  qdup
  dw  zbran,to_name4
  dw  dalias    ; skip if alias
  dw  zbran,to_name3
  dw  tdup,namef
  dw  equal
  dw  zbran,to_name3
  dw  drot,two_drop
  dw  exit
to_name3:
  dw  ntnam
  dw  branch,to_name2
to_name4:
  dw  swap
  dw  branch,to_name1
to_name5:
  dw  nip
  dw  exit    ; not found

; XXX OLD -- DX-Forth 4.00
;;; (NAME)  ( nfa -- c-addr u ) count 31 and
;;
;;  header 1,'(NAME)',,1
;;pname:
;;  call  do_colon
;;  dw  count
;;  dw  clit
;;  db  31
;;  dw  and_
;;  dw  exit

; XXX NEW -- DX-Forth 4.09
;  (NAME)  ( nfa -- c-addr u )  count 31 and

  hdr  1,'(NAME)',,1
pname:
  pop  de
  ld  a,(de)
  inc  de
  and  0x1f
  ld  l,a
  ld  h,0
  push de
  jp next

; .ID  ( nfa | 0 -- )   ?dup if (name) type exit then
;         ." [noname]"

  hdr 1,'.ID',,1
dotid:
  call  do_colon
  dw  qdup
  dw  zbran,dotid1
  dw  pname
  dw  typee
  dw  exit
dotid1:
  dw  paren_dot_quote
  dcs '[noname]'
  dw  exit

; .NAME  ( xt -- )  >name .id

  hdr 1,'.NAME',,1
dotnam:
  call  do_colon
  dw  to_name,dotid
  dw  exit

; .WID  ( wid -- )  cell+ cell+ @ .id
; XXX Renamed to '.VOC' in DX-Forth 4.09
  hdr 1,'.WID',,1
dotwid:
  call  do_colon
  dw  cellp,cellp
  dw  fetch,dotid
  dw  exit

; !CSP  ( -- )    sp@ csp !

  hdr 1,'!CSP',,1 ; FIG
scsp:
  ld  hl,0
  add hl,sp
  ld  (cspp1),hl
  jp  next

; ?CSP  ( -- )    sp@ csp @ - ?bal

  hdr 1,'?CSP',,1 ; FIG
qcsp:
  call  do_colon
  dw  sp_fetch
  dw  cspp,fetch
  dw  subb
  dw  qbal
  dw  exit

; ?COMP  ( -- )   state? 0= abort" compilation only'

  hdr 1,'?COMP',,1  ; FIG
qcomp:
  call  do_colon
  dw  state,fetch
  dw  zero_equals
  dw  paren_abort_quote
  dcs 'compilation only'
  dw  exit

; ?EXEC  ( -- )   state? abort" execution only'

  hdr 1,'?EXEC',,1  ; FIG
qexec:
  call  do_colon
  dw  stateq
  dw  paren_abort_quote
  dcs 'execution only'
  dw  exit

; ?STACK  ( -- )    sp@ s0 @ over u< swap pad u< or
;       abort" stack?" r0 @ rp@ u< rp@ fs0 @ u<
;       or abort" r-stack?" fs0 @ fsp @ u< fsp @
;       fs0 @ (nfpm) @ - u< or abort" f-stack?"

  hdr 1,'?STACK',,1 ; FIG
qstac:
  call  do_colon
  dw  sp_fetch
  dw  szero,fetch
  dw  over,uless
  dw  swap
  dw  pad
  dw  uless
  dw  or_
  dw  paren_abort_quote
  dcs 'stack?'
  dw  rzero,fetch
  dw  rp_fetch
  dw  uless
  dw  rp_fetch
  dw  fszero    ; = S0 if no float
  dw  fetch
  dw  uless,or_
  dw  paren_abort_quote
  dcs 'r-stack?'
; dw  fszero,fetch
; dw  fsp,fetch
; dw  uless
; dw  fsp,fetch
; dw  fszero,fetch
; dw  lit,nfpm
; dw  fetch
; dw  subb
; dw  uless
; dw  or_
; dw  paren_abort_quote
; dcs 'f-stack?'
  dw  exit

; ?defined  ( flag -- ) 0= abort" is undefined"

  hdr x,'?DEFINED',,1
qdef:
  call  do_colon
  dw  zero_equals
  dw  paren_abort_quote
  dcs 'is undefined'
  dw  exit

; [       state off ;immediate

  hdr 1,'[',1,1
lbrac:
  ld  hl,state1
  jp  off1

; ]     state on

  hdr 1,']',,1
rbrac:
  ld  hl,state1 ; must be -1 for INTERPRET to work
  jp  on1

; COMPILE,  ( xt -- ) warning @ 0< if dup limit u< sys? d0=
;       if dup .name ."  is system " then then ,

  hdr 1,'COMPILE,',,1
comxt:
  call  do_colon
  dw  warnn,fetch
   if wopt
  dw  zless
   endif
  dw  zbran,comxt1
  dw  dup,limit
  dw  uless
  dw  sysq
  dw  dzequ
  dw  zbran,comxt1
  dw  dup
  dw  dotnam
  dw  paren_dot_quote
  dcs ' is system '
comxt1:
  dw  comma
  dw  exit

; COMPILE  ( -- )   ?comp r> dup cell+ >r @ compile,

  hdr 1,'COMPILE',,1
comp:
  call  do_colon
  dw  qcomp   ; prevent crash if interpreting
  dw  from_r
  dw  dup,cellp
  dw  to_r
  dw  fetch
  dw  comxt
  dw  exit

; POSTPONE    defined dup ?defined 0< if compile
;       compile then compile, ;immediate

  hdr 1,'POSTPONE',1,1
postp:
  call  do_colon
  dw  defined_
  dw  dup,qdef
  dw  zless
  dw  zbran,postp1
  dw  comp,comp
postp1:
  dw  comxt
  dw  exit

; XXX OLD -- DX-Forth 4.00
;;; (ACCEPT)  ( c-addr +n1 -- +n2)
;;;       0 begin key dup >r dup bl 127 within 2over -
;;;       and if dup emit over 4 pick + c! 1+ else 2dup
;;;       dup 8 = swap esc = or and if esc = if 0 swap
;;;       else 1- 1 then begin 8 dup emit space emit 1-
;;;       dup 0= until then drop then r> 13 = until
;;;       -rot 2drop
;;
;;  header x,'(ACCEPT)'
;;pacce:
;;  call  do_colon
;;  dw  zero
;;pacce1:
;;  dw  key
;;  dw  dup,to_r
;;  dw  dup,bl  ; only accept chars between 32 and 126
;;  dw  clit
;;  db  127
;;  dw  within
;;  dw  tover,subb
;;  dw  and_
;;  dw  zbran,pacce2
;;  dw  dup,emit
;;  dw  over
;;  dw  clit
;;  db  4
;;  dw  pick
;;  dw  plus
;;  dw  cstor
;;  dw  onep
;;  dw  branch,pacce6
;;pacce2:
;;  dw  tdup
;;  dw  dup
;;  dw  clit
;;  db  bs_char    ; backspace?
;;  dw  equal,swap
;;  dw  clit
;;  db  esc_char    ; escape?
;;  dw  equal,or_
;;  dw  and_
;;  dw  zbran,pacce5
;;  dw  clit
;;  db  esc_char    ; escape?
;;  dw  equal
;;  dw  zbran,pacce3
;;  dw  zero,swap
;;  dw  branch,pacce4
;;pacce3:
;;  dw  onem,one
;;pacce4:
;;  dw  clit
;;  db  bs_char
;;  dw  dup,emit
;;  dw  space,emit
;;  dw  onem
;;  dw  dup,zero_equals
;;  dw  zbran,pacce4
;;pacce5:
;;  dw  drop
;;pacce6:
;;  dw  from_r
;;  dw  clit
;;  db  cr_char
;;  dw  equal
;;  dw  zbran,pacce1
;;  dw  drot,two_drop
;;  dw  exit

; XXX NEW -- DX-Forth 4.09 -- modified
;  (ACCEPT)  ( c-addr +n1 -- +n2)
;        0 begin key dup >r dup bl 127 within 2over -
;        and if dup emit over 4 pick + c! 1+ else 2dup
;        dup bs_char = swap esc = or and if esc = if
;        0 swap else 1- 1 then begin 8 dup emit space
;        emit 1- dup 0= until then drop then r> 13 =
;        until -rot 2drop

  hdr  x,'(ACCEPT)'
pacce:
  call  do_colon
  dw  zero
pacce1:
  dw  key
  dw  dup,to_r
  dw  dup,bl  ; only accept chars between 32 and 126
  dw  clit
  db  127
  dw  within
  dw  tover,subb
  dw  and_
  dw  zbran,pacce2
  dw  dup,emit
  dw  over
  dw  clit
  db  4
  dw  pick
  dw  plus
  dw  cstor
  dw  onep
  dw  branch,pacce6
pacce2:
  dw  tdup
  dw  dup
  dw  lit,bs_char,equal
  dw  swap
  dw  clit
  db  esc_char    ; escape?
  dw  equal,or_
  dw  and_
  dw  zbran,pacce5
  dw  clit
  db  esc_char    ; escape?
  dw  equal
  dw  zbran,pacce3
  dw  zero,swap
  dw  branch,pacce4
pacce3:
  dw  onem,one
pacce4:
  dw  clit
  db  bs_char
  dw  dup,emit
  dw  space,emit
  dw  onem
  dw  dup,zero_equals
  dw  zbran,pacce4
pacce5:
  dw  drop
pacce6:
  dw  from_r
  dw  clit
  db  cr_char
  dw  equal
  dw  zbran,pacce1
  dw  drot,two_drop
  dw  exit

; ACCEPT  ( c-addr +n1 -- +n2)

  hdr 1,'ACCEPT'
accept:
  call  fetch_execute
  dw  pacce

; PAD  ( -- addr )  dp @ (npno) @ +

  hdr 1,'PAD'
pad:
  call  do_colon
  dw  dpp,fetch
  dw  lit,npno
  dw  fetch
  dw  plus
  dw  exit

; SOURCE  ( -- c-addr u )   'source 2@

  hdr 1,'SOURCE',,1
source:
  ld  hl,tsour1
  jp  tat1

; PARSE  ( char -- c-addr u ) 0 (parse)

  hdr 1,'PARSE',,1
parse:
  ld  hl,0
  push  hl
  jp  ppars ; XXX NEW -- because headers and code share the same zone

; (parse)  ( char f -- c-addr u ) 2>r source >in @ /string r> if tuck
;         r@ skip over - >in +! then 2dup r>
;         scan nip tuck - dup rot 0<> - >in +!

  hdr 0,'(PARSE)',,1
ppars:
  call  do_colon
  dw  two_to_r
  dw  source
  dw  inn,fetch,sstr
  dw  from_r
  dw  zbran,ppars1
  dw  tuck
  dw  r_fetch,skip
  dw  rot,over,subb
  dw  inn,pstor
ppars1:
  dw  tdup
  dw  from_r
  dw  scan,nip
  dw  tuck
  dw  subb,dup
  dw  rot,zero_not_equals
  dw  subb
  dw  inn,pstor
  dw  exit

; +psb  ( a1 n1 n2 -- n3 )  >r (parsed_string_buffer_size) r@ - umin r> 2dup + >r
;         (psb) + swap cmove r>

  hdr x,'+PSB',,1
ppsb:
  call  do_colon
  dw  to_r
  dw  lit,parsed_string_buffer_size
  dw  r_fetch,subb
  dw  umin
  dw  from_r
  dw  tdup,plus
  dw  to_r
  dw  lit,psb
  dw  plus
  dw  swap
  dw  cmove
  dw  from_r
  dw  exit

; PARSE$  ( char "ccc" -- a n ) 0 begin >r dup parse 2dup r> +psb >r
;         1+ + dup source + u< while 2dup c@ =
;         while 1 dup >in +! r> +psb repeat
;         then 2drop (psb) r>

  hdr 1,'PARSE$',,1
parss:
  call  do_colon
  dw  zero
parss1:
  dw  to_r
  dw  dup,parse
  dw  tdup
  dw  from_r,ppsb
  dw  to_r
  dw  onep,plus
  dw  dup
  dw  source,plus
  dw  uless
  dw  zbran,parss2
  dw  tdup,c_fetch
  dw  equal
  dw  zbran,parss2
  dw  one,dup
  dw  inn,pstor
  dw  from_r,ppsb
  dw  branch,parss1
parss2:
  dw  two_drop
  dw  lit,psb
  dw  from_r
  dw  exit

; pwa  ( -- adr )   parsed word address

  hdr x,'PWA',,1
pwa:
  call  do_value
  ds  cw

; XXX OLD -- DX-Forth 4.00
;;; >wbuf  ( c-addr1 +n -- c-addr2 )
;;;       255 min (hm-5) over - dup to pwa place pwa
;;;       bl affix
;;
;;  header x,'>WBUF',,1  ; uses WORD's buffer
;;twbuf:
;;  call  do_colon
;;  dw  clit
;;  db  255
;;  dw  min
;;   if retro
;;  dw  dpp,fetch
;;   else
;;  dw  lit,hm-5
;;  dw  over,subb
;;   endif
;;  dw  dup
;;  dw  pto,pwa
;;  dw  place
;;  dw  pwa
;;  dw  bl   ; trailing blank
;;  dw  affix
;;  dw  exit
;;
;;; WORD  ( char -- c-addr )  true (parse) >wbuf
;;
;;  header 1,'WORD',,1
;;wordd:
;;  call  do_colon
;;  dw  true,ppars
;;  dw  twbuf
;;  dw  exit
;;
;;; bl-word  ( -- addr )  bl word
;;
;;  header x,'BL-WORD',,1
;;blword:
;;  call  do_colon
;;  dw  bl,wordd
;;  dw  exit

; XXX NEW -- DX-Forth 4.09
;  wpack  ( c-addr1 +n -- c-addr2 )
;        255 min (hm-5) over - dup to pwa packed
;        bl affix

  hdr  x,'WPACK',,1  ; pack string in WORD's buffer
wpack:
  call  do_colon
  dw  clit
  db  255
  dw  min
   if  retro
  dw  dpp,fetch
   else
  dw  lit,hm-5
  dw  over,subb
   endif
  dw  dup
  dw  pto,pwa
  dw  packd
  dw  bl,affix  ; trailing blank
  dw  exit

;  WORD  ( char -- c-addr )  true (parse) wpack

  hdr  1,'WORD',,1
wordd:
  call  do_colon
  dw  true,ppars
  dw  wpack
  dw  exit

;  bl-word  ( -- c-addr )  bl word

  hdr  x,'BL-WORD',,1
blword:
  ld  hl,0x20
  push  hl
  jp  wordd

; token  ( -- c-addr u )  bl-word count

  hdr 1,'TOKEN',,1
token:
  call  do_colon
  dw  blword,count
  dw  exit

; defined  ( -- c-addr 0 | xt -1 | xt 1 ) bl-word find

  hdr x,'DEFINED',,1
defined_:call  do_colon
  dw  blword,find
  dw  exit

; '  ( -- addr )    defined ?defined

  hdr 1,"'",,1
tick:
  call  do_colon
  dw  defined_
  dw  qdef
  dw  exit

; [UNDEFINED]  ( -- flag )  defined nip 0= ;immediate

  hdr 1,'[UNDEFINED]',1,1
budef:
  call  do_colon
  dw  defined_
  dw  nip
  dw  zero_equals
  dw  exit

; [DEFINED]  ( -- flag )  postpone [undefined] 0= ;immediate

  hdr 1,'[DEFINED]',1,1
bdef:
  call  do_colon
  dw  budef,zero_equals
  dw  exit

; (  ( "ccc<delim>" ) [char] ) parse 2drop ;immediate

  hdr 1,'(',1,1
paren:
  call  do_colon
  dw  clit
  db  ')'
  dw  parse,two_drop
  dw  exit

; .(  ( "ccc<delim>" )  [char] ) parse$ type ;immediate

  hdr 1,'.(',1,1
dotp:
  call  do_colon
  dw  clit
  db  ')'
  dw  parss,typee
  dw  exit

; \  ( "ccc" -- )   source nip blk @ if c/l >in @ over / 1+ *
;       min then >in ! ;immediate

  hdr 1,'\',1,1
bslas:
  call  do_colon
  dw  source,nip
  dw  blk,fetch
  dw  zbran,bslas1
  dw  csll
  dw  inn,fetch
  dw  over,slash
  dw  onep,star
  dw  min
bslas1:
  dw  inn,store
  dw  exit

; \\  ( "ccc" -- )  source nip >in ! ;immediate

  hdr 1,'\\',1,1
bslss:
  call  do_colon
  dw  source,nip
  dw  inn,store
  dw  exit

; XXX NEW -- DX-Forth 4.09
;  LINK,  ( a -- )    here over @ , swap !

  hdr  1,'LINK,',,1
linkc:
  call  do_colon
  dw  here
  dw  over,fetch
  dw  comma
  dw  swap,store
  dw  exit

; XXX OLD -- DX-Forth 4.00
;;; WORDLIST  ( -- wid )  $2001 , here 0 , here dup voc-link @ , !
;;;       0 ,
;;
;;  header 0,'WORDLIST',,1 ; nameless wordlists not supported
;;wlist:
;;  call  do_colon
;;  dw  lit,0x2001
;;  dw  comma
;;  dw  here
;;  dw  zero    ; nfa of top word in vocabulary
;;  dw  comma
;;  dw  here,vocl
;;  dw  dup,fetch   ; link to previous vocabulary
;;  dw  comma
;;  dw  store
;;  dw  zero,comma  ; null name
;;  dw  exit

; XXX NEW -- DX-Forth 4.09
;  WORDLIST  ( -- wid )  $2001 , here 0 , voc-link link, 0 ,

  hdr  x,'WORDLIST',,1
wlist:
  call  do_colon
  dw  lit,2001h
  dw  comma
  dw  here
  dw  zero    ; nfa of top word in vocabulary
  dw  comma
  dw  vocl,linkc  ; link in wordlist
  dw  zero,comma  ; null name
  dw  exit

; VOCABULARY  ( "name" )
;       sys? system wordlist
;       ;;  create dup ,  ;; XXX OLD -- DX-Forth 4.00
;       dup value  ;; XXX NEW -- DX-Forth 4.09
;       last @
;       swap cell+ cell+ ! sys ! does> @ context !

  hdr 1,'VOCABULARY',,1
vocab:
  call  do_colon
  dw  sysq
  dw  system
  dw  wlist
;;  dw  creat,dup,comma ; XXX OLD -- DX-Forth 4.00
  dw dup,value ; XXX NEW -- DX-Forth 4.09
  dw  last,fetch   ; set name field in wordlist struct
  dw  swap
  dw  cellp,cellp
  dw  store
  dw  sys,store
  dw  pscod
dovoc:
  call  do_colon
  dw  fetch
  dw  cont,store
  dw  exit

; DEFINITIONS  ( -- ) get-context set-current

  hdr 1,'DEFINITIONS',,1
defin:
  call  do_colon
  dw  getcon
  dw  setcur
  dw  exit

; wordlist structure

forth3 defl 0 ; XXX TMP -- this solves "forth3 undefined"

  dw  0x2001    ; dummy nfa for vocab chaining
forth1:
  dw  top_nfa    ; nfa of top word in vocabulary
forth2:
  dw  0   ; previous vocabulary
  dw  forth3    ; vocab nfa

; FORTH     vocabulary forth

  hdr 1,'FORTH',,1
forth:
  call  dovoc
  dw  forth1

forth3  defl  previous_nfa

; UNUSED  ( -- u )  sys? if (esm) @ else sp@ then here
;       255 + 2dup u> -rot - and

  hdr 1,'UNUSED'
unus:
  call  do_colon
  dw  sysq
  dw  zbran,unus1
  dw  lit,esm
  dw  fetch
  dw  branch,unus2
unus1:
  dw  sp_fetch
unus2:
  dw  here
  dw  clit    ; allow margin
  db  255
  dw  plus
  dw  tdup
  dw  ugrea
  dw  drot
  dw  subb
  dw  and_
  dw  exit

; INTERPRET  ( -- ) begin bl-word dup c@ while find ?dup if
;       state? = if compile, else execute then
;       else count base @ >r over c@ case [char] $
;       of hex 1 endof [char] # of decimal 1 endof
;       0 swap endcase /string 2dup number? if
;       2nip dpl @ 0< if drop state? if
;       postpone literal then else state? if
;       postpone 2literal then then true else
;       fnumber then r> base ! ?defined then ?stack
;       repeat drop

  hdr 1,'INTERPRET',,1
interpret:
  call  do_colon
interpret1:
  dw  blword
  dw  dup,c_fetch
  dw  zbran,interpret15  ; while not end of input stream
  dw  find
  dw  qdup
  dw  zbran,interpret4 ; if found
  dw  stateq
  dw  equal
  dw  zbran,interpret2 ; if compiling and not immediate
  dw  comxt
  dw  branch,interpret3
interpret2:
  dw  execute
interpret3:
  dw  branch,interpret14
interpret4:
  dw  count
  dw  base,fetch,to_r
  dw  over,c_fetch
  dw  clit
  db  '$'
  dw  pof,interpret5
  dw  hex,one
  dw  branch,interpret7
interpret5:
  dw  clit
  db  '#'
  dw  pof,interpret6
  dw  decimal,one
  dw  branch,interpret7
interpret6:
  dw  zero,swap
  dw  drop
interpret7:
  dw  sstr
  dw  tdup
interpret8:
  dw  numq    ; NUMBER? patch
  dw  zbran,interpret12
  dw  tnip
  dw  dpl,fetch,zless
  dw  zbran,interpret10
  dw  drop
  dw  stateq
  dw  zbran,interpret9
  dw  liter
interpret9:
  dw  branch,interpret11
interpret10:
  dw  stateq
  dw  zbran,interpret11
  dw  tlite
interpret11:
  dw  true
  dw  branch,interpret13
interpret12:
  dw  fnu     ; FNUMBER patch
interpret13:
  dw  from_r,base,store
  dw  qdef
interpret14:
  dw  qstac
  dw  branch,interpret1
interpret15:
  dw  drop
  dw  exit

; (eval)  ( c-addr u blk -- ) blk @ >in @ 2>r source 2>r blk !
;         'source 2! >in off interpret 2r>
;         'source 2! 2r> >in ! blk !

  hdr x,'(EVAL)',,1   ; does not restore block contents
peval:
  call  do_colon
  dw  blk,fetch
  dw  inn,fetch
  dw  two_to_r
  dw  source,two_to_r
  dw  blk,store
  dw  tsourc,two_store
  dw  inn,off     ; reset >IN
  dw  interpret
  dw  two_from_r,tsourc,two_store
  dw  two_from_r
  dw  inn,store
  dw  blk,store
  dw  exit

; ?BLOCK   ( -- )     blk @ ?dup if block drop then

  hdr x,'?BLOCK',,1   ; reload block
qblock:
  call  do_colon
  dw  blk,fetch,qdup
  dw  zbran,qblock1
  dw  block,drop
qblock1:dw  exit

; EVALUATE  ( c-addr u -- ) 0 (eval) ?block

  hdr 1,'EVALUATE',,1
eval:
  call  do_colon
  dw  zero,peval
  dw  qblock
  dw  exit

; (refill)  ( -- flag ) blk @ ?dup if 1+ dup #screens u< and dup
;       while dup blk ! block b/buf else (tib)
;       dup 80 accept space then 'source 2! >in
;       off true then

  hdr x,'(REFILL)',,1   ; doesn't correctly handle source
prefil:
  call  do_colon     ; from EVALUATE
   if debug
  dw  paren_dot_quote
  dcs '(REFILL) '
   endif
  dw  blk,fetch,qdup
  dw  zbran,prefil1
  dw  onep,dup
  dw  nscr,uless
  dw  and_,dup
  dw  zbran,prefil3
  dw  dup,blk,store
  dw  block,bbuf
  dw  branch,prefil2
prefil1:dw  lit,tib
  dw  dup
  dw  clit
  db  80
  dw  accept
  dw  space
prefil2:dw  tsourc,two_store
  dw  inn,off
  dw  true
prefil3:dw  exit

; REFILL  ( -- flag )

  hdr 1,'REFILL',,1
refil:
  call  fetch_execute
  dw  prefil

; reset  ( -- )   catcher off -caps console

  hdr x,'RESET'
reset:
  call  do_colon
  dw  catchr,off  ; reset error handler
  dw  dcaps   ; reset COMPARE/SEARCH caps
  dw  console    ; set EMIT vector
  dw  exit

; /interpret  ( -- )  blk off >in off postpone [

  hdr x,'/INTERPRET',,1
sinte:
  ld  hl,0
  ld  (blk1),hl
  ld  (inn1),hl
  jp  lbrac

; forth-reset  ( -- )
;       0 set-limit empty warning on checking
;       on (fdbs) (file_descriptor_size*nfd) erase empty-buffers
;       /interpret 'source off bl-word drop

  hdr x,'FORTH-RESET',,1
forth_reset:
  call  do_colon
; XXX TODO
; XXX OLD
;;  dw  zero
;;  dw  setlim
;;  dw  empty   ; reset vocabulary pointers
;;  dw  warnn,on  ; enable warnings
;;  dw  check,on  ; enable checking
;;  dw  lit,fdbs  ; clear files
;;  dw  lit,file_descriptor_size*nfd ;
;;  dw  erase   ;
;;  dw  empty_buffers   ; mark screen buffer as empty
;;  dw  sinte   ; reset interpreter
;;  dw  tsourc,off  ; clear parsed word buffer
;;  dw  blword,drop ;
  dw  exit

; QUIT  ( -- )    r0 @ rp! reset normal /interpret begin
;       cr (refill) drop interpret state? 0= if
;       ."  ok" then again

  hdr 1,'QUIT',,1
quit:
  call  do_colon
quit1:
  dw  rzero,fetch
  dw  rp_store
  dw  reset
;** dw  vnorm ; XXX OLD
  dw  sinte
   if debug
  dw  paren_dot_quote
  dcs 'QUIT '
   endif
quit2:
  dw  crr
  dw  prefil,drop
  dw  interpret
  dw  stateq
  dw  zero_equals
  dw  zbran,quit3
  dw  paren_dot_quote
  dcs ' ok'
quit3:
  dw  branch,quit2

; RETURN  ( x -- )  exit to DOS with return code x

  hdr 1,'RETURN'
return:
  ; XXX TODO
  pop bc
  ret
; XXX OLD
;;  call  do_colon
;;  dw  console
;;  dw  crr
;;  dw  $+2
;;  pop bc
;;  ld  hl,(z3eadr) ; for ZSYSTEM
;;  ld  a,h
;;  or  l
;;  jp  z,retrn1
;;  ld  de,34   ; Z3MSG?
;;  add hl,de
;;  ld  a,(hl)
;;  inc hl
;;  ld  h,(hl)
;;  ld  l,a
;;  or  h
;;  jp  z,retrn1
;;  ld  de,6    ; offset to error byte
;;  add hl,de
;;  ld  (hl),c
;;retrn1:
;;  ld  a,(dosv)  ; set program return code
;;  cp  0x30   ; CPM3 ?
;;  ld  e,c
;;  ld  d,0
;;  ld  c,108
;;rtrn2:
;;  call  nc,0x0005
;;  ld  a,(defusr)  ; restore default drive/user
;;  call  susr
;;  ld  a,(defdrv)
;;  ld  e,a
;;  ld  c,14
;;  call  0x0005
;;  ld  hl,(stack)  ; return to CP/M
;;  ld  a,h
;;  or  l
;;  jp  z,0x0000   ; warm boot
;;  ld  sp,hl
;;  ret

; BYE  ( -- )   close-all exit-video 0 return

  hdr 1,'BYE',,1
bye:
if 0
  ; XXX TODO -- Code from Benschop's ZX Spectrum Forth-83
  ld sp,(sys_err_sp) 
  pop bc
  ld bc,0x1303 
  push bc
  im 1
  ld (IY+31),2 ; update sys_e_line
  rst 0x08     ; error
  db 0xff      ; error code
endif
  jp  next
; XXX OLD
;;  call  do_colon
;;  dw  closa
;;  dw  exvid   ; terminal exit sequence
;;  dw  zero,return

; boot?  ( -- bootword )  (iboot) @

  ; XXX TODO -- convert this into a variable that holds an xt
  hdr x,'BOOT?'
bootq:
  ld  hl,(iboot)
  push hl
  jp next

; (abort)  ( -- )   s0 @ sp! fs0 @ fsp ! boot? if 1 return then
;       quit

  hdr x,'(ABORT)'
pabor:
  call  do_colon
  dw  szero,fetch
  dw  sp_store
  dw  fszero,fetch
  dw  fsp,store
  dw  bootq
   if debug
  dw  zbran,pabor1
  dw  one
  dw  return
pabor1  dw  paren_dot_quote
  dcs ' (ABORT) '
  dw  quit
   else
  dw  zbran,quit1
  dw  one
  dw  return
   endif

; .error  ( -- )
;       cr blk @ ?dup if file? and if filename type
;       >in @ 2- 0max blk @ 2dup scr 2! ."  Scr "
;       u. c/l / ." Line " . cr then then ." Error: "
;       [char] " dup emit pwa count 31 min type emit

  hdr x,'.ERROR',,1
doterr:
  call  do_colon
  dw  crr
  dw  blk,fetch
  dw  qdup
  dw  zbran,doterr1
  dw  fileq
  dw  and_    ; screen file open and loading from block?
  dw  zbran,doterr1
  dw  loadf,typee
  dw  inn,fetch
  dw  twom    ; adjust pointer
  dw  zero_max
  dw  blk,fetch
  dw  tdup    ; set error block, offset
  dw  scr,two_store
  dw  paren_dot_quote
  dcs ' Screen '
  dw  udot
  dw  csll
  dw  slash
  dw  paren_dot_quote
  dcs 'Line '
  dw  dot
  dw  crr
doterr1:dw  paren_dot_quote
  dcs 'Error: '
  dw  clit
  db  '"'
  dw  dup,emit
  dw  pwa,count
  dw  clit
  db  31
  dw  min
  dw  typee
  dw  emit
  dw  exit

; error  ( n -- )
;       -1 of (abort) then
;       -2 of boot cell+ @ 0=
;       if .error then space errmsg 2@ type (abort) then
;       ."  exception = " . (abort)

  hdr x,'ERROR'
error:
  call  do_colon
  dw  true    ; -1
  dw  pof,error1
  dw  pabor
error1:
  dw  lit,-2
  dw  pof,error3
  dw  boot,cellp,fetch
  dw  zero_equals
  dw  zbran,error2
  dw  doterr    ; skipped by applications
error2:
  dw  space
  dw  errmsg,tat
  dw  typee
  dw  pabor
error3:
  dw  paren_dot_quote
  dcs ' exception = '
  dw  dot
  dw  pabor
  dw  exit

; CATCH  ( xt -- n | 0 )  sp@ >r fsp @ >r catcher @ >r rp@ catcher
;       ! execute r> catcher ! 2r> 2drop 0

  hdr 1,'CATCH'
catch:
  call  do_colon
  dw  sp_fetch,to_r
  dw  fsp,fetch
  dw  to_r
  dw  catchr,fetch,to_r
  dw  rp_fetch,catchr,store
  dw  execute
  dw  from_r,catchr,store
  dw  two_from_r,two_drop
  dw  zero
  dw  exit

; THROW  ( n -- )   ?dup if catcher @ ?dup 0= if error then rp!
;       r> catcher ! r> fsp ! r> swap >r sp! drop
;       r> then

  hdr 1,'THROW'
throw:
  call  do_colon
  dw  qdup
  dw  zbran,throw2
  dw  catchr,fetch
   if debug
  dw  paren_dot_quote
  dcs ' THROW:'
  dw  over,dot
  dw  paren_dot_quote
  dcs 'CATCHER:'
  dw  dup,udot,space,space
   endif
  dw  qdup,zero_equals
  dw  zbran,throw1
  dw  error
throw1:
  dw  rp_store
  dw  from_r,catchr,store
  dw  from_r,fsp,store
  dw  from_r,swap,to_r
  dw  sp_store
  dw  drop,from_r
throw2:
  dw  exit

; ABORT  ( -- )   -1 throw

  hdr 1,'ABORT'
abort:
  ld  hl,-1
abort1:
  push  hl
  jp  throw

; (abort")  ( n -- )  r> count rot if errmsg 2! -2 throw then +
;       >r

  hdr x,'(ABORT")'
paren_abort_quote:
  call  do_colon
  dw  from_r,count
  dw  rot
  dw  zbran,paren_abort_quote_1
  dw  errmsg
  dw  two_store
  dw  lit,-2
  dw  throw
paren_abort_quote_1:
  dw  plus,to_r
  dw  exit

; ABORT"      postpone (abort") ," ;immediate

  hdr 1,'ABORT"',1,1
abort_quote:
  call  do_colon
  dw  comp,paren_abort_quote
  dw  comq
  dw  exit

; XXX OLD -- DX-Forth 4.00
;;; CMDTAIL  ( -- c-addr u )  (dosbuf) count
;;
;;  header 1,'CMDTAIL'
;;cmdtail:ld  de,dosbuf
;;  jp  count1
;;; XXX OLD -- DX-Forth 4.09
;;;  CMDTAIL  ( -- c-addr u )  (dosbuf) count bl skip -trailing
;;
;;  hdr  1,'CMDTAIL'
;;cmdtail:call  do_colon
;;  dw  clit
;;  db  dosbuf
;;  dw  count
;;  dw  bl,skip
;;  dw  dtrai
;;  dw  exit

; Cold boot

;nodos  db  'wrong DOS version',cr_char,lf_char,'$'
;noram:  db  'not enough RAM'
crlf:  db  cr_char,lf_char,'$' ; XXX TMP 

cold_boot:
  ; XXX TODO
  jp  cold ; XXX TMP
; XXX OLD
;;  call  gdrv      ; save default drive and user
;;  ld  (defdrv),a
;;  call  gusr
;;  ld  (defusr),a
;;
;;  ld  c,12      ; get CP/M version
;;  call  0x0005
;;  ld  (dosv),hl
;;
;;  ld  hl,(z3eadr)   ; test for ZSYSTEM
;;  push  hl
;;  ld  de,27
;;  add hl,de
;;  ld  e,(hl)
;;  inc hl
;;  ld  d,(hl)
;;  pop hl
;;  call  ssub
;;  ld  hl,0
;;  jp  z,cldd1
;;  ld  (z3eadr),hl   ; not present or invalid z3eadr
;;
;;cldd1:
;;  ld  (stack),hl    ; hl=0
;;
;;  ld  a,(noboot)    ; test noboot flag
;;  or  a
;;  ld  a,(0x0005+2)   ; bdos base
;;  jp  z,cldd2
;;
;;  add hl,sp     ; save old stack
;;  ld  (stack),hl
;;  sub 8     ; skip over CCP
;;
;;cldd2:
;;  ld  sp,tmpstk
;;  ld  h,a
;;  ld  l,0
;;  ld  (esm),hl    ; patch end of memory value
;;  ex  de,hl
;;
;;  ld  hl,(boot1)    ; get BOOT word
;;  ld  (iboot),hl    ; save it
;;  ld  a,h
;;  or  l
;;  ld  l,a
;;  ld  a,(boot2)
;;  and l
;;  jp  z,cldd3     ; need forth system
;;
;;  ld  hl,noop
;;  ld  (cold1),hl
;;  ld  hl,(ulimit)
;;  ld  a,l
;;  or  h
;;  jp  nz,cldd6
;;  ex  de,hl
;;  jp  cldd6
;;
;;cldd3:
;;  dec a     ; set command line flag
;;  ld  (cmdf),a
;;
;;  ld  hl,(idph)   ; move system segment into place
;;  ld  de,hm
;; XXX Some changes here in DX-Forth 4.09
;;  call  ssub
;;cldd4:
;;  ld  b,0     ; later patched to LD B,H
;;cldd5:
;;  ld  c,0     ; later patched to LD C,L
;;  ld  hl,(idp)
;;  call  bmovu
;;  ld  de,sm
;;
;;cldd6:
;;  ex  de,hl
;;  ld  (limit1),hl   ; patch LIMIT
;;
;;  db  0xc3      ; 'jmp'
;;cldd7:
;;  dw  movpat      ; later patched to 'cold'

; BOOTMESSAGE  ( -- )
; XXX NEW -- after Gforth
; XXX TODO -- defered

bootmessage:
  call do_colon
  dw paren_dot_quote
  dcs 'DZX-Forth'
;  dw paren_dot_quote
;  version
  jp next

; COLD  ( -- )

  hdr 1,'COLD'    ; FIG
cold:
; XXX TODO
; XXX OLD
;;  ld  sp,tmpstk
;;  ld  hl,(limit1)   ; get LIMIT
;;  ld  de,-recsiz    ; file r/w buffer size
;;  add hl,de
;;  ld  (hbuf1),hl    ; patch HBUF
;;  push  hl
;;  ld  hl,(nfcb1)    ; #fcb
;;  ld  de,-file_handle_size    ; handle size
;;  call  umstrr
;;  pop hl
;;  add hl,de
;;  ex  de,hl
;;  ld  hl,(nus)    ; user area size
;;  call  subd
;;  ld  (user_area_pointer),hl    ; patch UP
;;  ld  (ir0),hl    ; patch R0
;;  ld  (rpp),hl    ; patch RP
;;  ex  de,hl
;;  ld  hl,(nrts)   ; return stack size
;;  call  subd
;;  ld  (fspp),hl   ; init fp stack
;;  ld  (ifs0),hl   ; patch FS0
;;; XXX These lines were commented out in the original source:
;;; ex  de,hl
;;; ld  hl,(nfps)   ; fp stack size
;;; call  subd
;;  ld  sp,hl     ; set cpu stack pointer
;;  ld  (is0),hl    ; patch S0
;;   if cfs
;;  ld  (cfz1),hl   ; init CF0 with safe value
;;   endif
;;  ld  hl,(user_area_pointer)    ; init boot up variables
;;  ex  de,hl
;;  ld  hl,initu
;;  ld  bc,initu2-initu
;;  call  bmovu

  ld  hl,0      ; patch PAUSE
  ld  (pause1),hl

; XXX OLD
;;  ld  de,dosbuf   ; reset DOS DTA
;;  ld  c,26
;;  call  0x0005

  call  do_colon
;;  dw  zfh     ; reset handles
;;  dw  sys,off     ; default is APPLICATION

;  dw  decimal     ; default base
;  dw noop ; XXX TMP
  dw one
  dw border
;  dw bootmessage ; XXX FIXME fails
  dw paren_dot_quote
  dcs 'DZX-Forth'
  ; XXX NEW
;  dw cls
;  dw bootmessage
forever:
  dw branch,forever ; XXX INFORMER

;;  dw  reset     ; general reset
cold1:
;;  dw  forth_reset
cold2:
;;  dw  init      ; run INIT eg. for float
;;  dw  bootq
;;  dw  dup,boot,store     ; restore BOOT
;;  dw  qdup
;;  dw  zbran,cold3
;;  dw  execute      ; run application
  dw  zero,return  ; exit to DOS

cold3:
; XXX OLD >>>>>>>>>>>>>>>>>>>>>>>> command line parameter
;;  dw  cmdtail     ; process command-line
;;  dw  lit,cmdf
;;  dw  c_fetch,and_
;;  dw  tuck
;;  dw  lit,tib     ; copy to tib
;;  dw  zero,pstr
;;  dw  tsourc,two_store
;;  dw  zbran,cold5
;;  dw  zero
;;  dw  lit,cmdf    ; disable
;;  dw  cstor
;;  dw  blword      ; parse first word
;;  dw  fetch
;;  dw  lit
;;  db  1,'-'     ; skips file open
;;  dw  subb
;;  dw  zbran,cold4
;;  dw  inn,off
;;  dw  getfilename,popen
; XXX OLD <<<<<<<<<<<<<<<<<<<<<<<<

;;cold4:
;;  dw  interpret      ; interpret
;;cold5:
;;;;  dw  invid     ; terminal init sequence ; XXX OLD
;;  dw  crr,page
;;  dw  paren_dot_quote
;;  db  cold8-$-1
;;cold6:
;;  db  'DZX-Forth '
;;  version
;;cold7:
;;cold8:
;;;;  dw  lit,termn   ; show terminal name ; XXX OLD
;;;;  dw  count,typee
;;  dw  paren_dot_quote
;;  db  cold9-$-1
;;  db  cr_char,lf_char
cold9:
;;  dw  ident     ; run IDENTIFY
;;  dw  crr
;;  dw  fileq
;;  dw  zbran,cold10
;;  dw  crr
;;  dw  paren_dot_quote
;;  dcs 'Using '
;;  dw  loadf,typee
;;  dw  crr
;;cold10:
;;  dw  quit      ; jump to interpreter

; XXX OLD 
;;; SET-LIMIT  ( addr -- )  $fff0 and (ulimit) !
;;
;;  hdr  1,'SET-LIMIT',,1
;;setlim:
;;  pop hl
;;  ld  a,l
;;  and 0x00f0
;;  ld  l,a
;;  ld  (ulimit),hl
;;  jp  next

; }}} **********************************************************
; Dictionary support {{{

;  FREEZE  ( -- )    up @ (initu) (initu2-initu) cmove

  hdr  1,'FREEZE',,1
freez:
  call  do_colon
  dw  up,fetch
  dw  lit,initu
  dw  lit,initu2-initu
  dw  cmove
  dw  exit

;  'prune      variable 'prune  'prune off

  hdr  x,"'PRUNE",,1
tprun:
  call  do_create
  dw  toppru    ; 0=end

;  REMEMBER  ( xt -- )  'prune link, ,

  hdr  1,'REMEMBER',,1  ; add xt to prunes
remem:
  call  do_colon
  dw  tprun,linkc
  dw  comma
  dw  exit

;  xdp  ( adr -- adr xdp )  dup limit u< if dp else dph then

  hdr  x,'XDP',,1
xdp:
  pop  de
  push  de
  ld  hl,limit1
  ex  de,hl
  call  cmpu
  jp  nc,dph
  jp  dpp

;  prunes  ( -- )    begin 'prune @ dup while dup xdp @ u< 0=
;        while 2@ 'prune ! execute repeat then drop

  hdr  x,'PRUNES',,1
pruns:
  call  do_colon
pruns1:
  dw  tprun,fetch
  dw  dup
  dw  zbran,pruns2
  dw  dup
  dw  xdp,fetch
  dw  uless,zero_equals
  dw  zbran,pruns2
  dw  tat
  dw  tprun,store
  dw  execute
  dw  branch,pruns1
pruns2:
  dw  drop
  dw  exit

;  ?protected ( h-addr -- h-addr )  (idph) @ over u> check? and
;          abort" is protected"

  hdr  x,'?PROTECTED',,1
qprot:
  call  do_colon
  dw  lit,idph
  dw  fetch
  dw  over,ugrea
  dw  chkq,and_
  dw  paren_abort_quote
  dcs  'is protected'
  dw  exit

;  name? ( "name" -- xt nfa )  bl-word get-context wfind ?defined
;          ?protected

  hdr  x,'NAME?',,1  ; find name in context wordlist
nameq:
  call  do_colon
  dw  blword
  dw  getcon
  dw  wfind,qdef
  dw  qprot
  dw  exit

;  lfind  ( wid nfa -- lfa |0 )  swap begin 2dup @ - while @
;          dup while n>link repeat then nip

  hdr  x,'LFIND',,1  ; find link field containing nfa, 0=none
lfind:
  call  do_colon
  dw  swap
lfind1:
  dw  tdup,fetch
  dw  subb
  dw  zbran,lfind2
  dw  fetch,dup
  dw  zbran,lfind2
  dw  nlnk
  dw  branch,lfind1
lfind2:
  dw  nip
  dw  exit

;  BEHEAD  ( "name1" "name2" -- )  name? nip name? nip 2dup u< if swap
;          then n>name get-context rot lfind !

  hdr  1,'BEHEAD',,1  ; unlink word heads
behead:
  call  do_colon
  dw  nameq,nip
  dw  nameq,nip
  dw  tdup,uless
  dw  zbran,behead1
  dw  swap
behead1:dw  ntnam
  dw  getcon
  dw  rot,lfind
  dw  store
  dw  exit

;  ?voc  ( flag -- )    abort" invalid vocabulary"

  hdr  x,'?VOC',,1
qvoc:
  call  do_colon
        dw  paren_abort_quote
        dcs  'invalid vocabulary'
        dw  exit

;  CHAIN   ( "name" -- )    get-current postpone addr @ 2dup =
;          ?voc cell- $2001 over @ - ?voc
;          2dup lfind ?voc swap 0 lfind
;          ?protected 2dup u> ?voc !

  hdr  1,'CHAIN',,1
chain:
  call  do_colon
  dw  getcur
  dw  addr,fetch
  dw  tdup,equal  ; same wordlist
  dw  qvoc
  dw  cellm
  dw  lit,2001h
  dw  over,fetch,subb  ; not a wordlist
  dw  qvoc
  dw  tdup,lfind  ; already chained
  dw  qvoc
  dw  swap
  dw  zero,lfind
  dw  qprot
  dw  tdup,ugrea  ; forward reference
  dw  qvoc
  dw  store
  dw  exit

;  (forget)  ( nfa dp -- )  dp ! >r voc-link begin @ dup cell+ @ r@
;        u< until dup voc-link ! begin dup cell-
;        dup @ begin dup r@ u< 0= while -alias if
;        dup name> dp @ umin dp ! then n>name
;        repeat swap ! @ ?dup 0= until r> dup dp
;        cell+ ! (idph) @ u< if freeze then prunes

  hdr  x,'(FORGET)',,1
pforg:
  call  do_colon
  dw  dpp,store  ; starting maximums
  dw  to_r
  dw  vocl    ; trim vocs > nfa
pforg1:
  dw  fetch
  dw  dup,cellp,fetch
  dw  r_fetch,uless
  dw  zbran,pforg1
  dw  dup,vocl,store
pforg2:
  dw  dup,cellm  ; scan remaining vocs
  dw  dup
  dw  fetch
pforg3:
  dw  dup,r_fetch  ; for each word >= nfa
  dw  uless,zero_equals
  dw  zbran,pforg5
  dw  dalias    ; not an alias
  dw  zbran,pforg4
  dw  dup,namef  ; get its xt
  dw  dpp,fetch
  dw  umin,dpp,store  ; trim dict
pforg4:
  dw  ntnam
  dw  branch,pforg3
pforg5:
  dw  swap,store
  dw  fetch
  dw  qdup,zero_equals
  dw  zbran,pforg2  ; until all vocs done
  dw  from_r
  dw  dup,dpp
  dw  cellp,store
  dw  lit,idph  ; below fence?
  dw  fetch,uless
  dw  zbran,pforg6
  dw  freez    ; fix bootup values
pforg6:
  dw  pruns    ; run prunes chain
  dw  exit

;  EMPTY  ( -- )    forth definitions (idp) 2@ (forget)

  hdr  1,'EMPTY',,1
empty:
  call  do_colon
  dw  forth,defin  ; switch to a safe vocabulary
  dw  lit,idp
  dw  tat
  dw  pforg
  dw  exit

;  FORGET  ( "name" -- )  get-current context ! name? -alias 0=
;        abort" is alias" swap limit over u> if
;        drop dp @ then (forget)

  hdr  1,'FORGET',,1
forg:
  call  do_colon
  dw  getcur
  dw  cont,store
  dw  nameq
  dw  dalias,zero_equals  ; alias?
  dw  paren_abort_quote
  dcs  'is alias'
  dw  swap
  dw  limit
  dw  over,uless
  dw  zbran,forg1
  dw  drop
  dw  dpp,fetch
forg1:
  dw  pforg
  dw  exit

;  MARKER  ( "name" -- )  sys? system create sys !

  hdr  1,'MARKER',,1
marker:
  call  do_colon
  dw  sysq
  dw  system
  dw  creat
  dw  sys,store
  dw  exit

; }}} **********************************************************
; XXX {{{

; S,  ( c-addr u -- )
; 255 min 0max here over 1+ allot place

  hdr x,'S,',,1
scomm:
  call  do_colon
  dw  clit
  db  255
  dw  min
  dw  zero_max
  dw  here,over
  dw  onep,allot
  dw  place
  dw  exit

; ,"  ( "ccc" -- )  [char] " parse$ s,

  hdr 1,',"',,1
comq:
  call  do_colon
  dw  clit
  db  '"'
  dw  parss
  dw  scomm
  dw  exit

; XXX OLD -- DX-Forth 4.00
;;; (s")  ( -- c-addr u ) r> count 2dup + >r
;;
;;  header x,'(S")'
;;psqot:
;;  call  do_colon
;;  dw  from_r,count
;;  dw  tdup,plus,to_r
;;  dw  exit

; XXX NEW -- DX-Forth 4.09
; (s")  ( -- c-addr u ) r> count 2dup + >r

  hdr  x,'(S")'
psqot:
  ld  a,(bc)
  ld  l,a
  ld  h,0
  inc bc
  push  bc
  push  hl
  add hl,bc
  ld  c,l
  ld  b,h
  jp  next

; SLITERAL  ( c-addr u -- )  postpone (s") s, ;immediate

  hdr 1,'SLITERAL',1,1
slite:
  call  do_colon
  dw  comp,psqot
  dw  scomm
  dw  exit

; S"  ( -- c-addr u ) [char] " parse$ state? if postpone sliteral
;       then ;immediate

  hdr 1,'S"',1,1  ; state-smart
squot:
  call  do_colon
  dw  clit
  db  '"'
  dw  parss
  dw  stateq
  dw  zbran,squot1
  dw  slite
squot1:
  dw  exit

; XXX OLD -- DX-Forth 4.00
;;; (.")      r> count 2dup + >r type
;;
;;  header x,'(.")'
;;paren_dot_quote:
;;  call  do_colon
;;  dw  from_r,count
;;  dw  tdup,plus,to_r
;;  dw  typee
;;  dw  exit

; XXX NEW -- DX-Forth 4.09
; (.")      r> count 2dup + >r type

  hdr  x,'(.")'
paren_dot_quote:
  ld  a,(bc)  ; get the length of the string
  ld  l,a
  ld  h,0
  inc bc      ; address of the first char
  push  bc    ; push the address
  push  hl    ; push the length
  add hl,bc   ; calculate the new IP
  ld  c,l     ; update the IP
  ld  b,h
  jp  typee

; ."      compile (.") ," ;immediate

  hdr 1,'."',1,1
dot_quote:
  call  do_colon
  dw  comp,paren_dot_quote
  dw  comq
  dw  exit

; CHAR?  ( x -- x flag )

  hdr x,'CHAR?',,1
charq:
  pop hl
  push  hl
  ld  l,h
  jp  zequ1

; LITERAL  ( n -- ) char? if postpone clit c, exit then
;       postpone lit , ;immediate

  hdr 1,'LITERAL',1,1
liter:
  call  do_colon
  dw  charq
  dw  zbran,liter1
  dw  comp,clit
  dw  ccomm
  dw  exit
liter1:
  dw  comp,lit
  dw  comma
  dw  exit

; 2LITERAL  ( d -- )  postpone 2lit , , ;immediate

  hdr 1,'2LITERAL',1,1
tlite:
  call  do_colon
  dw  comp,tlit
  dw  comma,comma
  dw  exit

; [']     ' [compile] literal  ;immediate

  hdr 1,"[']",1,1
btick:
  call  do_colon
  dw  tick
  dw  liter
  dw  exit

; [COMPILE]   ' compile,  ;immediate

  hdr 1,'[COMPILE]',1,1
bcomp:
  call  do_colon
  dw  tick
  dw  comxt
  dw  exit

; RECURSE  ( -- )   last cell+ @ compile, ;immediate

  hdr 1,'RECURSE',1,1
recurs:
  ld  hl,(last2)
  push  hl
  jp  comxt

; CHAR  ( -- char ) bl word 1+ c@

  hdr 1,'CHAR',,1
char:
  call  do_colon
  dw  bl,wordd
  dw  onep,c_fetch
  dw  exit

; [CHAR]  ( -- char ) char [compile] literal

  hdr 1,'[CHAR]',1,1
pchar:
  call  do_colon
  dw  char
  dw  liter
  dw  exit

; Y/N  ( -- flag )  ." (y/n) N\bs" key upcase [char] Y = dup
;       if [char] Y else [char] N then emit space

  hdr 1,'Y/N'
yn:
  call  do_colon
  dw  paren_dot_quote
  dcs '(y/n) N',bs_char
  dw  key,upcas
  dw  clit
  db  'Y'
  dw  equal,dup
  dw  zbran,yn1
  dw  clit
  db  'Y'
  dw  branch,yn2
yn1:
  dw  clit
  db  'N'
yn2:
  dw  emit,space
  dw  exit

; CHAR+  ( c-addr1 -- c-addr2 ) aka 1+ char+

  hdr 1,'CHAR+',,,onep
charp equ onep

; CHARS  ( n1 -- n2 )   aka noop chars immediate

  hdr 1,'CHARS',1,,noop
chars equ next

; CELL+  ( addr1 -- addr2 ) aka 2+ cell+

  hdr 1,'CELL+',,,twop
cellp equ twop

; CELL-  ( addr1 -- addr2 ) aka 2- cell-

  hdr 1,'CELL-',,,twom
cellm equ twom

; CELLS  ( n1 -- n2 )   aka 2* cells

  hdr 1,'CELLS',,,tstar
cells equ tstar

; ALIGN  ( -- )     aka noop align immediate

  hdr 1,'ALIGN',1,,noop
alignn  equ next

; ALIGNED  ( addr -- a-addr ) aka noop aligned immediate

  hdr 1,'ALIGNED',1,,noop
alignd  equ next

; DZX-FORTH  ( -- minor major )

  hdr 1,'DZX-FORTH'
dxf:
; XXX OLD
;;  ld  hl,(dxver)
;;  jp  dosver1
; XXX TODO
  jp  next

; }}} **********************************************************
; Files {{{

;  RESET-DISKS  ( -- )

  hdr  1,'RESET-DISKS'
rstdsk:
  ld  a,25
  call  bdoss
  push  af
  ld  a,13
  call  bdoss
  pop  af
  ld  e,a
  ld  a,14
  call  bdoss
  jp next

;  >DRIVE  ( u1 -- u2 )  ?dup if 1- else 0 25 bdos then

  hdr  1,'>DRIVE'
tdrv:
  pop  de
  ld  a,e
  dec  a
  call  m,gdrv
  jp  push_a

;  PATH  ( u1 -- c-addr u2 ior )
;        255 32 bdos 0 <# [char] : hold #s rot >drive
;        [char] A + hold #> 0

  hdr  1,'PATH'  ; uses numeric buffer
path:
  call  do_colon
  dw  clit
  db  255
  dw  clit
  db  32
  dw  bdos
  dw  zero,bdigs
  dw  clit
  db  ':'
  dw  hold
  dw  digs
  dw  rot,tdrv
  dw  clit
  db  'A'
  dw  plus
  dw  hold,edigs
  dw  zero
  dw  exit

;  -PATH  ( addr1 u1 -- addr2 u2 )
;        2dup [char] : scan dup if 1 /string 2swap
;        then 2drop

  hdr  1,'-PATH'
dpath:
  call  do_colon
  dw  tdup
  dw  clit
  db  ':'
  dw  scan,dup
  dw  zbran,dpath1
  dw  one,sstr
  dw  tswap
dpath1:
  dw  two_drop
  dw  exit

;  filetype?  ( addr1 u1 -- u2 )  -path [char] . scan nip

  hdr  x,'FILETYPE?'  ; get filetype length
ftype:
  call  do_colon
  dw  dpath
  dw  clit
  db  '.'
  dw  scan,nip
  dw  exit

;  +EXT  ( addr1 u1 addr2 u2 -- addr3 u3 )
;        2over filetype? if 2drop exit then 3 min
;        s" ." 2rot -trailing (filename_size-5) min zbuf
;        @ 1+ 0 +string +string +string

  hdr  1,'+EXT'  ; uses filename buffer
pext:
  call  do_colon
  dw  tover,ftype
  dw  zbran,pext1
  dw  two_drop,exit
pext1:
  dw  three,min
  dw  psqot
  dcs  '.'
  dw  trot
  dw  dtrai    ; trim trailing blanks
  dw  clit
  db  filename_size-5
  dw  min
  dw  zbuf,fetch    ; unused
  dw  onep
  dw  zero
  dw  pstr
  dw  pstr
  dw  pstr
  dw  exit

;  -EXT  ( addr1 u1 -- addr2 u2 )  2dup filetype? -

  hdr  1,'-EXT'
dext:
  call  do_colon
  dw  tdup,ftype
  dw  subb
  dw  exit

;  SETFCB  ( addr u fcb-addr -- user# )

  hdr  1,'SETFCB'
sfcb:
  call  gusr    ; current user
  ld  (sfcb10+1),a
  call  gdrv    ; current drive
  inc  a
  pop  de
  ld  (de),a
  ld  (sfcb5+1),a
  ld  l,c
  ld  h,b
  pop  bc
  ex  (sp),hl
  ex  de,hl
  jp  sfcb2

sfcb1:
  inc  de
  dec  c
sfcb2:
  call  sfcb12    ; skip blanks
  cp  ' '
  jp  z,sfcb1

  push  de
  push  bc
  cp  '9'+1    ; user number
  jp  c,sfcb3
  sub  'A'-1    ; drive A-P
  jp  c,sfcb6
  cp  16+1
  jp  nc,sfcb6
  ld  (sfcb5+1),a
  call  sfcb11
  cp  ':'
  jp  z,sfcb5

sfcb3:
  ld  b,0
sfcb4:
  sub  '0'
  jp  c,sfcb6
  cp  9+1
  jp  nc,sfcb6
  push  bc
  ld  c,a
  ld  a,b
  add  a,a
  add  a,a
  add  a,b
  add  a,a
  add  a,c
  pop  bc
  ld  b,a
  call  sfcb11
  cp  ':'
  jp  nz,sfcb4

  ld  a,b
  cp  31+1    ; user 0-31
  jp  nc,sfcb6
  ld  (sfcb10+1),a

sfcb5:
  ld  (hl),0    ; modified
  pop  af
  pop  af
  call  sfcb11
  jp  sfcb7

sfcb6:
  pop  bc    ; not du:
  pop  de
sfcb7:
  ld  b,8
  call  sfcb15

  cp  '.'
  jp  z,sfcb8
  ld  c,1
sfcb8:
  inc  de
  dec  c

  ld  b,3
  call  sfcb15

  ld  b,21    ; clear EX..CR fields
sfcb9:
  inc  hl
  ld  (hl),0
  dec  b
  jp  nz,sfcb9

  pop  bc
sfcb10:
  ld  a,0    ; modified
  jp  push_a

sfcb11:
  inc  de    ; get next
  dec  c
sfcb12:
  inc  c    ; get char
  dec  c
  ld  a,c
  ret  z
  ld  a,(de)
  call  uppercase_a
  and  a
  ret

sfcb13:
  call  sfcb12    ; test delimiter
  cp  ' '+1
  jp  c,sfcb14
  cp  ','
  ret  z
  cp  '_'
;  ret  z
  jp  nc,sfcb14
  cp  '.'
  ret  z
  cp  ':'
  ret  c
  cp  '>'
  ret  nc
sfcb14:
  cp  a
  ret

sfcb15:
  call  sfcb13    ; fill field
  jp  z,sfcb19
  inc  hl
  cp  '*'
  jp  nz,sfcb16
  ld  (hl),'?'
  jp  sfcb17

sfcb16:
  ld  (hl),a
  inc  de
  dec  c
sfcb17:
  dec  b
  jp  nz,sfcb15

sfcb18:
  call  sfcb13    ; scan delimiter
  ret  z
  inc  de
  dec  c
  jp  sfcb18

sfcb19:
  inc  hl
  ld  (hl),' '
  dec  b
  jp  nz,sfcb19
  ret

oldusr:
  db  255    ; 255 = ignore

;  GETUSR  ( -- u )  get user

  hdr  1,'GETUSR'
getusr:
  call  gusr
  jp  push_a

;  SETUSR  ( u -- )  set user

  hdr  1,'SETUSR'
setusr:
  call  gusr
  ld  (oldusr),a  ; save current user
  pop  hl
  ld  a,l
setusr1:cp  255
  call  nz,susr
  jp next

;  RSTUSR  ( -- )    restore user

  hdr  1,'RSTUSR'
rstusr:
  ld  a,(oldusr)
  jp  setusr1

;  REC@  ( addr -- +d )  dup >r @ r> 2+ c@ 7 0 do d2* loop

  hdr  1,'REC@'
rrat:
  pop  hl
  inc  hl
  inc  hl
  xor  a
  ld  a,(hl)
  rra
  ld  d,a
  dec  hl
  ld  a,(hl)
  rra
  ld  e,a
  dec  hl
  ld  a,(hl)
  rra
  ld  h,a
  ld  a,0
  rra
  ld  l,a
  ex  de,hl
  push de
  jp next

;  REC!  ( +d addr -- )  >r 7 0 do d2/ loop r@ 2+ c! r> !

  hdr  1,'REC!'
rrsto:
  pop  de
  ld  l,c
  ld  h,b
  pop  bc
  ex  (sp),hl
  ex  de,hl
  ld  a,e
  rla
  ld  a,d
  rla
  ld  (hl),a
  inc  hl
  ld  a,c
  rla
  ld  (hl),a
  inc  hl
  ld  a,b
  rla
  ld  (hl),a
  pop  bc
  jp  next

;  >FNAME  ( addr1 u -- addr2 )  (filename_size-1) min zbuf @ packed 0 affix
;          zbuf 2@ swap zbuf 2!

  hdr  1,'>FNAME'
tfnam:
  call  do_colon
  dw  clit
  db  filename_size-1
  dw  min
  dw  zbuf,fetch
  dw  packd
  dw  zero,affix  ; trailing null
  dw  zbuf,tat
  dw  swap
  dw  zbuf,two_store
  dw  exit

;  fh  ( -- addr )

  hdr  x,'FH'
fh:
  call  do_value    ; current file handle
fh1:
  dw  0

;  /fh  ( -- )    #fcb (file_handle_size) * hbuf over - swap erase

  hdr  x,'/FH'
zfh:
  ld  hl,(nfcb1)
  ld  de,file_handle_size
  call  umstrr
  ld  hl,(hbuf1)
  call  ssub
  push  hl
  push  de
  jp  erase

;  use  ( -- addr )  fh (file_handle_size) negate * hbuf +

  hdr  x,'USE'
use:
  ld  hl,(fh1)
  ld  de,-file_handle_size
  call  umstrr
  ld  hl,(hbuf1)
  add  hl,de
  push hl
  jp next

;  uid  ( -- addr )  use 1+

  hdr  x,'UID'
uid:
  call  do_colon    ; user number
  dw  use,onep
  dw  exit

;  fcb  ( -- a )    use 6 +

  hdr  x,'FCB'
fcb:
  call  do_colon    ; FCB address
  dw  use
  dw  clit
  db  6
  dw  plus
  dw  exit

;  rwp@  ( -- ud )    use 2+ 2@

  hdr  x,'RWP@'
rwpat:
  call  do_colon
  dw  use,twop
  dw  tat
  dw  exit

;  rwp!  ( ud -- )    use 2+ 2! ;

  hdr  x,'RWP!'
rwpst:
  call  do_colon
  dw  use,twop
  dw  two_store
  dw  exit

;  >IOR  ( err# -- ior )  dup if $fe00 or then

  hdr  1,'>IOR'
ior:
  pop  hl
  ld  a,h
  or  l
  jp  z,ior1
  ld  h,0xfe
ior1:
  push hl
  jp next

;  ?ior  ( flag err# -- ior )  and ior ;

  hdr  x,'?IOR'
qior:
  call  do_colon
  dw  and_
  dw  ior
  dw  exit

;  getfh  ( -- fid | 0 )  #fcb 1+ begin 1- dup while dup to fh
;        use c@ 0= until then

  hdr  x,'GETFH'
gtfh:
  call  do_colon    ; get free handle, 0 if none
  dw  nfcb
  dw  onep
gtfh1:
  dw  onem
  dw  dup
  dw  zbran,gtfh2
  dw  dup
  dw  pto,fh
  dw  use,c_fetch
  dw  zero_equals
  dw  zbran,gtfh1
gtfh2:
  dw  exit

;  setfh  ( fid mask -- 0 | err )  swap dup 1- 0 #fcb within if to fh
;          use c@ and 0= 5 and exit then 2drop
;          6

  hdr  x,'SETFH'
stfh:
  call  do_colon    ; select/check handle
  dw  swap    ; mode mask: 1=read 2=write 3=r/w
  dw  dup,onem
  dw  zero
  dw  nfcb
  dw  within
  dw  zbran,stfh1
  dw  pto,fh
  dw  use,c_fetch
  dw  and_,zero_equals
  dw  clit
  db  5
  dw  and_
  dw  exit
stfh1:
  dw  two_drop
  dw  clit
  db  6
  dw  exit

;  FILE-POSITION  ( fideid -- ud ior )  3 setfh rwp@ rot ior

  hdr  1,'FILE-POSITION'
fpos:
  call  do_colon
  dw  three,stfh
  dw  rwpat
  dw  rot
  dw  ior
  dw  exit

;  REPOSITION-FILE  ( ud fid -- ior )  3 setfh dup >r if 2drop else
;              rwp! then r> ior

  hdr  1,'REPOSITION-FILE'
reposf:
  call  do_colon
  dw  three,stfh
  dw  dup,to_r
  dw  zbran,reposf1
  dw  two_drop
  dw  branch,reposf2
reposf1:dw  rwpst
reposf2:dw  from_r
  dw  ior
  dw  exit

;  xf5  ( -- )    $80 fcb 5 + ctoggle

  hdr  x,'XF5'
xff:
  call  do_colon
  dw  clit
  db  0x80
  dw  fcb
  dw  clit
  db  5
  dw  plus
  dw  ctog
  dw  exit

;  FILE-SIZE  ( fid -- ud ior )  3 setfh dup 0= if uid c@ setusr
;          xf5 fcb 16 bdos drop xf5 fcb 35
;          bdos drop rstusr then fcb 33 +
;          rec@ rot ior

  hdr  1,'FILE-SIZE'
fsiz:
  call  do_colon
  dw  three,stfh
  dw  dup,zero_equals
  dw  zbran,fsiz1
  dw  uid,c_fetch
  dw  setusr
  dw  xff
  dw  fcb
  dw  clit
  db  16
  dw  bdos,drop
  dw  xff
  dw  fcb
  dw  clit
  db  35
  dw  bdos,drop
  dw  rstusr
fsiz1:
  dw  fcb
  dw  clit
  db  33
  dw  plus
  dw  rrat
  dw  rot
  dw  ior
  dw  exit

;  CLOSE-FILE  ( fid -- ior )  3 setfh dup if ior exit then use c!
;          uid c@ setusr fcb 16 bdos rstusr 255
;          = 2 ?ior

  hdr  1,'CLOSE-FILE'
closf:
  call  do_colon
  dw  three,stfh
  dw  dup
  dw  zbran,closf1
  dw  ior
  dw  exit
closf1:
  dw  use,cstor
  dw  uid,c_fetch
  dw  setusr
  dw  fcb
  dw  clit
  db  16
closf2:
  dw  bdos
  dw  rstusr
  dw  clit
  db  255
  dw  equal
  dw  two
  dw  qior
  dw  exit

;  R/O  ( -- fam )      aka 0 r/o

  hdr  1,'R/O',,,zero
rso  equ  zero

;  W/O  ( -- fam )      aka 1 w/o

  hdr  1,'W/O',,,one
wso  equ  one

;  R/W  ( -- fam )      aka 2 r/w

  hdr  1,'R/W',,,two
rsw  equ  two

;  BIN  ( fam1 -- fam2 )    aka noop bin immediate

  hdr  1,'BIN',1,,noop
binn  equ  next

;  open1  ( addr u fam -- | x ior )
;          getfh 0= if 2drop 4 ior unnest exit
;          then 1+ use c! >fname count fcb
;          setfcb dup uid c! setusr 0 0 rwp!

  hdr  x,'OPEN1'
open1:
  call  do_colon
  dw  gtfh,zero_equals
  dw  zbran,open11
  dw  two_drop
  dw  clit
  db  4
  dw  ior
   if  debug
  dw  paren_dot_quote
  dcs  'UNNEST_OPEN1'
   endif
  dw  unnest
  dw  exit
open11:
  dw  onep
  dw  use,cstor
  dw  tfnam,count
  dw  fcb
  dw  sfcb
  dw  dup
  dw  uid,cstor
  dw  setusr
  dw  zero,zero
  dw  rwpst
  dw  exit

;  open2  ( fn# -- fid flag )  fh fcb rot bdos 255 = rstusr

  hdr  x,'OPEN2'
open2:
  call  do_colon
  dw  fh
  dw  fcb
  dw  rot
  dw  bdos
  dw  clit
  db  255
  dw  equal
  dw  rstusr
  dw  exit

;  open3  ( flag err -- | ior )  ?ior ?dup if 0 use c! unnest then

  hdr  x,'OPEN3'
open3:
  call  do_colon
  dw  qior
  dw  qdup
  dw  zbran,open31
  dw  zero
  dw  use,cstor
   if  debug
  dw  paren_dot_quote
  dcs  'UNNEST_OPEN3'
   endif
  dw  unnest
open31:
  dw  exit

;  OPEN-FILE  ( addr u fam -- fid ior )
;          open1 15 open2 2 open3 fcb 9 + c@
;          6 rshift use c@ and 1 > 5 open3 0

  hdr  1,'OPEN-FILE'
openf:
  call  do_colon
  dw  open1
  dw  clit
  db  15
  dw  open2
  dw  two,open3
  dw  fcb    ; test if file R/O and mode=write
  dw  clit
  db  9
  dw  plus,c_fetch
  dw  clit
  db  6
  dw  rsh
  dw  use,c_fetch,and_
  dw  one,great
  dw  clit
  db  5
  dw  open3,zero
  dw  exit

;  CREATE-FILE  ( addr u fam -- fid ior )
;          open1 fcb 19 bdos drop 22 open2
;          5 open3 0

  hdr  1,'CREATE-FILE'
creatf:
  call  do_colon
  dw  open1
  dw  fcb
  dw  clit
  db  19
  dw  bdos,drop
  dw  clit
  db  22
  dw  open2
  dw  clit
  db  5
  dw  open3
  dw  zero
  dw  exit

;  >FCB  ( addr u -- fcb usr )  2dup >fname 18 + -rot 2 pick setfcb

  hdr  1,'>FCB'
tfcb:
  call  do_colon
  dw  tdup,tfnam
  dw  clit
  db  18
  dw  plus
  dw  drot
  dw  two,pick
  dw  sfcb
  dw  exit

;  DELETE-FILE  ( addr u -- ior )  >fcb setusr 19 bdos rstusr 255 = 2
;          ?ior

  hdr  1,'DELETE-FILE'
delf:
  call  do_colon
  dw  tfcb,setusr
  dw  clit
  db  19
  dw  branch,closf2

;  RENAME-FILE  ( addr1 u1 addr2 u2 -- ior )
;          2swap >fcb setusr >r >fcb drop r@ c@
;          over c! dup 15 bdos 255 = if r@ 16 +
;          16 cmove r> 23 bdos 255 = 2 ?ior else
;          16 bdos r> 2drop 5 ior then rstusr

  hdr  1,'RENAME-FILE'
renf:
  call  do_colon
  dw  tswap
  dw  tfcb,setusr,to_r
  dw  tfcb,drop
  dw  r_fetch,c_fetch
  dw  over,cstor
  dw  dup
  dw  clit
  db  15
  dw  bdos
  dw  clit
  db  255
  dw  equal
  dw  zbran,renf1
  dw  r_fetch
  dw  clit
  db  16
  dw  plus
  dw  clit
  db  16
  dw  cmove,from_r
  dw  clit
  db  23
  dw  branch,closf2
renf1:
  dw  clit
  db  16
  dw  bdos
  dw  from_r,two_drop
  dw  clit
  db  5
  dw  ior
  dw  rstusr
  dw  exit

;  offs  ( -- x )      0 value offs

  hdr  x,'OFFS'
offs:
  call  do_value
  dw  0

;  setsiz  ( -- size )    rwp@ over $7F and to offs fcb 33 +
;          rec! (recsiz) offs -

  hdr  x,'SETSIZ'
setsiz:
  call  do_colon
  dw  rwpat,over
  dw  clit
  db  0x7f
  dw  and_
  dw  pto,offs
  dw  fcb
  dw  clit
  db  33
  dw  plus,rrsto
  dw  clit
  db  recsiz
  dw  offs,subb
  dw  exit

;  SETDMA  ( a -- )    26 bdos drop

  hdr  1,'SETDMA'
setdma:
  pop  de
  ld  a,26
  call  bdoss
  jp next

;  ranrw  ( a size fn# -- a size | a u' )
;          fcb swap bdos if drop unnest r> then

  hdr  x,'RANRW'
ranrw:
  call  do_colon
  dw  fcb,swap,bdos
  dw  zbran,ranrw1
  dw  drop
   if  debug
  dw  paren_dot_quote
  dcs  'UNNEST_RW'
   endif
  dw  unnest
  dw  from_r
ranrw1:
  dw  exit

;  rdini  ( a u fid mask -- u a u | u ior )
;          setfh ?dup if nip ior unnest exit
;          then tuck

  hdr  x,'RDINI'
rdini:
  call  do_colon
  dw  stfh,qdup
  dw  zbran,rdini1
  dw  nip
  dw  ior
   if  debug
  dw  paren_dot_quote
  dcs  'UNNEST_RDINI'
   endif
  dw  unnest
  dw  exit
rdini1:
  dw  tuck
  dw  exit

;  fread  ( a u1 -- a u2 )    begin dup while >r setsiz r@ umin
;          dup (recsiz) = if over setdma 33
;          ranrw else hbuf setdma 33 ranrw 2dup
;          hbuf offs + -rot cmove then dup >r +
;          rwp@ r@ m+ rwp! 2r> - repeat

  hdr  x,'FREAD'
fread:
  call  do_colon
fread1:
  dw  dup
  dw  zbran,fread4
  dw  to_r
  dw  setsiz
  dw  r_fetch,umin
  dw  dup
  dw  clit
  db  recsiz
  dw  equal
  dw  zbran,fread2
  dw  over,setdma
  dw  clit
  db  33
  dw  ranrw
  dw  branch,fread3
fread2:
  dw  hbuf,setdma
  dw  clit
  db  33
  dw  ranrw
  dw  tdup,hbuf
  dw  offs,plus
  dw  drot,cmove
fread3:
  dw  dup,to_r
  dw  plus
  dw  rwpat
  dw  r_fetch,mplus
  dw  rwpst
  dw  two_from_r,subb
  dw  branch,fread1
fread4:
  dw  exit

;  wrini  ( a u fid mask -- a u | ior )
;          setfh ?dup if nip nip ior unnest          then

  hdr  x,'WRINI'
wrini:
  call  do_colon
  dw  stfh,qdup
  dw  zbran,wrini1
  dw  nip,nip
  dw  ior
   if  debug
  dw  paren_dot_quote
  dcs  'UNNEST_WRINI'
   endif
  dw  unnest
wrini1:
  dw  exit

;  fwrite  ( a u1 -- a u2 )  begin dup while >r setsiz r@ umin dup
;          (recsiz) = if over setdma else hbuf
;          (recsiz) $1A fill hbuf setdma fcb 33
;          bdos drop 2dup hbuf offs + swap cmove
;          then 34 ranrw dup >r + rwp@ r@ m+
;          rwp! 2r> - repeat

  hdr  x,'FWRITE'
fwrit:
  ; XXX TODO
  ; XXX TMP -- 2drop
  pop hl
  pop hl
  jp  next
; XXX OLD
;;  call  do_colon
;;fwrit1:
;;  dw  dup
;;  dw  zbran,fwrit4
;;  dw  to_r
;;  dw  setsiz
;;  dw  r_fetch,umin
;;  dw  dup
;;  dw  clit
;;  db  recsiz
;;  dw  equal
;;  dw  zbran,fwrit2
;;  dw  over,setdma
;;  dw  branch,fwrit3
;;fwrit2:
;;  dw  hbuf
;;  dw  clit
;;  db  recsiz
;;  dw  clit
;;  db  ctlz
;;  dw  fill
;;  dw  hbuf,setdma
;;  dw  fcb
;;  dw  clit
;;  db  33
;;  dw  bdos,drop
;;  dw  tdup
;;  dw  hbuf
;;  dw  offs,plus
;;  dw  swap
;;  dw  cmove
;;fwrit3:
;;  dw  clit
;;  db  34
;;  dw  ranrw
;;  dw  dup,to_r
;;  dw  plus
;;  dw  rwpat
;;  dw  r_fetch,mplus
;;  dw  rwpst
;;  dw  two_from_r,subb
;;  dw  branch,fwrit1
;;fwrit4:
;;  dw  exit

;  READ-FILE  ( addr u1 fid -- u2 ior )  1 rdini uid c@ setusr fread
;          rstusr nip - 0

  hdr  1,'READ-FILE'
readf:
  call  do_colon
  dw  one,rdini
  dw  uid,c_fetch
  dw  setusr
  dw  fread
  dw  rstusr
  dw  nip
  dw  subb
  dw  zero
  dw  exit

;  WRITE-FILE  ( addr u fid -- ior )  2 wrini uid c@ setusr fwrite
;          rstusr nip 0<> 255 ?ior

  hdr  1,'WRITE-FILE'
writf:
  call  do_colon
  dw  two,wrini
  dw  uid,c_fetch
  dw  setusr
  dw  fwrit
  dw  rstusr
  dw  nip
  dw  zero_not_equals
  dw  clit
  db  255
  dw  qior
  dw  exit

;  WRITE-LINE  ( c-addr u fileid -- ior )
;        dup >r write-file ?dup if r> drop exit
;        then (crlf) 2 r> write-file

  hdr  1,'WRITE-LINE'
writl:
  call  do_colon
  dw  dup,to_r
  dw  writf,qdup
  dw  zbran,writl1
  dw  from_r,drop
  dw  exit
writl1:
  dw  lit,crlf
  dw  two
  dw  from_r
  dw  writf
  dw  exit

;  eol?  ( addr -- 2|1|0 )    c@ $0D of 2 exit then $0A of 1 exit
;          then drop 0

  hdr  x,'EOL?'
eolq:
  pop  hl
  ld  a,(hl)
  cp  cr_char
  jp  z,two
  cp  lf_char
  jp  z,one
  jp  zero

;  READ-LINE  ( addr u1 fid -- u2 flag ior )  >r over swap r> read-file
;          ?dup if exit then 2dup over + swap
;          ?do i dup c@ $1A = if rot - fh
;          file-size drop rwp! leave then eol?
;          ?dup if i + >r over + r> swap - dup
;          0<> rwp@ d+ rwp! i swap - -1 0 unloop
;          exit then loop nip dup 0<> 0

  hdr  1,'READ-LINE'
readl:
; XXX TODO
  pop hl
  pop hl
  pop hl
  jp next
; XXX OLD -- DX-Forth 4.00
;;  call  do_colon
;;  dw  to_r,over,swap,from_r
;;  dw  readf,qdup
;;  dw  zbran,readl1
;;  dw  exit
;;readl1:
;;  dw  tdup,over,plus,swap
;;  dw  xqdo,readl5
;;readl2:
;;  dw  ido
;;  dw  dup,c_fetch
;;  dw  clit
;;  db  ctlz
;;  dw  equal
;;  dw  zbran,readl3
;;  dw  rot,subb
;;  dw  fh,fsiz,drop,rwpst
;;  dw  pleav,readl2-cw
;;readl3:
;;  dw  eolq,qdup
;;  dw  zbran,readl4
;;  dw  ido,plus,to_r
;;  dw  over,plus
;;  dw  from_r
;;  dw  swap,subb
;;  dw  dup,zero_not_equals  ; handle buffer > 32K
;;  dw  rwpat,dplus,rwpst
;;  dw  ido,swap,subb
;;  dw  true,zero
;;  dw  unloo,exit
;;readl4:
;;  dw  xloop,readl2
;;readl5:
;;  dw  nip
;;  dw  dup,zero_not_equals,zero
;;  dw  exit

; screen file selector

fdtab:
  gfdb      ; fdb table

;  sfp  ( -- a )

  hdr  x,'SFP',,1
sfp:
  call  do_create
sfp1:
  dw  fdtab    ; current
sfp2:
  dw  fdtab+cw  ; swap-file

;  SWAP-FILE  ( -- )  scr @ scr# ! sfp 2@ swap sfp 2!
;        scr# @ scr ! empty-buffers

  hdr  1,'SWAP-FILE',,1
swapf:
  call  do_colon
  dw  scr,fetch
  dw  snum,store
  dw  sfp,tat
  dw  swap
  dw  sfp,two_store
  dw  snum,fetch
  dw  scr,store
  dw  empty_buffers
  dw  exit

;  FDB  ( -- addr )  (fdtab) (nfd) 0 do dup @ @ 0= if unloop exit
;        then cell+ loop abort" too many files"

  hdr  1,'FDB',,1  ; get a free slot
fdb:
  call  do_colon
  dw  lit,fdtab
  dw  clit
  db  nfd
  dw  zero
  dw  xdo,fdb3
fdb1:
  dw  dup,fetch,fetch
  dw  zero_equals
  dw  zbran,fdb2
  dw  unloo
  dw  exit
fdb2:
  dw  cellp
  dw  xloop,fdb1
fdb3:
  dw  paren_abort_quote
  dcs  'too many files'
  dw  exit

; file descriptor fields
;
;  FD  cell    status 0=closed
;  FID  cell    file handle
;  BLKS  cell    file size (blocks)
;  SCR#  cell    current SCR#
;  FNB  'filename_size' bytes  file name

;  fd  ( -- addr )

  hdr  x,'FD',,1
fd:
  call  do_colon    ; file descriptor field
  dw  sfp,fetch,fetch
  dw  exit

;  fid  ( -- addr )

  hdr  x,'FID',,1
fid:
  ld  e,cw*1    ; file handle field
fid1:
  ld  d,0
  push  de
  call  do_colon
  dw  fd,plus
  dw  exit

;  blks  ( -- addr )

  hdr  x,'BLKS',,1
blks:
  ld  e,cw*2    ; file size field
  jp  fid1

;  scr#  ( -- addr )

  hdr  x,'SCR#',,1
snum:
  ld  e,cw*3    ; current SCR# field
  jp  fid1

;  fnb  ( -- addr )

  hdr  x,'FNB',,1
fnb:
  ld  e,cw*4    ; file name field
  jp  fid1

;  buf  ( -- addr )

  hdr  x,'BUF',,1
buf:
  call  do_constant    ; file buffer address
  dw  sfb

;  blk#  ( -- addr )

  hdr  x,'BLK#',,1
bnum:
  call  do_create    ; block#, update flag
bnum1:
  ds  cw

;  FILE?  ( -- flag )  fd @ 0<>

  hdr  1,'FILE?',,1
fileq:
  call  do_colon
  dw  fd,fetch
  dw  zero_not_equals
  dw  exit

;  LOADFILE  ( -- c-addr u )  fnb count

  hdr  1,'LOADFILE',,1
loadf:
  call  do_colon
  dw  fnb,count
  dw  exit

;  ?open  ( -- )    file? 0= abort" no file open"

  hdr  x,'?OPEN',,1
qopen:
  call  do_colon
  dw  fileq
  dw  zero_equals
  dw  paren_abort_quote
  dcs  'no file open'
  dw  exit

;  #SCREENS  ( -- +n )  ?open blks @

  hdr  1,'#SCREENS',,1
nscr:
  call  do_colon
  dw  qopen
  dw  blks,fetch
  dw  exit

;  EMPTY-BUFFERS  ( -- )  $7fff blk# !

  hdr  1,'EMPTY-BUFFERS',,1
empty_buffers:
  ld  hl,7fffh
  ld  (bnum1),hl
  jp next

;  UPDATE  ( -- )    ?open blk# @ $8000 or blk# !

  hdr  1,'UPDATE',,1
update:
  call  do_colon
  dw  qopen
  dw  bnum,fetch
  dw  lit,8000h
  dw  or_
  dw  bnum,store
  dw  exit

;  blkerr  ( flag -- )  abort" block r/w error"

  hdr  x,'BLKERR',,1
blkerr:
  call  do_colon
  dw  paren_abort_quote
  dcs  'block r/w error'
  dw  exit

;  blk-rw  ( +n mode -- )  >r b/buf um* fid @ reposition-file blkerr
;        buf b/buf fid @ r> if write-file else
;        read-file blkerr b/buf < then blkerr

  hdr  x,'BLK-RW',,1
blkrw:
  call  do_colon
  dw  to_r
  dw  bbuf,umstr
  dw  fid,fetch
  dw  reposf
  dw  blkerr
  dw  buf,bbuf
  dw  fid,fetch
  dw  from_r
  dw  zbran,blkrw1
  dw  writf
  dw  branch,blkrw2
blkrw1:
  dw  readf
  dw  blkerr
  dw  bbuf,less
blkrw2:
  dw  blkerr
  dw  exit

;  ?blk  ( +n -- +n )  dup #screens 0 within
;        abort" block out of range"

  hdr  x,'?BLK',,1
qblk:
  call  do_colon
  dw  dup
  dw  nscr,zero
  dw  within    ; block in range?
  dw  paren_abort_quote
  dcs  'block out of range'
  dw  exit

;  SAVE-BUFFERS  ( -- )  ?open blk# @ 0< if blk# @ $7fff and
;        dup blk# ! ?blk 1 blk-rw then

  hdr  1,'SAVE-BUFFERS',,1
savbuf:
  call  do_colon
  dw  qopen
  dw  bnum,fetch
  dw  zless
  dw  zbran,savbuf1
  dw  bnum,fetch
  dw  lit,7fffh
  dw  and_
  dw  dup
  dw  bnum,store
  dw  qblk    ; block in range?
  dw  one,blkrw
savbuf1:dw  exit

;  FLUSH  ( -- )    save-buffers empty-buffers

  hdr  1,'FLUSH',,1
flush:
  call  do_colon
  dw  savbuf,empty_buffers
  dw  exit

;  BUFFER  ( +n -- addr )  save-buffers ?blk blk# ! buf

  hdr  1,'BUFFER',,1
buffer:
  call  do_colon
  dw  savbuf
  dw  qblk
  dw  bnum,store
  dw  buf
  dw  exit

;  BLOCK  ( +n -- addr )  ?open blk# @ $7fff and over - if dup
;        buffer drop 0 blk-rw else drop then buf

  hdr  1,'BLOCK',,1
block:
  call  do_colon
  dw  qopen
  dw  bnum,fetch
  dw  lit,7fffh
  dw  and_,over,subb
  dw  zbran,block1
  dw  dup,buffer,drop
  dw  zero,blkrw
  dw  branch,block2
block1:
  dw  drop
block2:
  dw  buf
  dw  exit

;  -->  ( -- )    blk @ 0= abort" loading only" (refill) drop
;        ;immediate

  hdr  1,'-->',1,1
arrow:
  call  do_colon
  dw  blk,fetch
  dw  zero_equals
  dw  paren_abort_quote
  dcs  'loading only'
  dw  prefil,drop
  dw  exit

;  (thru)  ( +n1 +n2 -- )  1+ swap ?do i block b/buf i (eval) loop

  hdr  x,'(THRU)',,1
pthru:
  call  do_colon
  dw  onep,swap
  dw  xqdo,pthru2
pthru1:
  dw  ido,block
  dw  bbuf
  dw  ido,peval
  dw  xloop,pthru1
pthru2:
  dw  exit

;  THRU  ( +n1 +n2 -- )  (thru) ?block

  hdr  1,'THRU',,1
thru:
  call  do_colon
  dw  pthru
  dw  qblock
  dw  exit

;  LOAD  ( +n -- )   dup thru

  hdr  1,'LOAD',,1
load:
  pop  hl
  push  hl
  push  hl
  jp  thru

;  fnbuf  ( -- addr )

  hdr  x,'FNBUF',,1
fnbuf:
  call  do_create    ; current file handle
  ds  filename_size

;  (fbk)  ( +n -- )  #screens 2dup u< if drop dup loadfile -ext
;        s" $$$" +ext fnbuf place fnbuf count w/o
;        create-file throw over 0 ?do dup i block
;        b/buf rot write-file throw loop close-file
;        throw fid @ close-file throw loadfile
;        delete-file throw fnbuf count loadfile
;        rename-file throw loadfile r/w open-file
;        throw fid ! then over blks ! ?do i buffer
;        b/buf blank update save-buffers loop

  hdr  x,'(FBK)',,1
pfbk:
  call  do_colon
  dw  nscr    ; tests if file open
  dw  tdup,uless
  dw  zbran,pfbk3
  dw  drop,dup
  dw  loadf,dext
  dw  psqot
  dcs  '$$$'
  dw  pext
  dw  fnbuf,place
  dw  fnbuf,count
  dw  wso,creatf,throw
  dw  over,zero
  dw  xqdo,pfbk2
pfbk1:
  dw  dup
  dw  ido,block
  dw  bbuf
  dw  rot,writf,throw
  dw  xloop,pfbk1
pfbk2:
  dw  closf,throw
  dw  fid,fetch
  dw  closf,throw
  dw  loadf,delf,throw
  dw  fnbuf,count
  dw  loadf,renf,throw
  dw  loadf
  dw  rsw,openf,throw
  dw  fid,store
pfbk3:
  dw  over
  dw  blks,store  ; update max block
  dw  xqdo,pfbk5
pfbk4:
  dw  ido,buffer
  dw  bbuf,blank
  dw  update,savbuf
  dw  xloop,pfbk4
pfbk5:
  dw  exit

;  FILEBLOCKS  ( +n -- )  ['] (fbk) catch abort" can't resize file"

  hdr  1,'FILEBLOCKS',,1
fbloc:
  call  do_colon
  dw  lit,pfbk
  dw  catch
  dw  paren_abort_quote
  dcs  "can't resize file"
  dw  exit

;  CLOSE  ( -- )    file? if flush fid @ close-file drop
;        fd off then empty-buffers
;
; NOTE: errors are NOT reported with this function

  hdr  1,'CLOSE',,1  ; close current file
close:
  call  do_colon
  dw  fileq
  dw  zbran,close1
  dw  flush
  dw  fid,fetch
  dw  closf,drop
  dw  fd,off
close1:
  dw  empty_buffers
  dw  exit

;  CLOSE-ALL  ( -- )  close (fdtab) nfd 0 do dup sfp ! close
;        cell+ loop drop

  hdr  1,'CLOSE-ALL',,1
closa:
  call  do_colon
  dw  close    ; ensure buffer flushed
  dw  lit,fdtab
  dw  clit
  db  nfd
  dw  zero
  dw  xdo,closa2
closa1:
  dw  dup
  dw  sfp,store
  dw  close
  dw  cellp
  dw  xloop,closa1
closa2:
  dw  drop
  dw  exit

;  lastfile  ( -- c-addr u )  zbuf cell+ @ count

  hdr  x,'LASTFILE',,1
lastf:
  call  do_colon    ; last named file used by open-file etc
  dw  zbuf,cellp
  dw  fetch,count
  dw  exit

;  .lastfile  ( -- )  beep cr lastfile type space

  hdr  x,'.LASTFILE',,1
dotlf:
  call  do_colon
  dw  beep,crr
  dw  lastf,typee
  dw  space
  dw  exit

;  ?create  ( c-addr u -- fileid )
;        r/o open-file 0= tuck if close-file then
;        drop if .lastfile ." exists - delete it? "
;        y/n 0= if abort then then lastfile r/w
;        create-file abort" can't create file"

  hdr  x,'?CREATE',,1
qcreat:
  call  do_colon
  dw  rso,openf  ; test if file exists
  dw  zero_equals,tuck
  dw  zbran,qcreat1
  dw  closf
qcreat1:dw  drop
  dw  zbran,qcreat2
  dw  dotlf
  dw  paren_dot_quote
  dcs  'exists - delete it? '
  dw  yn,zero_equals
  dw  zbran,qcreat2
  dw  abort
qcreat2:dw  lastf,rsw,creatf
  dw  paren_abort_quote
  dcs  "can't create file"
  dw  exit

;  init-scr  ( fileid ior -- )  if drop exit then fdb sfp ! fd on
;          dup fid ! file-size drop b/buf
;          um/mod nip blks ! lastfile fnb
;          place loadfile upper empty-buffers

  hdr  x,'INIT-SCR',,1
iniscr:
  call  do_colon    ; init screenfile
  dw  zbran,iniscr1
  dw  drop
  dw  exit
iniscr1:dw  fdb,sfp,store
  dw  fd,on
  dw  dup,fid,store
  dw  fsiz,drop
  dw  bbuf,umslm,nip  ; overflow stores $FFFF
  dw  blks,store
  dw  lastf,fnb,place
  dw  loadf,upper
  dw  empty_buffers
  dw  exit

;  OPEN  ( c-addr u fam -- ior )  fdb drop >r s" scr" +ext r>
;          open-file tuck init-scr

  hdr  1,'OPEN',,1  ; open a screen file
open:
  call  do_colon
  dw  fdb,drop  ; free slot?
  dw  to_r
  dw  psqot
  dcs  'scr'
  dw  pext
  dw  from_r,openf
  dw  tuck
  dw  iniscr
  dw  exit

;  (open)  ( c-addr u -- )    r/w open abort" can't open file"

  hdr  x,'(OPEN)',,1
popen:
  call  do_colon
  dw  rsw,open
  dw  paren_abort_quote
  dcs  "can't open file"
  dw  exit

;  GETFILENAME  ( -- c-addr u )  token dup 0= abort" specify filename"

  hdr  1,'GETFILENAME',,1
getfilename:
  call  do_colon
  dw  token
  dw  dup,zero_equals
  dw  paren_abort_quote
  dcs  'specify filename'
  dw  exit

;  USING  ( "filename[.SCR]" -- )  close getfilename r/w open ?dup if
;          .lastfile -507 = if ." access denied"
;          0 else ." not found - create it? "
;          y/n then 0= if abort then lastfile
;          ?create 0 init-scr then 0 0 scr 2!

  hdr  1,'USING',,1  ; open/make a screen file
using:
  call  do_colon
  dw  close
  dw  getfilename
  dw  rsw,open,qdup
  dw  zbran,using4
  dw  dotlf
  dw  lit,-507
  dw  equal
  dw  zbran,using1
  dw  paren_dot_quote
  dcs  'access denied'
  dw  zero
  dw  branch,using2
using1:
  dw  paren_dot_quote
  dcs  'not found - create it? '
  dw  yn
using2:
  dw  zero_equals
  dw  zbran,using3
  dw  abort
using3:
  dw  lastf,qcreat
  dw  zero,iniscr
using4:
  dw  zero,zero  ; reset SCR
  dw  scr,two_store
  dw  exit

;  LOADED  ( +n1 +n2 c-addr u -- )  sfp @ >r (open) (thru) close r>
;          sfp ! ?block

  hdr  1,'LOADED',,1
loaded:
  call  do_colon
  dw  sfp,fetch
  dw  to_r
  dw  popen
  dw  pthru
  dw  close
  dw  from_r
  dw  sfp,store
  dw  qblock
  dw  exit

;  FLOAD  ( +n "filename[.SCR]" -- )  dup getfilename loaded

  hdr  1,'FLOAD',,1
fload:
  call  do_colon
  dw  dup
  dw  getfilename
  dw  loaded
  dw  exit

;  SAVE  ( "filename[.COM]" -- )
;        0 0 freeze getfilename s" com" +ext
;        ?create >r over swap boot 2! (cold6) (zb1)
;        dup (zbsiz*2) erase (cold7-cold6) cmove
;        $100 dp @ over - r@ write-file boot cell+
;        off ?dup 0= if (hm) dph @ over - rot 0=
;        and r@ write-file then r> close-file or
;        abort" can't save file"

  hdr  1,'SAVE',,1
save:
  call  do_colon
  ; XXX TODO
  ; XXX OLD
;;  dw  zero,zero
;;save1:
;;  dw  freez
;;  dw  getfilename
;;  dw  psqot
;;  dcs  'com'
;;  dw  pext
;;  dw  qcreat
;;  dw  to_r    ; fid
;;  dw  over,swap  ; set boot flags
;;  dw  boot,two_store
;;  dw  lit,cold6  ; insert compiler logo
;;  dw  lit,zb1
;;  dw  dup
;;  dw  clit
;;  db  zbsiz*2
;;  dw  erase
;;  dw  clit
;;  db  cold7-cold6
;;  dw  cmove
;;  dw  lit,0x0100
;;  dw  dpp,fetch
;;  dw  over,subb
;;  dw  r_fetch,writf  ; save application
;;  dw  boot,cellp,off  ; reset forth flag
;;  dw  qdup,zero_equals
;;  dw  zbran,save2
;;  dw  lit,hm
;;  dw  dph,fetch
;;  dw  over,subb
;;  dw  rot,zero_equals,and_  ; system size
;;  dw  r_fetch,writf  ; save system
;;save2:
;;  dw  from_r,closf,or_
;;  dw  paren_abort_quote
;;  dcs  "can't save file"
  dw  exit

;  TURNKEY  ( "bootword" "filename[.COM]" -- )

  hdr  1,'TURNKEY',,1
turnkey:
  call  do_colon
  ; XXX TODO
  dw exit
  ; XXX OLD
;;  dw  true
;;turnkey1:
;;  dw  tick
;;  dw  branch,save1

;  TURNKEY-SYSTEM  ( "bootword" "filename[.COM]" -- )

  hdr  1,'TURNKEY-SYSTEM',,1
turnkey_system:
  call  do_colon
  call  do_colon
  ; XXX TODO
  dw exit
  ; XXX OLD
;;  dw  zero
;;  dw  branch,turnkey1

; }}} **********************************************************
; Graphics {{{

; BORDER  ( n -- )

  hdr 1,'BORDER'
border:
  ; XXX TODO -- Benschop's Forth-83 does this:
  ; DUP DUP 4 < 7 AND SWAP 8 * + 23624 C! 254 P!
  pop hl
  ld a,l
  and %111
  ld (sys_bordcr),a
  out (254),a
  jp next

; PAPER  ( n -- )
  hdr 1,'PAPER'
paper:
  ; XXX TODO
  jp next

; INK  ( n -- )
  hdr 1,'INK'
ink:
  ; XXX TODO
  jp next

; GOVER ( n -- )
  hdr 1,'GOVER'
gover:
  ; XXX TODO -- Benschop's Forth-83 does this:
  ; 23697 DUP C@ 252 AND ROT 3 * OR SWAP C!
  jp next

; INVERSE  ( n -- )
  hdr 1,'INVERSE'
inverse:
  ; XXX TODO -- Benschop's Forth-83 does this:
  ; 23697 DUP C@ 243 AND ROT 12 * OR SWAP C!
  jp next

; NORMAL  ( -- )
  hdr 1,'NORMAL'
normal:
  ; XXX TODO -- Benschop's Forth-83 does this:
  ; 0 INK 7 PAPER 0 FLASH 0 BRIGHT 7 BORDER 0 GOVER 0 INV
  jp next

; }}} **********************************************************
; Floating point functions {{{

  if float

;  -FP  ( -- addr )    marker -FP

  hdr  1,'-FP',,1
dfp:
  call  next

;  FLOAT+ ( f-addr1 -- f-addr2 )  4 +

  hdr  1,'FLOAT+'
floatp:
  pop  hl
  ld  de,fw
  add  hl,de
  push hl
  jp next

;  FLOATS ( n1 -- n2 )    4 *

  hdr  1,'FLOATS'
floats:
  pop  hl
  add  hl,hl
  add  hl,hl
  push hl
  jp next

;  FALIGN  ( -- )      aka noop falign immediate

  hdr  1,'FALIGN',1,,noop
falign  equ  next

;  FALIGNED ( addr -- f-addr )  aka noop faligned immediate

  hdr  1,'FALIGNED',1,,noop
falignd  equ  next

;  F,  (F: r -- ) or ( r -- )  , ,

  hdr  1,'F,',,1
fcomm:
  call  do_colon
  dw  comma,comma
  dw  exit

;  FLITERAL  ( -- r )
  ; aka fliteral 2literal immediate

  hdr  1,'FLITERAL',1,,tlite
flite  equ  tlite

flit  equ  tlit

;  FCONSTANT  ( -- r )
  ; aka 2constant fconstant

  hdr  1,'FCONSTANT',,,tcon
fcon  equ  tcon

dofcon  equ  tat

;  FVARIABLE  ( -- f-addr )
;  aka 2variable fvariable

  hdr  1,'FVARIABLE',,,tvar
fvar  equ  tvar

;  FDEPTH   ( -- +n )  depth 2/

  hdr  1,'FDEPTH'
fdepth:
  call  do_colon
  dw  depth
  dw  twodiv
  dw  exit

;  FDROP  ( r -- )

  hdr  1,'FDROP',,,two_drop  ; aka 2drop fdrop
fdrop  equ  two_drop

;  FDUP  ( r -- r r )

  hdr  1,'FDUP',,,tdup    ; aka 2dup fdup
fdup  equ  tdup

;  FSWAP  ( r1 r2 -- r2 r1 )

  hdr  1,'FSWAP',,,tswap  ; aka 2swap fswap
fswap  equ  tswap

;  FOVER  ( r1 r2 -- r1 r2 r1 )

  hdr  1,'FOVER',,,tover  ; aka 2over fover
fover  equ  tover

;  FROT  ( r1 r2 r3 -- r2 r3 r1 )

  hdr  1,'FROT',,,trot    ; aka 2rot frot
frot  equ  trot

;  F@  ( f-addr -- r )

  hdr  1,'F@',,,tat    ; aka 2@ f@
f_fetch  equ  tat

;  F!  ( r f-addr -- )

  hdr  1,'F!',,,two_store    ; aka 2! f!
f_store  equ  two_store

;  FPICK  ( +n -- r )  floats sp@ cell+ + f@

  hdr  1,'FPICK'
fpick:
  call  do_colon
  dw  floats
;   if  fstack
;  dw  fsp,fetch
;   else
  dw  sp_fetch,cellp
;   endif
  dw  plus,f_fetch
  dw  exit

; floating point accumulator

acce:
  ds  5    ; accumulator exponent
accs  equ  acce+1    ; accumulator sign
acc1  equ  accs+1    ; accumulator 1st fraction
acc2  equ  acc1+1    ; accumulator 2nd fraction
acc3  equ  acc2+1    ; accumulator 3rd fraction

sf:
  ds  1    ; subtraction flag

f1:
  ds  fw    ; temp float storage
f2:
  ds  fw    ;

ften:
  call  dofcon    ; fconstant
fp10:
  db  0x84,0x20,0,0  ; 10.0

; save/load temp fp registers

savf1:
  ld  hl,f1    ; save regs to f1
  jp  str

savf2:
  ld  hl,f2    ; save regs to f2
  jp  str

lodf1:
  ld  hl,f1    ; load accum/regs from f1
  jp  lod

lodf2:
  ld  hl,f2    ; load accum/regs from f2
  jp  lod

; pop float from stack to accum, saving bc

ldop:
  pop  de
  pop  hl
  ld  (f1),hl
  pop  hl
  ld  (f1+2),hl
  push  bc
  push  de
  ld  hl,f1
  jp  lod

; pop 2 float from stack to hl (f2) and accum, saving bc

ld2op:
  pop  hl
  ld  (ld2op1),hl
  pop  hl
  ld  (f2),hl
  pop  hl
  ld  (f2+2),hl
  call  ldop
  ld  hl,(ld2op1)
  push  hl
  ld  hl,f2
  ret

ld2op1:
  ds  2

; push float registers to stack, restore bc and exit

svop:
  ld  l,a
  ld  h,b
  ld  e,c
  pop  bc
  push de
  jp next

; str  store registers to accum

strr:
  ld  hl,acce
  ld  (hl),e
  inc  hl

; entry - hl=adr, a=exp, bcd (packed)
; exit  - none

str:
  ld  (hl),a
str1:
  inc  hl    ; entry when hl=accs
  ld  (hl),b
  inc  hl
  ld  (hl),c
  inc  hl
  ld  (hl),d
  ret

; zero - set accum and regs to zero

zro:
  xor  a
  ld  (acce),a
  ld  b,a
  ld  c,a
  ld  d,a
  ret

; overflow - set regs to maximum, set cy

ovf:
  ld  bc,7fffh
  ld  a,c
  ld  d,c
  scf
  ret

; chs  change sign of accumulator
; entry - none
; exit  - bcd (packed), a=exp, flags set

chs:
  ld  a,0x80
  jp  fab1

; change sign of accumulator and again on result
; (when calling routine completes)

chss:
  call  chs
  ld  hl,chs
  ex  (sp),hl
  jp  (hl)

; fab  set acc to absolute
;
; entry - none
; exit  - bcd (packed), a=exp, flags set

fab:
  xor  a
fab1:
  ld  hl,accs
  and  (hl)
  xor  0x80
  ld  (hl),a    ; fall thru tst

; tst  load registers from acc and test
; exit  - bcd (packed), a=exp, flags set

tst:
  ld  hl,acce
  ld  a,(hl)
  and  a
  jp  z,zro
  ld  e,a    ; e exp
  inc  hl
  ld  a,(hl)    ; accs
  inc  hl
  xor  (hl)    ; pack msb with sign
  inc  hl
  ld  c,(hl)
  inc  hl
  ld  d,(hl)
  jp  tst1

; lod  load float (hl) to accum and regs, set flags
; entry - hl=adr
; exit  - bcd (packed), a=exp, flags set

lod:
  ld  a,(hl)
  and  a
  jp  z,zro
  ld  e,a
  inc  hl
  ld  a,(hl)
  inc  hl
  ld  c,(hl)
  inc  hl
  ld  d,(hl)
  ld  l,a
  or  0x80
  ld  b,a
  xor  l
lod2:
  call  strr
  xor  b

; entry - acd (packed), e=exp
; exit  - bcd (packed), a=exp, flags set

tst1:
  ld  b,a
tst2:
  or  1    ; test sign, clear Z C flags
  ld  a,e
  ret

; entry - a=exp
; exit  - e=exp  Z=zero M=negative

tstr:
  ld  e,a
tstr1:
  or  a
  ret  z
tstr2:
  ld  a,b
  jp  tst2

; fcmp  compare registers with (hl), return M if regs < (hl)

fcmp:
  ld  e,a
  ld  a,(hl)
  or  a
  ld  a,e
  jp  z,tstr1    ; hl zero, test sign regs
  or  a
  inc  hl
  ld  a,(hl)
  cpl
  jp  z,tst2    ; regs zero, test sign hl
  xor  b
  jp  p,tstr2    ; signs differ
  call  fcmp1
  rra
  xor  b    ; complement sign for neg values
  ld  a,e
  ret

fcmp1:
  dec  hl
  ld  a,e
  cp  (hl)
  ret  nz
  inc  hl
  ld  a,b
  cp  (hl)
  ret  nz
  inc  hl
  ld  a,c
  cp  (hl)
  ret  nz
  inc  hl
  ld  a,d
  cp  (hl)
  ret  nz
  pop  hl
  ld  a,e
  ret

; right shift bcd by a bits
;
; entry - bcd, a=shift count
; exit  - bcde

shr_:
  ld  e,0
  ld  l,8    ; shift 8 bits by moving registers
shr_1:
  cp  l
  jp  m,shr_2    ; less than 8
  ld  e,d
  ld  d,c
  ld  c,b
  ld  b,0
  sub  l
  jp  nz,shr_1
shr_2:
  and  a
  ret  z    ; done
  ld  l,a
shr_3:
  and  a    ; clear carry
  ld  a,b
  rra
  ld  b,a
  ld  a,c
  rra
  ld  c,a
  ld  a,d
  rra
  ld  d,a
  ld  a,e
  rra
  ld  e,a
  dec  l
  jp  nz,shr_3
  ret

; left shift bcde one bit
;
; entry - bcde
; exit  - bcde

shl_:
  ld  a,e
  rla
  ld  e,a
  ld  a,d
  rla
  ld  d,a
  ld  a,c
  rla
  ld  c,a
  ld  a,b
  adc  a,a
  ld  b,a
  ret

; Complement bcde adjust accs, return sign flag

fcpl:
  ld  hl,accs    ; change accum sign
  ld  a,(hl)
  xor  0x80
  ld  (hl),a
  xor  a    ; complement fraction
  ld  l,a
  sub  e
  ld  e,a
  ld  a,l
  sbc  a,d
  ld  d,a
  ld  a,l
  sbc  a,c
  ld  c,a
  ld  a,l
  sbc  a,b
  ld  b,a
  ret

; Normalize bcde registers, adjust acce
;
; entry - bcde
; exit  - bcde, z= bcde=0 or acce=0

norm:
  ld  l,32    ; max shift
norm1:
  ld  a,b
  and  a
  jp  nz,norm3
  ld  b,c
  ld  c,d
  ld  d,e
  ld  e,a
  ld  a,l
  sub  8
  ld  l,a
  jp  nz,norm1
  ret     ; bcde = zero

norm2:
  dec  l    ; shl until bit 31 set
  call  shl_
norm3:
  jp  p,norm2

  ld  a,l    ; adjust accum exp
  sub  32
  ld  hl,acce
  add  a,(hl)
  ld  (hl),a
  ret  z    ; if zero exp
  rra      ; move borrow bit to sign
  and  a    ; set sign to indicate underflow
  ret

; Round the bcde registers, save to acc
;
; entry - bcde
; exit  - bcd, a=packed msb, e=exp, cy=ovf

rondr:
  ld  a,e    ; lsb
  and  a    ; test sign and clear cy
  ld  hl,acce    ; exp
  ld  e,(hl)
  call  m,rondr1
  ret  c    ; rounder overflow
  ld  a,b
  inc  hl    ; accs
  xor  (hl)    ; a=packed msb
  jp  str1    ; save bcd to acc

; round up bcd e=exp, cy=ovf

rondr1:
  inc  d
  ret  nz
  inc  c
  ret  nz
  inc  b
  ret  nz
  ld  b,0x80    ; new 1st fraction
  ld  a,e    ; inc exp
  add  a,1    ; adjust cy
  ld  e,a
  ld  (acce),a  ; new acc exp
  ret

; fsu  floating point subtract subroutine

fsu:
  ld  a,0x80    ; mask to change operand sign
  jp  fad1

; fad  floating point add subroutine

fad:
  xor  a
fad1:
  ld  e,(hl)    ; load operand to abcd
  inc  hl
  xor  (hl)
  ld  b,a
  inc  hl
  ld  c,(hl)
  inc  hl
  ld  d,(hl)
  ld  a,e
  and  a
  jp  z,tst    ; operand zero

  ld  l,b    ; unpack
  ld  a,b
  or  0x80
  ld  b,a
  xor  l    ; generate subtraction flag
  ld  hl,accs
  xor  (hl)
  ld  (sf),a

; determine relative magnitudes of operand and accum

  dec  hl    ; acce
  ld  a,(hl)
  and  a
  jp  z,fad8    ; accum zero

  sub  e    ; get difference of exponents
  jp  c,fad2    ; accum smaller

; check for insignificant operand

  jp  m,tst
  cp  25    ; compare shift count to 25
  jp  c,fad3
  jp  tst

; check for insignificant accum, exchange accum and operand

fad2:
  jp  p,fad8
  cp  0-25    ; compare shift count to -25
  jp  c,fad8

  ld  (hl),e    ; set acce

  ld  e,a    ; save shift count

  ld  a,(sf)    ; set accum sign
  inc  hl    ; accs
  xor  (hl)
  ld  (hl),a

  xor  a    ; complement shift count
  sub  e

  inc  hl    ; exchange fraction
  ld  e,(hl)
  ld  (hl),b
  ld  b,e
  inc  hl
  ld  e,(hl)
  ld  (hl),c
  ld  c,e
  inc  hl
  ld  e,(hl)
  ld  (hl),d
  ld  d,e

; position the operand, check if add or subtract

fad3:
  call  shr_
  ld  hl,acc3
  ld  a,(sf)
  and  a
  jp  m,fad4

  ld  a,(hl)    ; add
  add  a,d
  ld  d,a
  dec  hl
  ld  a,(hl)
  adc  a,c
  ld  c,a
  dec  hl
  ld  a,(hl)
  adc  a,b
  ld  b,a
  jp  nc,fpack

  rra      ; got carry, so rshift fraction
  ld  b,a
  ld  a,c
  rra
  ld  c,a
  ld  a,d
  rra
  ld  d,a
  rra
  ld  e,a
  ld  hl,acce    ; and adjust exponent
  ld  a,(hl)
  add  a,1
  ld  (hl),a
  jp  c,ovf    ; overflow
  jp  fpack

fad4:
  xor  a    ; subtract
  sub  e
  ld  e,a
  ld  a,(hl)
  sbc  a,d
  ld  d,a
  dec  hl
  ld  a,(hl)
  sbc  a,c
  ld  c,a
  dec  hl
  ld  a,(hl)
  sbc  a,b
  ld  b,a

; complement bcde if carry

cnpack:
  call  c,fcpl

; normalize and pack bcde

npack:
  ld  a,b
  and  a
  call  p,norm
  jp  p,zro    ; underflow or zero

; pack bcde

fpack:
  call  rondr    ; round bcde
  jp  c,ovf
  jp  tst1

; move operand to accumulator

fad8:
  ld  a,(sf)
  ld  hl,accs
  xor  (hl)
  jp  lod2

; read the operand at (hl), check the accum exponent

mdex:
  ld  b,a
  inc  hl
  ld  c,(hl)
  inc  hl
  ld  d,(hl)
  inc  hl
  ld  e,(hl)

  ld  hl,acce    ; accum exp
  ld  a,(hl)
  and  a
  ret  z    ; is zero

  add  a,b    ; result exp plus bias
  ld  b,a
  rra      ; carry to sign
  xor  b    ; carry and sign must differ
  ld  a,b    ; result exp plus bias
  ld  b,0x80    ; exp bias, sign mask, most sig bit
  jp  p,mdex1    ; if over or underflow
  sub  b    ; remove excess exp bias
  ret  z    ; return if underflow
  ld  (hl),a    ; result exp
  inc  hl    ; address accum sign
  ld  a,(hl)
  xor  c    ; result sign in sign bit
  and  b    ; result sign
  ld  (hl),a    ; store it
  ld  a,c    ; operand sign and 1st fraction
  or  b    ; operand first fraction
  ret

mdex1:
  rlca      ; set carry bit if overflow
  ret  c
  xor  a    ; clear a register
  ret      ; return if underflow

; fmu  floating point multiplication subroutine

fmu:
  ld  a,(hl)    ; operand exponent
  and  a
  push  hl
  call  nz,mdex    ; read operand
  pop  hl
  jp  z,zro    ; zero or underflow
  jp  c,ovf    ; overflow
  call  mulx    ; fixed mult
  ld  a,b    ; normalize if necessary
  and  a
  jp  m,fpack

  ld  hl,acce    ; dec accum exp
  dec  (hl)
  ret  z    ; underflow
  call  shl_
  jp  fpack

; fixed point multiply subroutine

mulx:
  ld  hl,mulx4
  ld  (hl),e    ; 3rd multiplicand
  inc  hl
  ld  (hl),d    ; 2nd multiplicand
  inc  hl
  ld  (hl),a    ; 1st multiplicand

  xor  a    ; clear 6th product
  ld  e,a    ; clear 5th product
  ld  d,a    ; clear 4th product

; multiply  by each accumulator fraction in turn

  ld  hl,acc3
  call  mulx2    ; multiply by accum 3rd fraction
  ld  hl,acc2
  call  mulx1    ; multiply by accum 2nd fraction
  ld  hl,acc1

; multiply by one accumulator byte

mulx1:
  ld  a,d    ; 5th partial product
  ld  e,c    ; 4th partial prod
  ld  d,b    ; 3rd partial prod
mulx2:
  ld  b,(hl)    ; multiplier
  ld  l,a    ; 5th partial prod
  xor  a    ; zero a register
  ld  c,a    ; 2nd partial prod
  sub  b    ; set carry bit for exit flag
  jp  c,mulx3    ; if multiplier is not zero
  ld  c,d    ; 2nd partial product
  ld  d,e    ; 3rd partial prod
  ret

; loop for each bit of multiplier byte

mulx3:
  ld  a,l    ; 5th partial product, exit flag
  adc  a,a    ; shift exit flag out if done
  ret  z    ; exit if multiplication done
  ld  l,a    ; 5th partial prod, exit flag
  ld  a,e    ; 4th partial prod
  rla      ; shift 4th partial prod
  ld  e,a    ; 4th partial prod
  ld  a,d    ; 3rd partial prod
  rla
  ld  d,a
  ld  a,c    ; 2nd partial prod
  rla
  ld  c,a
  ld  a,b    ; 1st partial prod and multiplier
  rla
  ld  b,a
  jp  nc,mulx3  ; if no addition required

; add the multiplicand to the product if the multiplier bit is one

  ld  a,(mulx4)  ; operand 3rd fraction
  add  a,e
  ld  e,a    ; 4th partial prod
  ld  a,(mulx4+1)  ; operand 2nd fraction
  adc  a,d
  ld  d,a    ; 3rd partial prod
  ld  a,(mulx4+2)  ; operand 1st fraction
  adc  a,c
  ld  c,a    ; 2nd partial prod
  jp  nc,mulx3  ; if no carry to 1st prod
  inc  b    ; add carry to 1st prod
  and  a    ; clear carry bit
  jp  mulx3

mulx4:
  ds  3

; fdi  floating point division subroutine

fdi:
  xor  a
  sub  (hl)    ; complement of divisor exponent
  cp  1    ; set carry if division by zero
  push  hl
  call  nc,mdex    ; read operand if not zero
  pop  hl
  jp  c,ovf    ; overflow or division by zero
  jp  z,zro    ; underflow or zero
  ld  c,a
  call  divx    ; fixed division
  jp  nc,ovf
  jp  fpack

; fixed point divide subroutine

; subtract divisor from accum to obtain 1st remainder

divx:
  ld  hl,acc3
  ld  a,(hl)    ; accum 3rd fraction
  sub  e
  ld  (hl),a
  dec  hl
  ld  a,(hl)    ; accum 2nd fraction
  sbc  a,d
  ld  (hl),a
  dec  hl
  ld  a,(hl)    ; accum 1st fraction
  sbc  a,c
  ld  (hl),a

; halve the divisor and store for addition or subtraction

  ld  a,c    ; get carry bit
  rla
  ld  a,c    ; divisor 1st fraction
  rra
  ld  (divx4+3),a
  ld  a,d    ; divisor 2nd fraction
  rra
  ld  (divx4+2),a
  ld  a,e    ; divisor 3rd fraction
  rra
  ld  (divx4+1),a  ; 3rd subtract divisor
  ld  b,0    ; init quot 1st fraction
  ld  a,b    ; divisor 4th fraction is zero
  rra
  ld  (divx4),a  ; 4th subtract divisor

; load 1st remainder

  ld  a,(hl)    ; 1st fraction
  inc  hl
  ld  d,(hl)    ; 2nd fraction
  inc  hl
  ld  e,(hl)    ; 3rd fraction

; position remainder, initialise quotient, check sign

  ex  de,hl    ; remainder 3rd fraction
        ; remainder 2nd fraction
  ld  e,a    ; remainder 1st fraction
  ld  c,b    ; init quot 2nd fraction
  ld  d,b    ; init quot 3rd fraction
  and  a
  jp  m,divx3    ; if remainder is negative

; adjust exponent

  ld  a,(acce)  ; increment quotient exp
  inc  a
  ret  z    ; overflow
  ld  (acce),a

  inc  d    ; init quot 3rd fraction

; subtract the divisor if remainder positive

divx1:
  push  bc
  ld  c,l
  ld  b,h
  xor  a    ; 4th fraction is zero
  ld  hl,divx4
  sub  (hl)
  ld  a,c    ; 3rd fraction
  inc  hl
  sbc  a,(hl)
  ld  c,a
  ld  a,b    ; 2nd fraction
  inc  hl
  sbc  a,(hl)
  ld  b,a
  ld  a,e    ; 1st fraction
  inc  hl
  sbc  a,(hl)
  ld  e,a
  ld  l,c
  ld  h,b
divx2:
  pop  bc

  ld  a,(divx4)  ; remainder 4th fraction
  rlca      ; shift remainder 4th fraction to carry

; shift the remainder left one bit

  ld  a,b
  rla
  ret  c    ; division complete
  rra      ; shift BCDEHL
  ld  a,l
  rla
  ld  l,a
  ld  a,h
  rla
  ld  h,a
  call  shl_

; branch if subtraction is required

  ld  a,d    ; quotient 3rd fraction
  rrca      ; remainder sign indic to carry bit
  jp  c,divx1    ; to sub divisor if remainder positive

; add the divisor if the remainder is negative

divx3:
  push  bc
  ld  bc,divx4+1
  ld  a,(bc)    ; 3rd fraction
  add  a,l
  ld  l,a
  inc  bc
  ld  a,(bc)    ; 2nd fraction
  adc  a,h
  ld  h,a
  inc  bc
  ld  a,(bc)    ; 1st fraction
  adc  a,e
  ld  e,a
  jp  divx2

divx4:
  ds  fw

; convert 32 bit signed integer to float
; entry - abcd (int)

flt:
  ld  e,d
  ld  d,c
  ld  c,b
  ld  b,a

; convert 32 bit signed integer to float
; entry - bc:de (int)

flt0:
  ld  a,32    ; scaling factor
flt1:
  xor  0x80    ; apply exponent bias
  ld  hl,acce
  ld  (hl),a
  inc  hl
  ld  (hl),0x80  ; assume positive accum sign
  ld  a,b    ; set cy if integer negative
  and  a
  rla
  jp  cnpack    ; complete the conversion

; convert signed integer A to float

flta:
  ld  de,0
  ld  c,e
  ld  b,a
  ld  a,8
  jp  flt1

; fix  convert float in acc to 32 bit integer
;
; exit  - abcd (int)

fix:
  ld  e,32    ; scaling factor
  ld  hl,acce
  ld  a,(hl)
  and  a
  jp  z,zro    ; zero
  ld  a,e
  add  a,0x80-1    ; add bias-1
  sub  (hl)    ; shift count -1
  ret  c    ; accum too large
  cp  31    ; compare to large shift
  jp  nc,zro    ; accum too small
  add  a,1    ; shift count
  ld  hl,acc1
  ld  b,(hl)
  inc  hl
  ld  c,(hl)
  inc  hl
  ld  d,(hl)
  call  shr_    ; position the fraction
  ld  a,(accs)  ; complement if negative
  and  a
  call  p,fcpl
  ld  a,1    ; set flags
  or  b
  ld  a,b
  ld  b,c
  ld  c,d
  ld  d,e
  ret

; Floor accum to integer
;
; entry - abcd
; exit  - abcd e=signed integer

flr:
  ld  e,d
  cp  0x80+24
  ret  nc    ; no fraction
flr1:
  ld  e,a
  ld  a,0x80    ; unpack b
  or  b
  ld  b,a
  ld  a,(accs)
  rla
  push  af
  jp  c,flr3    ; positive
  ld  a,d    ; decr bcd
  or  a
  jp  nz,flr2
  dec  bc
flr2:
  dec  d
flr3:
  ld  a,0x80+24
  sub  e
  call  shr_
  pop  af
  call  nc,rondr1  ; incr bcd
  ld  a,0x80+24
  ld  (acce),a
  ld  a,d
  jp  c,flr4
  cpl
  inc  a
flr4:
  push  af
  ld  e,0
  call  npack    ; normalise and pack
  pop  hl
  ld  e,h
  ret

; Round accum to integer

rnd:
  call  tstr
  call  m,chss
  cp  0x80+24
  ret  nc    ; no fraction
  ld  hl,fp50    ; 0.5
  call  fad
  jp  flr1

;  FABS  ( r1 -- r2 )

  hdr  1,'FABS'
fabss:
  call  ldop
  call  fab
  jp  svop

;  FNEGATE  ( r1 -- r2 )

  hdr  1,'FNEGATE'
fneg:
  call  ldop
  call  chs
  jp  svop

;  D>F  ( d -- r )

  hdr  1,'D>F'
dtof:
  pop  hl
  pop  de
  push  bc
  ld  c,l
  ld  b,h
  call  flt0
  jp  svop

;  F>D  ( r -- d )

  hdr  1,'F>D'
ftod:
  call  ldop
  call  fix
  ld  e,d
  ld  d,c
  ld  l,b
  ld  h,a
  pop  bc
  push de
  jp next

;  S>F  ( n -- r )    s>d d>f

  hdr  1,'S>F'
stof:
  call  do_colon
  dw  stod,dtof
  dw  exit

;  F>S  ( r -- n )    f>d d>s

  hdr  1,'F>S'
ftos:
  call  do_colon
  dw  ftod,dtos
  dw  exit

;  F0=  ( r -- flag )

  hdr  1,'F0='
fze:
  pop  hl
  ld  h,l
  ex  (sp),hl
  jp  zero_equals

   if  fpx

;  F=  ( r1 r2 -- flag )

  hdr  1,'F='
feq:
  call  ld2op
  call  fcmp
  pop  bc
  jp  nz,false
  jp  true

   endif

;  F0<  ( r -- flag )

  hdr  1,'F0<'
fzl:
  pop  hl
  pop  de
  ld  a,l
  or  a
  jp  z,false    ; zero
  ld  a,h
  rla
  jp  c,true    ; negative
  jp  false

;  F<  ( r1 r2 -- flag )

  hdr  1,'F<'
fles:
  call  ld2op
  call  fcmp
  pop  bc
  jp  m,true
  jp  false

;  F0>  ( r -- flag )

  hdr  1,'F0>'
fzg:
  call  ldop
fzg1:
  pop  bc
  jp  z,false
  jp  m,false
  jp  true

;  F>  ( r1 r2 -- flag )

  hdr  1,'F>'
fgre:
  call  ld2op
  call  fcmp
  jp  fzg1

;  FMIN  ( r1 r2 -- r1 | r2 )  fover fover f< 0= if fswap then fdrop

  hdr  1,'FMIN'
fmin:
  call  ld2op
  push  hl
  call  fcmp
  pop  hl
  call  p,lod    ; r1 >= r2
  jp  svop

;  FMAX  ( r1 r2 -- r1 | r2 )  fover fover f< if fswap then fdrop

  hdr  1,'FMAX'
fmax:
  call  ld2op
  push  hl
  call  fcmp
  pop  hl
  call  m,lod    ; r1 < r2
  jp  svop

;  FLOOR  ( r1 -- r2 )

  hdr  1,'FLOOR'
floor:
  call  ldop
  call  flr
  jp  svop

;  FROUND  ( r1 -- r2 )

  hdr  1,'FROUND'
frnd:
  call  ldop
  call  rnd
  jp  svop

;  F+  ( r1 r2 -- r3 )

  hdr  1,'F+'
fadd:
  call  ld2op
  call  fad
  jp  svop

;  F-  ( r1 r2 -- r3 )

  hdr  1,'F-'
fsub:
  call  ld2op
  call  fsu
  jp  svop

;  F*  ( r1 r2 -- r3 )

  hdr  1,'F*'
fstar:
  call  ld2op
  call  fmu
  jp  svop

;  F/  ( r1 r2 -- r3 )

  hdr  1,'F/'
fslas:
  call  ld2op
  call  fdi
  jp  svop

;  FRANDOM  ( r1 -- r2 )

  hdr  1,'FRANDOM'
rand:
  call  ldop
  jp  m,rand1    ; seed generator
  push  af
  ld  hl,rand4
  call  lod
  ld  e,a
  pop  af
  ld  a,e
  jp  z,svop    ; return last value
  ld  hl,rand2  ; get next value
  call  fmu
  ld  hl,rand3
  call  fad
rand1:
  ld  hl,acc3
  ld  b,(hl)    ; swap msb lsb
  dec  hl
  ld  c,(hl)
  dec  hl
  ld  d,(hl)
  dec  hl
  ld  (hl),0x80  ; make positive
  dec  hl
  ld  e,(hl)
  ld  (hl),0x80  ; fix exponent
  call  npack    ; normalise
  ld  hl,rand4
  call  str
  jp  svop

rand2:
  db  0x98,0x35,0x44,0x7a
rand3:
  db  0x68,0x28,0xb1,0x46
rand4:
  db  0x80,0x31,0x41,0x59    ; seed

finstr:
  ds  3  ; string addr, count
finsgn:
  ds  1  ; sign
finpt:
  ds  1  ; decimal point flag
finexp:
  ds  1  ; decimal exponent
fincvt:
  ds  1  ; converted digits

; fin  convert character string to float
; entry - hl=adr, a=len
; exit  - result in accum, cy=error

fin:
  dec  hl    ; init string adr, count
  ld  (finstr),hl
  inc  a
  ld  (finstr+2),a

  ld  a,0x80    ; set sign positive
  ld  (finsgn),a
  xor  a
  ld  (finpt),a  ; clear decimal point flag
  ld  (finexp),a  ; set decimal exponent = 0
  ld  (fincvt),a  ; zero converted digits
  ld  (acce),a  ; zero accum

  call  fin17    ; get 1st char
  jp  z,fin14    ; treat zero length as zero blanks

  cp  ' '
  jp  nz,fin2
fin1:
  call  fin17    ; treat all blanks as zero
  jp  z,fin14
  cp  ' '
  jp  z,fin1
  scf
  ret

fin2:
  cp  '+'    ; check for sign
  jp  z,fin3
  cp  '-'
  jp  nz,fin4
  xor  a    ; set negative flag
  ld  (finsgn),a
fin3:
  call  fin17    ; get char after sign
  scf
  ret  z    ; none

fin4:
  cp  '.'    ; check for decimal point
  jp  nz,fin7
  ld  hl,finpt
  xor  (hl)
  ld  (hl),a
  jp  nz,fin8
fin5:
  scf      ; 2nd decimal point
  ret

fin6:
  ld  a,(fincvt)
  or  a
  jp  z,fin5
  jp  fin14

; process char

fin7:
  call  fin18    ; convert char to digit
  ret  c    ; bad

  ld  hl,fincvt
  inc  (hl)
  push  af
  ld  hl,fp10    ; mult old value by 10
  call  fmu
  call  savf1
  pop  af    ; convert digit to floating point
  call  flta
  ld  hl,f1    ; add to old value
  call  fad

  ld  a,(finpt)  ; if decimal point
  and  a
  jp  z,fin8
  ld  hl,finexp  ; decrement exponent
  dec  (hl)

; get next char

fin8:
  ld  b,0    ; zero exponent
  call  fin17
  jp  z,fin6    ; done

; check for exponent

  cp  '+'
  jp  z,fin10
  cp  '-'
  jp  z,fin10
  call  uppercase_a
  cp  'E'
  jp  z,fin9
  cp  'D'
  jp  nz,fin4

; process exponent

fin9:
  call  fin17    ; next char
  jp  z,fin6    ; done

fin10:
  ld  b,a    ; save 1st char
  sub  '-'    ; compare minus sign
  ld  e,a
  jp  z,fin11
  add  a,'-'-'+'  ; compare plus sign
  ld  a,b
  jp  nz,fin12

fin11:
  call  fin17    ; got sign, get 1st digit

fin12:
  ld  b,0    ; possible decimal exponent
  jp  z,fin6    ; none - assume zero exponent

fin13:
  call  fin18
  ret  c    ; not digit
  ld  c,a    ; accumulate exponent
  ld  a,b
  add  a,a
  add  a,a
  add  a,b
  add  a,a
  add  a,c
  ld  b,a
  call  fin17    ; get next
  jp  nz,fin13

  ld  a,e    ; test exponent sign
  and  a
  jp  nz,fin14
  sub  b    ; complement if neg
  ld  b,a

fin14:
  ld  a,(finsgn)  ; store accum sign
  ld  (accs),a

; adjust exponent

  ld  a,b
fin15:
  ld  hl,finexp
  add  a,(hl)
  jp  z,tst    ; done
  ld  (hl),a
  ld  hl,fp10
  jp  p,fin16
  call  fdi    ; div by 10
  ld  a,1
  jp  fin15

fin16:
  call  fmu    ; mul by 10
  ret  c    ; overflow
  ld  a,0xff
  jp  fin15

; get next char, return z if end reached

fin17:
  ld  hl,finstr+2
  dec  (hl)
  ld  hl,(finstr)
  inc  hl
  ld  (finstr),hl
  ld  a,(hl)
  ret

; convert ascii char (a) to digit, return cy if not in range 0-9

fin18:
  sub  '0'
  ret  c
  cp  10
  ccf
  ret

;  >FLOAT  ( c-addr u -- r true | false )

  hdr  1,'>FLOAT'
tflt:
  pop  hl
  ld  a,l    ; assume u <= 255
  pop  hl
  push  bc
  call  fin
  ld  e,c
  ld  h,b
  ld  l,a
  pop  bc
  jp  c,false
  push  de
  push  hl
  jp  true

  hdr  1,'MAX-PRECISION'
mprec:
  call  do_byte_constant    ; max precision
  db  maxsig

  hdr  x,'EXSN'
exsn:
  call  do_create    ; exponent, sign
  ds  2*cw

;  REPRESENT  ( r c-addr n -- exp sign flag )
;        2dup max-precision max [char] 0 fill
;        max-precision min 2>r fdup f0< 0 exsn 2!
;        fabs fdup f0= 0= if begin fdup 1.0e f<
;        0= while 10.0e f/ 1 exsn +! repeat begin
;        fdup 0.1e f< while 10.0e f* -1 exsn +!
;        repeat then r@ 0 max 0 ?do 10.0e f* loop
;        fround f>d 2dup <# #s #> dup r@ - exsn +!
;        2r> rot min 1 max cmove d0= if 1 0 else
;        exsn 2@ swap then true

  hdr  1,'REPRESENT'
repr:
  call  do_colon
  dw  tdup
  dw  mprec,max
  dw  clit
  db  '0'
  dw  fill
  dw  mprec,min
  dw  two_to_r
  dw  fdup,fzl
  dw  zero,exsn,two_store
  dw  fabss
  dw  fdup,fze
  dw  zero_equals
  dw  zbran,repr3
repr1:
  dw  fdup    ; begin
  dw  flit
  db  0x81,0,0,0
  dw  fles,zero_equals
  dw  zbran,repr2  ; while
  dw  ften,fslas
  dw  one,exsn,pstor
  dw  branch,repr1  ; repeat
repr2:
  dw  fdup    ; begin
  dw  flit
  db  0x7d,0x4c,0xcc,0xcd
  dw  fles
  dw  zbran,repr3  ; while
  dw  ften,fstar
  dw  true,exsn,pstor
  dw  branch,repr2  ; repeat
repr3:
  dw  r_fetch
  dw  zero,max,zero
  dw  xqdo,repr5
repr4:
  dw  ften,fstar
  dw  xloop,repr4
repr5:
  dw  frnd,ftod
  dw  tdup
  dw  bdigs,digs,edigs
  dw  dup
  dw  r_fetch,subb  ; handle overflow
  dw  exsn,pstor
  dw  two_from_r
  dw  rot,min
  dw  one,max
  dw  cmove
  dw  dzequ
  dw  zbran,repr6
  dw  one,zero  ; 0.0E fixup
  dw  branch,repr7
repr6:
  dw  exsn,tat
  dw  swap
repr7:
  dw  true
  dw  exit

;  PRECISION  ( -- u )

  hdr  1,'PRECISION'
prec:
  call  do_value
  dw  maxsig    ; default

;  SET-PRECISION  ( u -- )   1 max max-precision min to precision

  hdr  1,'SET-PRECISION'
setpr:
  call  do_colon
  dw  one,max
  dw  mprec,min
  dw  pto,prec
  dw  exit

  hdr  1,'FDP'
fdp:
  call  do_create    ; decimal point display
  dw  -1    ; set by FPINIT
  ds  2

  hdr  x,'FBUF'
fbuf:
  call  do_create    ; fp string buffer
  ds  maxsig

  hdr  x,'EX#'
exn:
  call  do_value    ; exponent
  ds  cw

  hdr  x,'SN#'
snn:
  call  do_value    ; sign
  ds  cw

  hdr  x,'EF#'
efn:
  call  do_value    ; exponent factor
  ds  cw

  hdr  x,'PL#'
pln:
  call  do_value    ; places after decimal point
  ds  cw

;  (f1)  ( r -- r exp )
;        fdup fbuf max-precision represent 2drop

  hdr  x,'(F1)'  ; get exponent
pf1:
  call  do_colon
  dw  fdup
  dw  fbuf,mprec
  dw  repr,two_drop  ; never error
  dw  exit

;  (f2)  ( exp -- offset exp' )  s>d ef# fm/mod ef# *

  hdr  x,'(F2)'  ; apply exponent factor
pf2:
  call  do_colon
  dw  stod
  dw  efn,fmmod
  dw  efn,star
  dw  exit

;  (f3)  ( r places -- c-addr u )
;                               dup to pl# 0< if precision else (f1) ef# 0>
;                               if 1- (f2) drop 1+ then pl# + max-precision
;                               min then fbuf swap represent drop to sn# to
;                               ex# fbuf max-precision -trailing <# ;

  hdr  x,'(F3)'  ; float to ascii
pf3:
  call  do_colon
  dw  dup
  dw  pto,pln
  dw  zless
  dw  zbran,pf31
  dw  prec
  dw  branch,pf33
pf31:
  dw  pf1
  dw  efn,zgrea
  dw  zbran,pf32
  dw  onem
  dw  pf2,drop
  dw  onep
pf32:
  dw  pln,plus
  dw  mprec,min
pf33:
  dw  fbuf,swap
  dw  repr
  dw  drop    ; never error
  dw  pto,snn
  dw  pto,exn
  dw  fbuf
  dw  mprec
  dw  dtrai
  dw  bdigs
  dw  exit

;  (f4)  ( exp -- )  pl# 0< >r dup abs s>d r@ 0= if # then #s
;        2drop dup sign 0< r> d0= if [char] + hold
;        then [char] E hold

  hdr  x,'(F4)'  ; insert exponent
pf4:
  call  do_colon
  dw  pln,zless
  dw  to_r
  dw  dup
  dw  abss,stod
  dw  r_fetch,zero_equals
  dw  zbran,pf41
  dw  dig
pf41:
  dw  digs
  dw  two_drop
  dw  dup,sign
  dw  zless
  dw  from_r
  dw  dzequ
  dw  zbran,pf42
  dw  clit
  db  '+'
  dw  hold
pf42:
  dw  clit
  db  'E'
  dw  hold
  dw  exit

;  (f5)  ( n -- +n|0 )  0max dup fdp 2+ +!

  hdr  x,'(F5)'  ; conditionally set flag
pf5:
  call  do_colon
  dw  zero_max
  dw  dup
  dw  fdp,twop
  dw  pstor
  dw  exit

;  (f6)  ( c-addr u -- )  (f5) shold

  hdr  x,'(F6)'  ; insert string
pf6:
  call  do_colon
  dw  pf5,shold
  dw  exit

;  (f7)  ( n -- )    (f5) [char] 0 nhold

  hdr  x,'(F7)'  ; insert '0's
pf7:
  call  do_colon
  dw  pf5
  dw  clit
  db  '0'
  dw  nhold
  dw  exit

;  (f8)  ( -- )    sn# sign 0 0 #>

  hdr  x,'(F8)'  ; insert sign
pf8:
  call  do_colon
  dw  snn,sign
  dw  zero,zero
  dw  edigs
  dw  exit

;  (f9)  ( c-addr u1 -- c-addr u2 )
;        pl# 0< if begin dup while 1- 2dup
;        + c@ [char] 0 - until 1+ then then

  hdr  x,'(F9)'  ; trim trailing '0's
pf9:
  call  do_colon
  dw  pln,zless
  dw  zbran,pf92
pf91:
  dw  dup
  dw  zbran,pf92
  dw  onem,tdup
  dw  plus,c_fetch
  dw  clit
  db  '0'
  dw  subb
  dw  zbran,pf91
  dw  onep
pf92:
  dw  exit

;  (fa)  ( u1 -- u1 u2 )  pl# 0< if dup else pl# then

  hdr  x,'(FA)'
pfaa:
  call  do_colon
  dw  pln,zless
  dw  zbran,pfaa1
  dw  dup
  dw  branch,pfaa2
pfaa1:
  dw  pln
pfaa2:
  dw  exit

;  (fb)  ( c-addr u n -- )  fdp cell+ off >r (f9) r@ + (fa) over -
;        (f7) (fa) min r@ - (f6) r> (fa) min (f7)
;        fdp 2@ or if [char] . hold then

  hdr  x,'(FB)'  ; insert fraction n places right of dec. pt
pfbb:
  call  do_colon
  dw  fdp,twop
  dw  off
  dw  to_r
  dw  pf9
  dw  r_fetch,plus
  dw  pfaa
  dw  over,subb
  dw  pf7
  dw  pfaa,min
  dw  r_fetch,subb
  dw  pf6
  dw  from_r
  dw  pfaa,min
  dw  pf7
  dw  fdp,tat,or_
  dw  zbran,pfbb1
  dw  clit
  db  '.'
  dw  hold
pfbb1:
  dw  exit

;  (fc)  ( c-addr u n -- )
;        >r 2dup r@ min 2swap r> /string 0 (fb) (f6)

  hdr  x,'(FC)'  ; split into int/frac and insert
pfcc:
  call  do_colon
  dw  to_r
  dw  tdup
  dw  r_fetch,min
  dw  tswap
  dw  from_r,sstr
  dw  zero,pfbb
  dw  pf6
  dw  exit

;  (fd)  ( r n factor -- c-addr u )
;        to ef# (f3) ex# 1- (f2) (f4) 1+ (fc) (f8)

  hdr  x,'(FD)'  ; exponent form
pfdd:
  call  do_colon
  dw  pto,efn
  dw  pf3
  dw  exn,onem
  dw  pf2
  dw  pf4
  dw  onep,pfcc
  dw  pf8
  dw  exit

;  (FS.)  ( r n -- c-addr u )  1 (fd)

  hdr  1,'(FS.)'
pfsd:
  ld  hl,1
  push  hl
  jp  pfdd

;  FS.R  ( r n1 n2 -- )
;        >r (fs.) r> s.r

  hdr  1,'FS.R'
fsdr:
  call  do_colon
  dw  to_r
  dw  pfsd
  dw  branch,ddotr1

;  FS.  ( r -- )    -1 0 fs.r space

  hdr  1,'FS.'
fsdot:
  call  do_colon
  dw  true
  dw  zero,fsdr
  dw  space
  dw  exit

   if  fpeng

;  (FE.)  ( r -- c-addr u )  3 (fd)

  hdr  1,'(FE.)'
pfse:
  ld  hl,3
  push  hl
  jp  pfdd

;  FE.R  ( r n1 n2 -- )  >r (fe.) r> s.r

  hdr  1,'FE.R'
fedr:
  call  do_colon
  dw  to_r
  dw  pfse
  dw  branch,ddotr1

;  FE.  ( r -- )    -1 0 fe.r space

  hdr  1,'FE.'
fedot:
  call  do_colon
  dw  true
  dw  zero,fedr
  dw  space
  dw  exit

   endif

;  (F.)  ( r n -- c-addr u )
;        0 to ef# (f3) ex# dup max-precision > if
;        fbuf 0 0 (fb) max-precision - (f7) (f6)
;        else dup 0> if (fc) else abs (fb) 1 (f7)
;        then then (f8)

  hdr  1,'(F.)'
pfd:
  call  do_colon
  dw  zero
  dw  pto,efn
  dw  pf3
  dw  exn,dup
  dw  mprec,great
  dw  zbran,pfd1  ; if
  dw  fbuf,zero
  dw  zero,pfbb
  dw  mprec,subb
  dw  pf7
  dw  pf6
  dw  branch,pfd3  ; else
pfd1:
  dw  dup,zgrea
  dw  zbran,pfd2
  dw  pfcc
  dw  branch,pfd3  ; else
pfd2:
  dw  abss
  dw  pfbb
  dw  one,pf7
pfd3:
  dw  pf8    ; then then
  dw  exit

;  F.R  ( r n1 n2 -- )  >r (f.) r> s.r

  hdr  1,'F.R'
fdotr:
  call  do_colon
  dw  to_r
  dw  pfd
  dw  branch,ddotr1

;  F.  ( r -- )    -1 0 f.r space

  hdr  1,'F.'
fdot:
  call  do_colon
  dw  true
  dw  zero,fdotr
  dw  space
  dw  exit

;  (G.)  ( r n -- c-addr u )  >r (f1) -3 7 within  r> swap if (f.) else
;        (fs.) then

  hdr  1,'(G.)'
pgd:
  call  do_colon
  dw  to_r
  dw  pf1
  dw  lit,-3
  dw  clit
  db  7
  dw  within
  dw  from_r,swap
  dw  zbran,pgd1  ; if
  dw  pfd
  dw  branch,pgd2  ; else
pgd1:
  dw  pfsd
pgd2:
  dw  exit    ; then

;  G.R  ( r n1 n2 -- )  >r (g.) r> s.r

  hdr  1,'G.R'
gdotr:
  call  do_colon
  dw  to_r,pgd
  dw  branch,ddotr1

;  G.  ( r -- )    -1 0 g.r space

  hdr  1,'G.'
gdot:
  call  do_colon
  dw  true
  dw  zero,gdotr
  dw  space
  dw  exit

;  sqr

sqr:
  call  tstr
  ret  z    ; zero
  jp  m,ovf    ; neg
  call  savf1
  and  a
  rra
  add  a,0x40
  call  savf2
  ld  d,5
sqr1:
  push  de
  call  lodf1
  ld  hl,f2
  call  fdi
  ld  hl,f2
  call  fad
  sub  1
  call  savf2
  pop  de
  dec  d
  jp  nz,sqr1
  ld  hl,f2
  jp  lod

;  poly

poly:
  push  hl
  call  savf1
  pop  hl
  ld  a,(hl)
  ld  (poly3),a
  inc  hl
  push  hl
  call  lod
  jp  poly2

poly1:
  ld  hl,poly3
  dec  (hl)
  pop  hl
  ret  z
  push  hl
  ld  hl,f1
  call  fmu
  pop  hl
  push  hl
  call  fad
poly2:
  pop  hl
  inc  hl
  inc  hl
  inc  hl
  inc  hl
  push  hl
  jp  poly1

poly3:
  ds  1

;  polx

polx:
  push  hl
  call  savf2
  ld  hl,f2
  call  fmu
  pop  hl
  call  poly
  ld  hl,f2
  jp  fmu

;  exp

exp:
  ld  hl,ln2
  call  fdi
  cp  0x88
  jp  nc,ovf
  cp  0x68
  ld  hl,fp1
  jp  c,lod
  call  savf2
  call  flr
  call  savf1
  ld  a,e
  add  a,0x81
  jp  z,exp1
  push  af
  call  lodf2
  ld  hl,f1
  call  fsu
  ld  hl,exp4
  call  poly
  pop  af
  ld  bc,0
  ld  d,b
  call  savf1
  ld  hl,f1
  jp  fmu

exp1:
  call  tst
  jp  m,zro
  jp  ovf

exp4:
  db  7
  db  0x74,0x59,0x88,0x7c
  db  0x77,0x26,0x97,0x00e0
  db  0x7a,0x1e,0x1d,0xc4
  db  0x7c,0x63,0x50,0x5e
  db  0x7e,0x75,0xfe,0x1a
ln2:
  db  0x80,0x31,0x72,0x18    ; ln2
fp1:
  db  0x81,0,0,0    ; 1.0

;  log

log:
  call  tstr
  jp  m,ovf    ; neg
  jp  z,ovf    ; zero
  xor  0x80
  push  af
  ld  a,0x80
  ld  hl,log2
  call  poly
  call  savf1
  pop  af
  call  flta
  ld  hl,f1
  call  fad
  ld  hl,ln2
  jp  fmu

log2:
  db  9
  db  0x82,0x94,0xee,0xd8
  db  0x84,0x7d,0xaa,0xa9
  db  0x86,0xbf,0x99,0x7d
  db  0x87,0x28,0xe5,0x7b
  db  0x87,0x00c0,0x71,0x8a
  db  0x87,0x14,0x95,0x6e
  db  0x86,0x00a0,0x1e,0xb2
  db  0x85,0x02,0x7a,0xad
  db  0x83,0x8d,0x9d,0x09

;  sin / cos

cos:
  ld  hl,fpi2
  call  fad
sin:
  or  a
  ret  z
  cp  0x80+25
  jp  nc,ovf
  ld  hl,f2pi
  call  fdi
  call  savf1
  call  flr
  or  a
  push  af
  ld  hl,f2
  call  nz,str
  call  lodf1
  pop  af
  ld  hl,f2
  call  nz,fsu
  ld  hl,fp25    ; 0.25
  call  fsu
  push  af
  jp  m,sin1
  ld  hl,fp50    ; 0.5
  call  fsu
  call  p,chs
sin1:
  ld  hl,fp25    ; 0.25
  call  fad
  ld  e,a
  pop  af
  ld  a,e
  call  p,chs
  ld  hl,sin7
  jp  polx

sin7:
  db  5
  db  0x86,0x1e,0xd7,0xfb
  db  0x87,0x99,0x26,0x64
  db  0x87,0x23,0x34,0x58
  db  0x86,0xa5,0x5d,0xe1
f2pi:
  db  0x83,0x49,0fh,0xdb ; 2pi

fpi2:
  db  0x81,0x49,0x0f,0xdb ; pi/2

fp50:
  db  0x80,0,0,0  ; 0.5
fp25:
  db  0x7f,0,0,0  ; 0.25

;  atan

atan:
  call  tstr
  call  m,chss    ; make positive
  cp  0x81
  jp  c,atan1    ; < 1
  ld  hl,atan3
  push  hl
  call  savf1
  ld  hl,fp1
  call  lod
  ld  hl,f1
  call  fdi
atan1:
  ld  hl,atan9
  call  fcmp
  jp  m,atan2
  ld  hl,atan4
  push  hl
  call  savf1
  ld  hl,atan7
  call  fad
  ld  hl,atan11
  call  str
  call  lodf1
  ld  hl,atan6
  call  poly
  ld  hl,atan11
  call  fdi
atan2:
  ld  hl,atan8
  jp  polx

atan3:
  ld  hl,fpi2
  call  fsu
  jp  chs

atan4:
  ld  hl,atan10
  jp  fad

atan6:
  db  2
atan7:
  db  0x81,0x5d,0xb3,0xd7
  db  0x81,0x80,0,0    ; -1.0

atan8:
  db  4
  db  0x7e,0x83,0x35,0x62
  db  0x7e,0x4c,0x24,0x50
  db  0x7f,0xaa,0xa9,0x79
  db  0x81,0,0,0

atan9:
  db  0x7f,0x09,0x38,0xa3
atan10:
  db  0x80,0x06,0x0a,0x92

atan11:
  ds  fw

;  FSQRT  ( r1 -- r2 )

  hdr  1,'FSQRT'
fsqr:
  call  ldop
  call  sqr
  jp  svop

;  FEXP  ( r1 -- r2 )

  hdr  1,'FEXP'
fexp:
  call  ldop
  call  exp
  jp  svop

;  FLN  ( r1 -- r2 )

  hdr  1,'FLN'
ffln:
  call  ldop
  call  log
  jp  svop

;  F**  ( r1 r2 -- r3 )  fswap fln f* fexp

  hdr  1,'F**'
ftst:
  call  do_colon
  dw  fswap,ffln
  dw  fstar,fexp
  dw  exit

;  FSIN  ( r1 -- r2 )

  hdr  1,'FSIN'
fsin:
  call  ldop
  call  sin
  jp  svop

;  FCOS  ( r1 -- r2 )

  hdr  1,'FCOS'
fcos:
  call  ldop
  call  cos
  jp  svop

;  FATAN  ( r1 -- r2 )

  hdr  1,'FATAN'
fatan:
  call  ldop
  call  atan
  jp  svop

;  PI  ( -- r )

  hdr  1,'PI'
fpi:
  call  dofcon
  db  0x82,0x49,0fh,0xdb  ; pi

;  fpinit  ( -- )    max-precision set-precision fdp on

  hdr  x,'FPINIT'
fpini:
  call  do_colon
  dw  mprec,setpr
  dw  fdp,on
  dw  exit

;  fident  ( -- )

  hdr  x,'FIDENT',,1
fiden:
  call  do_colon
  dw  crr
  dw  paren_dot_quote
  db  fiden1-$-1
  db  'Software floating-point ('
;   if  fstack
;  db  'separate'
;   else
  db  'common'
;   endif
  db  ' stack)'
fiden1:
  dw  exit

;  fnumber  ( c-addr u -- [r] flag )
;        2dup s" E" caps search -rot 2drop decimal?
;        and if >float else 2drop 0 then dup >r
;        state? and if postpone fliteral then r>

  hdr  x,'FNUMBER',,1
fnumb:
  call  do_colon
  dw  tdup    ; scan 'E'
  dw  psqot
  dcs  'E'
   if  ucase
  dw  caps
   endif
  dw  search
  dw  drot,two_drop
  dw  dcmq    ; decimal base?
  dw  and_
  dw  zbran,fnumb2
fnumb1:
  dw  tflt
  dw  branch,fnumb3
fnumb2:
  dw  two_drop,zero
fnumb3:
  dw  dup,to_r
  dw  stateq
  dw  and_
  dw  zbran,fnumb4
  dw  flite
fnumb4:
  dw  from_r
  dw  exit

;   ( -- )      :noname ['] noop dup (cold2) ! (cold9) !
;        ['] false (interpret12) ! (nfps) off (nfpm) off
;        ; remember

  hdr  x,'(-FP)',,1
fprun:
  ld  hl,noop
  ld  (cold2),hl    ; INIT
  ld  (cold9),hl    ; INDENTIFY
  ld  hl,false
  ld  (interpret12),hl    ; FNUMBER
;  ld  hl,0
;  ld  (nfps),hl
;  ld  (nfpm),hl
  jp next

fprun1:
  dw  0    ; link
  dw  fprun    ; xt

  endif

; }}} **********************************************************
; XXX {{{

; XXX TODO it seems these 'last_' labels could be renamed
; to 'top_' instead:
top_nfa  equ last_nfa   ; nfa of top word in forth vocab
top_xt equ last_xt   ; xt of top word in forth vocab

initdp  equ $

initdph equ $

; Code is run once then disabled.

; MOVE-PATCH  ( -- )

;;movpat:
;;  ld  a,0x44   ; change to LD B,H
;;  ld  (cldd4),a
;;  ld  (cldd5),a
;;  ld  hl,cold
;;  ld  (cldd7),hl  ; patch myself out
;;  jp  (hl)

;  end cold_boot
  end sm
