; DZX-Forth (project under development)
; A direct-threaded Forth for ZX Spectrum
;
; DZX-Forth is a fork of CP/M DX-Forth v4.09 (2014-12)
;
; Assemble with Pasmo:
;   pasmo --tapbas dzx-forth.z80s dzx-forth.tap

; 2014-11-03: Start.
version: macro
  db 'A-00-201412271309'
  ; XXX Status: '(accept)' just rewritten, but still buggy (the length limit does not work). Problems with backspace (char 8), depending on the ZX Spectrum ROM.
  endm

; ------------------------------
; XXX TODO 

; See: "Programaci√≥n en Ensamblador", by Tony Woods, p. 168, ROM routines.

; Convert block update flags 0x7fff and 0x8000 to labels.

; }}} **********************************************************
; Labels {{{

no:     equ 0
yes:    equ not no

; Modification level
; XXX OLD
;;rel:  equ 4 ; release #
;;rev:  equ 00  ; revision #
;;beta: equ no  ; beta release

; ------------------------------
; Conditional assembly

debug:                            equ yes  ; debugging messages
case_insensitive_names:           equ yes
control_flow_stack_extensions:    equ yes
warning_options:                  equ yes

floored_division:                 equ no  ; integer division method
floating_point_support:           equ yes
fp_engineering_output_functions:  equ yes
separated_f_stack:                equ no ; XXX TODO -- not fully implemented in DX-Forth

classic_Forth_behaviours:         equ no

; ------------------------------
; Config

nfd:                    equ 6  ; max open source files (min = 2)
max_open_file_handles:  equ 10
top_prunes:             defl 0 ; XXX OLD ?

; ------------------------------
; Memory 

start: equ 0x8000 ; start of DZX-Forth in memory

cw: equ 2 ; cell size (bytes)
fw: equ 4 ; floating point number size (bytes)

; ------------------------------
; Buffer sizes

block_size:                   equ 1024
file_descriptor_size:         equ filename_size+(4*cw)  ; ; XXX OLD
file_handle_size:             equ 6+36      ; (keep even) ; XXX OLD
filename_size:                equ 10        ; XXX TODO bigger, for +3, divide, etc.
parsed_string_buffer_size:    equ 255
pictured_numeric_buffer_size: equ 68
stack_size:                   equ 256
return_stack_size:            equ 256
tib_size:                     equ 80        ; Terminal Input Buffer
user_data_size:               equ 128
word_buffer_size:             equ 31+5

; ------------------------------
; DOS ; XXX OLD

dosfcb: equ 0x005c   ; default file control block
dosbuf: equ 0x0080   ; default DTA and command-line buffer
recsiz: equ 128   ; CP/M record size

; ------------------------------
; Floating point

f_init_patch:     defl noop
f_identify_patch: defl noop
f_number_patch:   defl false
f_stack_items:    defl 0
f_stack_size:     defl 0 ; bytes

  if floating_point_support

    maxsig: equ 7 ; max significant digits

    f_init_patch:     defl f_init
    f_identify_patch: defl f_identify
    f_number_patch:   defl f_number

    if separated_f_stack
      f_stack_items: defl 6
      f_stack_size:  defl (f_stack_items+5)*fw ; allow extra for fp display etc
    endif

    top_prunes: defl fprun.1

  endif

; ------------------------------
; ZX Spectrum

  include zx_spectrum_system_variables.z80s
  include zx_spectrum_rom_routines.z80s

; XXX TODO complete
caps_char:      equ 0x06 ; toggle caps lock
edit_char:      equ 0x07 ; edit
left_char:      equ 0x08 ; cursor left (backspace)
bs_char:        equ 0x08 ; backspace (cursor left)
right_char:     equ 0x09 ; cursor right
down_char:      equ 0x0a ; cursor down
up_char:        equ 0x0b ; cursor up
lf_char:        equ 0x0a ; line feed ; XXX OLD
delete_char:    equ 0x0c ; delete (backspace)
ff_char:        equ 0x0c ; form feed (printer only)
cr_char:        equ 0x0d ; carriage return (enter key)
graphics_char:  equ 0x0f ; toggle graphics mode
at_char:        equ 0x16 ; at
tab_char:       equ 0x17 ; tab (screen only)
esc_char:       equ edit_char
sp_char:        equ 0x20 ; space

black_color:    equ 0
blue_color:     equ 1
red_color:      equ 2
magenta_color:  equ 3
green_color:    equ 4
cyan_color:     equ 5
yellow_color:   equ 6
white_color:    equ 7

; }}} **********************************************************
; Description {{{

; ------------------------------
; Forth Registers
;
; Forth Z80  Forth preservation rules
; ----- ---  ------------------------
; IP    BC   Interpretive pointer. Should be preserved across
;            forth words.
; SP    SP   Data stack pointer. Should be used only as data
;            stack across forth words. May be used within forth
;            words if restored before NEXT.
;       DE   Input only when push_de called.
;       HL   Input only when push_hl called.

; ------------------------------
; Stack comment conventions:
;
; a       = address
; aa      = cell-aligned address
; ca      = character-aligned address
; fa      = float-aligned address
; c       = 8-bit character
; u       = 16-bit unsigned number
; len     = 16-bit unsigned number, length of memory zone or string
; ca len  = string
; n       = 16-bit signed number
; x       = 16-bit signed or unsigned number
; d       = 32-bit signed double number
; ud      = 32-bit unsigned double number
; xd      = 32-bit signed or unsigned number
; xt      = execution token (same as cfa)
; cfa     = address of code field (same as xt)
; lfa     = address of link field
; nfa     = address of name field
; pfa     = address of parameter field (body)
; orig    = address of a control structure origin
; fam     = file access method

; ------------------------------
; Non Forth-83 Standard word definitions:
;
; FIG Fig-FORTH model
; ANS ANS FORTH Standard (document dpANS-6, June 1993)

; ------------------------------
; Memory allocation ; XXX OLD

; The memory above LIMIT is used only by the interpreter.  This space
; is not wasted for turnkey applications as LIMIT, user variables and
; stacks are relocated to EM giving applications more free ram (as
; indicated by UNUSED).

; EM  |-------------  end of memory
; |
; DPH |-------------
; |   word headers & system dictionary
; HM  |-------------
; |   interpretive string buffer
; |-------------
; |   terminal input buffer
; TIB |-------------
; |   file descriptor blocks
; FDB |-------------
; |   block buffer
; LIMIT |-------------
; |   handle r/w buffer
; HBUF  |-------------
; |   file handles
; |-------------
; |   user variables
; R0  |-------------
; |   return stack
; S0  |-------------
; |   data stack
; PAD |-------------
; |   word and number conversion area
; DP  |-------------
; |   application dictionary
; 0x0100 |-------------

; ------------------------------
; Header structure

; nfa db length+flags     ; length = 1..31
;     ds length           ; name 
; lfa dw previous_nfa
; cfa dw code_address
; pfa ds ...              ; data or code

; ------------------------------
; Memory map ; XXX TODO -- in progress

; ----- end of memory
; UDG
; ...
; WORD buffer
; parsed string buffer
; Return stack (grows toward low memory)
; Stack (grows toward high memory)
; User data
; TIB
; file descriptor
; block buffer
; boot jumps
; ---- DZX-Forth's org
; ---- BASIC's RAMTOP
; ...
; BASIC program and variables
; system variables
; screen memory
; ROM

; }}} **********************************************************
; Macros {{{

; ------------------------------
; Word header

alias_bit:          equ 7
alias_mask:         equ 1 << alias_bit
immediate_bit:      equ 6
immediate_mask:     equ 1 << immediate_bit
smudge_bit:         equ 5
smudge_mask:        equ 1 << smudge_bit

_public:      equ yes
_hidden:      equ not _public ; change this to make all hidden words public
_immediate:   equ yes

previous_nfa: defl 0   ; initial link pointer (end of chain)

hdr: macro enabled,name,immediate,alias_xt

  ; enabled     = (yes/no, _public/_hidden)
  ; name        = name string
  ; immediate   = immediate?
  ; alias_xt    = alias xt

  if enabled

    ; the name field
    last_nfa: defl $ ; link address for next word
    bits: defl 0
    if not nul immediate
      ; set immediate bit
      bits: defl bits | immediate_mask
    endif
    if not nul alias_xt
      ; set alias bit
      bits: defl bits | alias_mask
    endif
    local _first ; address of the first char of the name
    local _next  ; address after the last char of the name
    db _next-_first+bits    ; count and flags byte
    _first: db name
    _next:
    
    ; the link field
    dw previous_nfa

    ; the code field
    if nul alias_xt
      last_xt: defl $+2
    else
      last_xt: defl alias_xt
    endif
    dw last_xt
    previous_nfa: defl last_nfa

  endif

endm

; ------------------------------
; Counted string

dcs: macro string.1,string.2,string.3,string.4 ; allow comma separated strings
  local _first,_next
  db _next-_first ; count byte
  _first: db string.1
  if not nul string.2
    db string.2
    if not nul string.3
      db string.3
      if not nul string.4
        db string.4
      endif
    endif
  endif
  _next:
endm

; ------------------------------
; Save the IP

; This is used by words that call ROM routines.
; 'saved_ip' is defined in the word 'type'.
; See the word 'cls' as a usage example.

save_ip: macro
  ld h,b
  ld l,c
  ld (saved_ip),hl
endm

; }}} **********************************************************
; Boot {{{

  org start

  jp cold_boot
;  jp warm_boot  ; XXX TODO

; }}} **********************************************************
; Data {{{

block_buffer:
  ds block_size    ; block buffer

;;fdbs: ; XXX OLD
;;  ds file_descriptor_size*nfd ; file descriptor blocks

tib: ; XXX TODO make 'tib' a word
  ds tib_size  ; TIB (terminal input buffer)

user_data:
  ds user_data_size

  ds stack_size
stack_0:

  ds return_stack_size
return_stack_0:

  if separated_f_stack
    ds float_stack_size
    float_stack_0:
  endif

parsed_string_buffer:
  if classic_Forth_behaviours
    ds parsed_string_buffer_size   ; buffer of S"
  else
    ds parsed_string_buffer_size+word_buffer_size ; buffer of S" and WORD
  endif

hm: equ $   ; system definitions and header memory
dnfa:
  db 0   ; dummy nfa - don't remove! ; XXX NEW -- changed its position in DX-Forth 4.09

; If the following byte is non-zero, a warm boot is NOT performed on
; exit to CPM.
; XXX OLD
;;noboot:
;;  db 0   ; no warm boot flag   0110

; Identification and version

;;  dw 0x4683   ; id  ('DXF' in radix 36) 0111
;;dxver:
;;  db rel   ; release     0113
;;  db rev   ; revision      0114

;
; XXX OLD
;;  ds cw    ; reserved
user_data_pointer:
  dw user_data
return_stack_pointer:
  dw return_stack_0

; cpu speed (TURBO PASCAL compatible)
speed: ; XXX OLD -- not needed, unless the OS is not used
  dw 4   ; 1..8191 MHz

; ------------------------------
; Init user variables

; They are copied by 'COLD' into the user data area
; and must be in same order as 'USER' variables.

init_user_variables: ; start of data

                ds 3*cw     ; 00..04 = reserved for multitasking
init_s0:        dw stack_0  ; 06 = s0
init_r0:        dw return_stack_0 ; 08 = r0
init_dp:        dw initdp   ; 10 = dp
init_dph:       dw initdph  ; 12 = dph ; XXX OLD -- not used
init_voc_link:  dw forth.2  ; 14 = voc-link
init_fs0:                   ; 16 = fs0
  if separated_f_stack ; XXX TODO
                dw float_stack_0 ; 16 = fs0
  else
                dw 0             ; 16
  endif
                ds cw       ; 18 = reserved

init_user_variables.end:  ; end of data

; ------------------------------

system_stack_pointer:
  ds cw
esm:
  ds cw    ; end of memory pointer
init_boot_xt:
  dw noop
default_drive:
  ds 1
default_user:
  ds 1
; XXX OLD
;;scaps:   ; XXX converted to user variable
;;  ds 1   ; COMPARE SEARCH case flag
bios_parameter_block: ; XXX OLD
  ds 5
; XXX OLD 
;;ulimit:
;;  ds cw    ; LIMIT for turnkey ; XXX NEW -- from DX-Forth 4.09
;;  ds 2   ; spare

; Arrow key codes (default = Wordstar style) ; XXX OLD
;;  db 'E'-0x40   ; up arrow      014F
;;  db 'X'-0x40   ; down arrow      0150
;;  db 'D'-0x40   ; right arrow     0151
;;  db 'S'-0x40   ; left arrow      0152

; Scratch buffer - shared by several functions:
; +EXT  DELETE-FILE  RENAME-FILE
;; sbuf equ $ ; XXX OLD ? -- not used

; Buffer for temporary filename/fcb ; XXX OLD
zb_size:  equ filename_size+1+36
zb.1:   ds zb_size
zb.2:   ds zb_size

tmp_stack: equ $-cw ; temp stack for startup ; XXX OLD

; }}} **********************************************************
; Misc. subroutines

; ------------------------------
; BC is preserved

de_minus_hl_to_hl:
  ; Input:  de, hl
  ; Output: hl = de-hl
  ex de,hl

hl_minus_de_to_hl:
  ; Input:  de, hl
  ; Output: hl = hl-de
  ld a,l
  sub e
  ld l,a
  ld a,h
  sbc a,d
  ld h,a
  ret

compare_de_hl_unsigned:
  ; Input:  de, hl
  ; Output:
  ;  flag C if hl < de
  ;  flag Z if hl = de
  ld a,h
  cp d
  ret nz
  ld a,l
  cp e
  ret

compare_de_hl_signed:
  ; Input:  de, hl
  ; Output: flag C if hl < de
  ld a,h
  xor d
  jp p,compare_de_hl_unsigned
  ld a,h
  or a
  ret p
  scf
  ret

; XXX OLD
get_current_drive:
  ld a,25  ; get current drive a
  jp bdoss

; XXX OLD
get_current_user:
;;  ld a,0xff  ; get current user a

 ; XXX OLD
set_current_user:
;;  ld e,a ; set current user a
;;  ld a,32

; XXX OLD
bdoss:
;;  push bc  ; call bdos a
;;  ld c,a
;;  call 0x0005
;;  pop bc
  ret

; ------------------------------
; BC is affected

; move block upwards  HL = source, DE = destination, BC = count

move_block_upwards:
  add hl,bc
  ex de,hl
  add hl,bc
  ex de,hl
move_block_upwards.1:
  ld a,c
  or b
  ret z
  dec hl
  dec de
  ld a,(hl)
  ld (de),a
  dec bc
  jp move_block_upwards.1

; move block up/down  HL = source, DE = destination, BC = count

move_block:
  call compare_de_hl_unsigned
  jp c,move_block_upwards

; move block downwards  HL = source, DE = destination, BC = count

move_block_downwards:
  ld a,c
  or b
  ret z
  ld a,(hl)
  ld (de),a
  inc hl
  inc de
  dec bc
  jp move_block_downwards

; move block downwards  HL = source, DE = destination, A = count

amovd:
  push bc
  ld c,a
  ld b,0
  call move_block_downwards
  pop bc
  ret

; }}} **********************************************************
; Virtual machine {{{

; XXX TODO -- add headers:
do_create:        equ next
do_value:         equ fetch
do_constant:      equ fetch
do_byte_constant: equ c_fetch

; runtime for colon definitions

; XXX TODO -- add a header
do_colon:
  ld hl,(return_stack_pointer)  ; push IP onto return stack
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c
  ld (return_stack_pointer),hl
  pop bc    ; get new IP from 'call'
  jp next

; runtime for user variables

; XXX TODO -- add a header
do_user_variable:
  pop hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  ld hl,(user_data_pointer)
  add hl,de
  push hl
  jp next

; NOOP  ( -- )

  hdr _public,'NOOP'
noop: equ $

; NEXT  -  Forth Address Interpreter

next:
  ld a,(bc)   ; 7T
  ld l,a      ; 4T
  inc bc      ; 6T
  ld a,(bc)   ; 7T
  ld h,a      ; 4T
  inc bc      ; 6T
  jp (hl)     ; 4T

; UNNEST  ( -- )

  hdr _public,'UNNEST'
unnest:
  ld hl,(return_stack_pointer)
  inc hl
  inc hl
  ld (return_stack_pointer),hl
  jp next

; (EXIT)  ( -- )    exit colon definition

  hdr _public,'(EXIT)'
exit: ; XXX TODO rename 'paren_exit'
  ld bc,next
;;exit.1:
  push bc
  ld hl,(return_stack_pointer)  ; pop IP from return stack
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ld (return_stack_pointer),hl
  ret ; execute NEXT

; EXECUTE  ( xt -- )

  hdr _public,'EXECUTE'
execute:
  ret

; @EXECUTE  ( a -- )

  hdr _public,'@EXECUTE'
fetch_execute:
  pop hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  or h
  jp z,next
  jp (hl)

; CLIT  ( -- c )

  hdr _hidden,'CLIT'
c_lit:
  ld a,(bc)
  inc bc

push_a:
  ld l,a
push_l:
  ld h,0
push_hl:
  push hl
  jp next

; LIT  ( -- n )

  hdr _hidden,'LIT'
lit:
  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a
  inc bc
  push hl
  jp next

; 2LIT  ( -- d )

  hdr _hidden,'2LIT'
two_lit:
  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a
  ; XXX FIXME DX-Forth bug? HL is not pushed!
  inc bc
  ld a,(bc)
  ld e,a
  inc bc
  ld a,(bc)
  ld d,a
  inc bc
  push de
  jp next

; }}} **********************************************************
; Stack pointer manipulation {{{

; SP@  ( -- a )

  hdr _public,'SP@'
sp_fetch:
  ld hl,0
  add hl,sp
  push hl
  jp next

; SP!  ( a -- )

  hdr _public,'SP!'
sp_store:
  pop hl
  ld sp,hl
  jp next

; RP@  ( -- a )

  hdr _public,'RP@'
rp_fetch:
  ld hl,(return_stack_pointer)
  push hl
  jp next

; RP!  ( a -- )

  hdr _public,'RP!'
rp_store:
  pop hl
  ld (return_stack_pointer),hl
  jp next

; }}} **********************************************************
; Return stack {{{

; >R  ( x -- )

  hdr _public,'>R'
to_r:
  ld hl,(return_stack_pointer)
  pop de
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e
  ld (return_stack_pointer),hl
  jp next

; R>  ( -- x )

  hdr _public,'R>'
from_r:
  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (return_stack_pointer),hl
  push de
  jp next

; R@  ( -- x )

  hdr _public,'R@'
r_fetch:
  ld hl,(return_stack_pointer)
  jp fetch.1

; 2>R  ( x1 x2 -- )

  hdr _public,'2>R'
two_to_r:
  ld hl,(return_stack_pointer)
  ld de,-cw*2
  add hl,de
  ld (return_stack_pointer),hl
  jp two_store.1

; 2R>  ( -- x1 x2 )

  hdr _public,'2R>'
two_from_r:
  ld hl,(return_stack_pointer)
  push hl
  ld de,cw*2
  add hl,de
  ld (return_stack_pointer),hl
  jp two_fetch

; 2R@  ( -- x1 x2 )

  hdr _public,'2R@'
two_r_fetch:
  ld hl,(return_stack_pointer)
  jp two_fetch.hl

; 2DROP  ( x1 x2 -- )

  hdr _public,'2DROP'
two_drop:
  pop hl
  pop hl
  jp next

; }}} **********************************************************
; Data stack {{{

; DROP  ( x -- )

  hdr _public,'DROP'
drop:
  pop hl
  jp next

; DUP  ( x -- x x )

  hdr _public,'DUP'
dup:
  pop hl
  push hl
  push hl
  jp next

; ?DUP  ( x -- 0 | x x )

  hdr _public,'?DUP'
question_dup:
  pop hl
  ld a,l
  or h
  jp z,question_dup.1
  push hl
question_dup.1:
  push hl
  jp next

; SWAP  ( x1 x2 -- x2 x1 )

  hdr _public,'SWAP'
swap:
  pop hl
  ex (sp),hl
  push hl
  jp next

; OVER  ( x1 x2 -- x1 x2 x1 )

  hdr _public,'OVER'
over:
  pop de
  pop hl
  push hl
  push de
  jp next

; ROT  ( x1 x2 x3 -- x2 x3 x1 )

  hdr _public,'ROT'
rot:
  pop de
  pop hl
  ex (sp),hl
  push de
  jp next

; -ROT  ( x1 x2 x3 -- x3 x1 x2 )

  hdr _public,'-ROT'
minus_rot:
  pop hl
  pop de
  ex (sp),hl
  ex de,hl
  push de
  jp next

; ROLL  ( xu xn .. x0 u -- xn .. x0 xu )

  hdr _public,'ROLL'
roll:
  pop hl
  add hl,hl
  ld e,l
  ld d,h
  add hl,sp
  push bc
  ld c,(hl)
  inc hl
  ld b,(hl)
  push bc
  ld c,e
  ld b,d
  ld e,l
  ld d,h
  inc de
  dec hl
  call move_block_upwards.1
  pop hl
  pop bc
  ex (sp),hl
  jp next

if control_flow_stack_extensions

; -ROLL  ( xu .. xu+1 x0 u -- x0 xu .. xu+1 )

  hdr _public,'-ROLL'

; XXX OLD -- DX-Forth 4.00
;;minus_roll:
;;  call do_colon
;;  dw cells,two_to_r
;;  dw sp_fetch,sp_fetch,tuck
;;  dw r_fetch,cmove
;;  dw sp_fetch,two_from_r
;;  dw rot,plus,store
;;  dw exit

; XXX NEW -- DX-Forth 4.09
minus_roll:
  pop hl
  add hl,hl
  ex de,hl
  ld hl,0
  add hl,sp
  push bc
  ld c,(hl)
  inc  hl
  ld b,(hl)
  push bc
  ld c,e
  ld b,d
  ld e,l
  ld d,h
  dec  de
  inc  hl
  call move_block_downwards
  pop hl
  pop bc
  ex de,hl
  jp store_de_into_hl_pointer

endif

; PICK  ( xu .. x1 x0 u -- xu .. x1 x0 xu )

  hdr _public,'PICK'
pick:
  pop hl
  add hl,hl
  add hl,sp
  jp fetch.1

; NIP  ( x1 x2 -- x2 )

  hdr _public,'NIP'
nip:
  pop hl
  inc sp
  inc sp
  push hl
  jp next

; TUCK  ( x1 x2 -- x2 x1 x2 )

  hdr _public,'TUCK'
tuck:
  pop hl
  pop de
  push hl
  push de
  jp next

; 2DUP  ( x1 x2 -- x1 x2 x1 x2 )

  hdr _public,'2DUP'
two_dup:
  pop hl
  pop de
  push de
  push hl
  push de
  jp next

; 2SWAP  ( x1 x2 x3 x4 -- x3 x4 x1 x2 )

  hdr _public,'2SWAP'
two_swap:
; XXX OLD -- DX-Forth 4.00
;;  pop de
;;  pop hl
;;  inc sp
;;  inc sp
;;  ex (sp),hl
;;  dec sp
;;  dec sp
;;  ex de,hl
;;  ex (sp),hl
;;  jp push_de
; XXX NEW -- DX-Forth 4.09
  pop hl
  pop de
  ex (sp),hl
  push hl
  ld hl,5
  add hl,sp
  ld a,(hl)
  ld (hl),d
  ld d,a
  dec  hl
  ld a,(hl)
  ld (hl),e
  ld e,a
  pop hl
  push de
  jp next

; 2OVER  ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )

  hdr _public,'2OVER'
two_over:
  ld hl,4
  add hl,sp
  jp two_fetch.hl

; 2ROT  ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
;  5 roll 5 roll

  hdr _public,'2ROT'
two_rot:
  call do_colon
  dw c_lit
  db 5
  dw roll
  dw c_lit
  db 5
  dw roll
  dw exit

; 2NIP  ( x1 x2 x3 x4 -- x3 x4 )

  hdr _public,'2NIP'
two_nip:
  pop hl
  pop de
  inc  sp
  inc  sp
  inc  sp
  inc  sp
  push de
  jp next

; DEPTH  ( -- u )   sp@ s0 @ swap - 2/

  hdr _public,'DEPTH'
depth:
  call do_colon
  dw sp_fetch
  dw s0,fetch
  dw swap,minus
  dw two_slash
  dw exit

; }}} **********************************************************
; Memory operations {{{

; @  ( aa -- x )

  hdr _public,'@'
fetch:
  pop hl
fetch.1:
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  jp next

; 2!  ( x1 x2 aa -- )

  hdr _public,'2!'
two_store:
  pop hl
two_store.1:
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  jp store.1

; !  ( x aa -- )

  hdr _public,'!'
store:
  pop hl
store.1:
  pop de
store_de_into_hl_pointer:
  ld (hl),e
  inc hl
  ld (hl),d
  jp next

; C@  ( ca -- c )

  hdr _public,'C@'
c_fetch:
  pop hl
  ld l,(hl)
  ld h,0
  push hl
  jp next

; C!  ( c ca -- )

  hdr _public,'C!'
c_store:
  pop hl
  pop de
  ld (hl),e
  jp next

; 2@  ( aa -- x1 x2 )

  hdr _public,'2@'
two_fetch:
  pop hl
two_fetch.hl:
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  ex de,hl
  push de
  jp next

; +!  ( x aa -- )

  hdr _public,'+!'
plus_store:
  pop hl
  pop de
plus_store.1:
  ld a,(hl)
  add a,e
  ld (hl),a
  inc hl
  ld a,(hl)
  adc a,d
  ld (hl),a
  jp next

; MOVE  ( a1 a2 u -- )

  hdr _public,'MOVE'
move:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
  call move_block
  pop bc
  jp next

; ERASE  ( a u -- )

  hdr _public,'ERASE'
erase:
  ld e,0
  jp fill.1

; FILL  ( ca u c -- )

  hdr _public,'FILL'
fill:
  pop de
fill.1:
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
  jp fill.3

fill.2:
  ld (hl),e
  inc hl
  dec bc
fill.3:
  ld a,c
  or b
  jp nz,fill.2
  pop bc
  jp next

; ON  ( a -- )   -1 swap !

  hdr _public,'ON'
on:
  pop hl
on_hl:
  ld de,-1
  jp store_de_into_hl_pointer

; OFF  ( a -- )  0 swap !

  hdr _public,'OFF'
off:
  pop hl
off_hl:
  ld de,0
  jp store_de_into_hl_pointer

; XXX OLD -- DX-Forth 4.00
;;; TOGGLE  ( ca x -- )
;;
;;  hdr _public,'TOGGLE'
;;toggle:
;;  pop de
;;  pop hl
;;toggle.1:
;;  ld a,(hl)
;;  xor e
;;  ld (hl),a
;;  jp next

; XXX NEW -- DX-Forth 4.09
; CTOGGLE  ( x ca -- )

  hdr _public,'CTOGGLE'
c_toggle:
  pop hl
  pop de
c_toggle.1:
  ld a,(hl)
  xor e
  ld (hl),a
  jp next

; }}} **********************************************************
; Arithmetic and logical {{{

; ><  ( x1 -- x2 )

  hdr _public,'><'
byte_swap:
  pop de
  ld h,e
  ld l,d
  push hl
  jp next

; AND  ( x1 x2 -- x3 )

  hdr _public,'AND'
and_:
  pop de
  pop hl
  ld a,e
  and l
  ld l,a
  ld a,d
  and h
  ld h,a
  push hl
  jp next

; OR  ( x1 x2 -- x3 )

  hdr _public,'OR'
or_:
  pop de
  pop hl
  ld a,e
  or l
  ld l,a
  ld a,d
  or h
  ld h,a
  push hl
  jp next

; XOR  ( x1 x2 -- x3 )

  hdr _public,'XOR'
xor_:
  pop de
  pop hl
  ld a,e
  xor l
  ld l,a
  ld a,d
  xor h
  ld h,a
  push hl
  jp next

abs_hl:
  ld a,h
  or a
  ret p

negate_hl:
  dec hl    ; two's complement
negate_hl.1:
  ld a,l
  cpl
  ld l,a
  ld a,h
  cpl
  ld h,a
  ret

sra_hl:
  ld a,h   ; shift arithmetic right
  rlca
  rrca
sra_hl.1:
  rra
  ld h,a
  ld a,l
  rra
  ld l,a
  ret

abs_hlde:
  ld a,h
  or a
  ret p

negate_hlde:
  sub a   ; 16 bit two's complement
  sub e
  ld e,a
  ld a,0
  sbc a,d
  ld d,a
  ld a,0
  sbc a,l
  ld l,a
  ld a,0
  sbc a,h
  ld h,a
  ret

; INVERT  ( x1 -- x2 )  one's complement

  hdr _public,'INVERT'
invert:
  pop hl
  call negate_hl.1
  push hl
  jp next

; NOT  ( x1 -- x2 )
;   aka 0= not

  hdr _public,'NOT',,zero_equals    ; F79 NOT
not_: equ zero_equals

; S>D  ( n -- d )

  hdr _public,'S>D'
s_to_d:
  ld hl,0
  pop de
  ld a,d
  or a
  jp p,s_to_d.1
  dec hl
s_to_d.1:
  push de
  jp next

; D>S  ( d -- n )
;   aka drop d>s

  hdr _public,'D>S',,drop
d_to_s: equ drop

; NEGATE  ( n1 -- n2 )

  hdr _public,'NEGATE'
negate:
  pop hl
  call negate_hl
  push hl
  jp next

; ABS  ( n -- +n )

  hdr _public,'ABS'
abs:
  pop hl
  call abs_hl
  push hl
  jp next

; DNEGATE  ( d1 -- d2 )

  hdr _public,'DNEGATE'
d_negate:
  pop hl
  pop de
  call negate_hlde
  push de
  jp next

; DABS  ( d -- +d )

  hdr _public,'DABS'
d_abs:
  pop hl
  pop de
  call abs_hlde
  push de
  jp next

; +  ( x1 x2 -- x3 )

  hdr _public,'+'
plus:
  pop de
plus_de:
  pop hl
  add hl,de
  push hl
  jp next

; -  ( x1 x2 -- x3 )

  hdr _public,'-'
minus:
  pop de
  pop hl
  call hl_minus_de_to_hl
  push hl
  jp next

; D+  ( xd1 xd2 -- xd3 )

  hdr _public,'D+'
d_plus:
  ld hl,6
  add hl,sp
  ld e,(hl)
  ld (hl),c
  inc hl
  ld d,(hl)
  ld (hl),b
  pop bc
  pop hl
  add hl,de
  ex de,hl
  pop hl
  ld a,l
  adc a,c
  ld l,a
  ld a,h
  adc a,b
  ld h,a
  pop bc
  push de
  jp next

; D-  ( xd1 xd2 -- xd3 )  dnegate d+

  hdr _public,'D-'
d_minus:
  call do_colon
  dw d_negate,d_plus
  dw exit

; M+  ( xd1 n -- xd2 )  s>d d+

  hdr _public,'M+'
m_plus:
  call do_colon
  dw s_to_d,d_plus
  dw exit

; 1+  ( x1 -- x2 )

  hdr _public,'1+'
one_plus:
  pop hl
  inc hl
  push hl
  jp next

; 2+  ( x1 -- x2 )

  hdr _public,'2+'
two_plus:
  pop hl
  inc hl
  inc hl
  push hl
  jp next

; 1-  ( x1 -- x2 )

  hdr _public,'1-'
one_minus:
  pop hl
  dec hl
  push hl
  jp next

; 2-  ( x1 -- x2 )

  hdr _public,'2-'
two_minus:
  pop hl
  dec hl
  dec hl
  push hl
  jp next

; ------------------------------
; Multiplication primitives

; AHL <- A * DE

a_by_de_to_ahl:
  ld hl,0
  ld c,8
a_by_de_to_ahl.1:
  add hl,hl
  rla
  jp nc,a_by_de_to_ahl.2
  add hl,de
  adc a,0
a_by_de_to_ahl.2:
  dec c
  jp nz,a_by_de_to_ahl.1
  ret

; Unsigned 16*16 multiply, 32 bit result

; HLDE <- HL * DE

hl_by_de_to_hlde_unsigned:
  push bc    ; save IP
  ld b,h
  ld a,l
  call a_by_de_to_ahl
  push hl
  ld h,a
  ld a,b
  ld b,h
  call a_by_de_to_ahl
  pop de
  ld c,d
  add hl,bc
  adc a,0
  ld d,l
  ld l,h
  ld h,a
  pop bc    ; restore IP
  ret

; Signed 16*16 multiply, 32 bit result

; HLDE <- HL * DE

hl_by_de_to_hlde_signed:
  ld a,d
  xor h
  rla
  push af
  call abs_hl
  ex de,hl
  call abs_hl
  call hl_by_de_to_hlde_unsigned
  pop af
  ret nc
  jp negate_hlde

; UM*  ( u1 u2 -- ud )

  hdr _public,'UM*'
umstr:
  pop de
  pop hl
  call hl_by_de_to_hlde_unsigned
  push de
  jp next

; M*  ( n1 n2 -- d )
; 2dup xor >r abs swap abs um* r> ?dnegate

  hdr _public,'M*'
mstar:
  pop de
  pop hl
  call hl_by_de_to_hlde_signed
  push de
  jp next

; *  ( x1 x2 -- x3 )
; um* drop

  hdr _public,'*'
star:
  pop de
  pop hl
  call hl_by_de_to_hlde_unsigned
  push de
  jp next

; ------------------------------
; Division primitives

usl.1:
  sub c
  ld h,a
  ld a,e
  sbc a,b
usl.2:
  inc l
  dec d
  ret z

usl.3:
  add hl,hl
  rla
  ld e,a
  ld a,h
  jp c,usl.1
  sub c
  ld h,a
  ld a,e
  sbc a,b
  jp nc,usl.2
  ld a,h
  add a,c
  ld h,a
  ld a,e
  dec d
  jp nz,usl.3
  ret

usl:
  ld a,h
  ld h,l
  ld l,d
  ld d,8   ; loop counter
  push de
  call usl.3
  pop de
  push hl
  ld l,e
  call usl.3
  ld d,a
  ld e,h
  ld a,l
  pop hl
  ld h,l
  ld l,a
  ret

; Unsigned 32/16 divide
;
; entry HLDE = dividend, BC = divisor
; exit  HL = quotient, DE = remainder

mum:
  ld a,l   ; if overflow
  sub c
  ld a,h
  sbc a,b
  jp c,usl
  ld hl,-1   ; set rem & quot to max
  ld de,-1
  ret

; UM/MOD  ( ud u1 -- u2 u3 )

  hdr _public,'UM/MOD'
umslm:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
  ex de,hl
  call mum
  pop bc
  push de
  jp next

; Signed 32/16 divide - floored
;
; entry HLDE = dividend, BC = divisor
; exit  HL = quotient, DE = remainder

msm:
  push bc    ; save divisor
  ld a,b
  xor h
  push af    ; save quot sign
  push hl    ; save dividend
  push hl
  ld l,c
  ld h,b
  call abs_hl
  ld c,l
  ld b,h
  pop hl
  call abs_hlde
  call mum
  pop af    ; sign remainder
  or a
  ex de,hl
  call m,negate_hl
  ex de,hl
  pop af
  pop bc    ; restore divisor
  or a   ; sign quot
  jp p,msm.1
  jp negate_hl

msm.1:
  pop bc    ; discard return
msm.2:
  pop bc
  push de
  jp next

; SM/REM  ( d n1 -- n2 n3 )

  hdr _public,'SM/REM'
smrem:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
  ex de,hl
smrem.1:
  call msm
  jp msm.2

; FM/MOD  ( d n1 -- n2 n3 )

  hdr _public,'FM/MOD'
fm_slash_mod:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
  ex de,hl
fm_slash_mod.1:
  call msm
  ld a,d
  or e
  jp z,msm.2    ; skip if remainder = 0
  dec hl    ; floor
  push hl
  ex de,hl
  add hl,bc
  ex de,hl
  pop hl
  jp msm.2

; M/MOD  ( d n1 -- n2 n3 )  fm/mod or sm/rem

; XXX OLD -- DX-Forth 4.00 -- but kept
  hdr _hidden,'M/MOD',,m_slash_mod

if floored_division
  m_slash_mod: equ fm_slash_mod
else
  m_slash_mod: equ smrem
endif

; /MOD  ( n1 n2 -- n3 n4 )  >r s>d r> m/mod

; XXX NEW -- DX-Forth 4.09 -- instead of 'M/MOD'
  hdr _public,'/MOD'
slash_mod:
  call do_colon
  dw to_r,s_to_d
  dw from_r,m_slash_mod
  dw exit

; /  ( n1 n2 -- n3 )    /mod nip

  hdr _public,'/'
slash:
  call do_colon
  dw slash_mod,nip
  dw exit

; MOD  ( n1 n2 -- n3 )    /mod drop

  hdr _public,'MOD'
modd:
  call do_colon
  dw slash_mod,drop
  dw exit

; XXX OLD -- DX-Forth 4.00
;;; */MOD  ( n1 n2 n3 -- n4 n5 )  >r m* r> m/mod
;;
;;  header 1,'*/MOD'
;;star_slash_mod:
;;  call do_colon
;;  dw to_r,mstar
;;  dw from_r,m_slash_mod
;;  dw exit

; XXX NEW -- DX-Forth 4.09
; */MOD  ( n1 n2 n3 -- n4 n5 )  >r m* r> sm/rem
  hdr _public,'*/MOD'
star_slash_mod:
  call do_colon
  dw to_r,mstar
  dw from_r,smrem
  dw exit

; */  ( n1 n2 n3 -- n4 )    */mod nip

  hdr _public,'*/'
star_slash:
  call do_colon
  dw star_slash_mod,nip
  dw exit

; M*/  ( d1 n1 +n2 -- d2 )  abs >r 2dup xor swap abs >r -rot
;         dabs swap r@ um* rot r> um* rot 0 d+
;         r@ um/mod -rot r> um/mod nip swap
;         rot 0< if dnegate then

  hdr _public,'M*/'
m_star_slash:
  call do_colon
  dw abs,to_r
  dw two_dup,xor_
  dw swap,abs,to_r
  dw minus_rot,d_abs
  dw swap,r_fetch,umstr
  dw rot,from_r,umstr
  dw rot,zero,d_plus
  dw r_fetch,umslm
  dw minus_rot,from_r
  dw umslm,nip
  dw swap,rot,zero_less
  dw question_branch,m_star_slash.1
  dw d_negate
m_star_slash.1:
  dw exit

; 2*  ( x1 -- x2 )

  hdr _public,'2*'
two_star:
  pop hl
  add hl,hl
  push hl
  jp next

; 2/  ( n1 -- n2 )

  hdr _public,'2/'
two_slash:
  pop hl
  call sra_hl
  push hl
  jp next

; U2/  ( x1 -- x2 )

  hdr _public,'U2/'
u_two_slash:
  pop hl
  or a
  ld a,h
  call sra_hl.1
  push hl
  jp next

; D2*  ( xd1 -- xd2 )

  hdr _public,'D2*'
d_two_star:
  pop de
  pop hl
  add hl,hl
  ld a,e
  rla
  ld e,a
  ld a,d
  rla
  ld d,a
  ex de,hl
  push de
  jp next

; D2/  ( d1 -- d2 )

  hdr _public,'D2/'
d_two_slash:
  pop hl
  pop de
  call sra_hl
  ld a,d
  rra
  ld d,a
  ld a,e
  rra
  ld e,a
  push de
  jp next

; LSHIFT  ( x1 u -- x2 )

  hdr _public,'LSHIFT'
lshift:
  pop de
  pop hl
  inc e
lshift.1:
  dec e
  jp z,push_hl
  add hl,hl
  jp lshift.1

; RSHIFT  ( x1 u -- x2 )

  hdr _public,'RSHIFT'
rshift:
  pop de
  pop hl
  inc e
rshift.1:
  dec e
  jp z,push_hl
  or a
  ld a,h
  call sra_hl.1
  jp rshift.1

; }}} **********************************************************
; Comparison {{{ 

; 0=  ( x -- flag )

  hdr _public,'0='
zero_equals:
  pop hl
zero_equals_hl:
  ld a,l
  or h
  jp z,true
  jp false

; 0<>  ( x -- flag )

  hdr _public,'0<>'
zero_not_equals:
  pop hl
  ld a,l
  or h
  jp z,false
  jp true

; =  ( x1 x2 -- flag )  - 0=

  hdr _public,'='
equals:
  pop de
  pop hl
equals.1:
  call compare_de_hl_unsigned
  jp z,true
  jp false

; <>  ( x1 x2 -- flag ) - 0= 0=

  hdr _public,'<>'
not_equals:
  pop de
  pop hl
  call compare_de_hl_unsigned
  jp z,false
  jp true

; 0<  ( n -- flag )

  hdr _public,'0<'
zero_less:
  pop hl
zero_less.1:
  add hl,hl
zero_less.2:
  jp c,true
  jp false

; 0>  ( n -- flag )

  hdr _public,'0>'
zero_greater:
  pop de
  ld hl,0
zero_greater.1:
  call compare_de_hl_signed
  jp c,true
  jp false

; <  ( n1 n2 -- flag )

  hdr _public,'<'
less:
  pop de
  pop hl
  jp zero_greater.1

; >  ( n1 n2 -- flag )

  hdr _public,'>'
greater:
  pop hl
  pop de
  jp zero_greater.1

; U<  ( u1 u2 -- flag )

  hdr _public,'U<'
u_less:
  pop de
  pop hl
u_less.1:
  call compare_de_hl_unsigned
  jp c,true
  jp false

; U>  ( u1 u2 -- flag )

  hdr _public,'U>'
u_greater:
  pop hl
u_greater.1:
  pop de
  jp u_less.1

; 0MAX  ( n1 -- n2 )  0 max

  hdr _hidden,'0MAX'
zero_max:
  ld de,0
  jp max_de

; MAX  ( n1 n2 -- n1 | n2 )  2dup < if swap then drop

  hdr _public,'MAX'
max:
  pop de
max_de:
  pop hl
  call compare_de_hl_signed
max.1:
  ccf
max.2:
  jp c,max.3
  ex de,hl
max.3:
  push hl
  jp next

; MIN  ( n1 n2 -- n1 | n2 )  2dup > if swap then drop

  hdr _public,'MIN'
min:
  pop de
  pop hl
  call compare_de_hl_signed
  jp max.2

; UMAX  ( u1 u2 -- u1 | u2 )  2dup u< if swap then drop

  hdr _public,'UMAX'
u_max:
  pop de
  pop hl
  call compare_de_hl_unsigned
  jp max.1

; UMIN  ( u1 u2 -- u1 | u2 )  2dup u> if swap then drop

  hdr _public,'UMIN'
u_min:
  pop de
  pop hl
  call compare_de_hl_unsigned
  jp max.2

; WITHIN  ( n1|u1 n2|u2 n3|u3 -- flag )  over - >r - r> u<

  hdr _public,'WITHIN'
within:
  pop hl
  pop de
  call hl_minus_de_to_hl
  ex (sp),hl
  call hl_minus_de_to_hl
  jp u_greater.1

; BETWEEN  ( n1|u1 n2|u2 n3|u3 -- flag )  over - -rot - u< 0=

  hdr _public,'BETWEEN'
between:
  pop hl
  pop de
  call hl_minus_de_to_hl
  ex (sp),hl
  call hl_minus_de_to_hl
  pop de
  call compare_de_hl_unsigned
  jp z,true
  jp zero_less.2

; D0=  ( d -- flag )  or 0=

  hdr _public,'D0='
d_zero_equals:
  call do_colon
  dw or_,zero_equals
  dw exit

; D=  ( d1 d2 -- flag )

  hdr _public,'D='
d_equals:
  pop de
  pop hl
  ex (sp),hl
  call compare_de_hl_unsigned
  pop de
  pop hl
  jp nz,false
  jp equals.1

; D0<  ( d -- flag )  swap drop 0<

  hdr _public,'D0<'
d_zero_less:
  pop hl
  pop de
  jp zero_less.1

; D<  ( d1 d2 -- flag ) rot 2dup = if 2drop u< exit then 2nip >

  hdr _public,'D<'
d_less:
  pop de
  pop hl
  ex (sp),hl
  call compare_de_hl_unsigned
  jp z,u_less
  inc sp
  inc sp
  inc sp
  inc sp
  jp zero_greater.1

; DU<  ( ud1 ud2 -- flag )  rot swap 2dup u< if 2drop 2drop -1 exit
;         then - if 2drop 0 exit then u<

  hdr _public,'DU<'
d_u_less:
  pop de
  pop hl
  ex (sp),hl
  call compare_de_hl_unsigned
  pop de
  pop hl
  jp c,true
  jp nz,false
  jp u_less.1

; DMIN  ( d1 d2 -- d1 | d2 )  2over 2over d< 0= if 2swap then 2drop

  hdr _public,'DMIN'
d_min:
  call do_colon
  dw two_over,two_over
  dw d_less,zero_equals
d_min.1:
  dw question_branch,d_min.2
  dw two_swap
d_min.2:
  dw two_drop
  dw exit

; DMAX  ( d1 d2 -- d1 | d2 )  2over 2over d< if 2swap then 2drop

  hdr _public,'DMAX'
d_max:
  call do_colon
  dw two_over,two_over
  dw d_less
  dw branch,d_min.1

; }}} **********************************************************
; Numeric conversion {{{ 

; DECIMAL  ( -- )    10 base !

  hdr _public,'DECIMAL'
decimal:
  call do_colon
  dw c_lit
  db 10
  dw base,store
  dw exit

; HEX  ( -- )    16 base !

  hdr _public,'HEX'
hex:
  call do_colon
  dw c_lit
  db 16
  dw base,store
  dw exit

; DIGIT  ( c base -- u -1 | 0 )

  hdr _hidden,'DIGIT'
digit:
  pop hl
  pop de
  ld a,e
  call uppercase_a
  sub  '0'
  jp m,false
  cp 10
  jp m,digit.1
  sub  7
  cp 10
  jp m,false
digit.1:
  cp l
  jp p,false
  ld e,a
  push de
  jp true

; >NUMBER  ( d1 a1 u1 -- d2 a2 u2 )
;        begin dup while over c@ base @ digit while
;        >r 2swap r> swap base @ um* drop rot base @
;        um* d+ 2swap 1 /string 1 dpl +! repeat then

  hdr _public,'>NUMBER'
to_number:
  call do_colon
to_number.1:
  dw dup    ; begin
  dw question_branch,to_number.2  ; while
  dw over,c_fetch
  dw base,fetch
  dw digit
  dw question_branch,to_number.2  ; while
  dw to_r
  dw two_swap,from_r
  dw swap
  dw base,fetch
  dw umstr,drop
  dw rot
  dw base,fetch
  dw umstr
  dw d_plus
  dw two_swap
  dw one,sstr
  dw one,dpl,plus_store
  dw branch,to_number.1  ; repeat
to_number.2:
  dw exit    ; then

; NUMBER?  ( ca u -- d -1 | 0 )
;        over c@ [char] - = over 0> and dup >r 1
;        and /string over c@ [char] . > and 0 0
;        2swap ?dup if >number dpl on dup if 1-
;        over c@ [char] . - or dpl off then while
;        then r> 2drop 2drop false else drop r> if
;        dnegate then true then

  hdr _public,'NUMBER?'
number_question:
  call do_colon    ; convert string to double number
  dw over,c_fetch
  dw c_lit
  db '-'
  dw equals
  dw over,zero_greater
  dw and_
  dw dup,to_r
  dw one,and_
  dw sstr
  dw over,c_fetch
  dw c_lit
  db '.'
  dw greater,and_
  dw zero,zero
  dw two_swap
  dw question_dup
  dw question_branch,number_question.2
  dw to_number
  dw dpl,on
  dw dup
  dw question_branch,number_question.1
  dw one_minus
  dw over,c_fetch
  dw c_lit
  db '.'
  dw minus,or_
  dw dpl,off
number_question.1:
  dw question_branch,number_question.3
number_question.2:
  dw from_r
  dw two_drop,two_drop
  dw false
  dw branch,number_question.5
number_question.3:
  dw drop
  dw from_r
  dw question_branch,number_question.4
  dw d_negate
number_question.4:
  dw true
number_question.5:
  dw exit

; <#  ( -- )    pad hld !

  hdr _public,'<#'
bdigs:
  call do_colon
  dw pad
  dw hld,store
  dw exit

; #>  ( d -- ca u )  2drop hld @ pad over -

  hdr _public,'#>'
edigs:
  call do_colon
  dw two_drop
  dw hld,fetch
  dw pad
  dw over
  dw minus
  dw exit

;  +hld ( +n -- ca )  negate hld +! hld @ dup dp @ u<
;        abort" HOLD buffer overflow"

  hdr _hidden,'+HLD'
phld:
  call do_colon
  dw negate,hld,plus_store
  dw hld,fetch,dup
  dw dp,fetch,u_less
  dw paren_abort_quote
  dcs 'HOLD buffer overflow'
  dw exit

;  HOld ( c -- )  1 +hld c!

  hdr _public,'HOLD'
hold:
  call do_colon
  dw one,phld
  dw c_store
  dw exit

; SIGN  ( n -- )    0< if [char] - hold then

  hdr _public,'SIGN'
sign:
  call do_colon
  dw zero_less
  dw question_branch,sign.1
  dw c_lit
  db '-'
  dw hold
sign.1:
  dw exit

; #  ( ud1 -- ud2 )  0 base @ um/mod >r base @ um/mod r>
;        rot 9 over < if 7 + then [char] 0 + hold

  hdr _public,'#'
dig:
  call do_colon
  dw zero
  dw base,fetch
  dw umslm
  dw to_r
  dw base,fetch
  dw umslm
  dw from_r
  dw rot
  dw c_lit
  db 9
  dw over,less
  dw question_branch,dig.1
  dw c_lit
  db 7
  dw plus
dig.1:
  dw c_lit
  db '0'
  dw plus
  dw hold
  dw exit

; #S  ( +d -- 0 0 )  begin # 2dup d0= until

  hdr _public,'#S'
digs:
  call do_colon
digs.1:
  dw dig
  dw two_dup,d_zero_equals
  dw question_branch,digs.1
  dw exit

;  SHOld ( ca u -- )  dup +hld swap move

  hdr _public,'SHOLD'  ; hold string
shold:
  call do_colon
  dw dup,phld
  dw swap,move
  dw exit

;  NHOld ( n c -- )  over +hld -rot fill

  hdr _public,'NHOLD'  ; hold n characters
nhold:
  call do_colon
  dw over,phld
  dw minus_rot,fill
  dw exit

;  decimal? ( -- flag )  base @ 10 =

  hdr _hidden,'DECIMAL?'
decimal_question:
  call do_colon
  dw base,fetch    ; decimal base?
  dw c_lit
  db 10
  dw equals
  dw exit

; }}} **********************************************************
; String functions {{{ 

; CMOVE  ( ca1 ca2 u -- )

  hdr _public,'CMOVE'
cmove:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
cmove.1:
  call move_block_downwards
  pop bc
  jp next

; CMOVE>  ( ca1 ca2 u -- )

  hdr _public,'CMOVE>'
cmovu:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
cmovu.1:
  call move_block_upwards
  pop bc
  jp next

; BLANK  ( ca u -- )  bl fill

  hdr _public,'BLANK'
blank:
  ld e,' '
  jp fill.1

; COUNT  ( ca1 -- ca2 u )  dup 1+ swap c@

  hdr _public,'COUNT'
count:
  pop de
;;count.1: ; XXX OLD
  ld a,(de)
  inc de
  push de
  jp push_a

; PACKED  ( ca1 u ca2 -- ca2 )
;            2dup 2>r 1+ swap move 2r> tuck c!

  hdr _public,'PACKED'
packed:
  ld l,c
  ld h,b
  pop de
  pop bc
  ex (sp),hl
  push bc
  push de
  inc  de
  call move_block
  pop hl
  pop de
  ld (hl),e
  pop bc
  push hl
  jp next

; PLACE  ( ca1 u ca2 -- )  packed drop

  hdr _public,'PLACE'
place:
  call do_colon
  dw packed,drop
  dw exit

; XXX OLD -- DX-Forth 4.00
;;; PLACE  ( ca1 u ca2 -- )  2dup 2>r 1+ swap move 2r> c!
;;
;;  header 1,'PLACE'
;;place:
;;  call do_colon
;;  dw two_dup
;;  dw two_to_r
;;  dw one_plus,swap
;;  dw move
;;  dw two_from_r
;;  dw c_store
;;  dw exit

; AFFIX  ( ca c -- ca )  over count + c!

  ; append char to counted string
  ; count unchanged
  hdr _hidden,'AFFIX'
affix:
  call do_colon
  dw over
  dw count,plus
  dw c_store
  dw exit

; SCAN  ( ca1 u1 c -- ca2 u2 )

  hdr _public,'SCAN'
scan:
  pop de
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
scan.1:
  ld a,c
  or b
  jp z,scan.2
  ld a,e
  cp (hl)
  jp z,scan.2
  inc hl
  dec bc
  jp scan.1

scan.2:
  ex (sp),hl
scan.3:
  push bc
  ld c,l
  ld b,h
  jp next

; SKIP  ( ca1 u1 c -- ca2 u2 )

  hdr _public,'SKIP'
skip:
  pop de
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
skip.1:
  ld a,c
  or b
  jp z,scan.2
  ld a,e
  cp (hl)
  jp nz,scan.2
  inc hl
  dec bc
  jp skip.1

; -TRAILING  ( ca u1 -- ca u2 )

  hdr _public,'-TRAILING'
dtrai:
  pop de
  pop hl
  push hl
  add hl,de
  ex de,hl
dtrai.1:
  dec de
  ld a,l
  or h
  jp z,push_hl
  ld a,(de)
  cp ' '
  jp nz,push_hl
  dec hl
  jp dtrai.1

; /STRING  ( ca1 u1 n -- ca2 u2 )   rot over + -rot -

  hdr _public,'/STRING'
sstr:
  pop de
  pop hl
  call hl_minus_de_to_hl
  ex (sp),hl
  add hl,de
  ex (sp),hl
  push hl
  jp next

; XXX OLD 
;;; CAPS  ( -- )
;;; enable caps COMPARE/SEARCH
;;; XXX TODO use a user variable instead
;;  hdr _public,'CAPS'
;;caps:
;;  ld a,1
;;  jp dcaps.1
;;
;;; -CAPS  ( -- )
;;;   disable caps COMPARE/SEARCH
;;; XXX TODO use a user variable instead
;;  hdr _hidden,'-CAPS'
;;dcaps:
;;  xor a
;;dcaps.1:
;;  ld (scaps),a
;;  jp next

patch_compare_strings:

  ; Patch an address with the address of the routine 'compare' and 'search' use
  ; to compare strings, which depends on a user variable.
  ;
  ; This routine is called at the start of 'compare' and 'search', in order to
  ; patch themselves.

  ; Input:
  ;   DE = address to patch with the routine address

  push bc
  ld hl,(user_data_pointer)
  ld bc,case_sensitive_search_user_variable
  add hl,bc
  ld a,(hl)
  inc hl
  ld l,(hl)
  or l ; case sensitive search?
  ld hl,compare_strings_case_insensitive ; routine
  jp z,patch_compare_strings.end
  ld hl,compare_strings_case_sensitive ; routine
patch_compare_strings.end:
  ex de,hl
  ld (hl),e
  inc hl
  ld (hl),d
  pop bc
  ret

compare_strings_case_insensitive:
  ; Used by 'compare' and 'search'.
  ; Input:
  ;   HL = a1
  ;   BC = a2
  ;   DE = len
  ; Output:
  ;   Z = match?
  ld a,e
  or d
  ret z
  push bc
  ld a,(bc)
  call uppercase_a
  ld c,a
  ld a,(hl)
  call uppercase_a
  cp c
  pop bc
  ret nz
  inc hl
  inc bc
  dec de
  jp compare_strings_case_insensitive

; XXX OLD -- substituted by 'patch_compare_strings'
;;compare_strings:
;;  ; Input:
;;  ;   HL = a1
;;  ;   BC = a2
;;  ;   DE = len
;;  ; Output:
;;  ;   Z = match?
;;  push hl
;;  push de
;;  ld hl,(user_data_pointer)
;;  ld de,case_sensitive_search_user_variable
;;  add hl,de
;;  ld a,(hl) ; XXX TODO -- check the whole cell?
;;  or a
;;  pop de
;;  pop hl
;;  jp nz,compare_strings_case_insensitive

compare_strings_case_sensitive:
  ; Used by 'compare' and 'search'.
  ; Input:
  ;   HL = a1
  ;   BC = a2
  ;   DE = len
  ; Output:
  ;   Z = match?
  ld a,e
  or d
  ret z
  ld a,(bc)
  cp (hl)
  ret nz
  inc hl
  inc bc
  dec de
  jp compare_strings_case_sensitive

; COMPARE  ( ca1 u1 ca2 u2 -- -1 | 0 | 1 )

  hdr _public,'COMPARE'
compare:
  ld de,compare.compare_strings
  call patch_compare_strings
  pop de
  pop hl
  ex (sp),hl
  ld a,d
  cp h
  jp nz,compare.1
  ld a,e
  cp l
compare.1:
  jp c,compare.2
  ex de,hl
compare.2:
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
  push af
compare.compare_strings: equ $+1
  call 0 ; modifed
  jp z,compare.4
  pop bc
compare.3:
  pop bc
; XXX OLD -- Why this?:
;;  ld a,0
;;  ld (scaps),a
  jp c,one
  jp z,false
  jp true

compare.4:
  pop af
  jp compare.3

; SEARCH  ( ca1 u1 ca2 u2 -- ca3 u3 -1 | ca1 u1 0 )

  hdr _public,'SEARCH'
search:
  ld de,search.compare_strings
  call patch_compare_strings
  call do_colon
  dw $+2
  pop hl
  ld (string_2_len),hl
  ld a,l
  or h
  pop bc
  pop hl
  ld (string_1_len),hl
  ex de,hl
  pop hl
  ld (string_1_addr),hl
  jp z,search.2
  dec hl
  inc de
search.1:
  inc hl
  dec de
  ld a,e
  or d
  jp z,search.4
; XXX commented out in DX-Forth:
; ld a,(bc)
; CP  (hl)
; jp nz,search.1
  push de
  push bc
  push hl
  ex de,hl
string_2_len equ $+1
  ld hl,0  ; length of the second string
  ex de,hl
search.compare_strings: equ $+1
  call 0 ; modified
  pop hl
  pop bc
  pop de
  jp nz,search.1

search.2:
  ld bc,-1
search.3:
  push hl
  push de
  push bc
; XXX OLD -- Why this?
;;  xor a
;;  ld (scaps),a
  jp exit

search.4:
  ld bc,0
string_1_len equ $+1
  ld hl,0  ; length of the first string
  ex de,hl
string_1_addr equ $+1
  ld hl,0  ; address of the first string
  jp search.3

;;; +STRING  ( ca1 u1 ca2 u2 -- ca2 u3)
;;;         2swap swap 2over + 2 pick cmove +
;;
;;  header 1,'+STRING'
;;pstr:
;;  call do_colon
;;  dw two_swap,swap
;;  dw two_over,plus
;;  dw two,pick
;;  dw cmove,plus
;;  dw exit

; XXX NEW -- DX-Forth 4.09
; +STRING  ( ca1 u1 ca2 u2 -- ca2 u3)
;          2swap swap 2over + 2 pick cmove +

  hdr _public,'+STRING'  ; uses temps 1-3
pstr:
  ld l,c
  ld h,b
  ld (t3),hl    ; bsave
  pop de
  pop hl
  ld (t2),hl    ; a2
  add hl,de
  ex de,hl
  pop bc
  add hl,bc
  ld (t1),hl    ; u3
  pop hl
  call move_block_downwards
  ld hl,(t3)    ; bsave
  ld c,l
  ld b,h
  ld hl,t1
  jp two_fetch.hl

; XXX TMP
t1: ds cw
t2: ds cw
t3: ds cw

; XXX NEW -- DX-Forth 4.09
; S.R  ( ca n1 n2 -- )  over - spaces type

  hdr _public,'S.R'    ; type string right-justified
s_dot_r:
  call do_colon
  dw over,minus
  dw spaces
  dw type
  dw exit

; UPCASE  ( c1 -- c2 )

  ; XXX FIXME repeated
  hdr _public,'UPCASE'  ; make char uppercase
upcas:
  pop hl
  ld a,l
  call uppercase_a
  jp push_a

; UPPER  ( ca u -- )

  hdr _public,'UPPER' ; make string uppercase
upper:
  pop de
  pop hl
upper.1:
  ld a,d
  or e
  jp z,next
  ld a,(hl)
  call uppercase_a
  ld (hl),a
  inc hl
  dec de
  jp upper.1

; XXX NEW -- after Gforth
; TOUPPER  ( c1 -- c2 )

  hdr _public,'TOUPPER' ; make char uppercase

toupper:
  pop hl
  ld a,l
  call uppercase_a
  jp next

uppercase_a:
  cp 'a'
  ret c
  cp 'z'+1
  ret nc
  xor 0x20
  ret

; XXX NEW -- after UPPER
; LOWER  ( ca u -- )

  hdr _public,'LOWER' ; make string lowercase
lower:
  pop de
  pop hl
lower.1:
  ld a,d
  or e
  jp z,next
  ld a,(hl)
  call lowercase_a
  ld (hl),a
  inc hl
  dec de
  jp lower.1

; XXX NEW -- after TOUPPER
; TOLOWER  ( c1 -- c2 )

  hdr _public,'TOLOWER' ; make char lowercase

tolower:
  pop hl
  ld a,l
  call lowercase_a
  jp next

lowercase_a:
  cp 'A'
  ret c
  cp 'Z'+1
  ret nc
  xor 0x20
  ret

; }}} **********************************************************
; Control structures {{{

; (OF)  ( n1 n2 -- )

  hdr _hidden,'(OF)'
paren_of:
  pop hl
  pop de
  call hl_minus_de_to_hl
  ld a,l
  or h ; hl equal de?
  jp z,question_branch.1
  push de
; jp branch ; XXX commented out in DX-Forth

; BRANCH  ( -- )

  hdr _hidden,'BRANCH'
branch:
  ld h,b
  ld l,c
  ld c,(hl)
  inc hl
  ld b,(hl)
  jp next

; <>0BRANCH  ( flag -- )

  hdr _hidden,'?BRANCH'
not_equals_0_branch:
branch_if_true:
branch_if_not_false:
branch_if_not_0:
branch_if_not_zero:
  pop hl
  ld a,l
  or h
  jp nz,branch
  jp question_branch.1

; ?BRANCH  ( flag -- )

  hdr _hidden,'?BRANCH'
question_branch:
zero_branch:
branch_if_false:
branch_if_0:
  pop hl
  ld a,l
  or h
  jp z,branch
question_branch.1:
  inc bc
  inc bc
  jp next

; (LOOP)  ( -- )

  hdr _hidden,'(LOOP)'
paren_loop:
  ld hl,(return_stack_pointer)
  inc (hl)
  jp nz,branch
  inc hl
  inc (hl)
  jp nz,branch
paren_loop.1:
  inc bc    ; skip over branch
  inc bc
; jp unloo

; UNLOOP  ( -- )

  hdr _public,'UNLOOP'
unloo:
  ld hl,(return_stack_pointer)  ; discard loop parameters
  ld de,cw*2
  add hl,de
  ld (return_stack_pointer),hl
  jp next

; (+LOOP)  ( n -- )

  hdr _hidden,'(+LOOP)'
paren_plus_loop:
  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  pop hl
  ld a,h
  or a
  jp m,paren_plus_loop.2
  add hl,de
  jp c,paren_loop.1
paren_plus_loop.1:
  ex de,hl
  ld hl,(return_stack_pointer)
  ld (hl),e
  inc hl
  ld (hl),d
  jp branch

paren_plus_loop.2:
  add hl,de
  jp c,paren_plus_loop.1
  jp paren_loop.1

; (LEAVE)  ( -- )

  hdr _hidden,'(LEAVE)'
paren_leave:
  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a
  ld c,(hl)
  inc hl
  ld b,(hl)
  jp unloo

; (?DO)  ( n1 n2 -- ) 2dup = if 2drop r> @ >r exit then (do1)

  hdr _hidden,'(?DO)'
paren_question_do:
  call do_colon
  dw two_dup,equals
  dw question_branch,paren_do.1
  dw two_drop
  dw from_r,fetch,to_r
  dw exit

; (DO)  ( n1 n2 -- )    over - r> cell+ -rot 2>r >r

  hdr _hidden,'(DO)'
paren_do:
  call do_colon
paren_do.1: ; '(?do)' jumps here
  dw over,minus
  dw from_r,cell_plus
  dw minus_rot
  dw two_to_r
  dw to_r
  dw exit

; BAL  ( -- a )

  hdr _hidden,'BAL'
bal:
  call do_create
bal.1:
  ds 2

; +BAL  ( -- )      1 bal +!

  hdr _public,'+BAL'
plus_bal:
  ld de,1
plus_bal.1:
  ld hl,bal.1
  jp plus_store.1

; -BAL  ( -- )      -1 bal +!

  hdr _public,'-BAL'
minus_bal:
  ld de,-1
  jp plus_bal.1

; ?BAL  ( flag -- )   checking @ 0<> and
;         abort" definition unbalanced"

  hdr _public,'?BAL'
question_bal:
  call do_colon
  dw check,fetch
  dw zero_not_equals,and_
  dw paren_abort_quote
  dcs 'definition unbalanced'
  dw exit

; ?DEPTH  ( x -- x )    ?comp depth 0= ?bal

  hdr _hidden,'?DEPTH'
question_depth:
  call do_colon
  dw question_comp
  dw depth,zero_equals
  dw question_bal
  dw exit

; ?ORIG  ( orig -- orig )   ?depth dup @ ?bal

  hdr _hidden,'?ORIG'
question_orig:
  call do_colon
  dw question_depth
  dw dup,fetch
  dw question_bal
  dw exit

; ?DEST  ( dest -- dest )   ?depth dup @ 0= ?bal

  hdr _hidden,'?DEST'
qdest:
  call do_colon
  dw question_depth
  dw dup,fetch
  dw zero_equals
  dw question_bal
  dw exit

; BEGIN  ( -- dest )    ?comp here +bal ; immediate

  hdr _public,'BEGIN',_immediate
begin:
  call do_colon
  dw question_comp
  dw here
  dw plus_bal
  dw exit

; >MARK  ( -- orig )    postpone begin 0 ,

  hdr _public,'>MARK'
forward_mark:
  call do_colon
  dw begin
  dw zero
  dw comma
  dw exit

; <RESOLVE  ( dest -- )   ?dest , -bal

  hdr _public,'<RESOLVE'
backward_resolve:
  call do_colon
  dw qdest
  dw comma
  dw minus_bal
  dw exit

; THEN  ( orig -- )   ?orig here swap ! -bal ; immediate

  hdr _public,'THEN',_immediate
then:
  call do_colon
  dw question_orig
  dw here
  dw swap,store
  dw minus_bal
  dw exit

; IF  ( -- orig )     postpone ?branch >mark
;         ; immediate

  hdr _public,'IF',_immediate
iff:
  call do_colon
  dw compile,question_branch
  dw forward_mark
  dw exit

; AHEAD  ( -- orig )    postpone branch >mark
;         ; immediate

  hdr _public,'AHEAD',_immediate
ahead:
  call do_colon
  dw compile,branch
  dw forward_mark
  dw exit

; ELSE  ( orig1 -- orig2 )  ?orig postpone ahead swap postpone
;         then ; immediate

  hdr _public,'ELSE',_immediate
else_:
  call do_colon
  dw question_orig
  dw ahead
  dw swap
  dw then
  dw exit

; UNTIL  ( dest -- )    postpone ?branch <resolve
;         ; immediate

  hdr _public,'UNTIL',_immediate
until:
  ld hl,question_branch
until.1:
  push hl
  call do_colon
  dw compile_comma
  dw backward_resolve
  dw exit

; AGAIN  ( dest -- )    postpone branch <resolve ; immediate

  hdr _public,'AGAIN',_immediate
again:
  ld hl,branch
  jp until.1

; WHILE  ( x -- orig x )    ?depth postpone if swap ; immediate

  hdr _public,'WHILE',_immediate
while:
  call do_colon
  dw question_depth
  dw iff
  dw swap
  dw exit

; REPEAT  ( orig dest -- )  postpone again postpone then
;         ; immediate

  hdr _public,'REPEAT',_immediate
repeatt:
  call do_colon
  dw again
  dw then
  dw exit

; LV  ( -- a )     0 value lv

  hdr _hidden,'LV'
lv:
  call do_value
  dw 0

; DO  ( -- orig dest )    postpone (do) lv >mark dup to lv
;         postpone begin ; immediate

  hdr _public,'DO',_immediate
do:
  ld hl,paren_do
do1:
  push hl
  call do_colon
  dw compile_comma
  dw lv
  dw forward_mark
  dw dup
  dw paren_to,lv
  dw begin
  dw exit

; ?DO  ( -- orig dest )   postpone (?do) lv >mark dup to lv
;         postpone begin ; immediate

  hdr _public,'?DO',_immediate
qdo:
  ld hl,paren_question_do
  jp do1

; I  ( -- x )

  hdr _public,'I'
i_:
  ld hl,(return_stack_pointer)
i_.1:
  ld e,(hl)
  inc hl
  ld d,(hl)
i_.2:
  inc hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  add hl,de
  push hl
  jp next

if 0 ; XXX commented out in DX-Forth

; I'  ( -- x )

  hdr _public,"I'"
i_tick:
  ld hl,(return_stack_pointer)
  inc hl
  ld de,0
  jp i_.2

endif

; J  ( -- x )

  hdr _public,'J'
j:
  ld hl,(return_stack_pointer)
  ld de,cw*2
  add hl,de
  jp i_.1

; LEAVE  ( -- )     postpone (leave) lv ?orig ,
;         ; immediate

  hdr _public,'LEAVE',_immediate
leave:
  call do_colon
  dw compile,paren_leave
  dw lv
  dw question_orig
  dw comma
  dw exit

; LOOP  ( a1 a2 -- )  postpone (loop) <resolve
;         postpone then to lv ; immediate

  hdr _public,'LOOP',_immediate
loop:
  ld hl,paren_loop
loop.1:
  push hl
  call do_colon
  dw compile_comma
  dw backward_resolve
  dw then
  dw paren_to,lv
  dw exit

; +LOOP  ( a1 a2 -- )
;   postpone (+loop) <resolve
;   postpone then to lv ; immediate

  hdr _public,'+LOOP',_immediate
plus_loop:
  ld hl,paren_plus_loop
  jp loop.1

if control_flow_stack_extensions

; CS-PICK
;   pick +bal

  hdr _public,'CS-PICK'
cs_pick:
  call do_colon
  dw pick
  dw plus_bal
  dw exit

; CS-ROLL
;   aka roll cs-roll

  hdr _public,'CS-ROLL',,roll
cs_roll: equ roll

; CS-DROP
;   drop -bal

  hdr _public,'CS-DROP'
cs_drop:
  pop hl
  jp minus_bal

; CS0  ( -- a )
; control flow stack base

  hdr _hidden,'CS0'
cs0:
  call do_create
cs0.variable:
  ds cw

; #CS  ( -- cells )
;   sp@ cs0 @ - negate 2/ 1- 0 max

  hdr _hidden,'#CS'
ncs:
  ld hl,(cs0.variable)
  call negate_hl
  add hl,sp
  call negate_hl
  call sra_hl
  dec hl
  push hl
  jp zero_max

; CS-PUSH
;   #cs -roll

  hdr _public,'CS-PUSH'
cs_push:
  call do_colon
  dw ncs
  dw minus_roll
  dw exit

; CS-POP        #cs roll

  hdr _public,'CS-POP'
cs_pop:
  call do_colon
  dw ncs
  dw roll
  dw exit

; CS-MARK
;   0 +bal

  hdr _public,'CS-MARK'
cs_mark:
  ld hl,0
  push hl
  jp plus_bal

; CS-TEST
;   ?depth dup 0<>

  hdr _public,'CS-TEST'
cs_test:
  call do_colon
  dw question_depth
  dw dup
  dw zero_not_equals
  dw exit

; COND
;   ?comp cs-mark ; immediate

  hdr _public,'COND',_immediate
cond:
  call do_colon
  dw question_comp
  dw cs_mark
  dw exit

; THENS       ?comp begin cs-test while postpone
;         then repeat cs-drop ; immediate

  hdr _public,'THENS',_immediate
thens:
  call do_colon
  dw question_comp
thens.1:
  dw cs_test
  dw question_branch,thens.2
  dw then
  dw branch,thens.1
thens.2:
  dw cs_drop
  dw exit

else ; no control_flow_stack_extensions

; COND        ?comp 0 +bal ; immediate

  hdr _public,'COND',_immediate
cond:
  call do_colon
  dw question_comp
  dw zero
  dw plus_bal
  dw exit

; THENS   
;   ?comp begin ?depth ?dup while
;   postpone then repeat -bal ; immediate

  hdr _public,'THENS',_immediate
thens:
  call do_colon
  dw question_comp
thens.1:
  dw question_depth
  dw question_dup
  dw question_branch,thens.2
  dw then
  dw branch,thens.1
thens.2:
  dw minus_bal
  dw exit

endif ; control_flow_stack_extensions

; Eaker/ANS CASE support
;
; N.B. OF may be used in the form:  COND .. OF .. ELSE .. THENS

; OF  ( -- a )     postpone (of) >mark ; immediate

  hdr _public,'OF',_immediate
of:
  call do_colon
  dw compile,paren_of
  dw forward_mark
  dw exit

; ENDOF  ( a1 -- a2 )
;   aka else endof

  hdr _public,'ENDOF',_immediate,else_
endof: equ else_

; CASE  ( -- sys )
;   aka cond case

  hdr _public,'CASE',_immediate,cond
case: equ cond

; ENDCASE  ( sys -- )
;   postpone drop postpone thens
;   ; immediate

  hdr _public,'ENDCASE',_immediate
endcase:
  call do_colon
  dw compile,drop
  dw thens
  dw exit

; [ELSE]  ( -- )
;   1
;   begin
;     token 2dup upper dup if
;       2dup s" [IF]" compare if
;         2dup s" [ELSE]" compare if
;           s" [THEN]" compare 0=
;         else
;           2drop dup 1 =
;         then
;       else
;         2drop 1
;       then +
;     else
;       2drop refill and
;     then
;     ?dup 0=
;   until
; ; immediate

  hdr _public,'[ELSE]',_immediate
bracket_else:
  call do_colon
  dw one
bracket_else.1:
  dw token
  if case_insensitive_names
    dw two_dup,upper
  endif
  dw dup
  dw question_branch,bracket_else.6
  dw two_dup
  dw paren_s_quot
  dcs '[IF]'
  dw compare
  dw question_branch,bracket_else.4
  dw two_dup
  dw paren_s_quot
  dcs '[ELSE]'
  dw compare
  dw question_branch,bracket_else.2
  dw paren_s_quot
  dcs '[THEN]'
  dw compare,zero_equals
  dw branch,bracket_else.3
bracket_else.2:
  dw two_drop
  dw dup,one,equals
bracket_else.3:
  dw branch,bracket_else.5
bracket_else.4:
  dw two_drop,one
bracket_else.5:
  dw plus
  dw branch,bracket_else.7
bracket_else.6:
  dw two_drop
  dw refill,and_
bracket_else.7:
  dw question_dup,zero_equals
  dw question_branch,bracket_else.1
  dw exit

; [IF]  ( flag -- )
; 0= if [compile] [else] then ; immediate

  hdr _public,'[IF]',_immediate
bracket_if:
  pop hl
  ld a,l
  or h
  jp z,bracket_else
  jp next

; [THEN]  ( -- )
;   aka noop [then] immediate

  hdr _public,'[THEN]',_immediate,noop
bracket_then: equ next

; }}} **********************************************************
; Numeric output {{{

; (D.)  ( d -- ca u )  tuck dabs <# #s rot sign #>

  hdr _public,'(D.)'
paren_d_dot:
  call do_colon
  dw tuck
  dw d_abs
  dw bdigs
  dw digs
  dw rot,sign
  dw edigs
  dw exit

; U.R  ( u1 u2 -- ) 0 swap d.r

  hdr _public,'U.R'
udotr:
  ld hl,0
  ex (sp),hl
  push hl
  jp d_dot_r

; XXX OLD -- DX-Forth 4.00
;;; D.R  ( d u -- )   >r (d.) r> over - spaces type
;;
;;  header 1,'D.R'
;;d_dot_r:
;;  call do_colon
;;  dw to_r
;;  dw paren_d_dot
;;d_dot_r.1:
;;  dw from_r
;;  dw over,minus
;;  dw spaces
;;  dw type
;;  dw exit

; XXX NEW -- DX-Forth 4.09
; D.R  ( d n -- )   >r (d.) r> s.r

  hdr _public,'D.R'
d_dot_r:
  call do_colon
  dw to_r
  dw paren_d_dot
d_dot_r.1:
  dw from_r
  dw s_dot_r
  dw exit

; .R  ( n u -- )    >r s>d r> d.r

  hdr _public,'.R'
dot_r:
  call do_colon
  dw to_r
  dw s_to_d
  dw from_r,d_dot_r
  dw exit

; U.  ( u -- )    0 d.

  hdr _public,'U.'
u_dot:
  ld hl,0
  push hl
  jp ddot

; D.  ( d -- )    0 d.r space

  hdr _public,'D.'
ddot:
  call do_colon
  dw zero,d_dot_r
  dw space
  dw exit

; XXX OLD -- DX-Forth 4.00
;;; ?  ( a -- )    @ .
;;
;;  header 1,'?'
;;ques:
;;  call do_colon
;;  dw fetch,dot
;;  dw exit

; XXX NEW -- DX-Forth 4.09
; ?  ( a -- )

  hdr _public,'?'
ques:
  pop hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  jp dot

; XXX OLD -- DX-Forth 4.00
;;; .  ( n -- )   s>d d.
;;
;;  header 1,'.'
;;dot:
;;  call do_colon
;;  dw s_to_d,ddot
;;  dw exit

; XXX NEW -- DX-Forth 4.09
; .  ( n -- )   decimal? if s>d d. exit then u.

  hdr _public,'.'
dot:
  call do_colon
;  dw decimal_question ; XXX FIXME -- undefined
  dw question_branch,dot.1
  dw s_to_d,ddot
  dw exit
dot.1:
  dw u_dot
  dw exit

; }}} **********************************************************
; DOS functions {{{

; FDOS  ( DE u -- HL A )

  hdr _public,'FDOS'
fdos:
  ; XXX OLD
;;  pop hl
;;  ld a,l
;;  pop de
;;  call bdoss
;;  push hl
;;  jp push_a
  ; XXX TODO
  jp next

; BDOS  ( DE u -- A )

  hdr _public,'BDOS'
bdos:
  ; XXX TODO
  call do_colon
  ; XXX OLD
;;  dw fdos,nip
  dw exit

; BIOS  ( BC u -- A )

  hdr _public,'BIOS'
bios:
  jp next
; XXX OLD
;;  pop  de
;;  ld a,e
;;  ld (bios_parameter_block),a
;;  pop  hl
;;  ld (bios_parameter_block+1),hl
;;  push  bc
;;  call biosj
;;  pop  bc
;;  jp push_a

; BIOSHL  ( DE BC u -- HL )

  hdr _public,'BIOSHL'
;biosh:
; XXX OLD
;;  pop  de
;;  ld a,e
;;  ld (bios_parameter_block),a
;;  pop  hl
;;  ld (bios_parameter_block+1),hl
;;  pop  hl
;;  ld (bios_parameter_block+3),hl
;;  push  bc
;;  call biosj
;;  pop  bc
;;  push hl
  jp next

; PC@  ( pa -- x )

  hdr _public,'PC@'    ; FIG P@
p_c_fetch:
  pop hl
  ld a,l
  ld (p_c_fetch.1),a
  in  a,(0)    ; modified
p_c_fetch.1  equ  $-1
  jp push_a

; PC!  ( x pa -- )

  hdr _public,'PC!'    ; FIG P!
p_c_store:
  pop hl
  pop de
  ld a,l
  ld (p_c_store.1),a
  ld a,e
  out  (0),a    ; modified
p_c_store.1  equ  $-1
  jp next

; ?TERMINAL  ( -- flag )

  hdr _hidden,'?TERMINAL'
qterm:
  call do_colon
; XXX OLD
;;  dw zero,two
;;  dw bios
; XXX TODO
  dw exit

; CONIN  ( -- c )
;
;       begin key? until 0 3 bios
;       (iofn+cw) @ over = if 0 bdos then

  hdr _hidden,'CONIN'
conin:
  call do_colon    ; console input
conin.1:
; XXX TODO
;;  dw key_question
;;  dw question_branch,conin.1
;;  dw zero,three
;;  dw bios
;;  dw lit,iofn+cw  ; ctl-C check
;;  dw fetch
;;  dw over,equals
;;  dw question_branch,conin.2
;;  dw zero,bdos  ; exit to CP/M
conin.2:
  dw exit

dcono:
  call do_colon
  dw two
  dw bdos,drop
  dw exit

bcono:
  call do_colon
  ; XXX OLD
;;  dw c_lit
;;  db 4
;;  dw bios,drop
  ; XXX TODO
  dw exit

; CONOUT  ( c -- )

  hdr _hidden,'CONOUT'
conout:
; XXX TODO
;;  pop  de
;;  ld a,e
;;  cp  ff
;;  jp z,cls
;;  push  de
;;  ld hl,(iofn)
;;  jp (hl)
  jp next

; LSTOUT  ( c -- )

  hdr _hidden,'LSTOUT'
lstout:
  call do_colon
  dw c_lit
  db 5
  dw bios,drop
  dw exit

; XXX OLD
;;;  ZENV  ( -- a )  return Z-System address (0=none)
;;
;;  header  1,'ZENV'
;;zenv:
;;  ld hl,(z3eadr)
;;  jp push_hl

; }}} **********************************************************
; Facility functions

; (MS)  ( ms -- )

  hdr _hidden,'(MS)'
paren_ms:
  pop de
paren_ms.1:
  ld a,e
  or d
  jp z,next
  ld hl,(speed)
  add hl,hl
  add hl,hl
  add hl,hl
paren_ms.2:
  ex (sp),hl    ; 19T
  ex (sp),hl    ; 19T
  ex (sp),hl    ; 19T
  ex (sp),hl    ; 19T
  push hl    ; 11T
  pop hl    ; 10T
  dec  hl    ; 6T
  ld a,0    ; 7T
  ld a,l    ; 4T
  or h    ; 4T
  jp nz,paren_ms.2    ; 10T
  dec  de
  jp paren_ms.1

; (BEEP)  ( -- )

  hdr _hidden,'(BEEP)'
paren_beep:
  call do_colon
  ; XXX TODO
  dw exit

; MS  ( ms -- )

  hdr _public,'MS'
ms:
  call fetch_execute
  dw paren_ms

; SOUND  ( freq ms -- )
;
;  header  1,'SOUND'
;sound:  call fetch_execute
;  dw sound0

; BEEP  ( -- )

  hdr _public,'BEEP'
beep:
  call fetch_execute
  dw paren_beep

cpbuf:
  ds 16

; AT-XY  ( u1 u2 -- )  position cursor at col u1, row u2

  hdr _public,'AT-XY'
atxy:
  ; XXX TODO
  jp next ; XXX TMP
;;  pop  de
;;  pop  hl
;;  ld d,l
;;  push  bc
;;  push  de
;;  ld hl,tgxy
;;  ld de,cpbuf
;;  ld a,16
;;  call amovd
;;  pop  de
;;  ld a,(txpos)
;;  ld c,a
;;  ld a,(txofs)
;;  add  a,d
;;  push  de
;;  call atxy.3
;;  pop  de
;;  ld a,(typos)
;;  ld c,a
;;  ld a,(tyofs)
;;  add  a,e
;;  call atxy.3
;;  pop  bc
;;  ld de,tgxyd
;;  ld hl,cpbuf
;;atxy.1:
;;  push  de
;;  push  hl
;;atxy.2:
;;  call do_colon
;;  dw count,tuck
;;  dw type    ; send string
;;  dw zero_not_equals
;;  dw swap,fetch
;;  dw and_,ms    ; delay only if string not empty
;;  dw exit
;;
;;atxy.3:
;;  ld hl,cpbuf
;;  ld b,0
;;  add  hl,bc
;;  ex de,hl
;;  ld hl,tisbin
;;  inc  (hl)
;;  dec  (hl)
;;  jp z,atxy.4
;;  ld (de),a
;;  ret
;;
;;atxy.4:
;;  dec  de
;;  dec  de
;;  ld hl,atxy.8-1
;;  ld b,3
;;atxy.5:
;;  inc  hl
;;  ld c,'0'-1
;;atxy.6:
;;  inc  c
;;  sub  (hl)
;;  jp nc,atxy.6
;;  add  a,(hl)
;;  push  af
;;  ld a,c
;;  cp  '0'
;;  jp z,atxy.7
;;  ld (de),a
;;atxy.7:
;;  inc  de
;;  pop  af
;;  dec  b
;;  jp nz,atxy.5
;;  ret
;;
;;atxy.8:
;;  db 100,10,1

; XXX NEW
; CLS  ( -- )
  hdr _public,'CLS'
;  XXX TODO -- call it from 'PAGE'

cls:
  save_ip
  call rom_cl_all
  ld a,2
  call rom_chan_open
  jp restore_ip_next
; XXX OLD
;;  call do_colon
;;  dw lit,tceold
;;  dw lit,thome
;;  dw atxy.2
;;  dw lit,tclsd
;;  dw lit,tcls
;;  dw atxy.2
;;  dw exit

; NORMAL  ( -- )

  hdr _public,'NORMAL'
vnorm:
; XXX TODO
  jp next
;;  ld hl,tlovid
;;vnorm.1:
;;  ld de,tceold
;;  jp atxy.1

; HIGHLIGHT  ( -- )

  hdr _public,'HIGHLIGHT'
hilit:
; XXX TODO
  jp next
;;  ld hl,thivid
;;  jp vnorm.1

; CLEAR-LINE  ( -- )

  hdr _public,'CLEAR-LINE'
cleol:
; XXX TODO
  jp next
;;  ld hl,tceol
;;  jp vnorm.1

; INSERT-LINE  ( -- )

  hdr _public,'INSERT-LINE'
insln:
; XXX TODO
  jp next
;;  ld hl,tinsln
;;insln.1:
;;  ld de,tclsd
;;  jp atxy.1

; DELETE-LINE  ( -- )

  hdr _public,'DELETE-LINE'
delln:
; XXX TODO
  jp next
;;  ld hl,tdelln
;;  jp insln.1

; XXX OLD
;;;  INIT-VIDEO  ( -- )
;;
;;  header  1,'INIT-VIDEO'
;;invid:  ld hl,tinit
;;  jp insln.1
;;
;;;  EXIT-VIDEO  ( -- )
;;
;;  header  1,'EXIT-VIDEO'
;;exvid:  ld hl,texit
;;  jp insln.1

; }}} **********************************************************
; Input/output functions

; PAUSE  ( -- )

  hdr _public,'PAUSE' ; multitasking support
pause:
  call fetch_execute
pause.1: ; XXX TODO rename this label
  dw 0   ; patched by COLD

; KEY?  ( -- flag )

  hdr _public,'KEY?'
key_question:
  ld hl,0 ; false
  ld a,(sys_last_k)
  and a
  jp z,push_hl
  dec hl  ; true
  jp push_hl

; XXX OLD
;;  call do_colon
;;  dw lit,vkeyq   ; (vkeyq)
;;  dw fetch_execute       ; @execute
;;  dw pause       ; pause
;;  dw exit

; KEY  ( -- c )

  hdr _public,'KEY'
key:
  ld a,(sys_last_k)
  ld (previous_key),a
key.1
;  call pause ; XXX FIXME this causes trouble because of the way 'pause' calls 'fetch_execute'
  ; call rom_keyboard ; XXX TODO not needed if system interrupts are on
  ld a,(sys_last_k)
previous_key equ $+1
  cp 0 ; a different key?
  jp z,key.1
  ld l,a ; save the key
  xor a
  ld (sys_last_k),a ; delete the last key
  jp push_l

; XXX OLD
;;  call do_colon
;;  dw lit,vkey
;;  dw fetch_execute
;;  dw pause
;;  dw exit

;;; INKEY  ( -- c ) ; XXX OLD -- try
  
;;  hdr _public,'INKEY'
;;inkey:

  ; XXX OLD Unfinished convertion from Benschop's Forth-83:
;;  push de
;;  call rom_keyboard
;;  jp nz,no_inkey
;;  call rom_key_test
;;  jp nc,no_inkey
;;  ld c,0
;;  dec d
;;  call rom_key_decode
;;  pop de
;;  ; jr continue ; XXX in 'pkey'
;;no_inkey
;;  pop de
;;  ld hl,0
;;  push hl
;;  jp next

; XXX unfinished conversion from Boriel's ZX BASIC; moved to 'KEY'
;;  call rom_key_scan
;;  jp z,inkey
;;  call rom_key_test
;;  jp nc,inkey
;;  dec d   ; D is expected to be FLAGS so set bit 3 $FF
;;          ; 'L' Mode so no keywords
;;  ld e, a ; main key to A
;;          ; C is MODE 0 'KLC' from above still
;;  call rom_key_decode
;;  jp push_a

; SPACE  ( -- )   bl emit

  hdr _public,'SPACE'
space:
  ld a,32
  jp emit_a

; EMIT  ( c -- )
  ; XXX TODO make it defered
  hdr _public,'EMIT'
emit:
  pop hl
emit_l:
  ld a,l
emit_a:
  rst 0x10
  jp pause

; XXX OLD
;;;   (vemit) @execute 1 out +! pause
;;  call do_colon
;;  dw lit,vemit
;;  dw fetch_execute
;;  dw one,outt,plus_store
;;  dw pause
;;  dw exit

; TYPE  ( ca u -- )
; 0max 0 ?do count emit loop drop
; XXX TODO use ROM call instead
  hdr _public,'TYPE'
type:

; XXX OLD
;;  call do_colon
;;  dw zero_max,zero
;;  dw paren_question_do,type.2
;;type.1:
;;  dw count,emit
;;  dw paren_loop,type.1
;;type.2:
;;  dw drop
;;  dw exit

  save_ip
  call rom_chan_s ; set print to screen
  pop bc ; length
  pop de ; address
  call rom_print_string
restore_ip_next: equ $
saved_ip: equ $+1
  ld bc,0 ; restore IP
  jp next

; SPACES  ( +n -- ) 0max 0 ?do space loop

  ; XXX TODO in assembly
  hdr _public,'SPACES'
spaces:
  call do_colon
  dw zero_max,zero ; 0max 0
  dw paren_question_do,spaces.2 ; ?do
spaces.1:
  dw space
  dw paren_loop,spaces.1 ; loop
spaces.2:
  dw exit

; CR  ( -- )

  hdr _public,'CR'
cr:
  ; XXX TODO -- printer too? lf_char?
  ld a,cr_char
  jp emit_a

; PAGE  ( -- )

  hdr _public,'PAGE'
page:
  ; XXX FIXME -- this is only for printer
  ld a,ff_char ; formfeed char
  jp emit_a

; CONSOLE  ( -- )   (vcon) @ (vemit) !
  ; set EMIT to terminal

  hdr _public,'CONSOLE'
console:
  ; XXX TODO
; XXX OLD
;;  ld hl,(vcon)
;;  ld (vemit),hl
  jp next

; PRINTER  ( -- )
  ; set EMIT to printer
  hdr _public,'PRINTER'
printer:
  ; XXX TODO
; XXX OLD
;;  ld hl,(vlst)
;;  ld (vemit),hl
  jp next

; }}} **********************************************************
; Compiler functions {{{

; WFIND  ( ca wid -- 0 | xt nfa -1 | xt nfa 1 )

  hdr _hidden,'WFIND'
wfind:
  call do_colon   ; save IP
  dw $+2
  pop hl
  ld a,l
  or h
  jp z,wfind.2  ; wid=0
  ld e,(hl)
  inc hl
  ld d,(hl)
wfind.1:
  pop hl    ; string
  push hl
  ld a,e   ; end of list?
  or d
  ex de,hl
  jp nz,wfind.3
wfind.2:
  pop de    ; discard string
  jp wfind.6    ; no match

wfind.3:
  push hl    ; save nfa
  ld c,(hl)
  ld a,c
  and 0x1f
  ld b,a   ; dict name length
  ld a,(de)    ; string length
  xor c   ; check lengths/smudge bit
  and 0x3f
  jp z,wfind.5
  inc hl    ; to link
wfind.4:
  inc hl
  dec b
  jp nz,wfind.4
  ld e,(hl)    ; next nfa
  inc hl
  ld d,(hl)
  pop hl    ; discard old
  jp wfind.1

wfind.5:
  inc hl    ; check each char
  inc de
  ld a,(de)
  if case_insensitive_names
    call uppercase_a
  endif
  ld c,a
  ld a,(hl)
  if case_insensitive_names
    call uppercase_a
  endif
  xor c
  jp nz,wfind.4 ; no match
  dec b
  jp nz,wfind.5
  inc hl    ; to link
  inc hl    ; to cfa pointer
  inc hl
  ld e,(hl)    ; get xt
  inc hl
  ld d,(hl)
  pop hl    ; nfa
  pop bc    ; discard string
  push de
  push hl
  ld a,(hl)
  and immediate_mask   ; immediate?
  ld hl,-1
  jp z,wfind.6
  inc hl
  inc hl
wfind.6:
  push hl
  jp exit    ; restore IP

; (FIND)  ( ca -- ca 0 | xt -1 | xt 1 )
  hdr _hidden,'(FIND)'; searches CONTEXT CURRENT FORTH
;       0 3 0 do over i cells context + @
;       wfind ?dup if nip 2nip leave then loop

paren_find:
  call do_colon
  dw zero
  dw three
  dw zero
  dw paren_do,paren_find.3
paren_find.1:
  dw over
  dw i_,cells
  dw cont,plus,fetch
  dw wfind,question_dup
  dw question_branch,paren_find.2
  dw nip,two_nip
  dw paren_leave,paren_find.1-cw
paren_find.2:
  dw paren_loop,paren_find.1
paren_find.3:
  dw exit

; FIND  ( ca -- ca 0 | xt -1 | xt 1 )

  hdr _public,'FIND'
find:
  call fetch_execute
  dw paren_find

   if 0

; SEARCH-WORDLIST  ( ca u wid -- 0 | xt -1 | xt 1 )
;       >r wpack r> wfind dup if nip then

  hdr _public,'SEARCH-WORDLIST'
search_wordlist:
  call do_colon
  dw to_r
  dw wpack
  dw from_r
  dw wfind
  dw dup
  dw question_branch,search_wordlist.1
  dw nip
search_wordlist.1:
  dw exit

endif

if warning_options

; -?  ( -- ) ; XXX OLD
; disable warnings for next definition only
; warning @ 0fffe and warning !

  hdr _public,'-?'
dques:
  ld hl,warning.1
  ld a,(hl)
  and 0xfe    ; clear bit 0
  ld (hl),a
  jp next

; WARNING?  ( -- 0|1 )
; get warning flag and apply mask
;     warning @ dup if dup 1 and tuck if -1
;     else $7fff and 1 then or warning ! then

  hdr _hidden,'WARNING?'
warning_question:
  call do_colon
  dw warning,fetch
  dw dup
  dw question_branch,warning_question.3
  dw dup,one,and_ ; test bit 0
  dw tuck
  dw question_branch,warning_question.1
  dw true    ; enable all warnings
  dw branch,warning_question.2
warning_question.1:
  dw lit,0x7fff  ; disable compile warning
  dw and_
  dw one   ; enable redefinition warning
warning_question.2:
  dw or_
  dw warning,store
warning_question.3:
  dw exit

endif

; IMMEDIATE  ( -- )

  hdr _public,'IMMEDIATE'
immediate:
  ld e,immediate_mask
  jp smudge.1

; SMUDGE  ( -- )
;   $20 xnfa

  hdr _public,'SMUDGE'
smudge:
  ld e,smudge_mask
smudge.1:
  push de
; jp xnfa

; XNFA  ( x -- )    toggle nfa bit

xnfa:
  ld hl,(last.1)
  jp c_toggle.1

; HEADER  ( xt|0 "name" -- )
;       warning? 2>r bl-word dup c@ 32 1 within
;       abort" invalid name" dup find nip r> and
;       if dup count type ."  is redefined "
;       then dup count tuck + get-current w>name
;       over ! cell+ swap 5 + dph @ over dph +!
;       dup get-current ! rot r> ?dup 0= if here
;       then dup rot ! over last 2! swap cmove

  hdr _hidden,'HEADER'
header:
  call do_colon
  if warning_options
    dw warning_question
  else
    dw warning,fetch
  endif
  dw two_to_r
  dw bl_word
  dw dup,c_fetch
  dw c_lit
  db 32
  dw one,within
  dw paren_abort_quote
  dcs 'invalid name'
  dw dup,find,nip
  dw from_r,and_
  dw question_branch,header.1
  dw dup,count,type
  dw paren_dot_quote
  dcs ' is redefined '
header.1:
  dw dup,count
  dw tuck
  dw plus
  dw getcur,wtnam
  dw over,store
  dw cell_plus,swap
  dw c_lit
  db 5
  dw plus
  dw dph,fetch
  dw over,dph,plus_store
  dw dup
  dw getcur
  dw store   ; CP/M version
  dw rot
  dw from_r,question_dup,zero_equals
  dw question_branch,header.2
  dw here
header.2:
  dw dup,rot,store
  dw over,last,two_store
  dw swap,cmove
  dw exit

; ,call ( a -- )  $CD c, ,

  hdr _hidden,',CALL'
comma_call:
  call do_colon
  dw c_lit
  db 0xcd    ; 'call' opcode
  dw c_comma
  dw comma
  dw exit

; BUILD ( xt "name" -- )

  hdr _public,'BUILD'
build:
  call do_colon
  dw zero,header  ; 0 header
  dw comma_call   ; ,call
  dw exit

; :  ( -- )
;       (do_colon) build smudge bal off !csp
;       sp@ cs0 ! ]

  hdr _public,':'
colon:
  call do_colon
  dw lit,do_colon
  dw build
  dw smudge
colon.1:
  dw bal,off
  dw store_csp
  if control_flow_stack_extensions
    dw sp_fetch
    dw cs0,store
  endif
  dw right_bracket
  dw exit

; EXIT  ( -- )
;   postpone (exit) ; immediate

  hdr _public,'EXIT',_immediate
exitt: ; XXX TODO rename 'exit'
  call do_colon
  dw compile,exit
  dw exit

; ;  ( -- )   postpone exit bal @ ?bal ?csp smudge
;       postpone [ ; immediate

  hdr _public,';',_immediate
semic:
  call do_colon
  dw exitt
  dw bal,fetch
  dw question_bal
  dw question_csp
  dw smudge
  dw left_bracket
  dw exit

; :NONAME  ( -- xt )  warning? drop here dup (dnfa) last 2!
;       (do_colon) ,call bal off !csp sp@ cs0 ! ]

  hdr _public,':NONAME'
nonam:
  call do_colon
  if warning_options
    dw warning_question,drop  ; allow -?
  endif
  dw here
  dw dup    ; allow RECURSE etc
  dw lit,dnfa  ; allow IMMEDIATE etc
  dw last,two_store
  dw lit,do_colon
  dw comma_call
  dw branch,colon.1

; (;CODE)     r> last cell+ @ 1+ !

  hdr _public,'(;CODE)'
paren_semicolon_code:
  ld hl,(last.2)
  inc hl
  ld (hl),c
  inc hl
  ld (hl),b
  jp exit

; DOES>

  hdr _public,'DOES>',_immediate
does:
  call do_colon
  dw compile,paren_semicolon_code   ; postpone (;code)
  dw lit,do_colon                   ; do_colon
  dw comma_call                     ; ,call
  dw exit

; CREATE  ( -- a ) 'next build

  hdr _public,'CREATE'
create:
  ld hl,next
  push hl
  jp build

; VARIABLE  ( -- a ) create 2 allot

  hdr _public,'VARIABLE'
var:
  call do_colon
  dw create
  dw two,allot
  dw exit

; VALUE  ( -- x )   (dotcon) build ,

  hdr _public,'VALUE'
value:
  call do_colon
value.1:
  dw lit,do_value
  dw build
  dw comma
  dw exit

; CONSTANT  ( -- x )  char? if (do_byte_constant) build c,
;       else value then

  hdr _public,'CONSTANT'
con:
  call do_colon
  dw char_question
  dw question_branch,value.1
  dw lit,do_byte_constant
  dw build
  dw c_comma
  dw exit

; 2VARIABLE  ( -- a )  create 4 allot

  hdr _public,'2VARIABLE'
two_variable:
  call do_colon
  dw create
  dw c_lit
  db 4
  dw allot
  dw exit

dotvar: equ next

; 2CONSTANT  ( -- x2 x1 )  (dotcon) build , ,

  hdr _public,'2CONSTANT'
two_constant:
  call do_colon
  dw lit,dotcon
  dw build
  dw comma,comma
  dw exit

dotcon: equ two_fetch   ; 2@

; USER  ( -- a )

  hdr _public,'USER'
user:
  call do_colon
  dw lit,do_user_variable
  dw build
  dw comma
  dw exit

; ADDR  ( "name" -- a )
; immediate, state-smart

  hdr _public,'ADDR',_immediate
addr:
  call do_colon
  dw tick,to_body           ; ' >body
  dw state_question         ; state?
  dw question_branch,addr.1 ; if
  dw literal                ;   postpone literal
addr.1:                     ; then
  dw exit

; (TO)  ( x -- )    r> dup cell+ >r @ >body !

  hdr _hidden,'(TO)'
paren_to:
  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a
  inc bc
  inc hl
  inc hl
  inc hl
  jp store.1

; TO  ( x "name" -- )
;
;   ' state? if postpone (to) , else >body !  then ; immediate
; state-smart

  hdr _public,'TO',_immediate
to:
  call do_colon
  dw tick
  dw state_question
  dw question_branch,to.1
  dw compile,paren_to,comma
  dw branch,to.end
to.1:
  dw to_body,store
to.end:
  dw exit

  ; XXX TODO rewrite
undef:
  call do_colon
  dw one
  dw paren_abort_quote
  dcs 'uninitiated DEFER'

; DEFER  ( "name" -- )

  hdr _public,'DEFER'
defer:
  call do_colon
  dw lit,fetch_execute  ; ['] @execute
  dw build              ; build
  dw lit,undef,comma    ; undef ,
  dw exit

; IS  ( xt "name" -- )

  hdr _public,'IS',_immediate,to  ; state-smart
is: equ to

paren_is: equ paren_to

; AKA  ( "oldname" "newname" -- )  defined tuck ?defined (header)
;         $80 xnfa 0> if immediate then
; XXX TODO ' alias' too
  hdr _public,'AKA'
aka:
  call do_colon
  dw defined_
  dw tuck,qdef
  dw header   ; equivalent of
  dw c_lit    ; ALIAS ( xt "newname" -- )
  db 0x80   ;
  dw xnfa    ;
  dw zero_greater
  dw question_branch,aka.1
  dw immediate
aka.1:
  dw exit

; }}} **********************************************************
; Constants {{{

; TRUE

  hdr _public,'TRUE'
true:
  ld hl,-1
  push hl
  jp next

; FALSE

  hdr _public,'FALSE'
false:
  ld hl,0
  push hl
  jp next

; -1  ( -- -1 )
;   aka true -1

  hdr _public,'-1',,true

; 0  ( -- 0 )
;   aka false 0

  hdr _public,'0',,false
zero: equ false

; 1  ( -- 1 )

  hdr _public,'1'
one:
  call do_byte_constant
  db 1

; 2  ( -- 2 )

  hdr _public,'2'
two:
  call do_byte_constant
  db 2

; 3  ( -- 3 )

  hdr _public,'3'
three:
  call do_byte_constant
  db 3

; BL  ( -- 32 )   ascii value for space character

  hdr _public,'BL'
bl:
  call do_byte_constant
  db sp_char

; B/BUF  ( -- u )  bytes per screen buffer

  hdr _public,'B/BUF'
bytes_per_buffer:
  call do_value
bytes_per_buffer.1:
  dw 128*8 ; default

; C/L  ( -- u )    chars per screen line

  hdr _public,'C/L'
csll:
  call do_value
  dw 64 ; default

; For applications, LIMIT is the upper limit of available memory.
; In forth, it is the beginning of the area which holds the screen file
; buffer, word headers and system definitions.

; LIMIT  ( -- a )

  hdr _public,'LIMIT'
limit:
  call do_value   ; application word - used by BUF
limit.1:
  ds cw    ; patched by COLD

; HBUF  ( -- a ) handle r/w buffer

  hdr _hidden,'HBUF'
hbuf:
  call do_value
hbuf.1:
  ds cw    ; patched by COLD

; 'NEXT  ( -- a )  address of NEXT

  hdr _public,"'NEXT"
tnext:
  call do_constant
tnext.1:
  dw next

; #FCB  ( -- u )    number of file handles

  hdr _public,'#FCB'
nfcb:
  call do_value
nfcb.1:
  dw max_open_file_handles

; SYS-VEC  ( -- a )  system vector table

; XXX -- This word is not used in DX-Forth.
; It appears only in <misc.fs>, but commented out.
; XXX TODO -- The useful values could be converted to variables.

  hdr _public,'SYS-VEC'
sysvec:
  call do_create

vkeyq:
  dw qterm   ;  0 KEY?
vkey:
  dw conin   ;  2 KEY
vemit:
  dw conout    ;  4 EMIT
vcon:
  dw conout    ;  6 CONSOLE out
vlst:
  dw lstout    ;  8 PRINTER out
ainit:
  dw do_f_init_patch   ; 10 FINIT patch
aident:
  dw do_f_identify_patch   ; 12 FIDENTIFY patch
afnumb:
  dw interpret.12    ; 14 FNUMBER patch
nfps:
  dw f_stack_size   ; 16 floating point stack size (bytes)
anumb:
  dw interpret.8   ; 18 NUMBER? patch
nfpm:
  dw f_stack_items*fw    ; 20 fp-stack min (bytes)
nrts:
  dw return_stack_size   ; 22 return stack (bytes)
nus:
  dw user_data_size    ; 24 user area (bytes)
npno:
  dw pictured_numeric_buffer_size   ; 26 HOLD buffer size (bytes)
;nmscon: ; XXX OLD
;  dw -2386   ; 28 MS timing constant 
;ntmode: ; XXX OLD
;  dw 3   ; 30 Timer 0 mode

; }}} **********************************************************
; Variables {{{

; UDP  ( -- a )
; user data pointer

  hdr _public,'UDP'
udp:
  call do_constant
  dw user_data_pointer

; FSP  ( -- a )  fp stack pointer

  hdr _public,'FSP'
fsp:
  call do_create
fspp:
  ds cw

; BOOT  ( -- xt )

  hdr _hidden,'BOOT'
boot:
  call do_create
boot_xt:
  dw 0

; SYS  ( -- a )
; compile system or application
; XXX OLD
  hdr _public,'SYS'
sys:
  call do_create   ; application word - used by HERE, UNUSED
sys.1:
  dw 0

; LAST  ( -- a ) occupies 2 cells
; XXX TODO separate

  hdr _hidden,'LAST'
last:
  call do_create
last.1:
  dw top_nfa    ; latest nfa
last.2:
  dw top_xt   ; latest xt

; BLK

  hdr _public,'BLK'
blk:
  call do_create
blk.variable:
  ds cw

; >IN

  hdr _public,'>IN'
in_:
  call do_create
in_.variable:
  ds cw

; SCR
; occupies 2 cells

  hdr _public,'SCR'
scr:
  call do_create
  ds 2*cw

; STATE

  hdr _public,'STATE'
state:
  call do_create
state.1:
  ds cw

; 'SOURCE     occupies 2 cells

  hdr _public,"'SOURCE"
tick_source:
  call do_create
tick_source.variable:
  ds 2*cw

; WARNING

  hdr _public,'WARNING'
warning:
  call do_create
warning.1:
  ds cw

; CSP

  hdr _public,'CSP'
csp:
  call do_create
csp.1:
  ds cw

; CHECKING

  hdr _public,'CHECKING'
check:
  call do_create
check.1:
  ds cw

; ERRMSG  ( -- a ) message holder for abort"

  hdr _hidden,'ERRMSG'
errmsg:
  call do_create
errmsg.1:
  ds 2*cw

; CONTEXT  ( -- a )

  hdr _public,'CONTEXT'
cont:
  call do_create
acont:
  ds cw    ; context
acurr:
  ds cw    ; current
  dw forth.1    ; forth

; GET-CONTEXT  ( -- wid )

  hdr _hidden,'GET-CONTEXT'
getcon:
  ld hl,(acont)
  push hl
  jp next

; GET-CURRENT  ( -- wid )

  hdr _public,'GET-CURRENT'
getcur:
  ld hl,(acurr)
  push hl
  jp next

; SET-CURRENT  ( wid -- )

  hdr _public,'SET-CURRENT'
setcur:
  ld hl,acurr
  jp store.1

; ZBUF  ( -- a )
; filename buffer pointers

  hdr _hidden,'ZBUF'
zbuf:
  call do_create
zbuf.1:
  dw zb.1 ; next buffer
  dw zb.2 ; last buffer

; }}} **********************************************************
; User variables {{{

; user variables 0, 2, 4 are reserved for multitasking

; S0  ( -- a )

  hdr _public,'S0'
s0:
  call do_user_variable
  dw 6

; R0  ( -- a )

  hdr _public,'R0'
r0:
  call do_user_variable
  dw 8

; DP  ( -- a )

  hdr _public,'DP'
dp:
  call do_user_variable
  dw 10

; XXX OLD
;;; DPH     system dictionary pointer
;;
;;  hdr _hidden,'DPH'
;; must follow DP
;;dph:
;;  call do_user_variable
;;  dw 12

dph: equ dp ; XXX NEW

; VOC-LINK  ( -- a )

  hdr _public,'VOC-LINK'
voc_link:
  call do_user_variable
  dw 14

; FS0  ( -- a )

  hdr _public,'FS0'
fs0:
  call do_user_variable
  dw 16

; user variable 18 reserved for future expansion

; End of boot-up literals

; DPL  ( -- a )

  hdr _public,'DPL'
dpl:
  call do_user_variable
  dw 20

; HLD  ( -- a )

  hdr _hidden,'HLD'
hld:
  call do_user_variable
  dw 22

; BASE  ( -- a )

  hdr _public,'BASE'
base:
  call do_user_variable
  dw 24

; bytes 26-27   reserved for locals

; OUT  ( -- a )

  hdr _public,'OUT'
outt:
  call do_user_variable
  dw 28

; bytes 30-33   reserved

; CATCHER  ( -- a )

  hdr _public,'CATCHER'
catcher:
  call do_user_variable
  dw 34

; bytes 36-43   reserved

; XXX NEW -- this substitutes the old 'scaps', 'caps' and '-caps'
; CASE-SENSITIVE-SEARCH  ( -- a )
; case flag for 'compare' and 'search'

  hdr _public,'CASE-SENSITIVE-SEARCH'
case_sensitive_search:
  call do_user_variable
case_sensitive_search_user_variable: equ 44
  dw case_sensitive_search_user_variable

; User area bytes 46 onwards are available for user applications

; }}} **********************************************************
; Forth system {{{

; SYS?  ( -- flag ) sys@ 0<>

  hdr _hidden,'SYS?'
sys_question:
  ld hl,sys.1
sysq.1:
  ; XXX TODO -- maybe faster: use A, OR and write PUSH_A
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  jp zero_not_equals

; STATE?  ( -- flag ) state @ 0<>

  hdr _hidden,'STATE?'
state_question:
  ld hl,state.1
  jp sysq.1

; CHECK?  ( -- flag ) checking @ 0<>

  hdr _hidden,'CHECK?'
chkq:
  ld hl,check.1
  jp sysq.1

; APPLICATION  ( -- ) sys off

  hdr _public,'APPLICATION'
app:
  ld hl,sys.1
  jp off_hl

; SYSTEM  ( -- )    sys on

  hdr _public,'SYSTEM'
system:
  ld hl,sys.1
  jp on_hl

; XXX OLD
;;; h  ( -- a )    sys@ if dph else dp then
;;
;;  hdr _hidden,'H'
;;hh:
;;  ld hl,(sys.1)
;;  ld a,l
;;  or h
;;  jp z,dp
;;  jp dph

; ALLOT  ( n -- )   here over 0max dup unused u>
;       abort" no data space" erase h +!

  hdr _public,'ALLOT'
allot:
  call do_colon
  dw here,over
  dw zero_max,dup
  dw unused,u_greater
  dw paren_abort_quote
  dcs 'no data space'
  dw erase
;;  dw hh,plus_store ; XXX OLD
  dw dp,plus_store ; XXX NEW
  dw exit

; HERE  ( -- a )

  hdr _public,'HERE'
here:
  call do_colon
;;  dw hh,fetch ; XXX OLD
  dw dp,fetch ; XXX NEW
  dw exit

; C,  ( c -- )

  hdr _public,'C,'
c_comma:
  call do_colon
  dw here,one,allot,c_store
  dw exit

; ,  ( n -- )

  hdr _public,','
comma:
  call do_colon
  dw here,two,allot,store
  dw exit

; >BODY  ( xt -- pfa )

  hdr _public,'>BODY'
to_body:
  ld de,3
  jp plus_de

; BODY>  ( a -- xt ) 3 -
;
; XXX -- this word was commented out in DX-Forth, why?
  hdr _hidden,'BODY>'
fbody:
  ld de,-3
  jp plus_de

; XXX NEW -- DX-Forth 4.09
; N>COUNT  ( nfa -- ha len )
;   aka (name) n>count

  hdr _hidden,'N>COUNT',,paren_name
ncnt: equ  paren_name

; XXX OLD -- DX-Forth 4.00
;;; n>link  ( nfa -- lfa )
;;
;;  header x,'N>LINK',,1
;;nlnk:
;;  pop hl
;;  ld a,(hl)  ; name length and flags
;;  and 0x1f    ; name length only
;;  ld e,a
;;  ld d,0
;;  add hl,de
;;  inc hl
;;  jp push_hl

; XXX NEW -- DX-Forth 4.09
; N>LINK  ( nfa -- lfa )    n>count +

  hdr _public,'N>LINK'
nlnk:
  call do_colon
  dw ncnt,plus
  dw exit

; N>NAME  ( nfa1 -- nfa2 | 0 )

  hdr _public,'N>NAME'
ntnam:
  call do_colon
  dw nlnk,fetch  ; n>link @
  dw exit

; NAME>  ( nfa -- xt )

  hdr _public,'NAME>'
namef:
  call do_colon
  dw nlnk,cell_plus,fetch ; n>link cell+ @
  dw exit

; W>NAME  ( wid -- nfa | 0 )
;   aka @ w>name

  hdr _public,'W>NAME',,fetch
wtnam: equ fetch

; -ALIAS  ( nfa -- nfa flag )  dup c@ $80 <

  hdr _hidden,'-ALIAS'
  ; false if alias
dalias:
  pop hl
  push hl
  ld a,(hl)
  cp 0x80
  jp zero_less.2

; XXX OLD -- DX-Forth 4.00
;;; >name  ( xt -- nfa | 0 )
;;;       voc-link begin @ dup while tuck 2-
;;;       w>name begin ?dup while -alias if 2dup
;;;       name> = if -rot 2drop exit then then
;;;       n>name repeat swap repeat nip
;;
;;  header x,'>NAME',,1
;;to_name:
;;  call do_colon
;;  dw voc_link
;;to_name.1:
;;  dw fetch
;;  dw dup
;;  dw question_branch,to_name.5
;;  dw tuck
;;  dw two_minus
;;  dw wtnam
;;to_name.2:
;;  dw question_dup
;;  dw question_branch,to_name.4
;;  dw dalias    ; skip if alias
;;  dw question_branch,to_name.3
;;  dw two_dup,namef
;;  dw equals
;;  dw question_branch,to_name.3
;;  dw minus_rot,two_drop
;;  dw exit
;;to_name.3:
;;  dw ntnam
;;  dw branch,to_name.2
;;to_name.4:
;;  dw swap
;;  dw branch,to_name.1
;;to_name.5:
;;  dw nip
;;  dw exit    ; not found

; XXX NEW -- DX-Forth 4.09
; >NAME  ( xt -- nfa | 0 )
;        voc-link begin @ dup while tuck cell- w>name
;        begin ?dup while -alias if 2dup name> = if
;        -rot 2drop exit then then n>name repeat swap
;        repeat nip

  hdr _public,'>NAME'
to_name:
  call do_colon
  dw voc_link
to_name.1:
  dw fetch
  dw dup
  dw question_branch,to_name.5
  dw tuck
  dw cell_minus
  dw wtnam
to_name.2:
  dw question_dup
  dw question_branch,to_name.4
  dw dalias    ; skip if alias
  dw question_branch,to_name.3
  dw two_dup,namef
  dw equals
  dw question_branch,to_name.3
  dw minus_rot,two_drop
  dw exit
to_name.3:
  dw ntnam
  dw branch,to_name.2
to_name.4:
  dw swap
  dw branch,to_name.1
to_name.5:
  dw nip
  dw exit    ; not found

; XXX OLD -- DX-Forth 4.00
;;; (NAME)  ( nfa -- ca u ) count 31 and
;;
;;  header 1,'(NAME)',,1
;;paren_name:
;;  call do_colon
;;  dw count
;;  dw c_lit
;;  db 31
;;  dw and_
;;  dw exit

; XXX NEW -- DX-Forth 4.09
; (NAME)  ( nfa -- ca u )  count 31 and

  hdr _public,'(NAME)'
paren_name:
  pop de
  ld a,(de)
  inc  de
  and 0x1f
  ld l,a
  ld h,0
  push de
  jp next

; .ID  ( nfa | 0 -- )   ?dup if (name) type exit then
;         ." [noname]"

  hdr _public,'.ID'
dotid:
  call do_colon
  dw question_dup
  dw question_branch,dotid.1
  dw paren_name
  dw type
  dw exit
dotid.1:
  dw paren_dot_quote
  dcs '[noname]'
  dw exit

; .NAME  ( xt -- )  >name .id

  hdr _public,'.NAME'
dotnam:
  call do_colon
  dw to_name,dotid
  dw exit

; .WID  ( wid -- )  cell+ cell+ @ .id
; XXX Renamed to '.VOC' in DX-Forth 4.09
  hdr _public,'.WID'
dotwid:
  call do_colon
  dw cell_plus,cell_plus
  dw fetch,dotid
  dw exit

; !CSP  ( -- )    sp@ csp !

  hdr _public,'!CSP'
store_csp:
  ld hl,0
  add hl,sp
  ld (csp.1),hl
  jp next

; ?CSP  ( -- )    sp@ csp @ - ?bal

  hdr _public,'?CSP'
question_csp:
  call do_colon
  dw sp_fetch
  dw csp,fetch
  dw minus
  dw question_bal
  dw exit

; ?COMP  ( -- )   state? 0= abort" compilation only'

  hdr _public,'?COMP'
question_comp:
  call do_colon
  dw state,fetch
  dw zero_equals
  dw paren_abort_quote
  dcs 'compilation only'
  dw exit

; ?EXEC  ( -- )   state? abort" execution only'

  hdr _public,'?EXEC'
qexec:
  call do_colon
  dw state_question
  dw paren_abort_quote
  dcs 'execution only'
  dw exit

; ?STACK  ( -- )
;       sp@ s0 @ over u< swap pad u< or
;       abort" stack?" r0 @ rp@ u< rp@ fs0 @ u<
;       or abort" r-stack?" fs0 @ fsp @ u< fsp @
;       fs0 @ (nfpm) @ - u< or abort" f-stack?"

  hdr _public,'?STACK'
qstac:
  call do_colon
  dw sp_fetch
  dw s0,fetch
  dw over,u_less
  dw swap
  dw pad
  dw u_less
  dw or_
  dw paren_abort_quote
  dcs 'stack?'
  dw r0,fetch
  dw rp_fetch
  dw u_less
  dw rp_fetch
  dw fs0    ; = S0 if no float
  dw fetch
  dw u_less,or_
  dw paren_abort_quote
  dcs 'r-stack?'
; dw fs0,fetch
; dw fsp,fetch
; dw u_less
; dw fsp,fetch
; dw fs0,fetch
; dw lit,nfpm
; dw fetch
; dw minus
; dw u_less
; dw or_
; dw paren_abort_quote
; dcs 'f-stack?'
  dw exit

; ?DEFINED  ( flag -- ) 0= abort" is undefined"

  hdr _hidden,'?DEFINED'
qdef:
  call do_colon
  dw zero_equals
  dw paren_abort_quote
  dcs 'is undefined'
  dw exit

; [       state off ; immediate

  hdr _public,'[',_immediate
left_bracket:
  ld hl,state.1
  jp off_hl

; ]     state on

  hdr _public,']'
right_bracket:
  ld hl,state.1 ; must be -1 for INTERPRET to work
  jp on_hl

; COMPILE,  ( xt -- ) warning @ 0< if dup limit u< sys? d0=
;       if dup .name ."  is system " then then ,

  hdr _public,'COMPILE,'
compile_comma:
  call do_colon
  dw warning,fetch
  if warning_options
    dw zero_less
  endif
  dw question_branch,compile_comma.1
  dw dup,limit
  dw u_less
  dw sys_question
  dw d_zero_equals
  dw question_branch,compile_comma.1
  dw dup
  dw dotnam
  dw paren_dot_quote
  dcs ' is system '
compile_comma.1:
  dw comma
  dw exit

; COMPILE  ( -- )   ?comp r> dup cell+ >r @ compile,

  hdr _public,'COMPILE'
compile:
  call do_colon
  dw question_comp   ; prevent crash if interpreting
  dw from_r
  dw dup,cell_plus
  dw to_r
  dw fetch
  dw compile_comma
  dw exit

; POSTPONE
;   defined dup ?defined 0< if compile
;   compile then compile, ; immediate

  hdr _public,'POSTPONE',_immediate
postp:
  call do_colon
  dw defined_
  dw dup,qdef
  dw zero_less
  dw question_branch,postp.1
  dw compile,compile
postp.1:
  dw compile_comma
  dw exit

; (ACCEPT-DELETE)  ( n -- )
;   delete n chars at the left of the cursor

  hdr _hidden,'(ACCEPT-DELETE)'

paren_accept_delete:
  call do_colon
paren_accept_delete.loop:
  dw c_lit
  db left_char
  dw dup,emit,space,emit
  dw one_minus,dup
  dw branch_if_not_false,paren_accept_delete.loop
  dw exit

; (ACCEPT-CONTROL-CHAR)  ( ca len len2 c -- ca len len2' )

  hdr _hidden,'(ACCEPT-CONTROL-CHAR)'

paren_accept_control_char:

  call do_colon
  dw dup

  ; check the escape key
  dw c_lit
  db esc_char
  dw equals ; escape?
  dw branch_if_false,paren_accept_control_char.delete
  ; do escape
  dw zero,swap,paren_accept_delete
  dw exit

paren_accept_control_char.delete:
  ; check the delete key
  dw c_lit
  db delete_char
  dw equals
  dw branch_if_false,paren_accept_control_char.end
  ; do backspace
  dw one_minus,one,paren_accept_delete

paren_accept_control_char.end:
  dw exit

; (ACCEPT-ASCII-CHAR)  ( ca len len2 c -- ca len len2' )

  hdr _hidden,'(ACCEPT-ASCII-CHAR)'

paren_accept_ascii_char:
  call do_colon
paren_accept_ascii_char.0:
  dw to_r,two_dup,minus,from_r,swap ; space left
  dw branch_if_not_zero,paren_accept_ascii_char.valid
  dw drop
  dw exit

paren_accept_ascii_char.valid:
  ; there's space left for the char
  dw dup,emit,over
  dw c_lit
  db 4
  dw pick,plus,c_store,one_plus
  dw exit

; (ACCEPT-KEY)  ( ca len len2 c -- ca len len2' )

  hdr _hidden,'(ACCEPT-KEY)'

paren_accept_key:
  call do_colon
  dw dup,bl
  dw c_lit
  db 127
  dw within ; ASCII?
  dw branch_if_true,paren_accept_ascii_char.0
  ; not ASCII
  dw paren_accept_control_char
  dw exit


; (ACCEPT)  ( ca len -- len2 )

  hdr _hidden,'(ACCEPT)'
paren_accept:
  call do_colon
  if debug
    dw paren_dot_quote
    dcs '(ACCEPT)',cr_char
  endif
  dw zero ; len2
paren_accept.loop:
  dw key,dup
  dw c_lit
  db cr_char
  dw equals  ; enter key?
  dw branch_if_true,paren_accept.end
  dw paren_accept_key
  dw branch,paren_accept.loop
paren_accept.end:
  dw drop,nip,nip
  dw exit

; ACCEPT  ( ca +n1 -- +n2 )

  hdr _public,'ACCEPT'
accept:
  call fetch_execute
  dw paren_accept

; PAD  ( -- a )
; dp @ (npno) @ +

  hdr _public,'PAD'
pad:
  call do_colon
  dw dp,fetch
  dw lit,npno
  dw fetch
  dw plus
  dw exit

; SOURCE  ( -- ca u )
;   'source 2@

  hdr _public,'SOURCE'
source:
  ld hl,tick_source.variable
  jp two_fetch.hl

; PARSE  ( c -- ca u )
;   0 (parse)

  hdr _public,'PARSE'
parse:
  ld hl,0
  push hl
  jp paren_parse

; (PARSE)  ( c f -- ca u )
;         2>r source >in @ /string r> if tuck
;         r@ skip over - >in +! then 2dup r>
;         scan nip tuck - dup rot 0<> - >in +!

  hdr 0,'(PARSE)'
paren_parse:
  call do_colon
  dw two_to_r
  dw source
  dw in_,fetch,sstr
  dw from_r
  dw question_branch,paren_parse.1
  dw tuck
  dw r_fetch,skip
  dw rot,over,minus
  dw in_,plus_store
paren_parse.1:
  dw two_dup
  dw from_r
  dw scan,nip
  dw tuck
  dw minus,dup
  dw rot,zero_not_equals
  dw minus
  dw in_,plus_store
  dw exit

; +PSB  ( a1 n1 n2 -- n3 )
;   >r (parsed_string_buffer_size) r@ - umin r> 2dup + >r
;   (parsed_string_buffer) + swap cmove r>

  hdr _hidden,'+PSB'
ppsb:
  call do_colon
  dw to_r
  dw lit,parsed_string_buffer_size
  dw r_fetch,minus
  dw u_min
  dw from_r
  dw two_dup,plus
  dw to_r
  dw lit,parsed_string_buffer
  dw plus
  dw swap
  dw cmove
  dw from_r
  dw exit

; PARSE$  ( c "ccc" -- a n )
;         0 begin >r dup parse 2dup r> +psb >r
;         1+ + dup source + u< while 2dup c@ =
;         while 1 dup >in +! r> +psb repeat
;         then 2drop (parsed_string_buffer) r>

  hdr _public,'PARSE$'
parss:
  call do_colon
  dw zero
parss.1:
  dw to_r
  dw dup,parse
  dw two_dup
  dw from_r,ppsb
  dw to_r
  dw one_plus,plus
  dw dup
  dw source,plus
  dw u_less
  dw question_branch,parss.2
  dw two_dup,c_fetch
  dw equals
  dw question_branch,parss.2
  dw one,dup
  dw in_,plus_store
  dw from_r,ppsb
  dw branch,parss.1
parss.2:
  dw two_drop
  dw lit,parsed_string_buffer
  dw from_r
  dw exit

; PWA  ( -- adr )   parsed word address

  hdr _hidden,'PWA'
pwa:
  call do_value
  ds cw

; XXX OLD -- DX-Forth 4.00
;;; >wbuf  ( ca1 +n -- ca2 )
;;;       255 min (hm-5) over - dup to pwa place pwa
;;;       bl affix
;;
;;  header x,'>WBUF'
  ; uses WORD's buffer
;;twbuf:
;;  call do_colon
;;  dw c_lit
;;  db 255
;;  dw min
;;   if classic_Forth_behaviours
;;  dw dp,fetch
;;   else
;;  dw lit,hm-5
;;  dw over,minus
;;   endif
;;  dw dup
;;  dw paren_to,pwa
;;  dw place
;;  dw pwa
;;  dw bl   ; trailing blank
;;  dw affix
;;  dw exit
;;
;;; WORD  ( c -- ca )
;;;   true (parse) >wbuf
;;
;;  header 1,'WORD',,1
;;word:
;;  call do_colon
;;  dw true,paren_parse
;;  dw twbuf
;;  dw exit
;;
;;; bl-word  ( -- a )  bl word
;;
;;  header x,'BL-WORD',,1
;;bl_word:
;;  call do_colon
;;  dw bl,word
;;  dw exit

; XXX NEW -- DX-Forth 4.09
; WPACK  ( ca1 +n -- ca2 )
;        255 min (hm-5) over - dup to pwa packed
;        bl affix

  hdr _hidden,'WPACK'
  ; pack string in WORD's buffer
wpack:
  call do_colon
  dw c_lit
  db 255          ; 255
  dw min          ; min
  if  classic_Forth_behaviours
    dw dp,fetch     ; dp @
  else
    dw lit,hm-5     ; (hm) 5 -
    dw over,minus   ; over -
  endif
  dw dup
  dw paren_to,pwa ; to pwa
  dw packed
  dw bl,affix     ; bl affix \ add a trailing blank
  dw exit

; WORD  ( c -- ca )

  hdr _public,'WORD'
word:
  call do_colon
  dw true,paren_parse ; true (parse)
  dw wpack            ; wpack
  dw exit

; BL-WORD  ( -- ca )

  hdr _hidden,'BL-WORD'
bl_word:
  ld hl,sp_char
  push hl     ; bl
  jp word     ; word

; TOKEN  ( -- ca u )

  hdr _public,'TOKEN'
token:
  call do_colon
  dw bl_word,count ; bl-word count
  dw exit

; DEFINED  ( -- ca 0 | xt -1 | xt 1 )

  hdr _hidden,'DEFINED'
defined_:
  call do_colon
  dw bl_word,find ; bl-word find
  dw exit

; '  ( -- a )    defined ?defined

  hdr _public,"'"
tick:
  call do_colon
  dw defined_
  dw qdef
  dw exit

; [UNDEFINED]  ( -- flag )  defined nip 0= ; immediate

  hdr _public,'[UNDEFINED]',_immediate
budef:
  call do_colon
  dw defined_
  dw nip
  dw zero_equals
  dw exit

; [DEFINED]  ( -- flag )  postpone [undefined] 0= ; immediate

  hdr _public,'[DEFINED]',_immediate
bdef:
  call do_colon
  dw budef,zero_equals
  dw exit

; (  ( "ccc<delim>" ) [char] ) parse 2drop ; immediate

  hdr _public,'(',_immediate
paren:
  call do_colon
  dw c_lit
  db ')'
  dw parse,two_drop
  dw exit

; .(  ( "ccc<delim>" )  [char] ) parse$ type ; immediate

  hdr _public,'.(',_immediate
dotp:
  call do_colon
  dw c_lit
  db ')'
  dw parss,type
  dw exit

; \  ( "ccc" -- )   source nip blk @ if c/l >in @ over / 1+ *
;       min then >in ! ; immediate

  hdr _public,'\',_immediate
bslas:
  call do_colon
  dw source,nip
  dw blk,fetch
  dw question_branch,bslas.1
  dw csll
  dw in_,fetch
  dw over,slash
  dw one_plus,star
  dw min
bslas.1:
  dw in_,store
  dw exit

; \\  ( "ccc" -- )  source nip >in ! ; immediate

  hdr _public,'\\',_immediate
bslss:
  call do_colon
  dw source,nip
  dw in_,store
  dw exit

; XXX NEW -- DX-Forth 4.09
; LINK,  ( a -- )    here over @ , swap !

  hdr _public,'LINK,'
linkc:
  call do_colon
  dw here
  dw over,fetch
  dw comma
  dw swap,store
  dw exit

; XXX OLD -- DX-Forth 4.00
;;; WORDLIST  ( -- wid )  $2001 , here 0 , here dup voc-link @ , !
;;;       0 ,
;;
;;  header 0,'WORDLIST'
  ; nameless wordlists not supported
;;wlist:
;;  call do_colon
;;  dw lit,0x2001
;;  dw comma
;;  dw here
;;  dw zero    ; nfa of top word in vocabulary
;;  dw comma
;;  dw here,voc_link
;;  dw dup,fetch   ; link to previous vocabulary
;;  dw comma
;;  dw store
;;  dw zero,comma  ; null name
;;  dw exit

; XXX NEW -- DX-Forth 4.09
; WORDLIST  ( -- wid )  $2001 , here 0 , voc-link link, 0 ,

  hdr _hidden,'WORDLIST'
wlist:
  call do_colon
  dw lit,0x2001
  dw comma
  dw here
  dw zero    ; nfa of top word in vocabulary
  dw comma
  dw voc_link,linkc  ; link in wordlist
  dw zero,comma  ; null name
  dw exit

; VOCABULARY  ( "name" )
;       sys? system wordlist
;       ;;  create dup ,  ;; XXX OLD -- DX-Forth 4.00
;       dup value  ;; XXX NEW -- DX-Forth 4.09
;       last @
;       swap cell+ cell+ ! sys ! does> @ context !

  hdr _public,'VOCABULARY'
vocabulary:
  call do_colon
  dw sys_question
  dw system
  dw wlist
;;  dw create,dup,comma ; XXX OLD -- DX-Forth 4.00
  dw dup,value ; XXX NEW -- DX-Forth 4.09
  dw last,fetch   ; set name field in wordlist struct
  dw swap
  dw cell_plus,cell_plus
  dw store
  dw sys,store
  dw paren_semicolon_code
do_vocabulary:
  call do_colon
  dw fetch
  dw cont,store
  dw exit

; DEFINITIONS  ( -- ) get-context set-current

  hdr _public,'DEFINITIONS'
definitions:
  call do_colon
  dw getcon
  dw setcur
  dw exit

; wordlist structure

forth.3: defl previous_nfa

  dw 0x2001    ; dummy nfa for vocabulary chaining
forth.1:
  dw top_nfa    ; nfa of top word in vocabulary
forth.2:
  dw 0   ; previous vocabulary
  dw forth.3    ; vocabulary nfa

; FORTH     vocabulary forth

  hdr _public,'FORTH'
forth:
  call do_vocabulary
  dw forth.1

; UNUSED  ( -- u )

  hdr _public,'UNUSED'
unused:
  dw lit,0xffff,here,minus
  dw exit

; XXX OLD
;;;   sys? if (esm) @ else sp@ then here
;;;   255 + 2dup u> -rot - and
;;  call do_colon
;;  dw sys_question
;;  dw question_branch,unused.1
;;  dw lit,esm
;;  dw fetch
;;  dw branch,unused.2
;;unused.1:
;;  dw sp_fetch
;;unused.2:
;;  dw here
;;  dw c_lit    ; allow margin
;;  db 255
;;  dw plus
;;  dw two_dup
;;  dw u_greater
;;  dw minus_rot
;;  dw minus
;;  dw and_
;;  dw exit

; INTERPRET  ( -- ) begin bl-word dup c@ while find ?dup if
;       state? = if compile, else execute then
;       else count base @ >r over c@ case [char] $
;       of hex 1 endof [char] # of decimal 1 endof
;       0 swap endcase /string 2dup number? if
;       2nip dpl @ 0< if drop state? if
;       postpone literal then else state? if
;       postpone 2literal then then true else
;       fnumber then r> base ! ?defined then ?stack
;       repeat drop

  hdr _public,'INTERPRET'
interpret:
  call do_colon
interpret.1:
  dw bl_word
  dw dup,c_fetch
  dw question_branch,interpret.15  ; while not end of input stream
  dw find
  dw question_dup
  dw question_branch,interpret.4 ; if found
  dw state_question
  dw equals
  dw question_branch,interpret.2 ; if compiling and not immediate
  dw compile_comma
  dw branch,interpret.3
interpret.2:
  dw execute
interpret.3:
  dw branch,interpret.14
interpret.4:
  dw count
  dw base,fetch,to_r
  dw over,c_fetch

  dw c_lit
  db '$'
  dw paren_of,interpret.5
  dw hex,one
  dw branch,interpret.7

interpret.5:
  dw c_lit
  db '#'
  dw paren_of,interpret.6
  dw decimal,one
  dw branch,interpret.7

interpret.6: ; endcase
  dw zero,swap
  dw drop

interpret.7:
  dw sstr
  dw two_dup

interpret.8:
  dw number_question    ; NUMBER? patch
  dw question_branch,interpret.12
  dw two_nip
  dw dpl,fetch,zero_less
  dw question_branch,interpret.10
  dw drop
  dw state_question
  dw question_branch,interpret.9
  dw literal
interpret.9:
  dw branch,interpret.11
interpret.10:
  dw state_question
  dw question_branch,interpret.11
  dw two_literal
interpret.11:
  dw true
  dw branch,interpret.13
interpret.12:
  dw f_number_patch
interpret.13:
  dw from_r,base,store
  dw qdef
interpret.14:
  dw qstac
  dw branch,interpret.1
interpret.15:
  dw drop
  dw exit

; (EVALUATE)  ( ca u blk -- )
;
; does not restore block contents
;
;         blk @ >in @ 2>r source 2>r blk !
;         'source 2! >in off interpret 2r>
;         'source 2! 2r> >in ! blk !

  hdr _hidden,'(EVALUATE)'
paren_evaluate:
  call do_colon
  dw blk,fetch
  dw in_,fetch
  dw two_to_r
  dw source,two_to_r
  dw blk,store
  dw tick_source,two_store
  dw in_,off     ; reset >IN
  dw interpret
  dw two_from_r,tick_source,two_store
  dw two_from_r
  dw in_,store
  dw blk,store
  dw exit

; ?BLOCK   ( -- )
; reload block
; blk @ ?dup if block drop then

  hdr _hidden,'?BLOCK'
question_block:
  call do_colon
  dw blk,fetch,question_dup
  dw question_branch,question_block.1
  dw block,drop
question_block.1:
  dw exit

; EVALUATE  ( ca u -- ) 0 (evaluate) ?block

  hdr _public,'EVALUATE'
evaluate:
  call do_colon
  dw zero,paren_evaluate
  dw question_block
  dw exit

; (REFILL)  ( -- flag )
; doesn't correctly handle source

; blk @ ?dup if
;   1+ dup #screens u< and dup
;   while
;     dup blk ! block b/buf
; else
;   (tib) dup 80 accept space
; then
; 'source 2! >in off true then

  hdr _hidden,'(REFILL)'
paren_refill:
  call do_colon     ; from EVALUATE
  if debug
    dw paren_dot_quote
    dcs '(REFILL) '
  endif
  dw blk,fetch,question_dup
  dw question_branch,paren_refill.1
  dw one_plus,dup
  dw nscr,u_less
  dw and_,dup
  dw question_branch,paren_refill.3
  dw dup,blk,store
  dw block,bytes_per_buffer
  dw branch,paren_refill.2
paren_refill.1:
  dw lit,tib
  dw dup
  dw c_lit
  db 8 ; 80 ; XXX TMP 8, for testing
  dw accept
  dw space
paren_refill.2:
  dw tick_source,two_store
  dw in_,off
  dw true
paren_refill.3:
  dw exit

; REFILL  ( -- flag )

  hdr _public,'REFILL'
refill:
  call fetch_execute
  dw paren_refill

; RESET  ( -- )

  hdr _hidden,'RESET'
reset:
  call do_colon
  dw catcher,off   ; reset error handler
  ;; dw dcaps ; XXX OLD
  dw case_sensitive_search,off ; XXX NEW
  dw console      ; set EMIT vector
  dw exit

; RESET-INTERPRETER  ( -- )
;   blk off >in off postpone [

  hdr _hidden,'RESET-INTERPRETER'
reset_interpreter:
  ld hl,0
  ld (blk.variable),hl
  ld (in_.variable),hl
  jp left_bracket

; RESET-FORTH  ( -- )
;       0 set-limit empty warning on checking
;       on (fdbs) (file_descriptor_size*nfd) erase empty-buffers
;       reset-interpreter 'source off bl-word drop

  hdr _hidden,'RESET-FORTH'
reset_forth:
  call do_colon
; XXX TODO
; XXX OLD
;;  dw zero
;;  dw setlim
;;  dw empty   ; reset vocabulary pointers
;;  dw warning,on  ; enable warnings
;;  dw check,on  ; enable checking
;;  dw lit,fdbs  ; clear files
;;  dw lit,file_descriptor_size*nfd ;
;;  dw erase   ;
;;  dw empty_buffers   ; mark screen buffer as empty
;;  dw reset_interpreter   ; reset interpreter
;;  dw tick_source,off  ; clear parsed word buffer
;;  dw bl_word,drop ;
  dw decimal ; XXX NEW -- moved here from cold_boot
  dw case_sensitive_search,off
  dw exit

; QUIT  ( -- )

  hdr _public,'QUIT'
quit:
  call do_colon
quit.1:
  dw r0,fetch,rp_store      ; r0 @ rp!
  dw reset                  ; reset
;** dw vnorm ; XXX OLD
  dw reset_interpreter        ; reset-interpreter
quit.2:                          ; begin
  ; XXX FIXME move 'cr' to 'if'?
  dw cr,paren_refill,drop       ;   cr  (refill) drop
  if debug
    dw paren_dot_quote
    dcs 'QUIT '
    forever:
    dw branch,forever
  endif
  dw interpret                  ;   interpret
  dw state_question,zero_equals ;   state? 0=
  dw question_branch,quit.3      ;   if
  dw paren_dot_quote            ;     ."  ok" 
  dcs ' ok'
quit.3:                          ;   then
  dw branch,quit.2               ; again

; RETURN  ( u -- )
; Exit to BASIC with return code u.
; The return code is used as line number for disk operations.

  hdr _public,'RETURN'
return:
  ; XXX TODO restore stack, etc.
  pop bc
  ret

; BYE  ( -- )
; Exit to the BASIC command line.

  hdr _public,'BYE'
bye:
  ; XXX TODO restore the stack, etc.
  im 1
  rst 0x08     ; error
  db 0xff      ; 0: "OK"

if 0
  ; XXX TODO -- Code from Benschop's ZX Spectrum Forth-83
  ld sp,(sys_err_sp) 
  pop bc
  ld bc,0x1303 
  push bc
  im 1
  ld (IY+31),2 ; update sys_e_line
  rst 0x08     ; error
  db 0xff      ; error 0: OK
endif

; BOOT?  ( -- xt )

  ; XXX TODO -- convert this into a variable that holds an xt?
  ; XXX TODO -- combine with 'boot'
  hdr _hidden,'BOOT?'
boot_question:
  ld hl,(init_boot_xt)
  push hl
  jp next

; (ABORT)  ( -- )   s0 @ sp! fs0 @ fsp ! boot? if 1 return then
;       quit

  hdr _hidden,'(ABORT)'
paren_abort:
  call do_colon
  dw s0,fetch
  dw sp_store
  dw fs0,fetch
  dw fsp,store
  dw boot_question
  if debug
    dw question_branch,paren_abort.1
    dw one
    dw return
    paren_abort.1: dw paren_dot_quote
    dcs ' (ABORT) '
    dw quit
  else
    dw question_branch,quit.1
    dw one
    dw return
  endif

; .ERROR  ( -- )
;       cr blk @ ?dup if file? and if filename type
;       >in @ 2- 0max blk @ 2dup scr 2! ."  Scr "
;       u. c/l / ." Line " . cr then then ." Error: "
;       [char] " dup emit pwa count 31 min type emit

  hdr _hidden,'.ERROR'
doterr:
  call do_colon
  dw cr
  dw blk,fetch
  dw question_dup
  dw question_branch,doterr.1
  dw file_question
  dw and_    ; screen file open and loading from block?
  dw question_branch,doterr.1
  dw loadfile,type
  dw in_,fetch
  dw two_minus    ; adjust pointer
  dw zero_max
  dw blk,fetch
  dw two_dup    ; set error block, offset
  dw scr,two_store
  dw paren_dot_quote
  dcs ' Screen '
  dw u_dot
  dw csll
  dw slash
  dw paren_dot_quote
  dcs 'Line '
  dw dot
  dw cr
doterr.1:
  dw paren_dot_quote
  dcs 'Error: '
  dw c_lit
  db '"'
  dw dup,emit
  dw pwa,count
  dw c_lit
  db 31
  dw min
  dw type
  dw emit
  dw exit

; ERROR  ( n -- )
;       -1 of (abort) then
;       -2 of boot cell+ @ 0=
;       if .error then space errmsg 2@ type (abort) then
;       ."  exception = " . (abort)

  hdr _hidden,'ERROR'
error:
  call do_colon
  dw true    ; -1
  dw paren_of,error.1
  dw paren_abort
error.1:
  dw lit,-2
  dw paren_of,error.3
  dw boot,cell_plus,fetch
  dw zero_equals
  dw question_branch,error.2
  dw doterr    ; skipped by applications
error.2:
  dw space
  dw errmsg,two_fetch
  dw type
  dw paren_abort
error.3:
  dw paren_dot_quote
  dcs ' exception = '
  dw dot
  dw paren_abort
  dw exit

; CATCH  ( xt -- n | 0 )  sp@ >r fsp @ >r catcher @ >r rp@ catcher
;       ! execute r> catcher ! 2r> 2drop 0

  hdr _public,'CATCH'
catch:
  call do_colon
  dw sp_fetch,to_r
  dw fsp,fetch
  dw to_r
  dw catcher,fetch,to_r
  dw rp_fetch,catcher,store
  dw execute
  dw from_r,catcher,store
  dw two_from_r,two_drop
  dw zero
  dw exit

; THROW  ( n -- )   ?dup if catcher @ ?dup 0= if error then rp!
;       r> catcher ! r> fsp ! r> swap >r sp! drop
;       r> then

  hdr _public,'THROW'
throw:
  call do_colon
  dw question_dup
  dw question_branch,throw.2
  dw catcher,fetch
  if debug
    dw paren_dot_quote
    dcs ' THROW:'
    dw over,dot
    dw paren_dot_quote
    dcs 'CATCHER:'
    dw dup,u_dot,space,space
  endif
  dw question_dup,zero_equals
  dw question_branch,throw.1
  dw error
throw.1:
  dw rp_store
  dw from_r,catcher,store
  dw from_r,fsp,store
  dw from_r,swap,to_r
  dw sp_store
  dw drop,from_r
throw.2:
  dw exit

; ABORT  ( -- )   -1 throw

  hdr _public,'ABORT'
abort:
  ld hl,-1
abort.1:
  push hl
  jp throw

; (ABORT")  ( n -- )  r> count rot if errmsg 2! -2 throw then +
;       >r

  hdr _hidden,'(ABORT")'
paren_abort_quote:
  call do_colon
  dw from_r,count
  dw rot
  dw question_branch,paren_abort_quote_.1
  dw errmsg
  dw two_store
  dw lit,-2
  dw throw
paren_abort_quote_.1:
  dw plus,to_r
  dw exit

; ABORT"      postpone (abort") ," ; immediate

  hdr _public,'ABORT"',_immediate
abort_quote:
  call do_colon
  dw compile,paren_abort_quote
  dw comma_quote
  dw exit

; XXX OLD -- DX-Forth 4.00
;;; CMDTAIL  ( -- ca u )  (dosbuf) count
;;
;;  header 1,'CMDTAIL'
;;cmdtail:ld de,dosbuf
;;  jp count.1
;;; XXX OLD -- DX-Forth 4.09
;;;  CMDTAIL  ( -- ca u )  (dosbuf) count bl skip -trailing
;;
;;  hdr  1,'CMDTAIL'
;;cmdtail:call do_colon
;;  dw c_lit
;;  db dosbuf
;;  dw count
;;  dw bl,skip
;;  dw dtrai
;;  dw exit

; Cold boot

;nodos  db 'wrong DOS version',cr_char,lf_char,'$'
;noram:  db 'not enough RAM'
crlf:  db cr_char,lf_char,'$' ; XXX TMP 

cold_boot:
  ; XXX TODO
  jp cold ; XXX TMP
; XXX OLD
;;  call get_current_drive      ; save default drive and user
;;  ld (default_drive),a
;;  call get_current_user
;;  ld (default_user),a
;;
;;  ld hl,(z3eadr)   ; test for ZSYSTEM
;;  push  hl
;;  ld de,27
;;  add hl,de
;;  ld e,(hl)
;;  inc hl
;;  ld d,(hl)
;;  pop hl
;;  call hl_minus_de_to_hl
;;  ld hl,0
;;  jp z,cldd.1
;;  ld (z3eadr),hl   ; not present or invalid z3eadr
;;
;;cldd.1:
;;  ld (system_stack_pointer),hl    ; hl=0
;;
;;  ld a,(noboot)    ; test noboot flag
;;  or  a
;;  ld a,(0x0005+2)   ; bdos base
;;  jp z,cldd.2
;;
;;  add hl,sp     ; save old stack
;;  ld (system_stack_pointer),hl
;;  sub 8     ; skip over CCP
;;
;;cldd.2:
;;  ld sp,tmp_stack
;;  ld h,a
;;  ld l,0
;;  ld (esm),hl    ; patch end of memory value
;;  ex de,hl
;;
;;  ld hl,(boot.1)    ; get BOOT word
;;  ld (init_boot_xt),hl    ; save it
;;  ld a,h
;;  or  l
;;  ld l,a
;;  ld a,(boot.2)
;;  and l
;;  jp z,cldd.3     ; need forth system
;;
;;  ld hl,noop
;;  ld (cold.1),hl
;;  ld hl,(ulimit)
;;  ld a,l
;;  or  h
;;  jp nz,cldd.6
;;  ex de,hl
;;  jp cldd.6
;;
;;cldd.3:
;;
;;  ld hl,(init_dph)   ; move system segment into place
;;  ld de,hm
;; XXX Some changes here in DX-Forth 4.09
;;  call hl_minus_de_to_hl
;;cldd.4:
;;  ld b,0     ; later patched to LD B,H
;;cldd.5:
;;  ld c,0     ; later patched to LD C,L
;;  ld hl,(init_dp)
;;  call move_block_upwards
;;  ld de,start
;;
;;cldd.6:
;;  ex de,hl
;;  ld (limit.1),hl   ; patch LIMIT
;;
;;  db 0xc3      ; 'jmp'
;;cldd.7:
;;  dw movpat      ; later patched to 'cold'

; BOOTMESSAGE  ( -- )

; XXX NEW -- after Gforth
; XXX TODO -- defered

bootmessage:
  call do_colon
  dw paren_dot_quote
  db bootmessage.end-$-1  ; length
  db "DZX-Forth "
  version
  db cr_char,"Copyright (C) 2014 Marcos Cruz"
  db cr_char
; XXX OLD
;  db cr_char,"(programandala.net)"
;  db cr_char,"Type 'bye' to exit.",cr_char
bootmessage.end
  dw exit

; COLD ( -- )

  hdr _public,'COLD'
cold:
; XXX TODO
; XXX OLD
;;  ld sp,tmp_stack
;;  ld hl,(limit.1)   ; get LIMIT
;;  ld de,-recsiz    ; file r/w buffer size
;;  add hl,de
;;  ld (hbuf.1),hl    ; patch HBUF
;;  push  hl
;;  ld hl,(nfcb.1)    ; #fcb
;;  ld de,-file_handle_size    ; handle size
;;  call hl_by_de_to_hlde_unsigned
;;  pop hl
;;  add hl,de
;;  ex de,hl
;;  ld hl,(nus)    ; user area size
;;  call de_minus_hl_to_hl
;;  ld (user_data_pointer),hl    ; patch UP
;;  ld (init_r0),hl    ; patch R0
;;  ld (return_stack_pointer),hl    ; patch RP
;;  ex de,hl
;;  ld hl,(nrts)   ; return stack size
;;  call de_minus_hl_to_hl
;;  ld (fspp),hl   ; init fp stack
;;  ld (init_fs0),hl   ; patch FS0
;;; XXX These lines were commented out in the original source:
;;; ex de,hl
;;; ld hl,(nfps)   ; fp stack size
;;; call de_minus_hl_to_hl
;;  ld sp,hl     ; set cpu stack pointer
;;  ld (init_s0),hl    ; patch S0
;;   if control_flow_stack_extensions
;;  ld (cs0.variable),hl   ; init CS0 with safe value
;;   endif

  ; init the user data
  ld hl,(user_data_pointer)
  ex de,hl
  ld hl,init_user_variables
  ld bc,init_user_variables.end-init_user_variables
  call move_block_upwards

  ; patch 'pause' to do nothing
  ld hl,0
  ld (pause.1),hl

  ; delete the last key
  ; XXX needed by 'key?'?
  xor a
  ld (sys_last_k),a

; XXX OLD
;;  ld de,dosbuf   ; reset DOS DTA
;;  ld c,26
;;  call 0x0005

  call do_colon
;;  dw zfh     ; reset handles
;;  dw sys,off     ; default is APPLICATION

  dw reset     ; general reset
cold.1:
  dw reset_forth
do_f_init_patch:
  dw f_init_patch

; XXX TODO -- user boot
;;  dw boot_question
;;  dw dup,boot,store     ; restore BOOT
;;  dw question_dup
;;  dw question_branch,cold.3
;;  dw execute      ; run application
;;  dw zero,return  ; exit to DOS

cold.3:

;;cold.4:
;;  dw interpret      ; interpret
;;cold.5:
;;;;  dw invid     ; terminal init sequence ; XXX OLD
;;  dw cr,page
;;  dw paren_dot_quote
;;  db cold.8-$-1

;;cold.6:
  dw cls
  dw bootmessage

;;cold.7:
;;cold.8:
;;  dw paren_dot_quote
;;  db do_f_identify_patch-$-1
;;  db cr_char,lf_char
do_f_identify_patch:
  dw f_identify_patch
;;  dw cr
;;  dw file_question
;;  dw question_branch,cold.10
;;  dw cr
;;  dw paren_dot_quote
;;  dcs 'Using '
;;  dw loadfile,type
;;  dw cr
;;cold.10:
  dw quit      ; jump to interpreter
;  dw bye ; XXX TMP


; XXX OLD 
;;; SET-LIMIT  ( a -- )  $fff0 and (ulimit) !
;;
;;  hdr  1,'SET-LIMIT'
;;setlim:
;;  pop hl
;;  ld a,l
;;  and 0x00f0
;;  ld l,a
;;  ld (ulimit),hl
;;  jp next

; }}} **********************************************************
; Dictionary support {{{

; FREEZE  ( -- )

  hdr _public,'FREEZE'
freeze:
  call do_colon
  dw udp,fetch ; from
  dw lit,init_user_variables ; to
  dw lit,init_user_variables.end-init_user_variables ; count
  dw cmove
  dw exit

; XXX OLD
;;;  'prune      variable 'prune  'prune off
;;
;;  hdr _hidden,"'PRUNE"
;;tprun:
;;  call do_create
;;  dw top_prunes    ; 0=end

; XXX OLD
;;;  REMEMBER  ( xt -- )  'prune link, ,
;;; add xt to prunes
;;
;;  hdr _public,'REMEMBER'
;;remember:
;;  call do_colon
;;  dw tprun,linkc
;;  dw comma
;;  dw exit

; XDP  ( adr -- adr xdp )  dup limit u< if dp else dph then

  hdr _hidden,'XDP'
xdp:
  pop de
  push de
  ld hl,limit.1
  ex de,hl
  call compare_de_hl_unsigned
  jp nc,dph
  jp dp

; XXX OLD
;;;  prunes  ( -- )    begin 'prune @ dup while dup xdp @ u< 0=
;;;        while 2@ 'prune ! execute repeat then drop
;;
;;  hdr _hidden,'PRUNES'
;;pruns:
;;  call do_colon
;;pruns.1:
;;  dw tprun,fetch
;;  dw dup
;;  dw question_branch,pruns.2
;;  dw dup
;;  dw xdp,fetch
;;  dw u_less,zero_equals
;;  dw question_branch,pruns.2
;;  dw two_fetch
;;  dw tprun,store
;;  dw execute
;;  dw branch,pruns.1
;;pruns.2:
;;  dw drop
;;  dw exit

;  ?protected ( ha -- ha )  (init_dph) @ over u> check? and
;          abort" is protected"

  hdr _hidden,'?PROTECTED'
question_protected:
  call do_colon
  dw lit,init_dph
  dw fetch
  dw over,u_greater
  dw chkq,and_
  dw paren_abort_quote
  dcs 'is protected'
  dw exit

;  name? ( "name" -- xt nfa )
; find name in context wordlist
;         bl-word get-context wfind ?defined
;          ?protected

  hdr _hidden,'NAME?'
nameq:
  call do_colon
  dw bl_word
  dw getcon
  dw wfind,qdef
  dw question_protected
  dw exit

; LFIND  ( wid nfa -- lfa |0 )  swap begin 2dup @ - while @
;          dup while n>link repeat then nip

  ; find link field containing nfa, 0=none

  hdr _hidden,'LFIND'
lfind:
  call do_colon
  dw swap
lfind.1:
  dw two_dup,fetch
  dw minus
  dw question_branch,lfind.2
  dw fetch,dup
  dw question_branch,lfind.2
  dw nlnk
  dw branch,lfind.1
lfind.2:
  dw nip
  dw exit

; BEHEAD  ( "name1" "name2" -- )  name? nip name? nip 2dup u< if swap
;          then n>name get-context rot lfind !

  hdr _public,'BEHEAD'
  ; unlink word heads
behead:
  call do_colon
  dw nameq,nip
  dw nameq,nip
  dw two_dup,u_less
  dw question_branch,behead.1
  dw swap
behead.1:
  dw ntnam
  dw getcon
  dw rot,lfind
  dw store
  dw exit

; ?VOC  ( flag -- )    abort" invalid vocabulary"

  hdr _hidden,'?VOC'
question_voc:
  call do_colon
  dw paren_abort_quote
  dcs  'invalid vocabulary'
  dw exit

;  CHAIN   ( "name" -- )    get-current postpone addr @ 2dup =
;          ?voc cell- $2001 over @ - ?voc
;          2dup lfind ?voc swap 0 lfind
;          ?protected 2dup u> ?voc !

  hdr _public,'CHAIN'
chain:
  call do_colon
  dw getcur
  dw addr,fetch
  dw two_dup,equals  ; same wordlist
  dw question_voc
  dw cell_minus
  dw lit,0x2001
  dw over,fetch,minus  ; not a wordlist
  dw question_voc
  dw two_dup,lfind  ; already chained
  dw question_voc
  dw swap
  dw zero,lfind
  dw question_protected
  dw two_dup,u_greater  ; forward reference
  dw question_voc
  dw store
  dw exit

; (FORGET)  ( nfa dp -- )  dp ! >r voc-link begin @ dup cell+ @ r@
;        u< until dup voc-link ! begin dup cell-
;        dup @ begin dup r@ u< 0= while -alias if
;        dup name> dp @ umin dp ! then n>name
;        repeat swap ! @ ?dup 0= until r> dup dp
;        cell+ ! (init_dph) @ u< if freeze then prunes

  hdr _hidden,'(FORGET)'
paren_forget:
  call do_colon
  dw dp,store  ; starting maximums
  dw to_r
  dw voc_link    ; trim vocs > nfa
paren_forget.1:
  dw fetch
  dw dup,cell_plus,fetch
  dw r_fetch,u_less
  dw question_branch,paren_forget.1
  dw dup,voc_link,store
paren_forget.2:
  dw dup,cell_minus  ; scan remaining vocs
  dw dup
  dw fetch
paren_forget.3:
  dw dup,r_fetch  ; for each word >= nfa
  dw u_less,zero_equals
  dw question_branch,paren_forget.5
  dw dalias    ; not an alias
  dw question_branch,paren_forget.4
  dw dup,namef  ; get its xt
  dw dp,fetch
  dw u_min,dp,store  ; trim dict
paren_forget.4:
  dw ntnam
  dw branch,paren_forget.3
paren_forget.5:
  dw swap,store
  dw fetch
  dw question_dup,zero_equals
  dw question_branch,paren_forget.2  ; until all vocs done
  dw from_r
  dw dup,dp
  dw cell_plus,store
  dw lit,init_dph  ; below fence?
  dw fetch,u_less
  dw question_branch,paren_forget.6
  dw freeze    ; fix bootup values
paren_forget.6:
;;  dw pruns    ; run prunes chain ; XXX OLD
  dw exit

; EMPTY  ( -- )    forth definitions (init_dp) 2@ (forget)

  hdr _public,'EMPTY'
empty:
  call do_colon
  dw forth,definitions  ; switch to a safe vocabulary
  dw lit,init_dp
  dw two_fetch
  dw paren_forget
  dw exit

; FORGET  ( "name" -- )  get-current context ! name? -alias 0=
;        abort" is alias" swap limit over u> if
;        drop dp @ then (forget)

  hdr _public,'FORGET'
forget:
  call do_colon
  dw getcur
  dw cont,store
  dw nameq
  dw dalias,zero_equals  ; alias?
  dw paren_abort_quote
  dcs 'is alias'
  dw swap
  dw limit
  dw over,u_less
  dw question_branch,forget.1
  dw drop
  dw dp,fetch
forget.1:
  dw paren_forget
  dw exit

; MARKER  ( "name" -- )  sys? system create sys !

  hdr _public,'MARKER'
marker:
  call do_colon
  dw sys_question
  dw system
  dw create
  dw sys,store
  dw exit

; }}} **********************************************************
; XXX {{{

; S,  ( ca u -- )
; 255 min 0max here over 1+ allot place

  hdr _hidden,'S,'
s_comma:
  call do_colon
  dw c_lit
  db 255
  dw min
  dw zero_max
  dw here,over
  dw one_plus,allot
  dw place
  dw exit

; ,"  ( "ccc" -- )  [char] " parse$ s,

  hdr _public,',"'
comma_quote:
  call do_colon
  dw c_lit
  db '"'
  dw parss
  dw s_comma
  dw exit

; XXX OLD -- DX-Forth 4.00
;;; (s")  ( -- ca u ) r> count 2dup + >r
;;
;;  header x,'(S")'
;;paren_s_quot:
;;  call do_colon
;;  dw from_r,count
;;  dw two_dup,plus,to_r
;;  dw exit

; XXX NEW -- DX-Forth 4.09
; (S")  ( -- ca u ) r> count 2dup + >r

  hdr _hidden,'(S")'
paren_s_quot:
  ld a,(bc)
  ld l,a
  ld h,0
  inc bc
  push bc
  push hl
  add hl,bc
  ld c,l
  ld b,h
  jp next

; SLITERAL  ( ca u -- )  postpone (s") s, ; immediate

  hdr _public,'SLITERAL',_immediate
s_literal:
  call do_colon
  dw compile,paren_s_quot
  dw s_comma
  dw exit

; S"  ( -- ca u ) [char] " parse$ state? if postpone sliteral
;       then ; immediate
; state-smart

  hdr _public,'S"',_immediate
s_quote:
  call do_colon
  dw c_lit
  db '"'
  dw parss
  dw state_question
  dw question_branch,s_quote.1
  dw s_literal
s_quote.1:
  dw exit

; XXX OLD -- DX-Forth 4.00
;;; (.")      r> count 2dup + >r type
;;
;;  header x,'(.")'
;;paren_dot_quote:
;;  call do_colon
;;  dw from_r,count
;;  dw two_dup,plus,to_r
;;  dw type
;;  dw exit

; XXX NEW -- DX-Forth 4.09
; (.")      r> count 2dup + >r type

  hdr _hidden,'(.")'
paren_dot_quote:
  ld a,(bc)  ; length of the string
  ld h,0
  ld l,a
  inc bc      ; address of the first char
  push bc     ; address
  push hl     ; length
  add hl,bc   ; calculate the new IP
  ld b,h
  ld c,l      ; update the IP
  jp type

; ."      compile (.") ," ; immediate

  hdr _public,'."',_immediate
dot_quote:
  call do_colon
  dw compile,paren_dot_quote
  dw comma_quote
  dw exit

; CHAR?  ( x -- x flag )

  hdr _hidden,'CHAR?'
char_question:
  pop hl
  push hl
  ld l,h
  jp zero_equals_hl

; LITERAL  ( n -- ) char? if postpone c_lit c, exit then
;       postpone lit , ; immediate

  hdr _public,'LITERAL',_immediate
literal:
  call do_colon
  dw char_question
  dw question_branch,literal.1
  dw compile,c_lit
  dw c_comma
  dw exit
literal.1:
  dw compile,lit
  dw comma
  dw exit

; 2LITERAL  ( d -- )  postpone 2lit , , ; immediate

  hdr _public,'2LITERAL',_immediate
two_literal:
  call do_colon
  dw compile,two_lit
  dw comma,comma
  dw exit

; [']     ' [compile] literal  ; immediate

  hdr _public,"[']",_immediate
bracket_tick:
  call do_colon
  dw tick
  dw literal
  dw exit

; [COMPILE]   ' compile,  ; immediate

  hdr _public,'[COMPILE]',_immediate
bracket_compile:
  call do_colon
  dw tick
  dw compile_comma
  dw exit

; RECURSE  ( -- )   last cell+ @ compile, ; immediate

  hdr _public,'RECURSE',_immediate
recurse:
  ld hl,(last.2)
  push hl
  jp compile_comma

; CHAR  ( -- c ) bl word 1+ c@

  hdr _public,'CHAR'
char:
  call do_colon
  dw bl,word
  dw one_plus,c_fetch
  dw exit

; [CHAR]  ( -- c ) char [compile] literal

  hdr _public,'[CHAR]',_immediate
bracket_char:
  call do_colon
  dw char
  dw literal
  dw exit

; Y/N  ( -- flag )  ." (y/n) N\bs" key upcase [char] Y = dup
;       if [char] Y else [char] N then emit space

  hdr _public,'Y/N'
yn:
  call do_colon
  dw paren_dot_quote
  dcs '(y/n) N',bs_char
  dw key,upcas
  dw c_lit
  db 'Y'
  dw equals,dup
  dw question_branch,yn1
  dw c_lit
  db 'Y'
  dw branch,yn2
yn1:
  dw c_lit
  db 'N'
yn2:
  dw emit,space
  dw exit

; CHAR+  ( ca1 -- ca2 )
;   aka 1+ char+

  hdr _public,'CHAR+',,one_plus
char_plus: equ one_plus

; CHARS  ( n1 -- n2 )
;   aka noop chars immediate

  hdr _public,'CHARS',_immediate,noop
chars: equ next

; CELL+  ( a1 -- a2 )
;   aka 2+ cell+

  hdr _public,'CELL+',,two_plus
cell_plus: equ two_plus

; CELL-  ( a1 -- a2 )
;   aka 2- cell-

  hdr _public,'CELL-',,two_minus
cell_minus: equ two_minus

; CELLS  ( n1 -- n2 )
;   aka 2* cells

  hdr _public,'CELLS',,two_star
cells: equ two_star

; ALIGN  ( -- )
;   aka noop align immediate

  hdr _public,'ALIGN',_immediate,noop
align: equ next

; ALIGNED  ( a -- aa )
;   aka noop aligned immediate

  hdr _public,'ALIGNED',_immediate,noop
aligned: equ next

; DZX-FORTH  ( -- minor major )

  hdr _public,'DZX-FORTH'
dzx_forth:
; XXX OLD
;;  ld hl,(dxver)
;;  jp dosver.1
; XXX TODO
  jp next

; }}} **********************************************************
; Files {{{

; RESET-DISKS  ( -- )

  hdr _public,'RESET-DISKS'
reset_disks:
  ld a,25
  call bdoss
  push af
  ld a,13
  call bdoss
  pop af
  ld e,a
  ld a,14
  call bdoss
  jp next

; >DRIVE  ( u1 -- u2 )  ?dup if 1- else 0 25 bdos then

  hdr _public,'>DRIVE'
to_drive:
  pop de
  ld a,e
  dec  a
  call m,get_current_drive
  jp push_a

; PATH  ( u1 -- ca u2 ior )
;        255 32 bdos 0 <# [char] : hold #s rot >drive
;        [char] A + hold #> 0

  hdr _public,'PATH'  ; uses numeric buffer
path:
  call do_colon
  dw c_lit
  db 255
  dw c_lit
  db 32
  dw bdos
  dw zero,bdigs
  dw c_lit
  db ':'
  dw hold
  dw digs
  dw rot,to_drive
  dw c_lit
  db 'A'
  dw plus
  dw hold,edigs
  dw zero
  dw exit

; -PATH  ( a1 u1 -- a2 u2 )
;        2dup [char] : scan dup if 1 /string 2swap
;        then 2drop

  hdr _public,'-PATH'
dpath:
  call do_colon
  dw two_dup
  dw c_lit
  db ':'
  dw scan,dup
  dw question_branch,dpath.1
  dw one,sstr
  dw two_swap
dpath.1:
  dw two_drop
  dw exit

; FILETYPE?  ( a1 u1 -- u2 )  -path [char] . scan nip

  hdr _hidden,'FILETYPE?'  ; get filetype length
filetype_question:
  call do_colon
  dw dpath
  dw c_lit
  db '.'
  dw scan,nip
  dw exit

; +EXT  ( a1 u1 a2 u2 -- a3 u3 )
;        2over filetype? if 2drop exit then 3 min
;        s" ." 2rot -trailing (filename_size-5) min zbuf
;        @ 1+ 0 +string +string +string

  hdr _public,'+EXT'  ; uses filename buffer
plus_ext:
  call do_colon
  dw two_over,filetype_question
  dw question_branch,plus_ext.1
  dw two_drop,exit
plus_ext.1:
  dw three,min
  dw paren_s_quot
  dcs '.'
  dw two_rot
  dw dtrai    ; trim trailing blanks
  dw c_lit
  db filename_size-5
  dw min
  dw zbuf,fetch    ; unused
  dw one_plus
  dw zero
  dw pstr
  dw pstr
  dw pstr
  dw exit

; -EXT  ( a1 u1 -- a2 u2 )  2dup filetype? -

  hdr _public,'-EXT'
minus_ext:
  call do_colon
  dw two_dup,filetype_question
  dw minus
  dw exit

; SETFCB  ( a u fcb-a -- user# )

  hdr _public,'SETFCB'
sfcb:
  call get_current_user    ; current user
  ld (sfcb.10+1),a
  call get_current_drive    ; current drive
  inc  a
  pop de
  ld (de),a
  ld (sfcb.5+1),a
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
  ex de,hl
  jp sfcb.2

sfcb.1:
  inc  de
  dec  c
sfcb.2:
  call sfcb.12    ; skip blanks
  cp ' '
  jp z,sfcb.1

  push de
  push bc
  cp '9'+1    ; user number
  jp c,sfcb.3
  sub  'A'-1    ; drive A-P
  jp c,sfcb.6
  cp 16+1
  jp nc,sfcb.6
  ld (sfcb.5+1),a
  call sfcb.11
  cp ':'
  jp z,sfcb.5

sfcb.3:
  ld b,0
sfcb.4:
  sub  '0'
  jp c,sfcb.6
  cp 9+1
  jp nc,sfcb.6
  push bc
  ld c,a
  ld a,b
  add a,a
  add a,a
  add a,b
  add a,a
  add a,c
  pop bc
  ld b,a
  call sfcb.11
  cp ':'
  jp nz,sfcb.4

  ld a,b
  cp 31+1    ; user 0-31
  jp nc,sfcb.6
  ld (sfcb.10+1),a

sfcb.5:
  ld (hl),0    ; modified
  pop af
  pop af
  call sfcb.11
  jp sfcb.7

sfcb.6:
  pop bc    ; not du:
  pop de
sfcb.7:
  ld b,8
  call sfcb.15

  cp '.'
  jp z,sfcb.8
  ld c,1
sfcb.8:
  inc  de
  dec  c

  ld b,3
  call sfcb.15

  ld b,21    ; clear EX..CR fields
sfcb.9:
  inc  hl
  ld (hl),0
  dec  b
  jp nz,sfcb.9

  pop bc
sfcb.10:
  ld a,0    ; modified
  jp push_a

sfcb.11:
  inc  de    ; get next
  dec  c
sfcb.12:
  inc  c    ; get char
  dec  c
  ld a,c
  ret  z
  ld a,(de)
  call uppercase_a
  and a
  ret

sfcb.13:
  call sfcb.12    ; test delimiter
  cp ' '+1
  jp c,sfcb.14
  cp ','
  ret  z
  cp '_'
;  ret  z
  jp nc,sfcb.14
  cp '.'
  ret  z
  cp ':'
  ret  c
  cp '>'
  ret  nc
sfcb.14:
  cp a
  ret

sfcb.15:
  call sfcb.13    ; fill field
  jp z,sfcb.19
  inc  hl
  cp '*'
  jp nz,sfcb.16
  ld (hl),'?'
  jp sfcb.17

sfcb.16:
  ld (hl),a
  inc  de
  dec  c
sfcb.17:
  dec  b
  jp nz,sfcb.15

sfcb.18:
  call sfcb.13    ; scan delimiter
  ret  z
  inc  de
  dec  c
  jp sfcb.18

sfcb.19:
  inc  hl
  ld (hl),' '
  dec  b
  jp nz,sfcb.19
  ret

old_user:
  db 255    ; 255 = ignore

; GETUSR  ( -- u )  get user

  hdr _public,'GETUSR'
getusr:
  call get_current_user
  jp push_a

; SETUSR  ( u -- )  set user

  hdr _public,'SETUSR'
setusr:
  call get_current_user
  ld (old_user),a  ; save current user
  pop hl
  ld a,l
setusr.1:
  cp 255
  call nz,set_current_user
  jp next

; RSTUSR  ( -- )    restore user

  hdr _public,'RSTUSR'
rstusr:
  ld a,(old_user)
  jp setusr.1

; REC@  ( a -- +d )  dup >r @ r> 2+ c@ 7 0 do d2* loop

  hdr _public,'REC@'
rec_fetch:
  pop hl
  inc  hl
  inc  hl
  xor a
  ld a,(hl)
  rra
  ld d,a
  dec  hl
  ld a,(hl)
  rra
  ld e,a
  dec  hl
  ld a,(hl)
  rra
  ld h,a
  ld a,0
  rra
  ld l,a
  ex de,hl
  push de
  jp next

; REC!  ( +d a -- )  >r 7 0 do d2/ loop r@ 2+ c! r> !

  hdr _public,'REC!'
rec_store:
  pop de
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
  ex de,hl
  ld a,e
  rla
  ld a,d
  rla
  ld (hl),a
  inc  hl
  ld a,c
  rla
  ld (hl),a
  inc  hl
  ld a,b
  rla
  ld (hl),a
  pop bc
  jp next

; >FNAME  ( a1 u -- a2 )
;
;   (filename_size-1) min zbuf @ packed 0 affix
;   zbuf 2@ swap zbuf 2!

  hdr _public,'>FNAME'
tfnam:
  call do_colon
  dw c_lit
  db filename_size-1
  dw min
  dw zbuf,fetch
  dw packed
  dw zero,affix  ; trailing null ; XXX OLD
  dw zbuf,two_fetch
  dw swap
  dw zbuf,two_store
  dw exit

; FH  ( -- a )

  hdr _hidden,'FH'
fh:
  call do_value    ; current file handle
fh1:
  dw 0

; /FH  ( -- )    #fcb (file_handle_size) * hbuf over - swap erase

  hdr _hidden,'/FH'
zfh:
  ld hl,(nfcb.1)
  ld de,file_handle_size
  call hl_by_de_to_hlde_unsigned
  ld hl,(hbuf.1)
  call hl_minus_de_to_hl
  push hl
  push de
  jp erase

; USE  ( -- a )
; fh (file_handle_size) negate * hbuf +

  hdr _hidden,'USE'
use:
  ld hl,(fh1)
  ld de,-file_handle_size
  call hl_by_de_to_hlde_unsigned
  ld hl,(hbuf.1)
  add hl,de
  push hl
  jp next

; UID  ( -- a )
; use 1+

  hdr _hidden,'UID'
uid:
  call do_colon    ; user number
  dw use,one_plus
  dw exit

; FCB  ( -- a )    use 6 +

  hdr _hidden,'FCB'
fcb:
  call do_colon    ; FCB address
  dw use
  dw c_lit
  db 6
  dw plus
  dw exit

; RWP@  ( -- ud )    use 2+ 2@

  hdr _hidden,'RWP@'
rwp_fetch:
  call do_colon
  dw use,two_plus
  dw two_fetch
  dw exit

; RWP!  ( ud -- )    use 2+ 2! ;

  hdr _hidden,'RWP!'
rwpst:
  call do_colon
  dw use,two_plus
  dw two_store
  dw exit

; >IOR  ( err# -- ior )  dup if $fe00 or then

  hdr _public,'>IOR'
ior:
  pop hl
  ld a,h
  or l
  jp z,ior.1
  ld h,0xfe
ior.1:
  push hl
  jp next

; ?IOR  ( flag err# -- ior )  and ior ;

  hdr _hidden,'?IOR'
qior:
  call do_colon
  dw and_
  dw ior
  dw exit

; GETFH  ( -- fid | 0 )  #fcb 1+ begin 1- dup while dup to fh
;        use c@ 0= until then

  hdr _hidden,'GETFH'
gtfh:
  call do_colon    ; get free handle, 0 if none
  dw nfcb
  dw one_plus
gtfh.1:
  dw one_minus
  dw dup
  dw question_branch,gtfh.2
  dw dup
  dw paren_to,fh
  dw use,c_fetch
  dw zero_equals
  dw question_branch,gtfh.1
gtfh.2:
  dw exit

; SETFH  ( fid mask -- 0 | err )  swap dup 1- 0 #fcb within if to fh
;          use c@ and 0= 5 and exit then 2drop
;          6

  hdr _hidden,'SETFH'
stfh:
  call do_colon    ; select/check handle
  dw swap    ; mode mask: 1=read 2=write 3=r/w
  dw dup,one_minus
  dw zero
  dw nfcb
  dw within
  dw question_branch,stfh.1
  dw paren_to,fh
  dw use,c_fetch
  dw and_,zero_equals
  dw c_lit
  db 5
  dw and_
  dw exit
stfh.1:
  dw two_drop
  dw c_lit
  db 6
  dw exit

; FILE-POSITION  ( fideid -- ud ior )  3 setfh rwp@ rot ior

  hdr _public,'FILE-POSITION'
fpos:
  call do_colon
  dw three,stfh
  dw rwp_fetch
  dw rot
  dw ior
  dw exit

; REPOSITION-FILE  ( ud fid -- ior )  3 setfh dup >r if 2drop else
;              rwp! then r> ior

  hdr _public,'REPOSITION-FILE'
reposf:
  call do_colon
  dw three,stfh
  dw dup,to_r
  dw question_branch,reposf.1
  dw two_drop
  dw branch,reposf.2
reposf.1:
  dw rwpst
reposf.2:
  dw from_r
  dw ior
  dw exit

; XF5  ( -- )
;  $80 fcb 5 + ctoggle

  hdr _hidden,'XF5'
xff:
  call do_colon
  dw c_lit
  db 0x80
  dw fcb
  dw c_lit
  db 5
  dw plus
  dw c_toggle
  dw exit

; FILE-SIZE  ( fid -- ud ior )  3 setfh dup 0= if uid c@ setusr
;          xf5 fcb 16 bdos drop xf5 fcb 35
;          bdos drop rstusr then fcb 33 +
;          rec@ rot ior

  hdr _public,'FILE-SIZE'
file_size:
  call do_colon
  dw three,stfh
  dw dup,zero_equals
  dw question_branch,fsiz.1
  dw uid,c_fetch
  dw setusr
  dw xff
  dw fcb
  dw c_lit
  db 16
  dw bdos,drop
  dw xff
  dw fcb
  dw c_lit
  db 35
  dw bdos,drop
  dw rstusr
fsiz.1:
  dw fcb
  dw c_lit
  db 33
  dw plus
  dw rec_fetch
  dw rot
  dw ior
  dw exit

; CLOSE-FILE  ( fid -- ior )  3 setfh dup if ior exit then use c!
;          uid c@ setusr fcb 16 bdos rstusr 255
;          = 2 ?ior

  hdr _public,'CLOSE-FILE'
closf:
  call do_colon
  dw three,stfh
  dw dup
  dw question_branch,closf.1
  dw ior
  dw exit
closf.1:
  dw use,c_store
  dw uid,c_fetch
  dw setusr
  dw fcb
  dw c_lit
  db 16
closf.2:
  dw bdos
  dw rstusr
  dw c_lit
  db 255
  dw equals
  dw two
  dw qior
  dw exit

; R/O  ( -- fam )
;   aka 0 r/o

  hdr _public,'R/O',,zero
rso: equ  zero

; W/O  ( -- fam )
;   aka 1 w/o

  hdr _public,'W/O',,one
wso: equ  one

; R/W  ( -- fam )
;   aka 2 r/w

  hdr _public,'R/W',,two
read_write: equ  two

; BIN  ( fam1 -- fam2 )
;   aka noop bin immediate

  hdr _public,'BIN',_immediate,noop
binn: equ  next

; OPEN1  ( a u fam -- | x ior )
;          getfh 0= if 2drop 4 ior unnest exit
;          then 1+ use c! >fname count fcb
;          setfcb dup uid c! setusr 0 0 rwp!

  hdr _hidden,'OPEN1'
open1:
  call do_colon
  dw gtfh,zero_equals
  dw question_branch,open1.1
  dw two_drop
  dw c_lit
  db 4
  dw ior
  if  debug
    dw paren_dot_quote
    dcs 'UNNEST_OPEN1'
  endif
  dw unnest
  dw exit
open1.1:
  dw one_plus
  dw use,c_store
  dw tfnam,count
  dw fcb
  dw sfcb
  dw dup
  dw uid,c_store
  dw setusr
  dw zero,zero
  dw rwpst
  dw exit

; OPEN2  ( fn# -- fid flag )  fh fcb rot bdos 255 = rstusr

  hdr _hidden,'OPEN2'
open2:
  call do_colon
  dw fh
  dw fcb
  dw rot
  dw bdos
  dw c_lit
  db 255
  dw equals
  dw rstusr
  dw exit

; OPEN3  ( flag err -- | ior )  ?ior ?dup if 0 use c! unnest then

  hdr _hidden,'OPEN3'
open3:
  call do_colon
  dw qior
  dw question_dup
  dw question_branch,open3.1
  dw zero
  dw use,c_store
  if  debug
    dw paren_dot_quote
    dcs 'UNNEST_OPEN3'
  endif
  dw unnest
open3.1:
  dw exit

; OPEN-FILE  ( a u fam -- fid ior )
;          open1 15 open2 2 open3 fcb 9 + c@
;          6 rshift use c@ and 1 > 5 open3 0

  hdr _public,'OPEN-FILE'
open_file:
  call do_colon
  dw open1
  dw c_lit
  db 15
  dw open2
  dw two,open3
  dw fcb    ; test if file R/O and mode=write
  dw c_lit
  db 9
  dw plus,c_fetch
  dw c_lit
  db 6
  dw rshift
  dw use,c_fetch,and_
  dw one,greater
  dw c_lit
  db 5
  dw open3,zero
  dw exit

; CREATE-FILE  ( a u fam -- fid ior )
;          open1 fcb 19 bdos drop 22 open2
;          5 open3 0

  hdr _public,'CREATE-FILE'
creatf:
  call do_colon
  dw open1
  dw fcb
  dw c_lit
  db 19
  dw bdos,drop
  dw c_lit
  db 22
  dw open2
  dw c_lit
  db 5
  dw open3
  dw zero
  dw exit

; >FCB  ( a u -- fcb usr )  2dup >fname 18 + -rot 2 pick setfcb

  hdr _public,'>FCB'
tfcb:
  call do_colon
  dw two_dup,tfnam
  dw c_lit
  db 18
  dw plus
  dw minus_rot
  dw two,pick
  dw sfcb
  dw exit

; DELETE-FILE  ( a u -- ior )  >fcb setusr 19 bdos rstusr 255 = 2
;          ?ior

  hdr _public,'DELETE-FILE'
delf:
  call do_colon
  dw tfcb,setusr
  dw c_lit
  db 19
  dw branch,closf.2

; RENAME-FILE  ( a1 u1 a2 u2 -- ior )
;          2swap >fcb setusr >r >fcb drop r@ c@
;          over c! dup 15 bdos 255 = if r@ 16 +
;          16 cmove r> 23 bdos 255 = 2 ?ior else
;          16 bdos r> 2drop 5 ior then rstusr

  hdr _public,'RENAME-FILE'
renf:
  call do_colon
  dw two_swap
  dw tfcb,setusr,to_r
  dw tfcb,drop
  dw r_fetch,c_fetch
  dw over,c_store
  dw dup
  dw c_lit
  db 15
  dw bdos
  dw c_lit
  db 255
  dw equals
  dw question_branch,renf.1
  dw r_fetch
  dw c_lit
  db 16
  dw plus
  dw c_lit
  db 16
  dw cmove,from_r
  dw c_lit
  db 23
  dw branch,closf.2
renf.1:
  dw c_lit
  db 16
  dw bdos
  dw from_r,two_drop
  dw c_lit
  db 5
  dw ior
  dw rstusr
  dw exit

; OFFS  ( -- x )      0 value offs

  hdr _hidden,'OFFS'
offs:
  call do_value
  dw 0

; SETSIZ  ( -- size )    rwp@ over $7F and to offs fcb 33 +
;          rec! (recsiz) offs -

  hdr _hidden,'SETSIZ'
setsiz:
  call do_colon
  dw rwp_fetch,over
  dw c_lit
  db 0x7f
  dw and_
  dw paren_to,offs
  dw fcb
  dw c_lit
  db 33
  dw plus,rec_store
  dw c_lit
  db recsiz
  dw offs,minus
  dw exit

; SETDMA  ( a -- )    26 bdos drop

  hdr _public,'SETDMA'
setdma:
  pop de
  ld a,26
  call bdoss
  jp next

; RANRW  ( a size fn# -- a size | a u' )
;          fcb swap bdos if drop unnest r> then

  hdr _hidden,'RANRW'
ranrw:
  call do_colon
  dw fcb,swap,bdos
  dw question_branch,ranrw.1
  dw drop
  if  debug
    dw paren_dot_quote
    dcs 'UNNEST_RW'
  endif
  dw unnest
  dw from_r
ranrw.1:
  dw exit

; RDINI  ( a u fid mask -- u a u | u ior )
;          setfh ?dup if nip ior unnest exit
;          then tuck

  hdr _hidden,'RDINI'
rdini:
  call do_colon
  dw stfh,question_dup
  dw question_branch,rdini.1
  dw nip
  dw ior
  if  debug
    dw paren_dot_quote
    dcs 'UNNEST_RDINI'
  endif
  dw unnest
  dw exit
rdini.1:
  dw tuck
  dw exit

; FREAD  ( a u1 -- a u2 )    begin dup while >r setsiz r@ umin
;          dup (recsiz) = if over setdma 33
;          ranrw else hbuf setdma 33 ranrw 2dup
;          hbuf offs + -rot cmove then dup >r +
;          rwp@ r@ m+ rwp! 2r> - repeat

  hdr _hidden,'FREAD'
fread:
  call do_colon
fread.1:
  dw dup
  dw question_branch,fread.4
  dw to_r
  dw setsiz
  dw r_fetch,u_min
  dw dup
  dw c_lit
  db recsiz
  dw equals
  dw question_branch,fread.2
  dw over,setdma
  dw c_lit
  db 33
  dw ranrw
  dw branch,fread.3
fread.2:
  dw hbuf,setdma
  dw c_lit
  db 33
  dw ranrw
  dw two_dup,hbuf
  dw offs,plus
  dw minus_rot,cmove
fread.3:
  dw dup,to_r
  dw plus
  dw rwp_fetch
  dw r_fetch,m_plus
  dw rwpst
  dw two_from_r,minus
  dw branch,fread.1
fread.4:
  dw exit

; WRINI  ( a u fid mask -- a u | ior )
;          setfh ?dup if nip nip ior unnest          then

  hdr _hidden,'WRINI'
wrini:
  call do_colon
  dw stfh,question_dup
  dw question_branch,wrini.1
  dw nip,nip
  dw ior
  if  debug
    dw paren_dot_quote
    dcs 'UNNEST_WRINI'
  endif
  dw unnest
wrini.1:
  dw exit

; FWRITE  ( a u1 -- a u2 )  begin dup while >r setsiz r@ umin dup
;          (recsiz) = if over setdma else hbuf
;          (recsiz) $1A fill hbuf setdma fcb 33
;          bdos drop 2dup hbuf offs + swap cmove
;          then 34 ranrw dup >r + rwp@ r@ m+
;          rwp! 2r> - repeat

  hdr _hidden,'FWRITE'
fwrit:
  ; XXX TODO
  ; XXX TMP -- 2drop
  pop hl
  pop hl
  jp next
; XXX OLD
;;  call do_colon
;;fwrit.1:
;;  dw dup
;;  dw question_branch,fwrit.4
;;  dw to_r
;;  dw setsiz
;;  dw r_fetch,u_min
;;  dw dup
;;  dw c_lit
;;  db recsiz
;;  dw equals
;;  dw question_branch,fwrit.2
;;  dw over,setdma
;;  dw branch,fwrit.3
;;fwrit.2:
;;  dw hbuf
;;  dw c_lit
;;  db recsiz
;;  dw c_lit
;;  db ctlz
;;  dw fill
;;  dw hbuf,setdma
;;  dw fcb
;;  dw c_lit
;;  db 33
;;  dw bdos,drop
;;  dw two_dup
;;  dw hbuf
;;  dw offs,plus
;;  dw swap
;;  dw cmove
;;fwrit.3:
;;  dw c_lit
;;  db 34
;;  dw ranrw
;;  dw dup,to_r
;;  dw plus
;;  dw rwp_fetch
;;  dw r_fetch,m_plus
;;  dw rwpst
;;  dw two_from_r,minus
;;  dw branch,fwrit.1
;;fwrit.4:
;;  dw exit

; READ-FILE  ( a u1 fid -- u2 ior )  1 rdini uid c@ setusr fread
;          rstusr nip - 0

  hdr _public,'READ-FILE'
readf:
  call do_colon
  dw one,rdini
  dw uid,c_fetch
  dw setusr
  dw fread
  dw rstusr
  dw nip
  dw minus
  dw zero
  dw exit

; WRITE-FILE  ( a u fid -- ior )  2 wrini uid c@ setusr fwrite
;          rstusr nip 0<> 255 ?ior

  hdr _public,'WRITE-FILE'
writf:
  call do_colon
  dw two,wrini
  dw uid,c_fetch
  dw setusr
  dw fwrit
  dw rstusr
  dw nip
  dw zero_not_equals
  dw c_lit
  db 255
  dw qior
  dw exit

; WRITE-LINE  ( ca u fileid -- ior )
;        dup >r write-file ?dup if r> drop exit
;        then (crlf) 2 r> write-file

  hdr _public,'WRITE-LINE'
write_line:
  call do_colon
  dw dup,to_r
  dw writf,question_dup
  dw question_branch,write_line.1
  dw from_r,drop
  dw exit
write_line.1:
  dw lit,crlf
  dw two
  dw from_r
  dw writf
  dw exit

; EOL?  ( a -- 2|1|0 )    c@ $0D of 2 exit then $0A of 1 exit
;          then drop 0

  hdr _hidden,'EOL?'
eol_question:
  pop hl
  ld a,(hl)
  cp cr_char
  jp z,two
  cp lf_char
  jp z,one
  jp zero

; READ-LINE  ( a u1 fid -- u2 flag ior )  >r over swap r> read-file
;          ?dup if exit then 2dup over + swap
;          ?do i dup c@ $1A = if rot - fh
;          file-size drop rwp! leave then eol?
;          ?dup if i + >r over + r> swap - dup
;          0<> rwp@ d+ rwp! i swap - -1 0 unloop
;          exit then loop nip dup 0<> 0

  hdr _public,'READ-LINE'
read_line:
; XXX TODO
  pop hl
  pop hl
  pop hl
  jp next
; XXX OLD -- DX-Forth 4.00
;;  call do_colon
;;  dw to_r,over,swap,from_r
;;  dw readf,question_dup
;;  dw question_branch,read_line.1
;;  dw exit
;;read_line.1:
;;  dw two_dup,over,plus,swap
;;  dw paren_question_do,read_line.5
;;read_line.2:
;;  dw i_
;;  dw dup,c_fetch
;;  dw c_lit
;;  db ctlz
;;  dw equals
;;  dw question_branch,read_line.3
;;  dw rot,minus
;;  dw fh,file_size,drop,rwpst
;;  dw paren_leave,read_line.2-cw
;;read_line.3:
;;  dw eol_question,question_dup
;;  dw question_branch,read_line.4
;;  dw i_,plus,to_r
;;  dw over,plus
;;  dw from_r
;;  dw swap,minus
;;  dw dup,zero_not_equals  ; handle buffer > 32K
;;  dw rwp_fetch,d_plus,rwpst
;;  dw i_,swap,minus
;;  dw true,zero
;;  dw unloo,exit
;;read_line.4:
;;  dw paren_loop,read_line.2
;;read_line.5:
;;  dw nip
;;  dw dup,zero_not_equals,zero
;;  dw exit

; screen file selector

; XXX OLD
fdtab:
  gfdb      ; fdb table

; SFP  ( -- a )

  hdr _hidden,'SFP'
sfp:
  call do_create
sfp.1:
  dw fdtab    ; current
sfp.2:
  dw fdtab+cw  ; swap-file

; SWAP-FILE  ( -- )  scr @ scr# ! sfp 2@ swap sfp 2!
;        scr# @ scr ! empty-buffers

  hdr _public,'SWAP-FILE'
swap_file:
  call do_colon
  dw scr,fetch
  dw snum,store
  dw sfp,two_fetch
  dw swap
  dw sfp,two_store
  dw snum,fetch
  dw scr,store
  dw empty_buffers
  dw exit

; FDB  ( -- a )  (fdtab) (nfd) 0 do dup @ @ 0= if unloop exit
;        then cell+ loop abort" too many files"

  hdr _public,'FDB'
  ; get a free slot
fdb:
  call do_colon
  dw lit,fdtab
  dw c_lit
  db nfd
  dw zero
  dw paren_do,fdb.3
fdb.1:
  dw dup,fetch,fetch
  dw zero_equals
  dw question_branch,fdb.2
  dw unloo
  dw exit
fdb.2:
  dw cell_plus
  dw paren_loop,fdb.1
fdb.3:
  dw paren_abort_quote
  dcs 'too many files'
  dw exit

; file descriptor fields
;
;  FD  cell    status 0=closed
;  FID  cell    file handle
;  BLKS  cell    file size (blocks)
;  SCR#  cell    current SCR#
;  FNB  'filename_size' bytes  file name

; FD  ( -- a )

  hdr _hidden,'FD'
fd:
  call do_colon    ; file descriptor field
  dw sfp,fetch,fetch
  dw exit

; FID  ( -- a )

  hdr _hidden,'FID'
fid:
  ld e,cw    ; file handle field
fid.1:
  ld d,0
  push de
  call do_colon
  dw fd,plus
  dw exit

; BLKS  ( -- a )

  hdr _hidden,'BLKS'
blks:
  ld e,cw*2    ; file size field
  jp fid.1

; SCR#  ( -- a )

  hdr _hidden,'SCR#'
snum:
  ld e,cw*3    ; current SCR# field
  jp fid.1

; FNB  ( -- a )

  hdr _hidden,'FNB'
fnb:
  ld e,cw*4    ; file name field
  jp fid.1

; BUF  ( -- a )
; file buffer address

  hdr _hidden,'BUF'
buf:
  call do_constant
  dw block_buffer

; BLK#  ( -- a )
; update flag

  hdr _hidden,'BLK#'
blk_number:
  call do_create
blk_number.variable:
  ds cw

; FILE?  ( -- flag )

  hdr _public,'FILE?'
file_question:
  call do_colon
  dw fd,fetch ; fd @
  dw zero_not_equals ; 0<>
  dw exit

; LOADFILE  ( -- ca u )  fnb count

  hdr _public,'LOADFILE'
loadfile:
  call do_colon
  dw fnb,count
  dw exit

; ?OPEN  ( -- )    file? 0= abort" no file open"

  hdr _hidden,'?OPEN'
qopen:
  call do_colon
  dw file_question
  dw zero_equals
  dw paren_abort_quote
  dcs 'no file open'
  dw exit

; #SCREENS  ( -- +n )  ?open blks @

  hdr _public,'#SCREENS'
nscr:
  call do_colon
  dw qopen
  dw blks,fetch
  dw exit

; EMPTY-BUFFERS  ( -- )  $7fff blk# !

  hdr _public,'EMPTY-BUFFERS'
empty_buffers:
  ld hl,0x7fff
  ld (blk_number.variable),hl
  jp next

; UPDATE  ( -- )
; ?open blk# @ $8000 or blk# !

  hdr _public,'UPDATE'
update:
  call do_colon
  dw qopen
  dw blk_number,fetch
  dw lit,0x8000
  dw or_
  dw blk_number,store
  dw exit

; BLKERR  ( flag -- )  abort" block r/w error"

  hdr _hidden,'BLKERR'
blkerr:
  call do_colon
  dw paren_abort_quote
  dcs 'block r/w error'
  dw exit

; BLK-RW  ( +n mode -- )
;   >r b/buf um* fid @ reposition-file blkerr
;   buf b/buf fid @ r> if write-file else
;   read-file blkerr b/buf < then blkerr

  hdr _hidden,'BLK-RW'
blkrw:
  call do_colon
  dw to_r
  dw bytes_per_buffer,umstr
  dw fid,fetch
  dw reposf
  dw blkerr
  dw buf,bytes_per_buffer
  dw fid,fetch
  dw from_r
  dw question_branch,blkrw.1
  dw writf
  dw branch,blkrw.2
blkrw.1:
  dw readf
  dw blkerr
  dw bytes_per_buffer,less
blkrw.2:
  dw blkerr
  dw exit

; ?BLK  ( +n -- +n )  dup #screens 0 within
;        abort" block out of range"

  hdr _hidden,'?BLK'
qblk:
  call do_colon
  dw dup
  dw nscr,zero
  dw within    ; block in range?
  dw paren_abort_quote
  dcs 'block out of range'
  dw exit

; SAVE-BUFFERS  ( -- )  ?open blk# @ 0< if blk# @ $7fff and
;        dup blk# ! ?blk 1 blk-rw then

  hdr _public,'SAVE-BUFFERS'
save_buffers:
  call do_colon
  dw qopen
  dw blk_number,fetch
  dw zero_less
  dw question_branch,savbuf.1
  dw blk_number,fetch
  dw lit,0x7fff
  dw and_
  dw dup
  dw blk_number,store
  dw qblk    ; block in range?
  dw one,blkrw
savbuf.1:
  dw exit

; FLUSH  ( -- )    save-buffers empty-buffers

  hdr _public,'FLUSH'
flush:
  call do_colon
  dw save_buffers,empty_buffers
  dw exit

; BUFFER  ( +n -- a )  save-buffers ?blk blk# ! buf

  hdr _public,'BUFFER'
buffer:
  call do_colon
  dw save_buffers
  dw qblk
  dw blk_number,store
  dw buf
  dw exit

; BLOCK  ( +n -- a )
;   ?open blk# @ $7fff and over - if dup
;   buffer drop 0 blk-rw else drop then buf

  hdr _public,'BLOCK'
block:
  call do_colon
  dw qopen
  dw blk_number,fetch
  dw lit,0x7fff
  dw and_,over,minus
  dw question_branch,block.1
  dw dup,buffer,drop
  dw zero,blkrw
  dw branch,block.2
block.1:
  dw drop
block.2:
  dw buf
  dw exit

; -->  ( -- )
;   blk @ 0= abort" loading only" (refill) drop
;        ; immediate

  hdr _public,'-->',_immediate
next_block:
  call do_colon
  dw blk,fetch,zero_equals
  dw paren_abort_quote
  dcs 'loading only'
  dw paren_refill,drop
  dw exit

; (THRU)  ( +n1 +n2 -- )  1+ swap ?do i block b/buf i (evaluate) loop

  hdr _hidden,'(THRU)'
paren_thru:
  call do_colon
  dw one_plus,swap
  dw paren_question_do,paren_thru.2
paren_thru.1:
  dw i_,block
  dw bytes_per_buffer
  dw i_,paren_evaluate
  dw paren_loop,paren_thru.1
paren_thru.2:
  dw exit

; THRU  ( +n1 +n2 -- )  (thru) ?block

  hdr _public,'THRU'
thru:
  call do_colon
  dw paren_thru
  dw question_block
  dw exit

; LOAD  ( +n -- )   dup thru

  hdr _public,'LOAD'
load:
  pop hl
  push hl
  push hl
  jp thru

; FNBUF  ( -- a )

  hdr _hidden,'FNBUF'
fnbuf:
  call do_create    ; current file handle
  ds filename_size

; (FBK)  ( +n -- )  #screens 2dup u< if drop dup loadfile -ext
;        s" $$$" +ext fnbuf place fnbuf count w/o
;        create-file throw over 0 ?do dup i block
;        b/buf rot write-file throw loop close-file
;        throw fid @ close-file throw loadfile
;        delete-file throw fnbuf count loadfile
;        rename-file throw loadfile r/w open-file
;        throw fid ! then over blks ! ?do i buffer
;        b/buf blank update save-buffers loop

  hdr _hidden,'(FBK)'
pfbk:
  call do_colon
  dw nscr    ; tests if file open
  dw two_dup,u_less
  dw question_branch,pfbk.3
  dw drop,dup
  dw loadfile,minus_ext
  dw paren_s_quot
  dcs '$$$'
  dw plus_ext
  dw fnbuf,place
  dw fnbuf,count
  dw wso,creatf,throw
  dw over,zero
  dw paren_question_do,pfbk.2
pfbk.1:
  dw dup
  dw i_,block
  dw bytes_per_buffer
  dw rot,writf,throw
  dw paren_loop,pfbk.1
pfbk.2:
  dw closf,throw
  dw fid,fetch
  dw closf,throw
  dw loadfile,delf,throw
  dw fnbuf,count
  dw loadfile,renf,throw
  dw loadfile
  dw read_write,open_file,throw
  dw fid,store
pfbk.3:
  dw over
  dw blks,store  ; update max block
  dw paren_question_do,pfbk.5
pfbk.4:
  dw i_,buffer
  dw bytes_per_buffer,blank
  dw update,save_buffers
  dw paren_loop,pfbk.4
pfbk.5:
  dw exit

; FILEBLOCKS  ( +n -- )  ['] (fbk) catch abort" can't resize file"

  hdr _public,'FILEBLOCKS'
fbloc:
  call do_colon
  dw lit,pfbk
  dw catch
  dw paren_abort_quote
  dcs "can't resize file"
  dw exit

; CLOSE  ( -- )
;  file? if flush fid @ close-file drop
;        fd off then empty-buffers
;
; close current file
; NOTE: errors are NOT reported with this function

  hdr _public,'CLOSE'
close:
  call do_colon
  dw file_question
  dw question_branch,close.1
  dw flush
  dw fid,fetch
  dw closf,drop
  dw fd,off
close.1:
  dw empty_buffers
  dw exit

; CLOSE-ALL  ( -- )  close (fdtab) nfd 0 do dup sfp ! close
;        cell+ loop drop

  hdr _public,'CLOSE-ALL'
closa:
  call do_colon
  dw close    ; ensure buffer flushed
  dw lit,fdtab
  dw c_lit
  db nfd
  dw zero
  dw paren_do,closa.2
closa.1:
  dw dup
  dw sfp,store
  dw close
  dw cell_plus
  dw paren_loop,closa.1
closa.2:
  dw drop
  dw exit

; LASTFILE  ( -- ca u )  zbuf cell+ @ count

  hdr _hidden,'LASTFILE'
lastfile:
  call do_colon    ; last named file used by open-file etc
  dw zbuf,cell_plus
  dw fetch,count
  dw exit

; .LASTFILE  ( -- )  beep cr lastfile type space

  hdr _hidden,'.LASTFILE'
dot_lastfile:
  call do_colon
  dw beep,cr
  dw lastfile,type
  dw space
  dw exit

; ?CREATE  ( ca u -- fileid )
;        r/o open-file 0= tuck if close-file then
;        drop if .lastfile ." exists - delete it? "
;        y/n 0= if abort then then lastfile r/w
;        create-file abort" can't create file"

  hdr _hidden,'?CREATE'
question_create:
  call do_colon
  dw rso,open_file  ; test if file exists
  dw zero_equals,tuck
  dw question_branch,question_create.1
  dw closf
question_create.1:
  dw drop
  dw question_branch,question_create.2
  dw dot_lastfile
  dw paren_dot_quote
  dcs 'exists - delete it? '
  dw yn,zero_equals
  dw question_branch,question_create.2
  dw abort
question_create.2:
  dw lastfile,read_write,creatf
  dw paren_abort_quote
  dcs "can't create file"
  dw exit

; INIT-SCR  ( fileid ior -- )  if drop exit then fdb sfp ! fd on
;          dup fid ! file-size drop b/buf
;          um/mod nip blks ! lastfile fnb
;          place loadfile upper empty-buffers

  hdr _hidden,'INIT-SCR'
init_scr:
  call do_colon    ; init screenfile
  dw question_branch,init_scr.1
  dw drop
  dw exit
init_scr.1:
  dw fdb,sfp,store
  dw fd,on
  dw dup,fid,store
  dw file_size,drop
  dw bytes_per_buffer,umslm,nip  ; overflow stores $FFFF
  dw blks,store
  dw lastfile,fnb,place
  dw loadfile,upper
  dw empty_buffers
  dw exit

; OPEN  ( ca u fam -- ior )
; open a screen file
;         fdb drop >r s" scr" +ext r>
;         open-file tuck init-scr

  hdr _public,'OPEN'
open:
  call do_colon
  dw fdb,drop  ; free slot?
  dw to_r
  dw paren_s_quot
  dcs 'scr'
  dw plus_ext
  dw from_r,open_file
  dw tuck
  dw init_scr
  dw exit

; (OPEN)  ( ca u -- )    r/w open abort" can't open file"

  hdr _hidden,'(OPEN)'
popen:
  call do_colon
  dw read_write,open
  dw paren_abort_quote
  dcs "can't open file"
  dw exit

; GETFILENAME  ( -- ca u )  token dup 0= abort" specify filename"

  hdr _public,'GETFILENAME'
getfilename:
  call do_colon
  dw token
  dw dup,zero_equals
  dw paren_abort_quote
  dcs 'specify filename'
  dw exit

; USING  ( "filename[.SCR]" -- )
;         close getfilename r/w open ?dup if
;          .lastfile -507 = if ." access denied"
;          0 else ." not found - create it? "
;          y/n then 0= if abort then lastfile
;          ?create 0 init-scr then 0 0 scr 2!
; open/make a screen file

  hdr _public,'USING'
using:
  call do_colon
  dw close
  dw getfilename
  dw read_write,open,question_dup
  dw question_branch,using.4
  dw dot_lastfile
  dw lit,-507,equals
  dw question_branch,using.1
  dw paren_dot_quote
  dcs 'access denied'
  dw zero
  dw branch,using.2
using.1:
  dw paren_dot_quote
  dcs 'not found - create it? '
  dw yn
using.2:
  dw zero_equals
  dw question_branch,using.3
  dw abort
using.3:
  dw lastfile,question_create
  dw zero,init_scr
using.4:
  dw zero,zero,scr,two_store
  dw exit

; LOADED  ( +n1 +n2 ca u -- )  sfp @ >r (open) (thru) close r>
;          sfp ! ?block

  hdr _public,'LOADED'
loaded:
  call do_colon
  dw sfp,fetch
  dw to_r
  dw popen
  dw paren_thru
  dw close
  dw from_r
  dw sfp,store
  dw question_block
  dw exit

; FLOAD  ( +n "filename[.SCR]" -- )  dup getfilename loaded

  hdr _public,'FLOAD'
fload:
  call do_colon
  dw dup
  dw getfilename
  dw loaded
  dw exit

; SAVE  ( "filename[.COM]" -- )
;        0 0 freeze getfilename s" com" +ext
;        ?create >r over swap boot 2! (cold.6) (zb1)
;        dup (zb_size*2) erase (cold.7-cold.6) cmove
;        $100 dp @ over - r@ write-file boot cell+
;        off ?dup 0= if (hm) dph @ over - rot 0=
;        and r@ write-file then r> close-file or
;        abort" can't save file"

  hdr _public,'SAVE'
save:
  call do_colon
  ; XXX TODO
  ; XXX OLD
;;  dw zero,zero
;;save.1:
;;  dw freeze
;;  dw getfilename
;;  dw paren_s_quot
;;  dcs 'com'
;;  dw plus_ext
;;  dw question_create
;;  dw to_r    ; fid
;;  dw over,swap  ; set boot flags
;;  dw boot,two_store
;;  dw lit,cold.6  ; insert compiler logo
;;  dw lit,zb1
;;  dw dup
;;  dw c_lit
;;  db zb_size*2
;;  dw erase
;;  dw c_lit
;;  db cold.7-cold.6
;;  dw cmove
;;  dw lit,0x0100
;;  dw dp,fetch
;;  dw over,minus
;;  dw r_fetch,writf  ; save application
;;  dw boot,cell_plus,off  ; reset forth flag
;;  dw question_dup,zero_equals
;;  dw question_branch,save.2
;;  dw lit,hm
;;  dw dph,fetch
;;  dw over,minus
;;  dw rot,zero_equals,and_  ; system size
;;  dw r_fetch,writf  ; save system
;;save.2:
;;  dw from_r,closf,or_
;;  dw paren_abort_quote
;;  dcs  "can't save file"
  dw exit

; TURNKEY  ( "bootword" "filename[.COM]" -- )

  hdr _public,'TURNKEY'
turnkey:
  call do_colon
  ; XXX TODO
  dw exit
  ; XXX OLD
;;  dw true
;;turnkey.1:
;;  dw tick
;;  dw branch,save.1

; TURNKEY-SYSTEM  ( "bootword" "filename[.COM]" -- )

  hdr _public,'TURNKEY-SYSTEM'
turnkey_system:
  call do_colon
  call do_colon
  ; XXX TODO
  dw exit
  ; XXX OLD
;;  dw zero
;;  dw branch,turnkey.1

; }}} **********************************************************
; Graphics {{{

; BORDER  ( n -- )

  hdr _public,'BORDER'
border:
  ; Code based on Benschop's Forth-83:
  ;   : BORDER  ( n -- )
  ;     DUP DUP 4 < 7 AND SWAP 8 * + 23624 C! 254 P! ;
  ; And this is the translation in Z80:
  pop hl
  ld a,l
  cp 4 ; dark color?
  jp nc,border_a
  ; dark color
  sla a
  sla a
  sla a ; *8 (converted to paper)
  add a,7 ; white ink
border_a:
  ld (sys_bordcr),a
  ld a,l
  out (254),a
  jp next

; PAPER  ( n -- )
  hdr _public,'PAPER'
paper:
  ; XXX TODO
  jp next

; INK  ( n -- )
  hdr _public,'INK'
ink:
  ; XXX TODO
  jp next

; GOVER ( n -- )
  hdr _public,'GOVER'
gover:
  ; XXX TODO -- Benschop's Forth-83 does this:
  ; 23697 DUP C@ 252 AND ROT 3 * OR SWAP C!
  jp next

; INVERSE  ( n -- )
  hdr _public,'INVERSE'
inverse:
  ; XXX TODO -- Benschop's Forth-83 does this:
  ; 23697 DUP C@ 243 AND ROT 12 * OR SWAP C!
  jp next

; NORMAL  ( -- )
  hdr _public,'NORMAL'
normal:
  ; XXX TODO -- Benschop's Forth-83 does this:
  ; 0 INK 7 PAPER 0 FLASH 0 BRIGHT 7 BORDER 0 GOVER 0 INV
  jp next

; }}} **********************************************************
; Floating point {{{

  if floating_point_support

; -FP  ( -- a )    marker -FP

  hdr _public,'-FP'
dfp:
  call next

;  FLOAT+ ( f-a1 -- f-a2 )  4 +

  hdr _public,'FLOAT+'
floatp:
  pop hl
  ld de,fw
  add hl,de
  push hl
  jp next

;  FLOATS ( n1 -- n2 )    4 *

  hdr _public,'FLOATS'
floats:
  pop hl
  add hl,hl
  add hl,hl
  push hl
  jp next

; FALIGN  ( -- )
;   aka noop falign immediate

  hdr _public,'FALIGN',_immediate,noop
falign: equ  next

;  FALIGNED ( a -- fa )
;   aka noop faligned immediate

  hdr _public,'FALIGNED',_immediate,noop
falignd: equ  next

; F,  (F: r -- ) or ( r -- )  , ,

  hdr _public,'F,'
fcomm:
  call do_colon
  dw comma,comma
  dw exit

; FLITERAL  ( -- r )
;   aka fliteral 2literal immediate

  hdr _public,'FLITERAL',_immediate,two_literal
f_literal equ  two_literal
f_lit:    equ  two_lit

; FCONSTANT  ( -- r )
;   aka 2constant fconstant

  hdr _public,'FCONSTANT',,two_constant
f_constant: equ  two_constant

do_f_constant: equ  two_fetch

; FVARIABLE  ( -- fa )
;   aka 2variable fvariable

  hdr _public,'FVARIABLE',,two_variable
f_variable: equ  two_variable

; FDEPTH   ( -- +n )
;   depth 2/

  hdr _public,'FDEPTH'
fdepth:
  call do_colon
  dw depth
  dw two_slash
  dw exit

; FDROP  ( r -- )
;   aka 2drop fdrop

  hdr _public,'FDROP',,two_drop
f_drop: equ  two_drop

; FDUP  ( r -- r r )
;   aka 2dup fdup

  hdr _public,'FDUP',,two_dup
f_dup: equ  two_dup

; FSWAP  ( r1 r2 -- r2 r1 )
;   aka 2swap fswap

  hdr _public,'FSWAP',,two_swap
f_swap: equ  two_swap

; FOVER  ( r1 r2 -- r1 r2 r1 )
;   aka 2over fover

  hdr _public,'FOVER',,two_over
f_over: equ  two_over

; FROT  ( r1 r2 r3 -- r2 r3 r1 )
;   aka 2rot frot

  hdr _public,'FROT',,two_rot
f_rot: equ  two_rot

; F@  ( fa -- r )
;   aka 2@ f@

  hdr _public,'F@',,two_fetch
f_fetch: equ  two_fetch

; F!  ( r fa -- )
;   aka 2! f!

  hdr _public,'F!',,two_store
f_store: equ  two_store

; FPICK  ( +n -- r )
;   floats sp@ cell+ + f@

  hdr _public,'FPICK'
fpick:
  call do_colon
  dw floats
  if  separated_f_stack
    dw fsp,fetch
  else
    dw sp_fetch,cell_plus
  endif
  dw plus,f_fetch
  dw exit

; floating point accumulator

accumulator_exponent:     ds 1
accumulator_sign:         ds 1
accumulator_1st_fraction  ds 1
accumulator_2nd_fraction  ds 1
accumulator_3rd_fraction  ds 1

substraction_flag:        ds 1

float_tmp_1:
  ds fw    ; temp float storage
float_tmp_2:
  ds fw    ;

f_ten:
  call do_f_constant    ; fconstant
fp10:
  db 0x84,0x20,0,0  ; 10.0

; save/load temp fp registers

savf.1:
  ld hl,float_tmp_1    ; save regs to float_tmp_1
  jp str

savf.2:
  ld hl,float_tmp_2    ; save regs to float_tmp_2
  jp str

lodf.1:
  ld hl,float_tmp_1    ; load accum/regs from float_tmp_1
  jp lod

lodf.2:
  ld hl,float_tmp_2    ; load accum/regs from float_tmp_2
  jp lod

; pop float from stack to accum, saving bc

ldop:
  pop de
  pop hl
  ld (float_tmp_1),hl
  pop hl
  ld (float_tmp_1+2),hl
  push bc
  push de
  ld hl,float_tmp_1
  jp lod

; pop 2 float from stack to hl (float_tmp_2) and accum, saving bc

ld2op:
  pop hl
  ld (ld2op1),hl
  pop hl
  ld (float_tmp_2),hl
  pop hl
  ld (float_tmp_2+2),hl
  call ldop
  ld hl,(ld2op1)
  push hl
  ld hl,float_tmp_2
  ret

ld2op1:
  ds 2

; push float registers to stack, restore bc and exit

svop:
  ld l,a
  ld h,b
  ld e,c
  pop bc
  push de
  jp next

; str  store registers to accum

strr:
  ld hl,accumulator_exponent
  ld (hl),e
  inc  hl

; entry - hl=adr, a=exp, bcd (packed)
; exit  - none

str:
  ld (hl),a
str.1:
  inc  hl    ; entry when hl=accumulator_sign
  ld (hl),b
  inc  hl
  ld (hl),c
  inc  hl
  ld (hl),d
  ret

; zero - set accum and regs to zero

zro:
  xor a
  ld (accumulator_exponent),a
  ld b,a
  ld c,a
  ld d,a
  ret

; overflow - set regs to maximum, set cy

ovf:
  ld bc,0x7fff
  ld a,c
  ld d,c
  scf
  ret

; chs  change sign of accumulator
; entry - none
; exit  - bcd (packed), a=exp, flags set

chs:
  ld a,0x80
  jp fab.1

; change sign of accumulator and again on result
; (when calling routine completes)

chss:
  call chs
  ld hl,chs
  ex (sp),hl
  jp (hl)

; fab  set acc to absolute
;
; entry - none
; exit  - bcd (packed), a=exp, flags set

fab:
  xor a
fab.1:
  ld hl,accumulator_sign
  and (hl)
  xor 0x80
  ld (hl),a    ; fall thru tst

; tst  load registers from acc and test
; exit  - bcd (packed), a=exp, flags set

tst:
  ld hl,accumulator_exponent
  ld a,(hl)
  and a
  jp z,zro
  ld e,a    ; e exp
  inc  hl
  ld a,(hl)    ; accumulator_sign
  inc  hl
  xor (hl)    ; pack msb with sign
  inc  hl
  ld c,(hl)
  inc  hl
  ld d,(hl)
  jp tst.1

; lod  load float (hl) to accum and regs, set flags
; entry - hl=adr
; exit  - bcd (packed), a=exp, flags set

lod:
  ld a,(hl)
  and a
  jp z,zro
  ld e,a
  inc  hl
  ld a,(hl)
  inc  hl
  ld c,(hl)
  inc  hl
  ld d,(hl)
  ld l,a
  or 0x80
  ld b,a
  xor l
lod.2:
  call strr
  xor b

; entry - acd (packed), e=exp
; exit  - bcd (packed), a=exp, flags set

tst.1:
  ld b,a
tst.2:
  or 1    ; test sign, clear Z C flags
  ld a,e
  ret

; entry - a=exp
; exit  - e=exp  Z=zero M=negative

tstr:
  ld e,a
tstr.1:
  or a
  ret  z
tstr.2:
  ld a,b
  jp tst.2

; fcmp  compare registers with (hl), return M if regs < (hl)

fcmp:
  ld e,a
  ld a,(hl)
  or a
  ld a,e
  jp z,tstr.1    ; hl zero, test sign regs
  or a
  inc  hl
  ld a,(hl)
  cpl
  jp z,tst.2    ; regs zero, test sign hl
  xor b
  jp p,tstr.2    ; signs differ
  call fcmp.1
  rra
  xor b    ; complement sign for neg values
  ld a,e
  ret

fcmp.1:
  dec  hl
  ld a,e
  cp (hl)
  ret  nz
  inc  hl
  ld a,b
  cp (hl)
  ret  nz
  inc  hl
  ld a,c
  cp (hl)
  ret  nz
  inc  hl
  ld a,d
  cp (hl)
  ret  nz
  pop hl
  ld a,e
  ret

; right shift bcd by a bits
;
; entry - bcd, a=shift count
; exit  - bcde

shr_:
  ld e,0
  ld l,8    ; shift 8 bits by moving registers
shr_.1:
  cp l
  jp m,shr_.2    ; less than 8
  ld e,d
  ld d,c
  ld c,b
  ld b,0
  sub  l
  jp nz,shr_.1
shr_.2:
  and a
  ret  z    ; done
  ld l,a
shr_.3:
  and a    ; clear carry
  ld a,b
  rra
  ld b,a
  ld a,c
  rra
  ld c,a
  ld a,d
  rra
  ld d,a
  ld a,e
  rra
  ld e,a
  dec  l
  jp nz,shr_.3
  ret

; left shift bcde one bit
;
; entry - bcde
; exit  - bcde

shl_:
  ld a,e
  rla
  ld e,a
  ld a,d
  rla
  ld d,a
  ld a,c
  rla
  ld c,a
  ld a,b
  adc  a,a
  ld b,a
  ret

; Complement bcde adjust accumulator_sign, return sign flag

fcpl:
  ld hl,accumulator_sign    ; change accum sign
  ld a,(hl)
  xor 0x80
  ld (hl),a
  xor a    ; complement fraction
  ld l,a
  sub  e
  ld e,a
  ld a,l
  sbc a,d
  ld d,a
  ld a,l
  sbc a,c
  ld c,a
  ld a,l
  sbc a,b
  ld b,a
  ret

; Normalize bcde registers, adjust accumulator_exponent
;
; entry - bcde
; exit  - bcde, z= bcde=0 or accumulator_exponent=0

norm:
  ld l,32    ; max shift
norm.1:
  ld a,b
  and a
  jp nz,norm.3
  ld b,c
  ld c,d
  ld d,e
  ld e,a
  ld a,l
  sub  8
  ld l,a
  jp nz,norm.1
  ret     ; bcde = zero

norm.2:
  dec  l    ; shl until bit 31 set
  call shl_
norm.3:
  jp p,norm.2

  ld a,l    ; adjust accum exp
  sub  32
  ld hl,accumulator_exponent
  add a,(hl)
  ld (hl),a
  ret  z    ; if zero exp
  rra      ; move borrow bit to sign
  and a    ; set sign to indicate underflow
  ret

; Round the bcde registers, save to acc
;
; entry - bcde
; exit  - bcd, a=packed msb, e=exp, cy=ovf

rondr:
  ld a,e    ; lsb
  and a    ; test sign and clear cy
  ld hl,accumulator_exponent    ; exp
  ld e,(hl)
  call m,rondr.1
  ret  c    ; rounder overflow
  ld a,b
  inc  hl    ; accumulator_sign
  xor (hl)    ; a=packed msb
  jp str.1    ; save bcd to acc

; round up bcd e=exp, cy=ovf

rondr.1:
  inc  d
  ret  nz
  inc  c
  ret  nz
  inc  b
  ret  nz
  ld b,0x80    ; new 1st fraction
  ld a,e    ; inc exp
  add a,1    ; adjust cy
  ld e,a
  ld (accumulator_exponent),a  ; new acc exp
  ret

; fsu  floating point subtract subroutine

fsu:
  ld a,0x80    ; mask to change operand sign
  jp fad.1

; fad  floating point add subroutine

fad:
  xor a
fad.1:
  ld e,(hl)    ; load operand to abcd
  inc  hl
  xor (hl)
  ld b,a
  inc  hl
  ld c,(hl)
  inc  hl
  ld d,(hl)
  ld a,e
  and a
  jp z,tst    ; operand zero

  ld l,b    ; unpack
  ld a,b
  or 0x80
  ld b,a
  xor l    ; generate subtraction flag
  ld hl,accumulator_sign
  xor (hl)
  ld (substraction_flag),a

; determine relative magnitudes of operand and accum

  dec  hl    ; accumulator_exponent
  ld a,(hl)
  and a
  jp z,fad.8    ; accum zero

  sub  e    ; get difference of exponents
  jp c,fad.2    ; accum smaller

; check for insignificant operand

  jp m,tst
  cp 25    ; compare shift count to 25
  jp c,fad.3
  jp tst

; check for insignificant accum, exchange accum and operand

fad.2:
  jp p,fad.8
  cp 0-25    ; compare shift count to -25
  jp c,fad.8

  ld (hl),e    ; set accumulator_exponent

  ld e,a    ; save shift count

  ld a,(substraction_flag)    ; set accum sign
  inc  hl    ; accumulator_sign
  xor (hl)
  ld (hl),a

  xor a    ; complement shift count
  sub  e

  inc  hl    ; exchange fraction
  ld e,(hl)
  ld (hl),b
  ld b,e
  inc  hl
  ld e,(hl)
  ld (hl),c
  ld c,e
  inc  hl
  ld e,(hl)
  ld (hl),d
  ld d,e

; position the operand, check if add or subtract

fad.3:
  call shr_
  ld hl,accumulator_3rd_fraction
  ld a,(substraction_flag)
  and a
  jp m,fad.4

  ld a,(hl)    ; add
  add a,d
  ld d,a
  dec  hl
  ld a,(hl)
  adc  a,c
  ld c,a
  dec  hl
  ld a,(hl)
  adc  a,b
  ld b,a
  jp nc,fpack

  rra      ; got carry, so rshift fraction
  ld b,a
  ld a,c
  rra
  ld c,a
  ld a,d
  rra
  ld d,a
  rra
  ld e,a
  ld hl,accumulator_exponent    ; and adjust exponent
  ld a,(hl)
  add a,1
  ld (hl),a
  jp c,ovf    ; overflow
  jp fpack

fad.4:
  xor a    ; subtract
  sub  e
  ld e,a
  ld a,(hl)
  sbc a,d
  ld d,a
  dec  hl
  ld a,(hl)
  sbc a,c
  ld c,a
  dec  hl
  ld a,(hl)
  sbc a,b
  ld b,a

; complement bcde if carry

cnpack:
  call c,fcpl

; normalize and pack bcde

npack:
  ld a,b
  and a
  call p,norm
  jp p,zro    ; underflow or zero

; pack bcde

fpack:
  call rondr    ; round bcde
  jp c,ovf
  jp tst.1

; move operand to accumulator

fad.8:
  ld a,(substraction_flag)
  ld hl,accumulator_sign
  xor (hl)
  jp lod.2

; read the operand at (hl), check the accum exponent

mdex:
  ld b,a
  inc  hl
  ld c,(hl)
  inc  hl
  ld d,(hl)
  inc  hl
  ld e,(hl)

  ld hl,accumulator_exponent    ; accum exp
  ld a,(hl)
  and a
  ret  z    ; is zero

  add a,b    ; result exp plus bias
  ld b,a
  rra      ; carry to sign
  xor b    ; carry and sign must differ
  ld a,b    ; result exp plus bias
  ld b,0x80    ; exp bias, sign mask, most sig bit
  jp p,mdex.1    ; if over or underflow
  sub  b    ; remove excess exp bias
  ret  z    ; return if underflow
  ld (hl),a    ; result exp
  inc  hl    ; address accum sign
  ld a,(hl)
  xor c    ; result sign in sign bit
  and b    ; result sign
  ld (hl),a    ; store it
  ld a,c    ; operand sign and 1st fraction
  or b    ; operand first fraction
  ret

mdex.1:
  rlca      ; set carry bit if overflow
  ret  c
  xor a    ; clear a register
  ret      ; return if underflow

; fmu  floating point multiplication subroutine

fmu:
  ld a,(hl)    ; operand exponent
  and a
  push hl
  call nz,mdex    ; read operand
  pop hl
  jp z,zro    ; zero or underflow
  jp c,ovf    ; overflow
  call mulx    ; fixed mult
  ld a,b    ; normalize if necessary
  and a
  jp m,fpack

  ld hl,accumulator_exponent    ; dec accum exp
  dec  (hl)
  ret  z    ; underflow
  call shl_
  jp fpack

; fixed point multiply subroutine

mulx:
  ld hl,mulx.4
  ld (hl),e    ; 3rd multiplicand
  inc  hl
  ld (hl),d    ; 2nd multiplicand
  inc  hl
  ld (hl),a    ; 1st multiplicand

  xor a    ; clear 6th product
  ld e,a    ; clear 5th product
  ld d,a    ; clear 4th product

; multiply  by each accumulator fraction in turn

  ld hl,accumulator_3rd_fraction
  call mulx.2    ; multiply by accum 3rd fraction
  ld hl,accumulator_2nd_fraction
  call mulx.1    ; multiply by accum 2nd fraction
  ld hl,accumulator_1st_fraction

; multiply by one accumulator byte

mulx.1:
  ld a,d    ; 5th partial product
  ld e,c    ; 4th partial prod
  ld d,b    ; 3rd partial prod
mulx.2:
  ld b,(hl)    ; multiplier
  ld l,a    ; 5th partial prod
  xor a    ; zero a register
  ld c,a    ; 2nd partial prod
  sub  b    ; set carry bit for exit flag
  jp c,mulx.3    ; if multiplier is not zero
  ld c,d    ; 2nd partial product
  ld d,e    ; 3rd partial prod
  ret

; loop for each bit of multiplier byte

mulx.3:
  ld a,l    ; 5th partial product, exit flag
  adc  a,a    ; shift exit flag out if done
  ret  z    ; exit if multiplication done
  ld l,a    ; 5th partial prod, exit flag
  ld a,e    ; 4th partial prod
  rla      ; shift 4th partial prod
  ld e,a    ; 4th partial prod
  ld a,d    ; 3rd partial prod
  rla
  ld d,a
  ld a,c    ; 2nd partial prod
  rla
  ld c,a
  ld a,b    ; 1st partial prod and multiplier
  rla
  ld b,a
  jp nc,mulx.3  ; if no addition required

; add the multiplicand to the product if the multiplier bit is one

  ld a,(mulx.4)  ; operand 3rd fraction
  add a,e
  ld e,a    ; 4th partial prod
  ld a,(mulx.4+1)  ; operand 2nd fraction
  adc  a,d
  ld d,a    ; 3rd partial prod
  ld a,(mulx.4+2)  ; operand 1st fraction
  adc  a,c
  ld c,a    ; 2nd partial prod
  jp nc,mulx.3  ; if no carry to 1st prod
  inc  b    ; add carry to 1st prod
  and a    ; clear carry bit
  jp mulx.3

mulx.4:
  ds 3

; fdi  floating point division subroutine

fdi:
  xor a
  sub  (hl)    ; complement of divisor exponent
  cp 1    ; set carry if division by zero
  push hl
  call nc,mdex    ; read operand if not zero
  pop hl
  jp c,ovf    ; overflow or division by zero
  jp z,zro    ; underflow or zero
  ld c,a
  call divx    ; fixed division
  jp nc,ovf
  jp fpack

; fixed point divide subroutine

; subtract divisor from accum to obtain 1st remainder

divx:
  ld hl,accumulator_3rd_fraction
  ld a,(hl)    ; accum 3rd fraction
  sub  e
  ld (hl),a
  dec  hl
  ld a,(hl)    ; accum 2nd fraction
  sbc a,d
  ld (hl),a
  dec  hl
  ld a,(hl)    ; accum 1st fraction
  sbc a,c
  ld (hl),a

; halve the divisor and store for addition or subtraction

  ld a,c    ; get carry bit
  rla
  ld a,c    ; divisor 1st fraction
  rra
  ld (divx.4+3),a
  ld a,d    ; divisor 2nd fraction
  rra
  ld (divx.4+2),a
  ld a,e    ; divisor 3rd fraction
  rra
  ld (divx.4+1),a  ; 3rd subtract divisor
  ld b,0    ; init quot 1st fraction
  ld a,b    ; divisor 4th fraction is zero
  rra
  ld (divx.4),a  ; 4th subtract divisor

; load 1st remainder

  ld a,(hl)    ; 1st fraction
  inc  hl
  ld d,(hl)    ; 2nd fraction
  inc  hl
  ld e,(hl)    ; 3rd fraction

; position remainder, initialise quotient, check sign

  ex de,hl    ; remainder 3rd fraction
        ; remainder 2nd fraction
  ld e,a    ; remainder 1st fraction
  ld c,b    ; init quot 2nd fraction
  ld d,b    ; init quot 3rd fraction
  and a
  jp m,divx.3    ; if remainder is negative

; adjust exponent

  ld a,(accumulator_exponent)  ; increment quotient exp
  inc  a
  ret  z    ; overflow
  ld (accumulator_exponent),a

  inc  d    ; init quot 3rd fraction

; subtract the divisor if remainder positive

divx.1:
  push bc
  ld c,l
  ld b,h
  xor a    ; 4th fraction is zero
  ld hl,divx.4
  sub  (hl)
  ld a,c    ; 3rd fraction
  inc  hl
  sbc a,(hl)
  ld c,a
  ld a,b    ; 2nd fraction
  inc  hl
  sbc a,(hl)
  ld b,a
  ld a,e    ; 1st fraction
  inc  hl
  sbc a,(hl)
  ld e,a
  ld l,c
  ld h,b
divx.2:
  pop bc

  ld a,(divx.4)  ; remainder 4th fraction
  rlca      ; shift remainder 4th fraction to carry

; shift the remainder left one bit

  ld a,b
  rla
  ret  c    ; division complete
  rra      ; shift BCDEHL
  ld a,l
  rla
  ld l,a
  ld a,h
  rla
  ld h,a
  call shl_

; branch if subtraction is required

  ld a,d    ; quotient 3rd fraction
  rrca      ; remainder sign indic to carry bit
  jp c,divx.1    ; to sub divisor if remainder positive

; add the divisor if the remainder is negative

divx.3:
  push bc
  ld bc,divx.4+1
  ld a,(bc)    ; 3rd fraction
  add a,l
  ld l,a
  inc  bc
  ld a,(bc)    ; 2nd fraction
  adc  a,h
  ld h,a
  inc  bc
  ld a,(bc)    ; 1st fraction
  adc  a,e
  ld e,a
  jp divx.2

divx.4:
  ds fw

; convert 32 bit signed integer to float
; entry - abcd (int)

flt:
  ld e,d
  ld d,c
  ld c,b
  ld b,a

; convert 32 bit signed integer to float
; entry - bc:de (int)

flt0:
  ld a,32    ; scaling factor
flt.1:
  xor 0x80    ; apply exponent bias
  ld hl,accumulator_exponent
  ld (hl),a
  inc  hl
  ld (hl),0x80  ; assume positive accum sign
  ld a,b    ; set cy if integer negative
  and a
  rla
  jp cnpack    ; complete the conversion

; convert signed integer A to float

flta:
  ld de,0
  ld c,e
  ld b,a
  ld a,8
  jp flt.1

; fix  convert float in acc to 32 bit integer
;
; exit  - abcd (int)

fix:
  ld e,32    ; scaling factor
  ld hl,accumulator_exponent
  ld a,(hl)
  and a
  jp z,zro    ; zero
  ld a,e
  add a,0x80-1    ; add bias-1
  sub  (hl)    ; shift count -1
  ret  c    ; accum too large
  cp 31    ; compare to large shift
  jp nc,zro    ; accum too small
  add a,1    ; shift count
  ld hl,accumulator_1st_fraction
  ld b,(hl)
  inc  hl
  ld c,(hl)
  inc  hl
  ld d,(hl)
  call shr_    ; position the fraction
  ld a,(accumulator_sign)  ; complement if negative
  and a
  call p,fcpl
  ld a,1    ; set flags
  or b
  ld a,b
  ld b,c
  ld c,d
  ld d,e
  ret

; Floor accum to integer
;
; entry - abcd
; exit  - abcd e=signed integer

flr:
  ld e,d
  cp 0x80+24
  ret  nc    ; no fraction
flr.1:
  ld e,a
  ld a,0x80    ; unpack b
  or b
  ld b,a
  ld a,(accumulator_sign)
  rla
  push af
  jp c,flr.3    ; positive
  ld a,d    ; decr bcd
  or a
  jp nz,flr.2
  dec  bc
flr.2:
  dec  d
flr.3:
  ld a,0x80+24
  sub  e
  call shr_
  pop af
  call nc,rondr.1  ; incr bcd
  ld a,0x80+24
  ld (accumulator_exponent),a
  ld a,d
  jp c,flr.4
  cpl
  inc  a
flr.4:
  push af
  ld e,0
  call npack    ; normalise and pack
  pop hl
  ld e,h
  ret

; Round accum to integer

rnd:
  call tstr
  call m,chss
  cp 0x80+24
  ret  nc    ; no fraction
  ld hl,fp50    ; 0.5
  call fad
  jp flr.1

; FABS  ( r1 -- r2 )

  hdr _public,'FABS'
f_abs:
  call ldop
  call fab
  jp svop

; FNEGATE  ( r1 -- r2 )

  hdr _public,'FNEGATE'
fneg:
  call ldop
  call chs
  jp svop

; D>F  ( d -- r )

  hdr _public,'D>F'
d_to_f:
  pop hl
  pop de
  push bc
  ld c,l
  ld b,h
  call flt0
  jp svop

; F>D  ( r -- d )

  hdr _public,'F>D'
f_to_d:
  call ldop
  call fix
  ld e,d
  ld d,c
  ld l,b
  ld h,a
  pop bc
  push de
  jp next

; S>F  ( n -- r )    s>d d>f

  hdr _public,'S>F'
s_to_f:
  call do_colon
  dw s_to_d,d_to_f
  dw exit

; F>S  ( r -- n )    f>d d>s

  hdr _public,'F>S'
f_to_s:
  call do_colon
  dw f_to_d,d_to_s
  dw exit

; F0=  ( r -- flag )

  hdr _public,'F0='
f_zero_equals:
  pop hl
  ld h,l
  ex (sp),hl
  jp zero_equals

; F=  ( r1 r2 -- flag )

  hdr _public,'F='
f_equals:
  call ld2op
  call fcmp
  pop bc
  jp nz,false
  jp true

; F0<  ( r -- flag )

  hdr _public,'F0<'
f_zero_less:
  pop hl
  pop de
  ld a,l
  or a
  jp z,false    ; zero
  ld a,h
  rla
  jp c,true    ; negative
  jp false

; F<  ( r1 r2 -- flag )

  hdr _public,'F<'
f_less:
  call ld2op
  call fcmp
  pop bc
  jp m,true
  jp false

; F0>  ( r -- flag )

  hdr _public,'F0>'
f_zero_greater:
  call ldop
f_zero_greater.1:
  pop bc
  jp z,false
  jp m,false
  jp true

; F>  ( r1 r2 -- flag )

  hdr _public,'F>'
f_greater:
  call ld2op
  call fcmp
  jp f_zero_greater.1

; FMIN  ( r1 r2 -- r1 | r2 )  fover fover f< 0= if fswap then fdrop

  hdr _public,'FMIN'
f_min:
  call ld2op
  push hl
  call fcmp
  pop hl
  call p,lod    ; r1 >= r2
  jp svop

; FMAX  ( r1 r2 -- r1 | r2 )  fover fover f< if fswap then fdrop

  hdr _public,'FMAX'
f_max:
  call ld2op
  push hl
  call fcmp
  pop hl
  call m,lod    ; r1 < r2
  jp svop

; FLOOR  ( r1 -- r2 )

  hdr _public,'FLOOR'
floor:
  call ldop
  call flr
  jp svop

; FROUND  ( r1 -- r2 )

  hdr _public,'FROUND'
f_round:
  call ldop
  call rnd
  jp svop

; F+  ( r1 r2 -- r3 )

  hdr _public,'F+'
f_plus:
  call ld2op
  call fad
  jp svop

; F-  ( r1 r2 -- r3 )

  hdr _public,'F-'
f_minus:
  call ld2op
  call fsu
  jp svop

; F*  ( r1 r2 -- r3 )

  hdr _public,'F*'
f_star:
  call ld2op
  call fmu
  jp svop

; F/  ( r1 r2 -- r3 )

  hdr _public,'F/'
f_slash:
  call ld2op
  call fdi
  jp svop

; FRANDOM  ( r1 -- r2 )

  hdr _public,'FRANDOM'
f_random:
  call ldop
  jp m,f_random.1    ; seed generator
  push af
  ld hl,f_random.4
  call lod
  ld e,a
  pop af
  ld a,e
  jp z,svop    ; return last value
  ld hl,f_random.2  ; get next value
  call fmu
  ld hl,f_random.3
  call fad
f_random.1:
  ld hl,accumulator_3rd_fraction
  ld b,(hl)    ; swap msb lsb
  dec  hl
  ld c,(hl)
  dec  hl
  ld d,(hl)
  dec  hl
  ld (hl),0x80  ; make positive
  dec  hl
  ld e,(hl)
  ld (hl),0x80  ; fix exponent
  call npack    ; normalise
  ld hl,f_random.4
  call str
  jp svop

f_random.2:
  db 0x98,0x35,0x44,0x7a
f_random.3:
  db 0x68,0x28,0xb1,0x46
f_random.4:
  db 0x80,0x31,0x41,0x59    ; seed

finstr:
  ds 3  ; string address, count
finsgn:
  ds 1  ; sign
finpt:
  ds 1  ; decimal point flag
finexp:
  ds 1  ; decimal exponent
fincvt:
  ds 1  ; converted digits

; fin  convert character string to float
; entry - hl=adr, a=len
; exit  - result in accum, cy=error

fin:
  dec  hl    ; init string adr, count
  ld (finstr),hl
  inc  a
  ld (finstr+2),a

  ld a,0x80    ; set sign positive
  ld (finsgn),a
  xor a
  ld (finpt),a  ; clear decimal point flag
  ld (finexp),a  ; set decimal exponent = 0
  ld (fincvt),a  ; zero converted digits
  ld (accumulator_exponent),a  ; zero accum

  call fin.17    ; get 1st char
  jp z,fin.14    ; treat zero length as zero blanks

  cp ' '
  jp nz,fin.2
fin.1:
  call fin.17    ; treat all blanks as zero
  jp z,fin.14
  cp ' '
  jp z,fin.1
  scf
  ret

fin.2:
  cp '+'    ; check for sign
  jp z,fin.3
  cp '-'
  jp nz,fin.4
  xor a    ; set negative flag
  ld (finsgn),a
fin.3:
  call fin.17    ; get char after sign
  scf
  ret  z    ; none

fin.4:
  cp '.'    ; check for decimal point
  jp nz,fin.7
  ld hl,finpt
  xor (hl)
  ld (hl),a
  jp nz,fin.8
fin.5:
  scf      ; 2nd decimal point
  ret

fin.6:
  ld a,(fincvt)
  or a
  jp z,fin.5
  jp fin.14

; process char

fin.7:
  call fin.18    ; convert char to digit
  ret  c    ; bad

  ld hl,fincvt
  inc  (hl)
  push af
  ld hl,fp10    ; mult old value by 10
  call fmu
  call savf.1
  pop af    ; convert digit to floating point
  call flta
  ld hl,float_tmp_1    ; add to old value
  call fad

  ld a,(finpt)  ; if decimal point
  and a
  jp z,fin.8
  ld hl,finexp  ; decrement exponent
  dec  (hl)

; get next char

fin.8:
  ld b,0    ; zero exponent
  call fin.17
  jp z,fin.6    ; done

; check for exponent

  cp '+'
  jp z,fin.10
  cp '-'
  jp z,fin.10
  call uppercase_a
  cp 'E'
  jp z,fin.9
  cp 'D'
  jp nz,fin.4

; process exponent

fin.9:
  call fin.17    ; next char
  jp z,fin.6    ; done

fin.10:
  ld b,a    ; save 1st char
  sub  '-'    ; compare minus sign
  ld e,a
  jp z,fin.11
  add a,'-'-'+'  ; compare plus sign
  ld a,b
  jp nz,fin.12

fin.11:
  call fin.17    ; got sign, get 1st digit

fin.12:
  ld b,0    ; possible decimal exponent
  jp z,fin.6    ; none - assume zero exponent

fin.13:
  call fin.18
  ret  c    ; not digit
  ld c,a    ; accumulate exponent
  ld a,b
  add a,a
  add a,a
  add a,b
  add a,a
  add a,c
  ld b,a
  call fin.17    ; get next
  jp nz,fin.13

  ld a,e    ; test exponent sign
  and a
  jp nz,fin.14
  sub  b    ; complement if neg
  ld b,a

fin.14:
  ld a,(finsgn)  ; store accum sign
  ld (accumulator_sign),a

; adjust exponent

  ld a,b
fin.15:
  ld hl,finexp
  add a,(hl)
  jp z,tst    ; done
  ld (hl),a
  ld hl,fp10
  jp p,fin.16
  call fdi    ; div by 10
  ld a,1
  jp fin.15

fin.16:
  call fmu    ; mul by 10
  ret  c    ; overflow
  ld a,0xff
  jp fin.15

; get next char, return z if end reached

fin.17:
  ld hl,finstr+2
  dec  (hl)
  ld hl,(finstr)
  inc  hl
  ld (finstr),hl
  ld a,(hl)
  ret

; convert ascii char (a) to digit, return cy if not in range 0-9

fin.18:
  sub  '0'
  ret  c
  cp 10
  ccf
  ret

; >FLOAT  ( ca u -- r true | false )

  hdr _public,'>FLOAT'
to_float:
  pop hl
  ld a,l    ; assume u <= 255
  pop hl
  push bc
  call fin
  ld e,c
  ld h,b
  ld l,a
  pop bc
  jp c,false
  push de
  push hl
  jp true

  hdr _public,'MAX-PRECISION'
max_precision:
  call do_byte_constant    ; max precision
  db maxsig

  hdr _hidden,'EXSN'
exsn:
  call do_create    ; exponent, sign
  ds 2*cw

; REPRESENT  ( r ca n -- exp sign flag )
;        2dup max-precision max [char] 0 fill
;        max-precision min 2>r fdup f0< 0 exsn 2!
;        fabs fdup f0= 0= if begin fdup 1.0e f<
;        0= while 10.0e f/ 1 exsn +! repeat begin
;        fdup 0.1e f< while 10.0e f* -1 exsn +!
;        repeat then r@ 0 max 0 ?do 10.0e f* loop
;        fround f>d 2dup <# #s #> dup r@ - exsn +!
;        2r> rot min 1 max cmove d0= if 1 0 else
;        exsn 2@ swap then true

  hdr _public,'REPRESENT'
represent:
  call do_colon
  dw two_dup
  dw max_precision,max
  dw c_lit
  db '0'
  dw fill
  dw max_precision,min
  dw two_to_r
  dw f_dup,f_zero_less
  dw zero,exsn,two_store
  dw f_abs
  dw f_dup,f_zero_equals
  dw zero_equals
  dw question_branch,represent.3
represent.1:
  dw f_dup    ; begin
  dw f_lit
  db 0x81,0,0,0
  dw f_less,zero_equals
  dw question_branch,represent.2  ; while
  dw f_ten,f_slash
  dw one,exsn,plus_store
  dw branch,represent.1  ; repeat
represent.2:
  dw f_dup    ; begin
  dw f_lit
  db 0x7d,0x4c,0xcc,0xcd
  dw f_less
  dw question_branch,represent.3  ; while
  dw f_ten,f_star
  dw true,exsn,plus_store
  dw branch,represent.2  ; repeat
represent.3:
  dw r_fetch
  dw zero,max,zero
  dw paren_question_do,represent.5
represent.4:
  dw f_ten,f_star
  dw paren_loop,represent.4
represent.5:
  dw f_round,f_to_d
  dw two_dup
  dw bdigs,digs,edigs
  dw dup
  dw r_fetch,minus  ; handle overflow
  dw exsn,plus_store
  dw two_from_r
  dw rot,min
  dw one,max
  dw cmove
  dw d_zero_equals
  dw question_branch,represent.6
  dw one,zero  ; 0.0E fixup
  dw branch,represent.7
represent.6:
  dw exsn,two_fetch
  dw swap
represent.7:
  dw true
  dw exit

; PRECISION  ( -- u )

  hdr _public,'PRECISION'
precision:
  call do_value
  dw maxsig    ; default

; SET-PRECISION  ( u -- )   1 max max-precision min to precision

  hdr _public,'SET-PRECISION'
set_precision:
  call do_colon
  dw one,max
  dw max_precision,min
  dw paren_to,precision
  dw exit

  hdr _public,'FDP'
fdp:
  call do_create    ; decimal point display
  dw -1    ; set by FINIT
  ds 2

  hdr _hidden,'FBUF'
fbuf:
  call do_create    ; fp string buffer
  ds maxsig

  hdr _hidden,'EX#'
exn:
  call do_value    ; exponent
  ds cw

  hdr _hidden,'SN#'
snn:
  call do_value    ; sign
  ds cw

  hdr _hidden,'EF#'
efn:
  call do_value    ; exponent factor
  ds cw

  hdr _hidden,'PL#'
pln:
  call do_value    ; places after decimal point
  ds cw

; (F1)  ( r -- r exp )
;        fdup fbuf max-precision represent 2drop

  hdr _hidden,'(F1)'  ; get exponent
paren_f1:
  call do_colon
  dw f_dup
  dw fbuf,max_precision
  dw represent,two_drop  ; never error
  dw exit

; (F2)  ( exp -- offset exp' )  s>d ef# fm/mod ef# *

  hdr _hidden,'(F2)'  ; apply exponent factor
paren_f2:
  call do_colon
  dw s_to_d
  dw efn,fm_slash_mod
  dw efn,star
  dw exit

; (F3)  ( r places -- ca u )
;                               dup to pl# 0< if precision else (f1) ef# 0>
;                               if 1- (f2) drop 1+ then pl# + max-precision
;                               min then fbuf swap represent drop to sn# to
;                               ex# fbuf max-precision -trailing <# ;

  hdr _hidden,'(F3)'  ; float to ascii
paren_f3:
  call do_colon
  dw dup
  dw paren_to,pln
  dw zero_less
  dw question_branch,paren_f3.1
  dw precision
  dw branch,paren_f3.3
paren_f3.1:
  dw paren_f1
  dw efn,zero_greater
  dw question_branch,paren_f3.2
  dw one_minus
  dw paren_f2,drop
  dw one_plus
paren_f3.2:
  dw pln,plus
  dw max_precision,min
paren_f3.3:
  dw fbuf,swap
  dw represent
  dw drop    ; never error
  dw paren_to,snn
  dw paren_to,exn
  dw fbuf
  dw max_precision
  dw dtrai
  dw bdigs
  dw exit

; (F4)  ( exp -- )  pl# 0< >r dup abs s>d r@ 0= if # then #s
;        2drop dup sign 0< r> d0= if [char] + hold
;        then [char] E hold

  hdr _hidden,'(F4)'  ; insert exponent
paren_f4:
  call do_colon
  dw pln,zero_less
  dw to_r
  dw dup
  dw abs,s_to_d
  dw r_fetch,zero_equals
  dw question_branch,paren_f4.1
  dw dig
paren_f4.1:
  dw digs
  dw two_drop
  dw dup,sign
  dw zero_less
  dw from_r
  dw d_zero_equals
  dw question_branch,paren_f4.2
  dw c_lit
  db '+'
  dw hold
paren_f4.2:
  dw c_lit
  db 'E'
  dw hold
  dw exit

; (F5)  ( n -- +n|0 )  0max dup fdp 2+ +!

  hdr _hidden,'(F5)'  ; conditionally set flag
paren_f5:
  call do_colon
  dw zero_max
  dw dup
  dw fdp,two_plus
  dw plus_store
  dw exit

; (F6)  ( ca u -- )  (f5) shold

  hdr _hidden,'(F6)'  ; insert string
paren_f6:
  call do_colon
  dw paren_f5,shold
  dw exit

; (F7)  ( n -- )    (f5) [char] 0 nhold

  hdr _hidden,'(F7)'  ; insert '0's
paren_f7:
  call do_colon
  dw paren_f5
  dw c_lit
  db '0'
  dw nhold
  dw exit

; (F8)  ( -- )    sn# sign 0 0 #>

  hdr _hidden,'(F8)'  ; insert sign
paren_f8:
  call do_colon
  dw snn,sign
  dw zero,zero
  dw edigs
  dw exit

; (F9)  ( ca u1 -- ca u2 )
;        pl# 0< if begin dup while 1- 2dup
;        + c@ [char] 0 - until 1+ then then

  hdr _hidden,'(F9)'  ; trim trailing '0's
paren_f9:
  call do_colon
  dw pln,zero_less
  dw question_branch,paren_f9.2
paren_f9.1:
  dw dup
  dw question_branch,paren_f9.2
  dw one_minus,two_dup
  dw plus,c_fetch
  dw c_lit
  db '0'
  dw minus
  dw question_branch,paren_f9.1
  dw one_plus
paren_f9.2:
  dw exit

; (FA)  ( u1 -- u1 u2 )  pl# 0< if dup else pl# then

  hdr _hidden,'(FA)'
paren_fa:
  call do_colon
  dw pln,zero_less
  dw question_branch,paren_fa.1
  dw dup
  dw branch,paren_fa.2
paren_fa.1:
  dw pln
paren_fa.2:
  dw exit

; (FB)  ( ca u n -- )  fdp cell+ off >r (f9) r@ + (fa) over -
;        (f7) (fa) min r@ - (f6) r> (fa) min (f7)
;        fdp 2@ or if [char] . hold then

  hdr _hidden,'(FB)'  ; insert fraction n places right of dec. pt
paren_fb:
  call do_colon
  dw fdp,two_plus
  dw off
  dw to_r
  dw paren_f9
  dw r_fetch,plus
  dw paren_fa
  dw over,minus
  dw paren_f7
  dw paren_fa,min
  dw r_fetch,minus
  dw paren_f6
  dw from_r
  dw paren_fa,min
  dw paren_f7
  dw fdp,two_fetch,or_
  dw question_branch,paren_fb.1
  dw c_lit
  db '.'
  dw hold
paren_fb.1:
  dw exit

; (FC)  ( ca u n -- )
;        >r 2dup r@ min 2swap r> /string 0 (fb) (f6)

  hdr _hidden,'(FC)'  ; split into int/frac and insert
paren_fc:
  call do_colon
  dw to_r
  dw two_dup
  dw r_fetch,min
  dw two_swap
  dw from_r,sstr
  dw zero,paren_fb
  dw paren_f6
  dw exit

; (FD)  ( r n factor -- ca u )
;        to ef# (f3) ex# 1- (f2) (f4) 1+ (fc) (f8)

  hdr _hidden,'(FD)'  ; exponent form
paren_fd:
  call do_colon
  dw paren_to,efn
  dw paren_f3
  dw exn,one_minus
  dw paren_f2
  dw paren_f4
  dw one_plus,paren_fc
  dw paren_f8
  dw exit

; (FS.)  ( r n -- ca u )  1 (fd)

  hdr _public,'(FS.)'
paren_fs_dot:
  ld hl,1
  push hl
  jp paren_fd

; FS.R  ( r n1 n2 -- )
;        >r (fs.) r> s.r

  hdr _public,'FS.R'
fs_dot_r:
  call do_colon
  dw to_r
  dw paren_fs_dot
  dw branch,d_dot_r.1

; FS.  ( r -- )    -1 0 fs.r space

  hdr _public,'FS.'
fs_dot:
  call do_colon
  dw true
  dw zero,fs_dot_r
  dw space
  dw exit

if  fp_engineering_output_functions

; (FE.)  ( r -- ca u )  3 (fd)

  hdr _public,'(FE.)'
paren_fe_dot:
  ld hl,3
  push hl
  jp paren_fd

; FE.R  ( r n1 n2 -- )  >r (fe.) r> s.r

  hdr _public,'FE.R'
fe_dot_r:
  call do_colon
  dw to_r
  dw paren_fe_dot
  dw branch,d_dot_r.1

; FE.  ( r -- )    -1 0 fe.r space

  hdr _public,'FE.'
fe_dot:
  call do_colon
  dw true
  dw zero,fe_dot_r
  dw space
  dw exit

endif ; fp_engineering_output_functions

; (F.)  ( r n -- ca u )
;        0 to ef# (f3) ex# dup max-precision > if
;        fbuf 0 0 (fb) max-precision - (f7) (f6)
;        else dup 0> if (fc) else abs (fb) 1 (f7)
;        then then (f8)

  hdr _public,'(F.)'
paren_f_dot:
  call do_colon
  dw zero
  dw paren_to,efn
  dw paren_f3
  dw exn,dup
  dw max_precision,greater
  dw question_branch,paren_f_dot.1  ; if
  dw fbuf,zero
  dw zero,paren_fb
  dw max_precision,minus
  dw paren_f7
  dw paren_f6
  dw branch,paren_f_dot.3  ; else
paren_f_dot.1:
  dw dup,zero_greater
  dw question_branch,paren_f_dot.2
  dw paren_fc
  dw branch,paren_f_dot.3  ; else
paren_f_dot.2:
  dw abs
  dw paren_fb
  dw one,paren_f7
paren_f_dot.3:
  dw paren_f8    ; then then
  dw exit

; F.R  ( r n1 n2 -- )  >r (f.) r> s.r

  hdr _public,'F.R'
f_dot_r:
  call do_colon
  dw to_r
  dw paren_f_dot
  dw branch,d_dot_r.1

; F.  ( r -- )    -1 0 f.r space

  hdr _public,'F.'
f_dot:
  call do_colon
  dw true
  dw zero,f_dot_r
  dw space
  dw exit

; (G.)  ( r n -- ca u )  >r (f1) -3 7 within  r> swap if (f.) else
;        (fs.) then

  hdr _public,'(G.)'
paren_g_dot:
  call do_colon
  dw to_r
  dw paren_f1
  dw lit,-3
  dw c_lit
  db 7
  dw within
  dw from_r,swap
  dw question_branch,paren_g_dot.1  ; if
  dw paren_f_dot
  dw branch,paren_g_dot.2  ; else
paren_g_dot.1:
  dw paren_fs_dot
paren_g_dot.2:
  dw exit    ; then

; G.R  ( r n1 n2 -- )  >r (g.) r> s.r

  hdr _public,'G.R'
g_dot_r:
  call do_colon
  dw to_r,paren_g_dot
  dw branch,d_dot_r.1

; G.  ( r -- )    -1 0 g.r space

  hdr _public,'G.'
g_dot:
  call do_colon
  dw true
  dw zero,g_dot_r
  dw space
  dw exit

;  sqr

sqr:
  call tstr
  ret  z    ; zero
  jp m,ovf    ; neg
  call savf.1
  and a
  rra
  add a,0x40
  call savf.2
  ld d,5
sqr.1:
  push de
  call lodf.1
  ld hl,float_tmp_2
  call fdi
  ld hl,float_tmp_2
  call fad
  sub  1
  call savf.2
  pop de
  dec  d
  jp nz,sqr.1
  ld hl,float_tmp_2
  jp lod

;  poly

poly:
  push hl
  call savf.1
  pop hl
  ld a,(hl)
  ld (poly.3),a
  inc  hl
  push hl
  call lod
  jp poly.2

poly.1:
  ld hl,poly.3
  dec  (hl)
  pop hl
  ret  z
  push hl
  ld hl,float_tmp_1
  call fmu
  pop hl
  push hl
  call fad
poly.2:
  pop hl
  inc  hl
  inc  hl
  inc  hl
  inc  hl
  push hl
  jp poly.1

poly.3:
  ds 1

;  polx

polx:
  push hl
  call savf.2
  ld hl,float_tmp_2
  call fmu
  pop hl
  call poly
  ld hl,float_tmp_2
  jp fmu

;  exp

exp:
  ld hl,ln2
  call fdi
  cp 0x88
  jp nc,ovf
  cp 0x68
  ld hl,fp1
  jp c,lod
  call savf.2
  call flr
  call savf.1
  ld a,e
  add a,0x81
  jp z,exp.1
  push af
  call lodf.2
  ld hl,float_tmp_1
  call fsu
  ld hl,exp.4
  call poly
  pop af
  ld bc,0
  ld d,b
  call savf.1
  ld hl,float_tmp_1
  jp fmu

exp.1:
  call tst
  jp m,zro
  jp ovf

exp.4:
  db 7
  db 0x74,0x59,0x88,0x7c
  db 0x77,0x26,0x97,0x00e0
  db 0x7a,0x1e,0x1d,0xc4
  db 0x7c,0x63,0x50,0x5e
  db 0x7e,0x75,0xfe,0x1a
ln2:
  db 0x80,0x31,0x72,0x18    ; ln2
fp1:
  db 0x81,0,0,0    ; 1.0

;  log

log:
  call tstr
  jp m,ovf    ; neg
  jp z,ovf    ; zero
  xor 0x80
  push af
  ld a,0x80
  ld hl,log.2
  call poly
  call savf.1
  pop af
  call flta
  ld hl,float_tmp_1
  call fad
  ld hl,ln2
  jp fmu

log.2:
  db 9
  db 0x82,0x94,0xee,0xd8
  db 0x84,0x7d,0xaa,0xa9
  db 0x86,0xbf,0x99,0x7d
  db 0x87,0x28,0xe5,0x7b
  db 0x87,0x00c0,0x71,0x8a
  db 0x87,0x14,0x95,0x6e
  db 0x86,0x00a0,0x1e,0xb2
  db 0x85,0x02,0x7a,0xad
  db 0x83,0x8d,0x9d,0x09

;  sin / cos

cos:
  ld hl,fpi.2
  call fad
sin:
  or a
  ret  z
  cp 0x80+25
  jp nc,ovf
  ld hl,f2pi
  call fdi
  call savf.1
  call flr
  or a
  push af
  ld hl,float_tmp_2
  call nz,str
  call lodf.1
  pop af
  ld hl,float_tmp_2
  call nz,fsu
  ld hl,fp25    ; 0.25
  call fsu
  push af
  jp m,sin.1
  ld hl,fp50    ; 0.5
  call fsu
  call p,chs
sin.1:
  ld hl,fp25    ; 0.25
  call fad
  ld e,a
  pop af
  ld a,e
  call p,chs
  ld hl,sin.7
  jp polx

sin.7:
  db 5
  db 0x86,0x1e,0xd7,0xfb
  db 0x87,0x99,0x26,0x64
  db 0x87,0x23,0x34,0x58
  db 0x86,0xa5,0x5d,0xe1
f2pi:
  db 0x83,0x49,0x0f,0xdb ; 2pi

fpi.2:
  db 0x81,0x49,0x0f,0xdb ; pi/2

fp50:
  db 0x80,0,0,0  ; 0.5
fp25:
  db 0x7f,0,0,0  ; 0.25

;  atan

atan:
  call tstr
  call m,chss    ; make positive
  cp 0x81
  jp c,atan.1    ; < 1
  ld hl,atan.3
  push hl
  call savf.1
  ld hl,fp1
  call lod
  ld hl,float_tmp_1
  call fdi
atan.1:
  ld hl,atan.9
  call fcmp
  jp m,atan.2
  ld hl,atan.4
  push hl
  call savf.1
  ld hl,atan.7
  call fad
  ld hl,atan.11
  call str
  call lodf.1
  ld hl,atan.6
  call poly
  ld hl,atan.11
  call fdi
atan.2:
  ld hl,atan.8
  jp polx

atan.3:
  ld hl,fpi.2
  call fsu
  jp chs

atan.4:
  ld hl,atan.10
  jp fad

atan.6:
  db 2
atan.7:
  db 0x81,0x5d,0xb3,0xd7
  db 0x81,0x80,0,0    ; -1.0

atan.8:
  db 4
  db 0x7e,0x83,0x35,0x62
  db 0x7e,0x4c,0x24,0x50
  db 0x7f,0xaa,0xa9,0x79
  db 0x81,0,0,0

atan.9:
  db 0x7f,0x09,0x38,0xa3
atan.10:
  db 0x80,0x06,0x0a,0x92

atan.11:
  ds fw

; FSQRT  ( r1 -- r2 )

  hdr _public,'FSQRT'
fsqr:
  call ldop
  call sqr
  jp svop

; FEXP  ( r1 -- r2 )

  hdr _public,'FEXP'
f_exp:
  call ldop
  call exp
  jp svop

; FLN  ( r1 -- r2 )

  hdr _public,'FLN'
f_ln:
  call ldop
  call log
  jp svop

; F**  ( r1 r2 -- r3 )  fswap fln f* fexp

  hdr _public,'F**'
f_star_star:
  call do_colon
  dw f_swap,f_ln
  dw f_star,f_exp
  dw exit

; FSIN  ( r1 -- r2 )

  hdr _public,'FSIN'
f_sin:
  call ldop
  call sin
  jp svop

; FCOS  ( r1 -- r2 )

  hdr _public,'FCOS'
f_cos:
  call ldop
  call cos
  jp svop

; FATAN  ( r1 -- r2 )

  hdr _public,'FATAN'
f_atan:
  call ldop
  call atan
  jp svop

; PI  ( -- r )

  hdr _public,'PI'
f_pi:
  call do_f_constant
  db 0x82,0x49,0x0f,0xdb  ; pi

; FINIT  ( -- )    max-precision set-precision fdp on

  hdr _hidden,'FINIT'
f_init:
  call do_colon
  dw max_precision,set_precision
  dw fdp,on
  dw exit

; FIDENTIFY  ( -- )

  hdr _hidden,'FIDENTIFY'
f_identify:
  call do_colon
  dw cr
  dw paren_dot_quote
  db f_identify.1-$-1
  db 'Software floating-point ('
  if  separated_f_stack
    db 'separate'
  else
    db 'common'
  endif
  db ' stack)'
f_identify.1:
  dw exit

; FNUMBER  ( ca u -- [r] flag )
;        2dup s" E" caps search -rot 2drop decimal?
;        and if >float else 2drop 0 then dup >r
;        state? and if postpone fliteral then r>

  hdr _hidden,'FNUMBER'
f_number:
  call do_colon
  dw two_dup    ; scan 'E'
  dw paren_s_quot
  dcs 'E'
  if  case_insensitive_names
    ; XXX FIXME -- the logic is wrong, because conditional compilation
    ; sets a user variable to be modifed.
    ;; dw caps ; XXX OLD
    dw case_sensitive_search,off ; XXX NEW
  endif
  dw search
  dw minus_rot,two_drop
  dw decimal_question ; decimal base?
  dw and_
  dw question_branch,f_number.2
f_number.1:
  dw to_float
  dw branch,f_number.3
f_number.2:
  dw two_drop,zero
f_number.3:
  dw dup,to_r
  dw state_question
  dw and_
  dw question_branch,f_number.4
  dw f_literal
f_number.4:
  dw from_r
  dw exit

;   ( -- )
;        :noname ['] noop dup (do_f_init_patch) ! (do_f_identify_patch) !
;        ['] false (interpret.12) ! (nfps) off (nfpm) off
;        ; remember

  hdr _hidden,'(-FP)'
fprun:
  ld hl,noop
  ld (do_f_init_patch),hl    ; INIT
  ld (do_f_identify_patch),hl    ; INDENTIFY
  ld hl,false
  ld (interpret.12),hl    ; FNUMBER
;  ld hl,0
;  ld (nfps),hl
;  ld (nfpm),hl
  jp next

fprun.1:
  dw 0    ; link
  dw fprun    ; xt

  endif ; floating_point_support

; }}} **********************************************************
; End {{{

; XXX TODO it seems these 'last_' labels could be renamed
; to 'top_' instead:

top_nfa:  equ last_nfa   ; nfa of top word in forth vocabulary
top_xt:   equ last_xt   ; xt of top word in forth vocabulary

initdp:   equ $
initdph:  equ $ ; XXX OLD

; XXX OLD
; Code is run once then disabled.
; MOVE-PATCH  ( -- )
;;movpat:
;;  ld a,0x44   ; change to LD B,H
;;  ld (cldd.4),a
;;  ld (cldd.5),a
;;  ld hl,cold
;;  ld (cldd.7),hl  ; patch myself out
;;  jp (hl)

  end start

; ----------------------- XXX TMP -- for testing

  ; XXX TEST -- it works:
;  dw lit,-10
;  dw return

  ; XXX TEST -- it works:
;  dw paren_dot_quote
;  dcs 'DZX-Forth'

  ; XXX TEST -- it works:
;  dw lit,sys_last_k
;  dw c_fetch
;  dw return

  ; XXX TEST -- it works:
;;  dw c_lit
;;  db '"'
;;  dw emit
;;  dw key
;;  dw emit
;;  dw c_lit
;;  db '"'
;;  dw emit
;;  dw lit,2
;;  dw return
  
  ; XXX TEST -- it works:
;;  call rom_chan_s ; set print to screen
;;  ld bc,9 ; length
;;  ld de,tmpmsg ; address
;;  call rom_print_string
;;  jr tmp
;;tmpmsg:
;;  db "DZX-Forth"
;;tmp:

  ; XXX TEST -- it works:
;;  ld bc,9 ; length
;;  ld de,tmpmsg ; address
;;  push de
;;  push bc
;;  call rom_chan_s ; set print to screen
;;  pop bc
;;  pop de
;;  call rom_print_string
;;  jr tmp
;;tmpmsg:
;;  db "DZX-Forth"
;;tmp:


  ; XXX NEW
;  dw cls
;  dw bootmessage
;forever:
;  dw branch,forever ; XXX INFORMER
; -----------------------
