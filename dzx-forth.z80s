; DZX-Forth
; A direct-threaded Forth for ZX Spectrum
;
; DZX-Forth is a fork of CP/M DX-Forth v4.09 (2014-12)
;
; Assemble with Pasmo:
;   pasmo --tapbas dzx-forth.z80s dzx-forth.tap

; XXX TODO Use ROM 703 (0x02bf) wait for key and store it into last-k
; XXX TODO Doc: Programaci√≥n en Ensamblador, by Tony Woods, p. 168, ROM routines.
; XXX TODO Use Benschop's Forth-83's 'bcal' to write 'goto'.

version macro
  dcs 'A-00-201412241812'
  endm

; }}} **********************************************************
; Labels {{{

no:  equ 0
yes: equ not no

; Modification level
; XXX OLD
;;rel:  equ 4 ; release #
;;rev:  equ 00  ; revision #
;;beta: equ no  ; beta release

; Equates for conditional assembly

debug: equ no  ; debugging messages
ucase: equ yes ; forth names case insensitive
fpeng: equ yes ; engineering output functions
control_flow_stack_extensions:   equ yes
warning_options:  equ yes ; warning options

;

x       equ no  ; show hidden words
;fstack equ yes ; separate floating point stack XXX TODO -- try
floord: equ no  ; integer division method
float:  equ yes ; floating point
nfd:    equ 6 ; max open source files (min = 2)
retro:  equ no  ; classic forth behaviours

; Memory 

sm: equ 0x8000 ; start of system memory

cw: equ 2   ; cell size (bytes)
fw: equ 4 ; float size (bytes)

; Buffer sizes

block_size:                   equ 1024
file_descriptor_size:         equ filename_size+(4*cw)  ; ; XXX OLD
file_handle_size:             equ 6+36      ; (keep even) ; XXX OLD
filename_size:                equ 10        ; XXX TODO bigger, for +3, divide, etc.
parsed_string_buffer_size:    equ 255
pictured_numeric_buffer_size: equ 68
return_stack_size:            equ 256
tib_size:                     equ 80        ; (Terminal Input Buffer)
user_area_size:               equ 128
word_buffer_size:             equ 31+5

; DOS and memory ; XXX OLD
dosfcb: equ 0x005c   ; default file control block
dosbuf: equ 0x0080   ; default DTA and command-line buffer
recsiz: equ 128   ; CP/M record size

; Equates ; XXX TODO rename, organize

max_open_file_handles: equ 10

f_init_patch defl  noop  ; INIT
f_identify_patch: defl  noop
f_number_patch:  defl false
f_stack_items: defl  0 ; fp-stack items
f_stack_size:  defl  0 ; floating point stack size (bytes)

toppru: defl  0 ; top prunes

; Float

   if float

maxsig: equ 7 ; max significant digits

f_init_patch defl  f_init
f_identify_patch: defl  f_identify
f_number_patch:  defl  f_number

;  if fstack
;f_stack_items defl  6
;f_stack_size: defl  (f_stack_items+5)*fw ; allow extra for fp display etc
;  endif

toppru: defl  fprun1

   endif

; ZX Spectrum

  include zx_spectrum_system_variables.z80s
  include zx_spectrum_rom_routines.z80s

; ASCII characters
; XXX TODO adapt
;; bel equ 0x07 ; bell ; XXX OLD
bs_char:      equ 0x08 ; backspace
tab_char:     equ 0x09 ; tab
lf_char:      equ 0x0a ; line feed
ff_char:      equ 0x0c ; form feed
cr_char:      equ 0x0d ; carriage return
;;can equ 0x18 ; ctl-x 
ctrl_z_char:  equ 0x1a ; ctl-z ;; XXX OLD -- still used in old code
esc_char:     equ 0x1b ; escape
sp_char:      equ 0x20 ; space

; }}} **********************************************************
; Description {{{

; Forth Registers
;
; Forth Z80  Forth preservation rules
; ----- ---  ------------------------
; IP    BC   Interpretive pointer. Should be preserved across
;            forth words.
; SP    SP   Data stack pointer. Should be used only as data
;            stack across forth words. May be used within forth
;            words if restored before NEXT.
;       DE   Input only when push_de called.
;       HL   Input only when push_hl called.
;
; Comment conventions:
;
; a = address
; c = 8b character
; u = 16b unsigned number
; n = 16b signed number
; x = 16b signed or unsigned number
; d = 32b signed double number
; ud  = 32b unsigned double number
; xd  = 32b signed or unsigned number
; cfa,xt  = addr of code field (execution token)
; lfa = addr of link field
; nfa = addr of name field
; pfa = addr of parameter field (body)
;
; Non Forth-83 Standard word definitions:
;
; FIG Fig-FORTH model
; ANS ANS FORTH Standard (document dpANS-6, June 1993)

; Memory allocation ; XXX OLD

; The memory above LIMIT is used only by the interpreter.  This space
; is not wasted for turnkey applications as LIMIT, user variables and
; stacks are relocated to EM giving applications more free ram (as
; indicated by UNUSED).

; EM  |-------------  end of memory
; |
; DPH |-------------
; |   word headers & system dictionary
; HM  |-------------
; |   interpretive string buffer
; |-------------
; |   terminal input buffer
; TIB |-------------
; |   file descriptor blocks
; FDB |-------------
; |   block buffer
; LIMIT |-------------
; |   handle r/w buffer
; HBUF  |-------------
; |   file handles
; |-------------
; |   user variables
; R0  |-------------
; |   return stack
; S0  |-------------
; |   data stack
; PAD |-------------
; |   word and number conversion area
; DP  |-------------
; |   application dictionary
; 0x0100 |-------------

; Header structure

; nfa db length+flags     ; length = 1..31
;     ds length           ; name 
; lfa dw previous_nfa
; cfa dw code_address
; pfa ds ...              ; data or code

; Memory map ; XXX TODO -- in progress

; ----- end of memory
; UDG
; ...
; WORD buffer
; parsed string buffer
; TIB
; file descriptor
; block buffer
; boot jumps
; ---- DZX-Forth's org
; ---- BASIC's RAMTOP
; ...
; BASIC program and variables
; system variables
; screen memory
; ROM

; }}} **********************************************************
; Macros {{{

; ------------------------------
; Macro for generating word headers

previous_nfa defl  0   ; initial link pointer (end of chain)

hdr macro enabled,name,immediate,fl,alias_xt
  ; enabled  = enable the header? (0=disable)
  ; name = name string
  ; immediate  = immediate
  ; fl  = application/system flag ; XXX OLD not used anymore
  ; XXX TODO remove 'fl' from the macro header calls
  ; alias_xt = alias xt
  if enabled

    ; the name field
    last_nfa defl  $ ; link address for next word
    bits  defl  0
    if not nul immediate
      bits  defl  bits+0x40  ; set immediate bit
    endif
    if not nul alias_xt
      bits  defl  bits+0x80  ; set alias bit
    endif
    local _first ; address of the first char of the name
    local _next  ; address after the last char of the name
    db _next-_first+bits    ; count and flags byte
    _first: db name
    _next:
    
    ; the link field
    dw previous_nfa

    ; the code field
    if nul alias_xt
      last_xt defl $+2
    else
      last_xt defl alias_xt
    endif
    dw last_xt
    previous_nfa defl  last_nfa

  endif

  endm

; ------------------------------
; Macro to generate a counted string

dcs macro string1,string2,string3,string4 ; allow comma separated
    local _first,_next
    db _next-_first ; count byte
  _first: db string1
    if not nul string2
      db string2
      if not nul string3
        db string3
        if not nul string4
          db string4
        endif
      endif
    endif
  _next:
  endm

; ------------------------------
; Macro to ignore next 1 bytes

; XXX OLD -- not needed anymore
; XXX TODO -- how does it worked?
;;ignore1  macro
;;  db 0x00fe  ; cp n
;;   endm

; ------------------------------
; Macro to generate fdb table

; XXX OLD
;;gfdb   macro
;;  local _a
;;_a: defl  fdbs
;;   rept nfd
;;  dw _a
;;_a: defl  _a+file_descriptor_size
;;   endm
;;   endm

; ------------------------------
; Macro to save the IP

; This is used by words that call ROM routines.
; 'saved_ip' is defined in the word 'type'.
; See the word 'cls' as a usage example.

save_ip macro
  ld h,b
  ld l,c
  ld (saved_ip),hl
  endm

; }}} **********************************************************
; Boot {{{

  org sm

  jp cold_boot
;  jp warm_boot  ; XXX TODO

; }}} **********************************************************
; Data {{{

block_buffer:
  ds block_size    ; block buffer
;;fdbs: ; XXX OLD
;;  ds file_descriptor_size*nfd ; file descriptor blocks
tib:
  ds tib_size  ; TIB (terminal input buffer)
user_area:
  ds user_area_size

parsed_string_buffer:
   if retro
  ds parsed_string_buffer_size   ; buffer S"
   else
  ds parsed_string_buffer_size+word_buffer_size ; buffer S" WORD
   endif

hm: equ $   ; system definitions and header memory
dnfa:
  db 0   ; dummy nfa - don't remove! ; XXX NEW -- changed its position in DX-Forth 4.09

; If the following byte is non-zero, a warm boot is NOT performed on
; exit to CPM.
; XXX OLD
;;noboot:
;;  db 0   ; no warm boot flag   0110

; Identification and version

;;  dw 0x4683   ; id  ('DXF' in radix 36) 0111
;;dxver:
;;  db rel   ; release     0113
;;  db rev   ; revision      0114

;
; XXX OLD
;;  ds cw    ; reserved
user_area_pointer:
  dw user_area
return_stack_pointer:
  ds cw

; cpu speed (TURBO PASCAL compatible)
speed:
  dw 4   ; 1..8191 MHz

; Boot up variables used by COLD, must be in same order as USER variables

initu: equ $   ; <<< beginning data
  ds 3*cw    ; reserved for multitasking
is0:
  ds cw    ; s0
ir0:
  ds cw    ; r0
idp:
  dw initdp    ; dp
idph: ; XXX OLD
  dw initdph   ; dph
ivoc:
  dw forth2    ; voc-link
ifs0:
  ds cw    ; fs0
  ds cw    ; reserved
initu2  equ $   ; <<< end data

stack:
  ds cw    ; CP/M stack pointer
esm:
  ds cw    ; end of memory pointer
iboot:
  ds cw    ; initial boot value
defdrv:
  ds 1   ; default drive
defusr:
  ds 1   ; default user
scaps:   ; XXX TODO convert to user variable
  ds 1   ; COMPARE SEARCH case flag
cmdf:
  ds 1   ; command line flag
biospb:
  ds 5   ; bios param block
; XXX OLD 
;;ulimit:
;;  ds cw    ; LIMIT for turnkey ; XXX NEW -- from DX-Forth 4.09
;;  ds 2   ; spare

; Arrow key codes (default = Wordstar style)

  db 'E'-0x40   ; up arrow      014F
  db 'X'-0x40   ; down arrow      0150
  db 'D'-0x40   ; right arrow     0151
  db 'S'-0x40   ; left arrow      0152

; Scratch buffer - shared by several functions:
; +EXT  DELETE-FILE  RENAME-FILE
;; sbuf equ $ ; XXX OLD ? -- not used

; Buffer for temporary filename/fcb

zbsiz: equ filename_size+1+36

zb1:
  ds zbsiz
zb2:
  ds zbsiz

tmp_stack: equ $-cw ; temp stack for startup

; }}} **********************************************************
; Misc. subroutines

; ------------------------------
; BC is preserved

de_minus_hl_to_hl:
  ; Input:  de, hl
  ; Output: hl = de-hl
  ex de,hl

hl_minus_de_to_hl:
  ; Input:  de, hl
  ; Output: hl = hl-de
  ld a,l
  sub e
  ld l,a
  ld a,h
  sbc a,d
  ld h,a
  ret

compare_de_hl_unsigned:
  ; Input:  de, hl
  ; Output:
  ;  flag C if hl < de
  ;  flag Z if hl = de
  ld a,h
  cp d
  ret nz
  ld a,l
  cp e
  ret

compare_de_hl_signed:
  ; Input:  de, hl
  ; Output: flag C if hl < de
  ld a,h
  xor d
  jp p,compare_de_hl_unsigned
  ld a,h
  or a
  ret p
  scf
  ret

; XXX OLD
get_current_drive:
  ld a,25  ; get current drive a
  jp bdoss

; XXX OLD
get_current_user:
;;  ld a,0xff  ; get current user a

 ; XXX OLD
set_current_user:
;;  ld e,a ; set current user a
;;  ld a,32

; XXX OLD
bdoss:
;;  push bc  ; call bdos a
;;  ld c,a
;;  call 0x0005
;;  pop bc
  ret

; ------------------------------
; BC is affected

; move block upwards  HL = source, DE = destination, BC = count

bmovu:
  add hl,bc
  ex de,hl
  add hl,bc
  ex de,hl
bmovu1:
  ld a,c
  or b
  ret z
  dec hl
  dec de
  ld a,(hl)
  ld (de),a
  dec bc
  jp bmovu1

; move block up/down  HL = source, DE = destination, BC = count

bmove:
  call compare_de_hl_unsigned
  jp c,bmovu

; move block downwards  HL = source, DE = destination, BC = count

bmovd:
  ld a,c
  or b
  ret z
  ld a,(hl)
  ld (de),a
  inc hl
  inc de
  dec bc
  jp bmovd

; move block downwards  HL = source, DE = destination, A = count

amovd:
  push bc
  ld c,a
  ld b,0
  call bmovd
  pop bc
  ret

; }}} **********************************************************
; Virtual machine {{{

; XXX TODO -- add headers:
do_create:        equ next
do_value:         equ fetch
do_constant:      equ fetch
do_byte_constant: equ c_fetch

; runtime for colon definitions

; XXX TODO -- add a header
do_colon:
  ld hl,(return_stack_pointer)  ; push IP onto return stack
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c
  ld (return_stack_pointer),hl
  pop bc    ; get new IP from 'call'
  jp next

; runtime for user variables

; XXX TODO -- add a header
do_user_variable:
  pop hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  ld hl,(user_area_pointer)
  add hl,de
  push hl
  jp next

; NOOP  ( -- )

  hdr 1,'NOOP'
noop: equ $

; NEXT  -  Forth Address Interpreter

next:
  ld a,(bc)   ; 7T
  ld l,a      ; 4T
  inc bc      ; 6T
  ld a,(bc)   ; 7T
  ld h,a      ; 4T
  inc bc      ; 6T
  jp (hl)     ; 4T

; UNNEST  ( -- )

  hdr 1,'UNNEST'
unnest:
  ld hl,(return_stack_pointer)
  inc hl
  inc hl
  ld (return_stack_pointer),hl
  jp next

; (EXIT)  ( -- )    exit colon definition

  hdr 1,'(EXIT)'
exit:
  ld bc,next
;;exit1:
  push bc
  ld hl,(return_stack_pointer)  ; pop IP from return stack
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  ld (return_stack_pointer),hl
  ret ; execute NEXT

; EXECUTE  ( xt -- )

  hdr 1,'EXECUTE'
execute:
  ret

; @EXECUTE  ( a-addr -- )

  hdr 1,'@EXECUTE'
fetch_execute:
  pop hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  or h
  jp z,next
  jp (hl)

; clit  ( -- char )

  hdr x,'CLIT'  ; FIG
c_lit:
  ld a,(bc)
  inc bc

push_a:
  ld l,a
push_l:
  ld h,0
push_hl:
  push hl
  jp next

; lit  ( -- n )

  hdr x,'LIT'   ; FIG
lit:
  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a
  inc bc
  push hl
  jp next

; 2lit  ( -- d )

  hdr x,'2LIT'
two_lit:
  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a
  ; XXX FIXME DX-Forth bug? HL is not pushed!
  inc bc
  ld a,(bc)
  ld e,a
  inc bc
  ld a,(bc)
  ld d,a
  inc bc
  push de
  jp next

; }}} **********************************************************
; Stack functions {{{

; SP@  ( -- addr )

  hdr 1,'SP@'
sp_fetch:
  ld hl,0
  add hl,sp
  push hl
  jp next

; SP!  ( addr -- )

  hdr 1,'SP!'
sp_store:
  pop hl
  ld sp,hl
  jp next

; RP@  ( -- addr )

  hdr 1,'RP@'
rp_fetch:
  ld hl,(return_stack_pointer)
  push hl
  jp next

; RP!  ( addr -- )

  hdr 1,'RP!'
rp_store:
  pop hl
  ld (return_stack_pointer),hl
  jp next

; >R  ( x -- )

  hdr 1,'>R'
to_r:
  ld hl,(return_stack_pointer)
  pop de
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e
  ld (return_stack_pointer),hl
  jp next

; R>  ( -- x )

  hdr 1,'R>'
from_r:
  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (return_stack_pointer),hl
  push de
  jp next

; R@  ( -- x )

  hdr 1,'R@'
r_fetch:
  ld hl,(return_stack_pointer)
  jp fetch1

; 2>R  ( x1 x2 -- )

  hdr 1,'2>R'
two_to_r:
  ld hl,(return_stack_pointer)
  ld de,-cw*2
  add hl,de
  ld (return_stack_pointer),hl
  jp two_store1

; 2R>  ( -- x1 x2 )

  hdr 1,'2R>'
two_from_r:
  ld hl,(return_stack_pointer)
  push hl
  ld de,cw*2
  add hl,de
  ld (return_stack_pointer),hl
  jp two_fetch

; 2R@  ( -- x1 x2 )

  hdr 1,'2R@'
two_r_fetch:
  ld hl,(return_stack_pointer)
  jp two_fetch1

; 2DROP  ( x1 x2 -- )

  hdr 1,'2DROP'
two_drop:
  pop hl
  pop hl ; XXX NEW
  jp next ; XXX NEW -- because headers and code share the same zone

; DROP  ( x -- )

  hdr 1,'DROP'
drop:
  pop hl
  jp next

; DUP  ( x -- x x )

  hdr 1,'DUP'
dup:
  pop hl
  push hl
  push hl
  jp next

; ?DUP  ( x -- 0 | x x )

  hdr 1,'?DUP'
question_dup:
  pop hl
  ld a,l
  or h
  jp z,question_dup1
  push hl
question_dup1:
  push hl
  jp next

; SWAP  ( x1 x2 -- x2 x1 )

  hdr 1,'SWAP'
swap:
  pop hl
  ex (sp),hl
  push hl
  jp next

; OVER  ( x1 x2 -- x1 x2 x1 )

  hdr 1,'OVER'
over:
  pop de
  pop hl
  push hl
  push de
  jp next

; ROT  ( x1 x2 x3 -- x2 x3 x1 )

  hdr 1,'ROT'
rot:
  pop de
  pop hl
  ex (sp),hl
  push de
  jp next

; -ROT  ( x1 x2 x3 -- x3 x1 x2 )

  hdr 1,'-ROT'
drot:
  pop hl
  pop de
  ex (sp),hl
  ex de,hl
  push de
  jp next

; ROLL  ( xu xn .. x0 u -- xn .. x0 xu )

  hdr 1,'ROLL'
roll:
  pop hl
  add hl,hl
  ld e,l
  ld d,h
  add hl,sp
  push bc
  ld c,(hl)
  inc hl
  ld b,(hl)
  push bc
  ld c,e
  ld b,d
  ld e,l
  ld d,h
  inc de
  dec hl
  call bmovu1
  pop hl
  pop bc
  ex (sp),hl
  jp next

   if control_flow_stack_extensions

; -ROLL  ( xu .. xu+1 x0 u -- x0 xu .. xu+1 )

  hdr 1,'-ROLL'

; XXX OLD -- DX-Forth 4.00
;;droll:
;;  call  do_colon
;;  dw cells,two_to_r
;;  dw sp_fetch,sp_fetch,tuck
;;  dw r_fetch,cmove
;;  dw sp_fetch,two_from_r
;;  dw rot,plus,store
;;  dw exit

; XXX NEW -- DX-Forth 4.09
droll:
  pop hl
  add hl,hl
  ex de,hl
  ld hl,0
  add hl,sp
  push bc
  ld c,(hl)
  inc  hl
  ld b,(hl)
  push bc
  ld c,e
  ld b,d
  ld e,l
  ld d,h
  dec  de
  inc  hl
  call bmovd
  pop hl
  pop bc
  ex de,hl
  jp store_de_into_hl_pointer

   endif

; PICK  ( xu .. x1 x0 u -- xu .. x1 x0 xu )

  hdr 1,'PICK'
pick:
  pop hl
  add hl,hl
  add hl,sp
  jp fetch1

; NIP  ( x1 x2 -- x2 )

  hdr 1,'NIP'
nip:
  pop hl
  inc sp
  inc sp
  push hl
  jp next

; TUCK  ( x1 x2 -- x2 x1 x2 )

  hdr 1,'TUCK'
tuck:
  pop hl
  pop de
  push hl
  push de
  jp next

; ><  ( x1 -- x2 )

  hdr 1,'><'
bswp:
  pop de
  ld h,e
  ld l,d
  push hl
  jp next

;  2DUP  ( x1 x2 -- x1 x2 x1 x2 )

  hdr 1,'2DUP'
two_dup:
  pop hl
  pop de
  push de
  push hl
  push de
  jp next

;  2SWAP  ( x1 x2 x3 x4 -- x3 x4 x1 x2 )

  hdr 1,'2SWAP'
tswap:
; XXX OLD -- DX-Forth 4.00
;;  pop de
;;  pop hl
;;  inc sp
;;  inc sp
;;  ex  (sp),hl
;;  dec sp
;;  dec sp
;;  ex  de,hl
;;  ex  (sp),hl
;;  jp push_de
; XXX NEW -- DX-Forth 4.09
  pop hl
  pop de
  ex (sp),hl
  push hl
  ld hl,5
  add hl,sp
  ld a,(hl)
  ld (hl),d
  ld d,a
  dec  hl
  ld a,(hl)
  ld (hl),e
  ld e,a
  pop hl
  push de
  jp next

;  2OVER  ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )

  hdr 1,'2OVER'
two_over:
  ld hl,4
  add hl,sp
  jp two_fetch1

;  2ROT  ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
;  5 roll 5 roll

  hdr 1,'2ROT'
trot:
  call do_colon
  dw c_lit
  db 5
  dw roll
  dw c_lit
  db 5
  dw roll
  dw exit

;  2NIP  ( x1 x2 x3 x4 -- x3 x4 )

  hdr 1,'2NIP'
tnip:
  pop hl
  pop de
  inc  sp
  inc  sp
  inc  sp
  inc  sp
  push de
  jp next

; DEPTH  ( -- u )   sp@ s0 @ swap - 2/

  hdr 1,'DEPTH'
depth:
  call do_colon
  dw sp_fetch
  dw s0,fetch
  dw swap,minus
  dw twodiv
  dw exit

; end

; }}} **********************************************************
; Memory operations {{{

; @  ( a-addr -- x )

  hdr 1,'@'
fetch:
  pop hl
fetch1:
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  jp next

; 2!  ( x1 x2 a-addr -- )

  hdr 1,'2!'
two_store:
  pop hl
two_store1:
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  jp store1 ; XXX NEW -- because headers and code share the same zone
;  ignore1 ; XXX OLD

; !  ( x a-addr -- )

  hdr 1,'!'
store:
  pop hl
store1:
  pop de
store_de_into_hl_pointer:
  ld (hl),e
  inc hl
  ld (hl),d
  jp next

; C@  ( c-addr -- char )

  hdr 1,'C@'
c_fetch:
  pop hl
  ld l,(hl)
  ld h,0
  push hl
  jp next

; C!  ( char c-addr -- )

  hdr 1,'C!'
c_store:
  pop hl
  pop de
cstor1:
  ld (hl),e
  jp next

; 2@  ( a-addr -- x1 x2 )

  hdr 1,'2@'
two_fetch:
  pop hl
two_fetch1:
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  ex de,hl
  push de
  jp next

; +!  ( x a-addr -- )

  hdr 1,'+!'
pstor:
  pop hl
  pop de
pstor1:
  ld a,(hl)
  add a,e
  ld (hl),a
  inc hl
  ld a,(hl)
  adc a,d
  ld (hl),a
  jp next

; MOVE  ( addr1 addr2 u -- )

  hdr 1,'MOVE'  ; ANS
move:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
  call bmove
  pop bc
  jp next

; ERASE  ( addr u -- )

  hdr 1,'ERASE'
erase:
  ld e,0
  jp fill1  ; XXX NEW -- because headers and code share the same zone
;  ignore1 ; XXX OLD

; FILL  ( c-addr u char -- )

  hdr 1,'FILL'
fill:
  pop de
fill1:
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
  jp fill3

fill2:
  ld (hl),e
  inc hl
  dec bc
fill3:
  ld a,c
  or b
  jp nz,fill2
  pop bc
  jp next

; ON  ( addr -- )   -1 swap !

  hdr 1,'ON'
on:
  pop hl
on_hl:
  ld de,-1
  jp store_de_into_hl_pointer

; OFF  ( addr -- )  0 swap !

  hdr 1,'OFF'
off:
  pop hl
off_hl:
  ld de,0
  jp store_de_into_hl_pointer

; XXX OLD -- DX-Forth 4.00
; TOGGLE  ( c-addr x -- )

  hdr 1,'TOGGLE'
toggle:
  pop de
  pop hl
toggle1:
  ld a,(hl)
  xor e
  ld (hl),a
  jp next

; XXX NEW -- DX-Forth 4.09
; CTOGGLE  ( x c-addr -- )

  hdr 1,'CTOGGLE'
ctog:
  pop hl
  pop de
ctog1:
  ; XXX TODO jp toggle1
  ld a,(hl)
  xor e
  ld (hl),a
  jp next

; }}} **********************************************************
; Arithmetic and logical {{{

; AND  ( x1 x2 -- x3 )

  hdr 1,'AND'
and_:
  pop de
  pop hl
  ld a,e
  and l
  ld l,a
  ld a,d
  and h
  ld h,a
  push hl
  jp next

; OR  ( x1 x2 -- x3 )

  hdr 1,'OR'
or_:
  pop de
  pop hl
  ld a,e
  or l
  ld l,a
  ld a,d
  or h
  ld h,a
  push hl
  jp next

; XOR  ( x1 x2 -- x3 )

  hdr 1,'XOR'
xor_:
  pop de
  pop hl
  ld a,e
  xor l
  ld l,a
  ld a,d
  xor h
  ld h,a
  push hl
  jp next

abs_hl:
  ld a,h
  or a
  ret p

negate_hl:
  dec hl    ; two's complement
negate_hl1:
  ld a,l
  cpl
  ld l,a
  ld a,h
  cpl
  ld h,a
  ret

sra_hl:
  ld a,h   ; shift arithmetic right
  rlca
  rrca
sra_hl1:
  rra
  ld h,a
  ld a,l
  rra
  ld l,a
  ret

abs_hlde:
  ld a,h
  or a
  ret p

negate_hlde:
  sub a   ; 16 bit two's complement
  sub e
  ld e,a
  ld a,0
  sbc a,d
  ld d,a
  ld a,0
  sbc a,l
  ld l,a
  ld a,0
  sbc a,h
  ld h,a
  ret

; INVERT  ( x1 -- x2 )  one's complement

  hdr 1,'INVERT'
invert:
  pop hl
  call negate_hl1
  push hl
  jp next

; NOT  ( x1 -- x2 )   aka 0= not

  hdr 1,'NOT',,,zero_equals    ; F79 NOT
not_: equ zero_equals

; S>D  ( n -- d )

  hdr 1,'S>D'
s_to_d:
  ld hl,0
  pop de
  ld a,d
  or a
  jp p,s_to_d1
  dec hl
s_to_d1:
  push de
  jp next

; D>S  ( d -- n )     aka drop d>s

  hdr 1,'D>S',,,drop
d_to_s: equ drop

; NEGATE  ( n1 -- n2 )

  hdr 1,'NEGATE'
negate:
  pop hl
  call negate_hl
  push hl
  jp next

; ABS  ( n -- +n )

  hdr 1,'ABS'
abs:
  pop hl
  call abs_hl
  push hl
  jp next

; DNEGATE  ( d1 -- d2 )

  hdr 1,'DNEGATE'
d_negate:
  pop hl
  pop de
  call negate_hlde
  push de
  jp next

; DABS  ( d -- +d )

  hdr 1,'DABS'
d_abs:
  pop hl
  pop de
  call abs_hlde
  push de
  jp next

; +  ( x1 x2 -- x3 )

  hdr 1,'+'
plus:
  pop de
plus_de:
  pop hl
  add hl,de
  push hl
  jp next

; -  ( x1 x2 -- x3 )

  hdr 1,'-'
minus:
  pop de
  pop hl
  call hl_minus_de_to_hl
  push hl
  jp next

; D+  ( xd1 xd2 -- xd3 )

  hdr 1,'D+'
d_plus:
  ld hl,6
  add hl,sp
  ld e,(hl)
  ld (hl),c
  inc hl
  ld d,(hl)
  ld (hl),b
  pop bc
  pop hl
  add hl,de
  ex de,hl
  pop hl
  ld a,l
  adc a,c
  ld l,a
  ld a,h
  adc a,b
  ld h,a
  pop bc
  push de
  jp next

; D-  ( xd1 xd2 -- xd3 )  dnegate d+

  hdr 1,'D-'
d_minus:
  call do_colon
  dw d_negate,d_plus
  dw exit

; M+  ( xd1 n -- xd2 )  s>d d+

  hdr 1,'M+'    ; ANS
m_plus:
  call do_colon
  dw s_to_d,d_plus
  dw exit

; 1+  ( x1 -- x2 )

  hdr 1,'1+'
one_plus:
  pop hl
  inc hl
  push hl
  jp next

; 2+  ( x1 -- x2 )

  hdr 1,'2+'
two_plus:
  pop hl
  inc hl
  inc hl
  push hl
  jp next

; 1-  ( x1 -- x2 )

  hdr 1,'1-'
one_minus:
  pop hl
  dec hl
  push hl
  jp next

; 2-  ( x1 -- x2 )

  hdr 1,'2-'
two_minus:
  pop hl
  dec hl
  dec hl
  push hl
  jp next

; multiplication primitives

; AHL <- A * DE

mpyx:
  ld hl,0
  ld c,8
mpyx1:
  add hl,hl
  rla
  jp nc,mpyx2
  add hl,de
  adc a,0
mpyx2:
  dec c
  jp nz,mpyx1
  ret

; Unsigned 16*16 multiply, 32 bit result

; HLDE <- HL * DE

hl_by_de_to_hlde_unsigned:
  push bc    ; save IP
  ld b,h
  ld a,l
  call mpyx
  push hl
  ld h,a
  ld a,b
  ld b,h
  call mpyx
  pop de
  ld c,d
  add hl,bc
  adc a,0
  ld d,l
  ld l,h
  ld h,a
  pop bc    ; restore IP
  ret

; Signed 16*16 multiply, 32 bit result

; HLDE <- HL * DE

hl_by_de_to_hlde_signed:
  ld a,d
  xor h
  rla
  push af
  call abs_hl
  ex de,hl
  call abs_hl
  call hl_by_de_to_hlde_unsigned
  pop af
  ret nc
  jp negate_hlde

; UM*  ( u1 u2 -- ud )

  hdr 1,'UM*'
umstr:
  pop de
  pop hl
  call hl_by_de_to_hlde_unsigned
  push de
  jp next

; M*  ( n1 n2 -- d )  2dup xor >r abs swap abs um* r> ?dnegate

  hdr 1,'M*'    ; ANS
mstar:
  pop de
  pop hl
  call hl_by_de_to_hlde_signed
  push de
  jp next

; *  ( x1 x2 -- x3 )  um* drop

  hdr 1,'*'
star:
  pop de
  pop hl
  call hl_by_de_to_hlde_unsigned
  push de
  jp next

; division primitives

usl1:
  sub c
  ld h,a
  ld a,e
  sbc a,b
usl2:
  inc l
  dec d
  ret z

usl3:
  add hl,hl
  rla
  ld e,a
  ld a,h
  jp c,usl1
  sub c
  ld h,a
  ld a,e
  sbc a,b
  jp nc,usl2
  ld a,h
  add a,c
  ld h,a
  ld a,e
  dec d
  jp nz,usl3
  ret

usl:
  ld a,h
  ld h,l
  ld l,d
  ld d,8   ; loop counter
  push de
  call usl3
  pop de
  push hl
  ld l,e
  call usl3
  ld d,a
  ld e,h
  ld a,l
  pop hl
  ld h,l
  ld l,a
  ret

; Unsigned 32/16 divide
;
; entry HLDE = dividend, BC = divisor
; exit  HL = quotient, DE = remainder

mum:
  ld a,l   ; if overflow
  sub c
  ld a,h
  sbc a,b
  jp c,usl
  ld hl,-1   ; set rem & quot to max
  ld de,-1
  ret

; UM/MOD  ( ud u1 -- u2 u3 )

  hdr 1,'UM/MOD'
umslm:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
  ex de,hl
  call mum
  pop bc
  push de
  jp next

; Signed 32/16 divide - floored
;
; entry HLDE = dividend, BC = divisor
; exit  HL = quotient, DE = remainder

msm:
  push bc    ; save divisor
  ld a,b
  xor h
  push af    ; save quot sign
  push hl    ; save dividend
  push hl
  ld l,c
  ld h,b
  call abs_hl
  ld c,l
  ld b,h
  pop hl
  call abs_hlde
  call mum
  pop af    ; sign remainder
  or a
  ex de,hl
  call m,negate_hl
  ex de,hl
  pop af
  pop bc    ; restore divisor
  or a   ; sign quot
  jp p,msm1
  jp negate_hl

msm1:
  pop bc    ; discard return
msm2:
  pop bc
  push de
  jp next

; SM/REM  ( d n1 -- n2 n3 )

  hdr 1,'SM/REM'
smrem:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
  ex de,hl
smrem1:
  call msm
  jp msm2

; FM/MOD  ( d n1 -- n2 n3 )

  hdr 1,'FM/MOD'  ; ANS
fmmod:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
  ex de,hl
fmmod1:
  call msm
  ld a,d
  or e
  jp z,msm2    ; skip if remainder = 0
  dec hl    ; floor
  push hl
  ex de,hl
  add hl,bc
  ex de,hl
  pop hl
  jp msm2

; M/MOD  ( d n1 -- n2 n3 )  fm/mod or sm/rem

; XXX OLD -- DX-Forth 4.00 -- but kept
  hdr x,'M/MOD',,,msmod

   if floord
msmod: equ fmmod
   else
msmod: equ smrem
   endif

; /MOD  ( n1 n2 -- n3 n4 )  >r s>d r> m/mod

; XXX NEW -- DX-Forth 4.09 -- instead of 'M/MOD'
  hdr 1,'/MOD'
slmod:
  call do_colon
  dw to_r,s_to_d
  dw from_r,msmod
  dw exit

; /  ( n1 n2 -- n3 )    /mod nip

  hdr 1,'/'
slash:
  call do_colon
  dw slmod,nip
  dw exit

; MOD  ( n1 n2 -- n3 )    /mod drop

  hdr 1,'MOD'
modd:
  call do_colon
  dw slmod,drop
  dw exit

; XXX OLD -- DX-Forth 4.00
;;; */MOD  ( n1 n2 n3 -- n4 n5 )  >r m* r> m/mod
;;
;;  header 1,'*/MOD'
;;ssmod:
;;  call  do_colon
;;  dw to_r,mstar
;;  dw from_r,msmod
;;  dw exit

; XXX NEW -- DX-Forth 4.09
;  */MOD  ( n1 n2 n3 -- n4 n5 )  >r m* r> sm/rem
  hdr 1,'*/MOD'
ssmod:
  call do_colon
  dw to_r,mstar
  dw from_r,smrem
  dw exit

; */  ( n1 n2 n3 -- n4 )    */mod nip

  hdr 1,'*/'
ssla:
  call do_colon
  dw ssmod,nip
  dw exit

; M*/  ( d1 n1 +n2 -- d2 )  abs >r 2dup xor swap abs >r -rot
;         dabs swap r@ um* rot r> um* rot 0 d+
;         r@ um/mod -rot r> um/mod nip swap
;         rot 0< if dnegate then

  hdr 1,'M*/'   ; ANS
mssl:
  call do_colon
  dw abs,to_r
  dw two_dup,xor_
  dw swap,abs,to_r
  dw drot,d_abs
  dw swap,r_fetch,umstr
  dw rot,from_r,umstr
  dw rot,zero,d_plus
  dw r_fetch,umslm
  dw drot,from_r
  dw umslm,nip
  dw swap,rot,zero_less_than
  dw question_branch,mssl1
  dw d_negate
mssl1:
  dw exit

; 2*  ( x1 -- x2 )

  hdr 1,'2*'    ; ANS
tstar:
  pop hl
  add hl,hl
  push hl
  jp next

; 2/  ( n1 -- n2 )

  hdr 1,'2/'
twodiv:
  pop hl
  call sra_hl
  push hl
  jp next

; U2/  ( x1 -- x2 )

  hdr 1,'U2/'
utdiv:
  pop hl
  or a
  ld a,h
  call sra_hl1
  push hl
  jp next

; D2*  ( xd1 -- xd2 )

  hdr 1,'D2*'   ; ANS
dtstr:
  pop de
  pop hl
  add hl,hl
  ld a,e
  rla
  ld e,a
  ld a,d
  rla
  ld d,a
  ex de,hl
  push de
  jp next

; D2/  ( d1 -- d2 )

  hdr 1,'D2/'
dtdiv:
  pop hl
  pop de
  call sra_hl
  ld a,d
  rra
  ld d,a
  ld a,e
  rra
  ld e,a
  push de
  jp next

; LSHIFT  ( x1 u -- x2 )

  hdr 1,'LSHIFT'    ; ANS
lsh:
  pop de
  pop hl
  inc e
lsh1:
  dec e
  jp z,push_hl
  add hl,hl
  jp lsh1

; RSHIFT  ( x1 u -- x2 )

  hdr 1,'RSHIFT'    ; ANS
rshift:
  pop de
  pop hl
  inc e
rsh1:
  dec e
  jp z,push_hl
  or a
  ld a,h
  call sra_hl1
  jp rsh1

; end

; }}} **********************************************************
; Comparison {{{ 

; 0=  ( x -- flag )

  hdr 1,'0='
zero_equals:
  pop hl
zero_equals_hl:
  ld a,l
  or h
  jp z,true
  jp false

; 0<>  ( x -- flag )

  hdr 1,'0<>'
zero_not_equals:
  pop hl
  ld a,l
  or h
  jp z,false
  jp true

; =  ( x1 x2 -- flag )  - 0=

  hdr 1,'='
equals:
  pop de
  pop hl
equals1:
  call compare_de_hl_unsigned
  jp z,true
  jp false

; <>  ( x1 x2 -- flag ) - 0= 0=

  hdr 1,'<>'
not_equals:
  pop de
  pop hl
  call compare_de_hl_unsigned
  jp z,false
  jp true

; 0<  ( n -- flag )

  hdr 1,'0<'
zero_less_than:
  pop hl
zero_less_than1:
  add hl,hl
zero_less_than2:
  jp c,true
  jp false

; 0>  ( n -- flag )

  hdr 1,'0>'
zero_greater_than:
  pop de
  ld hl,0
zero_greater_than1:
  call compare_de_hl_signed
  jp c,true
  jp false

; <  ( n1 n2 -- flag )

  hdr 1,'<'
less_than:
  pop de
  pop hl
  jp zero_greater_than1

; >  ( n1 n2 -- flag )

  hdr 1,'>'
greater_than:
  pop hl
  pop de
  jp zero_greater_than1

; U<  ( u1 u2 -- flag )

  hdr 1,'U<'
u_less_than:
  pop de
  pop hl
u_less_than1:
  call compare_de_hl_unsigned
  jp c,true
  jp false

; U>  ( u1 u2 -- flag )

  hdr 1,'U>'
u_greater_than:
  pop hl
u_greater_than1:
  pop de
  jp u_less_than1

; 0max  ( n1 -- n2 )  0 max

  hdr x,'0MAX'
zero_max:
  ld de,0
  jp max_de

; MAX  ( n1 n2 -- n1 | n2 )  2dup < if swap then drop

  hdr 1,'MAX'
max:
  pop de
max_de:
  pop hl
  call compare_de_hl_signed
max1:
  ccf
max2:
  jp c,max3
  ex de,hl
max3:
  push hl
  jp next

; MIN  ( n1 n2 -- n1 | n2 )  2dup > if swap then drop

  hdr 1,'MIN'
min:
  pop de
  pop hl
  call compare_de_hl_signed
  jp max2

; UMAX  ( u1 u2 -- u1 | u2 )  2dup u< if swap then drop

  hdr 1,'UMAX'
u_max:
  pop de
  pop hl
  call compare_de_hl_unsigned
  jp max1

; UMIN  ( u1 u2 -- u1 | u2 )  2dup u> if swap then drop

  hdr 1,'UMIN'
u_min:
  pop de
  pop hl
  call compare_de_hl_unsigned
  jp max2

; WITHIN  ( n1|u1 n2|u2 n3|u3 -- flag )  over - >r - r> u<

  hdr 1,'WITHIN'  ; ANS
within:
  pop hl
  pop de
  call hl_minus_de_to_hl
  ex (sp),hl
  call hl_minus_de_to_hl
  jp u_greater_than1

; BETWEEN  ( n1|u1 n2|u2 n3|u3 -- flag )  over - -rot - u< 0=

  hdr 1,'BETWEEN'
between:
  pop hl
  pop de
  call hl_minus_de_to_hl
  ex (sp),hl
  call hl_minus_de_to_hl
  pop de
  call compare_de_hl_unsigned
  jp z,true
  jp zero_less_than2

; D0=  ( d -- flag )  or 0=

  hdr 1,'D0='
d_zero_equals:
  call do_colon
  dw or_,zero_equals
  dw exit

; D=  ( d1 d2 -- flag )

  hdr 1,'D='
d_equals:
  pop de
  pop hl
  ex (sp),hl
  call compare_de_hl_unsigned
  pop de
  pop hl
  jp nz,false
  jp equals1

; D0<  ( d -- flag )  swap drop 0<

  hdr 1,'D0<'   ; ANS
d_zero_less_than:
  pop hl
  pop de
  jp zero_less_than1

; D<  ( d1 d2 -- flag ) rot 2dup = if 2drop u< exit then 2nip >

  hdr 1,'D<'
d_less_than:
  pop de
  pop hl
  ex (sp),hl
  call compare_de_hl_unsigned
  jp z,u_less_than
  inc sp
  inc sp
  inc sp
  inc sp
  jp zero_greater_than1

; DU<  ( ud1 ud2 -- flag )  rot swap 2dup u< if 2drop 2drop -1 exit
;         then - if 2drop 0 exit then u<

  hdr 1,'DU<'
d_u_less_than:
  pop de
  pop hl
  ex (sp),hl
  call compare_de_hl_unsigned
  pop de
  pop hl
  jp c,true
  jp nz,false
  jp u_less_than1

; DMIN  ( d1 d2 -- d1 | d2 )  2over 2over d< 0= if 2swap then 2drop

  hdr 1,'DMIN'
d_min:
  call do_colon
  dw two_over,two_over
  dw d_less_than,zero_equals
d_min1:
  dw question_branch,d_min2
  dw tswap
d_min2:
  dw two_drop
  dw exit

; DMAX  ( d1 d2 -- d1 | d2 )  2over 2over d< if 2swap then 2drop

  hdr 1,'DMAX'
d_max:
  call do_colon
  dw two_over,two_over
  dw d_less_than
  dw branch,d_min1

; }}} **********************************************************
; Numeric conversion {{{ 

;  DECIMAL  ( -- )    10 base !

  hdr 1,'DECIMAL'
decimal:
  call do_colon
  dw c_lit
  db 10
  dw base,store
  dw exit

;  HEX  ( -- )    16 base !

  hdr 1,'HEX'
hex:
  call do_colon
  dw c_lit
  db 16
  dw base,store
  dw exit

;  digit  ( char base -- u -1 | 0 )

  hdr x,'DIGIT'
digit:
  pop hl
  pop de
  ld a,e
  call uppercase_a
  sub  '0'
  jp m,false
  cp 10
  jp m,digit1
  sub  7
  cp 10
  jp m,false
digit1:
  cp l
  jp p,false
  ld e,a
  push de
  jp true

;  >NUMBER  ( d1 addr1 u1 -- d2 addr2 u2 )
;        begin dup while over c@ base @ digit while
;        >r 2swap r> swap base @ um* drop rot base @
;        um* d+ 2swap 1 /string 1 dpl +! repeat then

  hdr 1,'>NUMBER'
tonum:
  call do_colon
tonum1:
  dw dup    ; begin
  dw question_branch,tonum2  ; while
  dw over,c_fetch
  dw base,fetch
  dw digit
  dw question_branch,tonum2  ; while
  dw to_r
  dw tswap,from_r
  dw swap
  dw base,fetch
  dw umstr,drop
  dw rot
  dw base,fetch
  dw umstr
  dw d_plus
  dw tswap
  dw one,sstr
  dw one,dpl,pstor
  dw branch,tonum1  ; repeat
tonum2:
  dw exit    ; then

;  NUMBER?  ( c-addr u -- d -1 | 0 )
;        over c@ [char] - = over 0> and dup >r 1
;        and /string over c@ [char] . > and 0 0
;        2swap ?dup if >number dpl on dup if 1-
;        over c@ [char] . - or dpl off then while
;        then r> 2drop 2drop false else drop r> if
;        dnegate then true then

  hdr 1,'NUMBER?'
numq:
  call do_colon    ; convert string to double number
  dw over,c_fetch
  dw c_lit
  db '-'
  dw equals
  dw over,zero_greater_than
  dw and_
  dw dup,to_r
  dw one,and_
  dw sstr
  dw over,c_fetch
  dw c_lit
  db '.'
  dw greater_than,and_
  dw zero,zero
  dw tswap
  dw question_dup
  dw question_branch,numq2
  dw tonum
  dw dpl,on
  dw dup
  dw question_branch,numq1
  dw one_minus
  dw over,c_fetch
  dw c_lit
  db '.'
  dw minus,or_
  dw dpl,off
numq1:
  dw question_branch,numq3
numq2:
  dw from_r
  dw two_drop,two_drop
  dw false
  dw branch,numq5
numq3:
  dw drop
  dw from_r
  dw question_branch,numq4
  dw d_negate
numq4:
  dw true
numq5:
  dw exit

;  <#  ( -- )    pad hld !

  hdr 1,'<#'
bdigs:
  call do_colon
  dw pad
  dw hld,store
  dw exit

;  #>  ( d -- c-addr u )  2drop hld @ pad over -

  hdr 1,'#>'
edigs:
  call do_colon
  dw two_drop
  dw hld,fetch
  dw pad
  dw over
  dw minus
  dw exit

;  +hld ( +n -- c-addr )  negate hld +! hld @ dup dp @ u<
;        abort" HOLD buffer overflow"

  hdr x,'+HLD'
phld:
  call do_colon
  dw negate,hld,pstor
  dw hld,fetch,dup
  dw dpp,fetch,u_less_than
  dw paren_abort_quote
  dcs 'HOLD buffer overflow'
  dw exit

;  HOld ( char -- )  1 +hld c!

  hdr 1,'HOLD'
hold:
  call do_colon
  dw one,phld
  dw c_store
  dw exit

;  SIGN  ( n -- )    0< if [char] - hold then

  hdr 1,'SIGN'
sign:
  call do_colon
  dw zero_less_than
  dw question_branch,sign1
  dw c_lit
  db '-'
  dw hold
sign1:
  dw exit

;  #  ( ud1 -- ud2 )  0 base @ um/mod >r base @ um/mod r>
;        rot 9 over < if 7 + then [char] 0 + hold

  hdr 1,'#'
dig:
  call do_colon
  dw zero
  dw base,fetch
  dw umslm
  dw to_r
  dw base,fetch
  dw umslm
  dw from_r
  dw rot
  dw c_lit
  db 9
  dw over,less_than
  dw question_branch,dig1
  dw c_lit
  db 7
  dw plus
dig1:
  dw c_lit
  db '0'
  dw plus
  dw hold
  dw exit

;  #S  ( +d -- 0 0 )  begin # 2dup d0= until

  hdr 1,'#S'
digs:
  call do_colon
digs1:
  dw dig
  dw two_dup,d_zero_equals
  dw question_branch,digs1
  dw exit

;  SHOld ( c-addr u -- )  dup +hld swap move

  hdr 1,'SHOLD'  ; hold string
shold:
  call do_colon
  dw dup,phld
  dw swap,move
  dw exit

;  NHOld ( n char -- )  over +hld -rot fill

  hdr 1,'NHOLD'  ; hold n characters
nhold:
  call do_colon
  dw over,phld
  dw drot,fill
  dw exit

;  decimal? ( -- flag )  base @ 10 =

  hdr x,'DECIMAL?'
dcmq:
  call do_colon
  dw base,fetch    ; decimal base?
  dw c_lit
  db 10
  dw equals
  dw exit

; }}} **********************************************************
; String functions {{{ 

; CMOVE  ( c-addr1 c-addr2 u -- )

  hdr 1,'CMOVE'
cmove:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
cmove1:
  call bmovd
  pop bc
  jp next

; CMOVE>  ( c-addr1 c-addr2 u -- )

  hdr 1,'CMOVE>'
cmovu:
  ld l,c
  ld h,b
  pop bc
  pop de
  ex (sp),hl
cmovu1:
  call bmovu
  pop bc
  jp next

; BLANK  ( c-addr u -- )  bl fill

  hdr 1,'BLANK'
blank:
  ld e,' '
  jp fill1

; COUNT  ( c-addr1 -- c-addr2 u )  dup 1+ swap c@

  hdr 1,'COUNT'
count:
  pop de
;;count1: ; XXX OLD
  ld a,(de)
  inc de
  push de
  jp push_a

;  PACKED  ( c-addr1 u c-addr2 -- c-addr2 )
;            2dup 2>r 1+ swap move 2r> tuck c!

  hdr 1,'PACKED'
packd:
  ld l,c
  ld h,b
  pop de
  pop bc
  ex (sp),hl
  push bc
  push de
  inc  de
  call bmove
  pop hl
  pop de
  ld (hl),e
  pop bc
  push hl
  jp next

;  PLACE  ( c-addr1 u c-addr2 -- )  packed drop

  hdr 1,'PLACE'
place:
  call do_colon
  dw packd,drop
  dw exit

; XXX OLD -- DX-Forth 4.00
;;; PLACE  ( c-addr1 u c-addr2 -- )  2dup 2>r 1+ swap move 2r> c!
;;
;;  header 1,'PLACE'
;;place:
;;  call  do_colon
;;  dw two_dup
;;  dw two_to_r
;;  dw one_plus,swap
;;  dw move
;;  dw two_from_r
;;  dw c_store
;;  dw exit

; affix  ( c-addr char -- c-addr )  over count + c!

  ; append char to counted string
  ; count unchanged
  hdr x,'AFFIX'
affix:
  call do_colon
  dw over
  dw count,plus
  dw c_store
  dw exit

; SCAN  ( c-addr1 u1 char -- c-addr2 u2 )

  hdr 1,'SCAN'
scan:
  pop de
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
scan1:
  ld a,c
  or b
  jp z,scan2
  ld a,e
  cp (hl)
  jp z,scan2
  inc hl
  dec bc
  jp scan1

scan2:
  ex (sp),hl
scan3:
  push bc
  ld c,l
  ld b,h
  jp next

; SKIP  ( c-addr1 u1 char -- c-addr2 u2 )

  hdr 1,'SKIP'
skip:
  pop de
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
skip1:
  ld a,c
  or b
  jp z,scan2
  ld a,e
  cp (hl)
  jp nz,scan2
  inc hl
  dec bc
  jp skip1

; -TRAILING  ( c-addr u1 -- c-addr u2 )

  hdr 1,'-TRAILING'
dtrai:
  pop de
  pop hl
  push hl
  add hl,de
  ex de,hl
dtrai1:
  dec de
  ld a,l
  or h
  jp z,push_hl
  ld a,(de)
  cp ' '
  jp nz,push_hl
  dec hl
  jp dtrai1

; /STRING  ( c-addr1 u1 n -- c-addr2 u2 )   rot over + -rot -

  hdr 1,'/STRING' ; ANS
sstr:
  pop de
  pop hl
  call hl_minus_de_to_hl
  ex (sp),hl
  add hl,de
  ex (sp),hl
  push hl
  jp next

; CAPS  ( -- )
; enable caps COMPARE/SEARCH
; XXX TODO use a user variable instead
  hdr 1,'CAPS'
caps:
  ld a,1
  jp dcaps1

; -caps  ( -- )
;   disable caps COMPARE/SEARCH
; XXX TODO use a user variable instead
  hdr x,'-CAPS'
dcaps:
  xor a
dcaps1:
  ld (scaps),a
  jp next

compare_strings_case_insensitive:
  ; Input:
  ;   HL = a1
  ;   BC = a2
  ;   DE = len
  ; Output:
  ;   Z = match?
  ld a,e
  or d
  ret z
  push bc
  ld a,(bc)
  call uppercase_a
  ld c,a
  ld a,(hl)
  call uppercase_a
  cp c
  pop bc
  ret nz
  inc hl
  inc bc
  dec de
  jp compare_strings_case_insensitive

compare_strings:
  ; Input:
  ;   HL = a1
  ;   BC = a2
  ;   DE = len
  ; Output:
  ;   Z = match?
  ld a,(scaps)
  or a
  jp nz,compare_strings_case_insensitive

compare_strings_case_sensitive:
  ; Input:
  ;   HL = a1
  ;   BC = a2
  ;   DE = len
  ; Output:
  ;   Z = match?
  ld a,e
  or d
  ret z
  ld a,(bc)
  cp (hl)
  ret nz
  inc hl
  inc bc
  dec de
  jp compare_strings_case_sensitive

; COMPARE  ( c-addr1 u1 c-addr2 u2 -- -1 | 0 | 1 )

  hdr 1,'COMPARE' ; ANS
compare:
  pop de
  pop hl
  ex (sp),hl
  ld a,d
  cp h
  jp nz,compare1
  ld a,e
  cp l
compare1:
  jp c,compare2
  ex de,hl
compare2:
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
  push af
  call compare_strings
  jp z,compare4
  pop bc
compare3:
  pop bc
  ld a,0 ; XXX xor a instead?
  ld (scaps),a
  jp c,one
  jp z,false
  jp true

compare4:
  pop af
  jp compare3

; SEARCH  ( c-addr1 u1 c-addr2 u2 -- c-addr3 u3 -1 | c-addr1 u1 0 )

  hdr 1,'SEARCH'
search:
  call do_colon
  dw $+2
  pop hl
  ld (string_2_len),hl
  ld a,l
  or h
  pop bc
  pop hl
  ld (string_1_len),hl
  ex de,hl
  pop hl
  ld (string_1_addr),hl
  jp z,search2
  dec hl
  inc de
search1:
  inc hl
  dec de
  ld a,e
  or d
  jp z,search4
; XXX commented out in DX-Forth:
; ld a,(bc)
; cp  (hl)
; jp nz,search1
  push de
  push bc
  push hl
  ex de,hl
string_2_len equ $+1
  ld hl,0  ; length of the second string
  ex de,hl
  call compare_strings
  pop hl
  pop bc
  pop de
  jp nz,search1

search2:
  ld bc,-1
search3:
  push hl
  push de
  push bc
  xor a
  ld (scaps),a
  jp exit

search4:
  ld bc,0
string_1_len equ $+1
  ld hl,0  ; length of the first string
  ex de,hl
string_1_addr equ $+1
  ld hl,0  ; address of the first string
  jp search3

;;; +STRING  ( c-addr1 u1 c-addr2 u2 -- c-addr2 u3)
;;;         2swap swap 2over + 2 pick cmove +
;;
;;  header 1,'+STRING'
;;pstr:
;;  call  do_colon
;;  dw tswap,swap
;;  dw two_over,plus
;;  dw two,pick
;;  dw cmove,plus
;;  dw exit

; XXX NEW -- DX-Forth 4.09
;  +STRING  ( c-addr1 u1 c-addr2 u2 -- c-addr2 u3)
;          2swap swap 2over + 2 pick cmove +

  hdr 1,'+STRING'  ; uses temps 1-3
pstr:
  ld l,c
  ld h,b
  ld (t3),hl    ; bsave
  pop de
  pop hl
  ld (t2),hl    ; adr2
  add hl,de
  ex de,hl
  pop bc
  add hl,bc
  ld (t1),hl    ; u3
  pop hl
  call bmovd
  ld hl,(t3)    ; bsave
  ld c,l
  ld b,h
  ld hl,t1
  jp two_fetch1

; XXX TMP
t1: ds cw
t2: ds cw
t3: ds cw

; XXX NEW -- DX-Forth 4.09
;  S.R  ( c-addr n1 n2 -- )  over - spaces type

  hdr 1,'S.R'    ; type string right-justified
sdotr:
  call do_colon
  dw over,minus
  dw spacs
  dw type
  dw exit

; UPCASE  ( char1 -- char2 )

  hdr 1,'UPCASE'  ; make char uppercase
upcas:
  pop hl
  ld a,l
  call uppercase_a
  jp push_a

; UPPER  ( c-addr u -- )

  hdr 1,'UPPER' ; make string uppercase
upper:
  pop de
  pop hl
upper1:
  ld a,d
  or e
  jp z,next
  ld a,(hl)
  call uppercase_a
  ld (hl),a
  inc hl
  dec de
  jp upper1

; XXX NEW -- after Gforth
; TOUPPER  ( c1 -- c2 )

  hdr 1,'TOUPPER' ; make char uppercase

toupper:
  pop hl
  ld a,l
  call uppercase_a
  jp next

uppercase_a:
  cp 'a'
  ret c
  cp 'z'+1
  ret nc
  xor 0x20
  ret

; XXX NEW -- after UPPER
; LOWER  ( c-addr u -- )

  hdr 1,'LOWER' ; make string lowercase
lower:
  pop de
  pop hl
lower1:
  ld a,d
  or e
  jp z,next
  ld a,(hl)
  call lowercase_a
  ld (hl),a
  inc hl
  dec de
  jp lower1

; XXX NEW -- after TOUPPER
; TOLOWER  ( c1 -- c2 )

  hdr 1,'TOLOWER' ; make char lowercase

tolower:
  pop hl
  ld a,l
  call lowercase_a
  jp next

lowercase_a:
  cp 'A'
  ret c
  cp 'Z'+1
  ret nc
  xor 0x20
  ret

; }}} **********************************************************
; Control structures {{{

; (of)  ( n1 n2 -- )

  hdr x,'(OF)'
paren_of:
  pop hl
  pop de
  call hl_minus_de_to_hl
  ld a,l
  or h ; hl equal de?
  jp z,question_branch1
  push de
; jp branch ; XXX commented out in DX-Forth

; branch  ( -- )

  hdr x,'BRANCH'
branch:
  ld h,b
  ld l,c
  ld c,(hl)
  inc hl
  ld b,(hl)
  jp next

; ?branch  ( flag -- )

  hdr x,'?BRANCH'
question_branch:
  pop hl
  ld a,l
  or h
  jp z,branch
question_branch1:
  inc bc
  inc bc
  jp next

; (loop)  ( -- )

  hdr x,'(LOOP)'
paren_loop:
  ld hl,(return_stack_pointer)
  inc (hl)
  jp nz,branch
  inc hl
  inc (hl)
  jp nz,branch
paren_loop1:
  inc bc    ; skip over branch
  inc bc
; jp unloo

; UNLOOP  ( -- )

  hdr 1,'UNLOOP'  ; ANS
unloo:
  ld hl,(return_stack_pointer)  ; discard loop parameters
  ld de,cw*2
  add hl,de
  ld (return_stack_pointer),hl
  jp next

; (+loop)  ( n -- )

  hdr x,'(+LOOP)'
paren_plus_loop:
  ld hl,(return_stack_pointer)
  ld e,(hl)
  inc hl
  ld d,(hl)
  pop hl
  ld a,h
  or a
  jp m,paren_plus_loop2
  add hl,de
  jp c,paren_loop1
paren_plus_loop1:
  ex de,hl
  ld hl,(return_stack_pointer)
  ld (hl),e
  inc hl
  ld (hl),d
  jp branch

paren_plus_loop2:
  add hl,de
  jp c,paren_plus_loop1
  jp paren_loop1

; (leave)  ( -- )

  hdr x,'(LEAVE)'
paren_leave:
  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a
  ld c,(hl)
  inc hl
  ld b,(hl)
  jp unloo

; (?do)  ( n1 n2 -- ) 2dup = if 2drop r> @ >r exit then (xdo1)

  hdr x,'(?DO)'
paren_question_do:
  call do_colon
  dw two_dup,equals
  dw question_branch,paren_do1
  dw two_drop
  dw from_r,fetch,to_r
  dw exit

; (do)  ( n1 n2 -- )    over - r> cell+ -rot 2>r >r

  hdr x,'(DO)'
paren_do:
  call do_colon
paren_do1:
  dw over,minus
  dw from_r,cell_plus
  dw drot
  dw two_to_r
  dw to_r
  dw exit

; bal  ( -- addr )

  hdr x,'BAL',,1
bal:
  call do_create
bal1:
  ds 2

; +BAL  ( -- )      1 bal +!

  hdr 1,'+BAL',,1
pbal:
  ld de,1
pbal1:
  ld hl,bal1
  jp pstor1

; -BAL  ( -- )      -1 bal +!

  hdr 1,'-BAL',,1
dbal:
  ld de,-1
  jp pbal1

; ?BAL  ( flag -- )   checking @ 0<> and
;         abort" definition unbalanced"

  hdr 1,'?BAL',,1
qbal:
  call do_colon
  dw check,fetch
  dw zero_not_equals,and_
  dw paren_abort_quote
  dcs 'definition unbalanced'
  dw exit

; ?depth  ( x -- x )    ?comp depth 0= ?bal

  hdr x,'?DEPTH',,1
qdep:
  call do_colon
  dw qcomp
  dw depth,zero_equals
  dw qbal
  dw exit

; ?orig  ( orig -- orig )   ?depth dup @ ?bal

  hdr x,'?ORIG',,1
question_orig:
  call do_colon
  dw qdep
  dw dup,fetch
  dw qbal
  dw exit

; ?dest  ( dest -- dest )   ?depth dup @ 0= ?bal

  hdr x,'?DEST',,1
qdest:
  call do_colon
  dw qdep
  dw dup,fetch
  dw zero_equals
  dw qbal
  dw exit

; BEGIN  ( -- dest )    ?comp here +bal ;immediate

  hdr 1,'BEGIN',1,1
begin:
  call do_colon
  dw qcomp
  dw here
  dw pbal
  dw exit

; >MARK  ( -- orig )    postpone begin 0 ,

  hdr 1,'>MARK',,1
to_mark:
  call do_colon
  dw begin
  dw zero
  dw comma
  dw exit

; <RESOLVE  ( dest -- )   ?dest , -bal

  hdr 1,'<RESOLVE',,1
bresol:
  call do_colon
  dw qdest
  dw comma
  dw dbal
  dw exit

; THEN  ( orig -- )   ?orig here swap ! -bal ;immediate

  hdr 1,'THEN',1,1
then:
  call do_colon
  dw question_orig
  dw here
  dw swap,store
  dw dbal
  dw exit

; IF  ( -- orig )     postpone ?branch >mark
;         ;immediate

  hdr 1,'IF',1,1
iff:
  call do_colon
  dw compile,question_branch
  dw to_mark
  dw exit

; AHEAD  ( -- orig )    postpone branch >mark
;         ;immediate

  hdr 1,'AHEAD',1,1
ahead:
  call do_colon
  dw compile,branch
  dw to_mark
  dw exit

; ELSE  ( orig1 -- orig2 )  ?orig postpone ahead swap postpone
;         then ;immediate

  hdr 1,'ELSE',1,1
elsee:
  call do_colon
  dw question_orig
  dw ahead
  dw swap
  dw then
  dw exit

; UNTIL  ( dest -- )    postpone ?branch <resolve
;         ;immediate

  hdr 1,'UNTIL',1,1
until:
  ld hl,question_branch
until1:
  push hl
  call do_colon
  dw comxt
  dw bresol
  dw exit

; AGAIN  ( dest -- )    postpone branch <resolve ;immediate

  hdr 1,'AGAIN',1,1
again:
  ld hl,branch
  jp until1

; WHILE  ( x -- orig x )    ?depth postpone if swap ;immediate

  hdr 1,'WHILE',1,1
whilee:
  call do_colon
  dw qdep
  dw iff
  dw swap
  dw exit

; REPEAT  ( orig dest -- )  postpone again postpone then
;         ;immediate

  hdr 1,'REPEAT',1,1
repeatt:
  call do_colon
  dw again
  dw then
  dw exit

; lv  ( -- addr )     0 value lv

  hdr x,'LV',,1
lvv:
  call do_value
  dw 0

; DO  ( -- orig dest )    postpone (do) lv >mark dup to lv
;         postpone begin ;immediate

  hdr 1,'DO',1,1
do:
  ld hl,paren_do
do1:
  push hl
  call do_colon
  dw comxt
  dw lvv
  dw to_mark
  dw dup
  dw paren_to,lvv
  dw begin
  dw exit

; ?DO  ( -- orig dest )   postpone (?do) lv >mark dup to lv
;         postpone begin ;immediate

  hdr 1,'?DO',1,1
qdo:
  ld hl,paren_question_do
  jp do1

; I  ( -- x )

  hdr 1,'I'
i_:
  ld hl,(return_stack_pointer)
i_1:
  ld e,(hl)
  inc hl
  ld d,(hl)
i_2:
  inc hl
  ld a,(hl)
  inc hl
  ld h,(hl)
  ld l,a
  add hl,de
  push hl
  jp next

   if 0

; I'  ( -- x )

  hdr 1,"I'"
idot:
  ld hl,(return_stack_pointer)
  inc hl
  ld de,0
  jp i_2

   endif

; J  ( -- x )

  hdr 1,'J'
jdo:
  ld hl,(return_stack_pointer)
  ld de,cw*2
  add hl,de
  jp i_1

; LEAVE  ( -- )     postpone (leave) lv ?orig ,
;         ;immediate

  hdr 1,'LEAVE',1,1
leave:
  call do_colon
  dw compile,paren_leave
  dw lvv
  dw question_orig
  dw comma
  dw exit

; LOOP  ( addr1 addr2 -- )  postpone (loop) <resolve
;         postpone then to lv ;immediate

  hdr 1,'LOOP',1,1
loopp:
  ld hl,paren_loop
loopp1:
  push hl
  call do_colon
  dw comxt
  dw bresol
  dw then
  dw paren_to,lvv
  dw exit

; +LOOP  ( addr1 addr2 -- ) postpone (+loop) <resolve
;         postpone then to lv ;immediate

  hdr 1,'+LOOP',1,1
plus_loop:
  ld hl,paren_plus_loop
  jp loopp1

   if control_flow_stack_extensions

; CS-PICK       pick +bal

  hdr 1,'CS-PICK',,1
cs_pick:
  call do_colon
  dw pick
  dw pbal
  dw exit

; CS-ROLL       aka roll cs-roll

  hdr 1,'CS-ROLL',,,roll
csrol: equ roll

; CS-DROP       drop -bal

  hdr 1,'CS-DROP',,1
csdro:
  pop hl
  jp dbal

; cf0       control flow stack base

  hdr x,'CF0',,1
cfz:
  call do_create
cfz1:
  ds 2

; #cs  ( -- cells )   sp@ cf0 @ - negate 2/ 1- 0 max

  hdr x,'#CS',,1
ncs:
  ld hl,(cfz1)
  call negate_hl
  add hl,sp
  call negate_hl
  call sra_hl
  dec hl
  push hl
  jp zero_max

; CS-PUSH       #cs -roll

  hdr 1,'CS-PUSH',,1
cs_push:
  call do_colon
  dw ncs
  dw droll
  dw exit

; CS-POP        #cs roll

  hdr 1,'CS-POP',,1
cs_pop:
  call do_colon
  dw ncs
  dw roll
  dw exit

; CS-MARK       0 +bal

  hdr 1,'CS-MARK',,1
cs_mark:
  ld hl,0
  push hl
  jp pbal

; CS-TEST       ?depth dup 0<>

  hdr 1,'CS-TEST',,1
cs_test:
  call do_colon
  dw qdep
  dw dup
  dw zero_not_equals
  dw exit

; COND        ?comp cs-mark immediate

  hdr 1,'COND',1,1
cond:
  call do_colon
  dw qcomp
  dw cs_mark
  dw exit

; THENS       ?comp begin cs-test while postpone
;         then repeat cs-drop ;immediate

  hdr 1,'THENS',1,1
thens:
  call do_colon
  dw qcomp
thens1:
  dw cs_test
  dw question_branch,thens2
  dw then
  dw branch,thens1
thens2:
  dw csdro
  dw exit

   else

; COND        ?comp 0 +bal ;immediate

  hdr 1,'COND',1,1
cond:
  call do_colon
  dw qcomp
  dw zero
  dw pbal
  dw exit

; THENS       ?comp begin ?depth ?dup while
;         postpone then repeat -bal ;immediate

  hdr 1,'THENS',1,1
thens:
  call do_colon
  dw qcomp
thens1  dw qdep
  dw question_dup
  dw question_branch,thens2
  dw then
  dw branch,thens1
thens2  dw dbal
  dw exit

   endif

; Eaker/ANS CASE support
;
; N.B. OF may be used in the form:  COND .. OF .. ELSE .. THENS

; OF  ( -- addr )     postpone (of) >mark ;immediate

  hdr 1,'OF',1,1
of:
  call do_colon
  dw compile,paren_of
  dw to_mark
  dw exit

; ENDOF  ( addr1 -- addr2 ) aka else endof

  hdr 1,'ENDOF',1,,elsee
endof: equ elsee

; CASE  ( -- sys )    aka cond case

  hdr 1,'CASE',1,,cond
casee: equ cond

; ENDCASE  ( sys -- )   postpone drop postpone thens
;         ;immediate

  hdr 1,'ENDCASE',1,1
endc:
  call do_colon
  dw compile,drop
  dw thens
  dw exit

; [ELSE]  ( -- )    1 begin token 2dup upper dup if 2dup
;       s" [IF]" compare if 2dup s" [ELSE]"
;       compare if s" [THEN]" compare 0= else
;       2drop dup 1 = then else 2drop 1 then +
;       else 2drop refill and then ?dup 0= until
;       ;immediate

  hdr 1,'[ELSE]',1,1
pels:
  call do_colon
  dw one
pels1:
  dw token
   if ucase
  dw two_dup,upper
   endif
  dw dup
  dw question_branch,pels6
  dw two_dup
  dw paren_s_quot
  dcs '[IF]'
  dw compare
  dw question_branch,pels4
  dw two_dup
  dw paren_s_quot
  dcs '[ELSE]'
  dw compare
  dw question_branch,pels2
  dw paren_s_quot
  dcs '[THEN]'
  dw compare,zero_equals
  dw branch,pels3
pels2:
  dw two_drop
  dw dup,one,equals
pels3:
  dw branch,pels5
pels4:
  dw two_drop,one
pels5:
  dw plus
  dw branch,pels7
pels6:
  dw two_drop
  dw refill,and_
pels7:
  dw question_dup,zero_equals
  dw question_branch,pels1
  dw exit

; [IF]  ( flag -- ) 0= if [compile] [else] then ;immediate

  hdr 1,'[IF]',1,1  ; ANS
pif:
  pop hl
  ld a,l
  or h
  jp z,pels
  jp next

; [THEN]  ( -- )    aka noop [then] immediate

  hdr 1,'[THEN]',1,,noop
pthen: equ next

; }}} **********************************************************
; Numeric output {{{

; (D.)  ( d -- c-addr u )  tuck dabs <# #s rot sign #>

  hdr 1,'(D.)'
paren_d_dot:
  call do_colon
  dw tuck
  dw d_abs
  dw bdigs
  dw digs
  dw rot,sign
  dw edigs
  dw exit

; U.R  ( u1 u2 -- ) 0 swap d.r

  hdr 1,'U.R'
udotr:
  ld hl,0
  ex (sp),hl
  push hl
  jp d_dot_r ; XXX NEW -- because headers and code share the same zone

; XXX OLD -- DX-Forth 4.00
;;; D.R  ( d u -- )   >r (d.) r> over - spaces type
;;
;;  header 1,'D.R'
;;d_dot_r:
;;  call  do_colon
;;  dw to_r
;;  dw paren_d_dot
;;d_dot_r1:
;;  dw from_r
;;  dw over,minus
;;  dw spacs
;;  dw type
;;  dw exit

; XXX NEW -- DX-Forth 4.09
; D.R  ( d n -- )   >r (d.) r> s.r

  hdr 1,'D.R'
d_dot_r:
  call do_colon
  dw to_r
  dw paren_d_dot
d_dot_r1:
  dw from_r
  ; dw sdotr ; XXX FIXME -- not found
  dw exit

; .R  ( n u -- )    >r s>d r> d.r

  hdr 1,'.R'
dot_r:
  call do_colon
  dw to_r
  dw s_to_d
  dw from_r,d_dot_r
  dw exit

; U.  ( u -- )    0 d.

  hdr 1,'U.'
u_dot:
  ld hl,0
  push hl
  jp ddot ; XXX NEW -- because headers and code share the same zone

; D.  ( d -- )    0 d.r space

  hdr 1,'D.'
ddot:
  call do_colon
  dw zero,d_dot_r
  dw space
  dw exit

; XXX OLD -- DX-Forth 4.00
;;; ?  ( addr -- )    @ .
;;
;;  header 1,'?'
;;ques:
;;  call  do_colon
;;  dw fetch,dot
;;  dw exit

; XXX NEW -- DX-Forth 4.09
; ?  ( addr -- )

  hdr 1,'?'
ques:
  pop hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  jp dot

; XXX OLD -- DX-Forth 4.00
;;; .  ( n -- )   s>d d.
;;
;;  header 1,'.'
;;dot:
;;  call  do_colon
;;  dw s_to_d,ddot
;;  dw exit

; XXX NEW -- DX-Forth 4.09
; .  ( n -- )   decimal? if s>d d. exit then u.

  hdr 1,'.'
dot:
  call do_colon
;  dw dcmq ; XXX FIXME -- undefined
  dw question_branch,dot1
  dw s_to_d,ddot
  dw exit
dot1:
  dw u_dot
  dw exit

; }}} **********************************************************
; DOS functions {{{

;  FDOS  ( DE u -- HL A )

  hdr 1,'FDOS'
fdos:
  ; XXX OLD
;;  pop hl
;;  ld a,l
;;  pop de
;;  call bdoss
;;  push hl
;;  jp push_a
  ; XXX TODO
  jp next

;  BDOS  ( DE u -- A )

  hdr 1,'BDOS'
bdos:
  ; XXX TODO
  call do_colon
  ; XXX OLD
;;  dw fdos,nip
  dw exit

;  BIOS  ( BC u -- A )

  hdr 1,'BIOS'
bios:
  jp next
; XXX OLD
;;  pop  de
;;  ld a,e
;;  ld (biospb),a
;;  pop  hl
;;  ld (biospb+1),hl
;;  push  bc
;;  call  biosj
;;  pop  bc
;;  jp push_a

;  BIOSHL  ( DE BC u -- HL )

  hdr 1,'BIOSHL'
;biosh:
; XXX OLD
;;  pop  de
;;  ld a,e
;;  ld (biospb),a
;;  pop  hl
;;  ld (biospb+1),hl
;;  pop  hl
;;  ld (biospb+3),hl
;;  push  bc
;;  call  biosj
;;  pop  bc
;;  push hl
  jp next

;  PC@  ( p-addr -- x )

  hdr 1,'PC@'    ; FIG P@
p_c_fetch:
  pop hl
  ld a,l
  ld (p_c_fetch1),a
  in  a,(0)    ; modified
p_c_fetch1  equ  $-1
  jp push_a

;  PC!  ( x p-addr -- )

  hdr 1,'PC!'    ; FIG P!
p_c_store:
  pop hl
  pop de
  ld a,l
  ld (p_c_store1),a
  ld a,e
  out  (0),a    ; modified
p_c_store1  equ  $-1
  jp next

;  ?terminal  ( -- flag )

  hdr x,'?TERMINAL'
qterm:
  call do_colon
; XXX OLD
;;  dw zero,two
;;  dw bios
; XXX TODO
  dw exit

;  conin  ( -- char )
;
;       begin key? until 0 3 bios
;       (iofn+cw) @ over = if 0 bdos then

  hdr x,'CONIN'
conin:
  call do_colon    ; console input
conin1:
; XXX TODO
;;  dw key_question
;;  dw question_branch,conin1
;;  dw zero,three
;;  dw bios
;;  dw lit,iofn+cw  ; ctl-C check
;;  dw fetch
;;  dw over,equals
;;  dw question_branch,conin2
;;  dw zero,bdos  ; exit to CP/M
conin2:
  dw exit

dcono:
  call do_colon
  dw two
  dw bdos,drop
  dw exit

bcono:
  call do_colon
  ; XXX OLD
;;  dw c_lit
;;  db 4
;;  dw bios,drop
  ; XXX TODO
  dw exit

;  conout  ( char -- )

  hdr x,'CONOUT'
conout:
; XXX TODO
;;  pop  de
;;  ld a,e
;;  cp  ff
;;  jp z,cls
;;  push  de
;;  ld hl,(iofn)
;;  jp (hl)
  jp next

;  lstout  ( char -- )

  hdr x,'LSTOUT'
lstout:
  call do_colon
  dw c_lit
  db 5
  dw bios,drop
  dw exit

; XXX OLD
;;;  ZENV  ( -- addr )  return Z-System address (0=none)
;;
;;  header  1,'ZENV'
;;zenv:
;;  ld hl,(z3eadr)
;;  jp push_hl

; }}} **********************************************************
; Facility functions

; (MS)  ( ms -- )

  hdr x,'(MS)'
paren_ms:
  pop de
paren_ms1:
  ld a,e
  or d
  jp z,next
  ld hl,(speed)
  add hl,hl
  add hl,hl
  add hl,hl
paren_ms2:
  ex (sp),hl    ; 19T
  ex (sp),hl    ; 19T
  ex (sp),hl    ; 19T
  ex (sp),hl    ; 19T
  push hl    ; 11T
  pop hl    ; 10T
  dec  hl    ; 6T
  ld a,0    ; 7T
  ld a,l    ; 4T
  or h    ; 4T
  jp nz,paren_ms2    ; 10T
  dec  de
  jp paren_ms1

;  (BEEP)  ( -- )

  hdr x,'(BEEP)'
paren_beep:
  call do_colon
  ; XXX TODO
  dw exit

;  MS  ( ms -- )

  hdr 1,'MS'
ms:
  call fetch_execute
  dw paren_ms

;  SOUND  ( freq ms -- )
;
;  header  1,'SOUND'
;sound:  call  fetch_execute
;  dw sound0

;  BEEP  ( -- )

  hdr 1,'BEEP'
beep:
  call fetch_execute
  dw paren_beep

cpbuf:
  ds 16

;  AT-XY  ( u1 u2 -- )  position cursor at col u1, row u2

  hdr 1,'AT-XY'
atxy:
  ; XXX TODO
  jp next ; XXX TMP
;;  pop  de
;;  pop  hl
;;  ld d,l
;;  push  bc
;;  push  de
;;  ld hl,tgxy
;;  ld de,cpbuf
;;  ld a,16
;;  call  amovd
;;  pop  de
;;  ld a,(txpos)
;;  ld c,a
;;  ld a,(txofs)
;;  add  a,d
;;  push  de
;;  call  atxy3
;;  pop  de
;;  ld a,(typos)
;;  ld c,a
;;  ld a,(tyofs)
;;  add  a,e
;;  call  atxy3
;;  pop  bc
;;  ld de,tgxyd
;;  ld hl,cpbuf
;;atxy1:
;;  push  de
;;  push  hl
;;atxy2:
;;  call  do_colon
;;  dw count,tuck
;;  dw type    ; send string
;;  dw zero_not_equals
;;  dw swap,fetch
;;  dw and_,ms    ; delay only if string not empty
;;  dw exit
;;
;;atxy3:
;;  ld hl,cpbuf
;;  ld b,0
;;  add  hl,bc
;;  ex  de,hl
;;  ld hl,tisbin
;;  inc  (hl)
;;  dec  (hl)
;;  jp z,atxy4
;;  ld (de),a
;;  ret
;;
;;atxy4:
;;  dec  de
;;  dec  de
;;  ld hl,atxy8-1
;;  ld b,3
;;atxy5:
;;  inc  hl
;;  ld c,'0'-1
;;atxy6:
;;  inc  c
;;  sub  (hl)
;;  jp nc,atxy6
;;  add  a,(hl)
;;  push  af
;;  ld a,c
;;  cp  '0'
;;  jp z,atxy7
;;  ld (de),a
;;atxy7:
;;  inc  de
;;  pop  af
;;  dec  b
;;  jp nz,atxy5
;;  ret
;;
;;atxy8:
;;  db 100,10,1

; XXX NEW
;  CLS  ( -- )
  hdr 1,'CLS'
;  XXX TODO -- call it from 'PAGE'

cls:
  save_ip
  call rom_cl_all
  ld a,2
  call rom_chan_open
  jp restore_ip_next
; XXX OLD
;;  call  do_colon
;;  dw lit,tceold
;;  dw lit,thome
;;  dw atxy2
;;  dw lit,tclsd
;;  dw lit,tcls
;;  dw atxy2
;;  dw exit

;  NORMAL  ( -- )

  hdr 1,'NORMAL'
vnorm:
; XXX TODO
  jp next
;;  ld hl,tlovid
;;vnorm1:
;;  ld de,tceold
;;  jp atxy1

;  HIGHLIGHT  ( -- )

  hdr 1,'HIGHLIGHT'
hilit:
; XXX TODO
  jp next
;;  ld hl,thivid
;;  jp vnorm1

;  CLEAR-LINE  ( -- )

  hdr 1,'CLEAR-LINE'
cleol:
; XXX TODO
  jp next
;;  ld hl,tceol
;;  jp vnorm1

;  INSERT-LINE  ( -- )

  hdr 1,'INSERT-LINE'
insln:
; XXX TODO
  jp next
;;  ld hl,tinsln
;;insln1:
;;  ld de,tclsd
;;  jp atxy1

;  DELETE-LINE  ( -- )

  hdr 1,'DELETE-LINE'
delln:
; XXX TODO
  jp next
;;  ld hl,tdelln
;;  jp insln1

; XXX OLD
;;;  INIT-VIDEO  ( -- )
;;
;;  header  1,'INIT-VIDEO'
;;invid:  ld hl,tinit
;;  jp insln1
;;
;;;  EXIT-VIDEO  ( -- )
;;
;;  header  1,'EXIT-VIDEO'
;;exvid:  ld hl,texit
;;  jp insln1

; }}} **********************************************************
; Input/output functions

; PAUSE  ( -- )

  hdr 1,'PAUSE' ; multitasking support
pause:
  call fetch_execute
pause1: ; XXX TODO rename this label
  dw 0   ; patched by COLD

; KEY?  ( -- flag )

  hdr 1,'KEY?'
key_question:
  ld hl,0
  ld a,(sys_last_k)
  and a
  jp z,push_hl
  dec hl
  jp push_hl

; XXX OLD
;;  call do_colon
;;  dw lit,vkeyq   ; (vkeyq)
;;  dw fetch_execute       ; @execute
;;  dw pause       ; pause
;;  dw exit

; KEY  ( -- char )

  hdr 1,'KEY'
key:
  ld a,(sys_last_k)
  ld (previous_key),a
key1
  call pause
  ; call rom_keyboard ; XXX TODO not needed if system interrupts are on
  ld a,(sys_last_k)
previous_key equ $+1
  cp 0 ; a different key?
  jp z,key1
  ld l,a ; save the key
  xor a
  ld (sys_last_k),a ; delete the last key
  jp push_l

; XXX OLD
;;  call do_colon
;;  dw lit,vkey
;;  dw fetch_execute
;;  dw pause
;;  dw exit

;;; INKEY  ( -- char ) ; XXX OLD -- try
  
;;  hdr 1,'INKEY'
;;inkey:

  ; XXX OLD Unfinished convertion from Benschop's Forth-83:
;;  push de
;;  call rom_keyboard
;;  jp nz,no_inkey
;;  call rom_key_test
;;  jp nc,no_inkey
;;  ld c,0
;;  dec d
;;  call rom_key_decode
;;  pop de
;;  ; jr continue ; XXX in 'pkey'
;;no_inkey
;;  pop de
;;  ld hl,0
;;  push hl
;;  jp next

; XXX unfinished conversion from Boriel's ZX BASIC; moved to 'KEY'
;;  call rom_key_scan
;;  jp z,inkey
;;  call rom_key_test
;;  jp nc,inkey
;;  dec d   ; D is expected to be FLAGS so set bit 3 $FF
;;          ; 'L' Mode so no keywords
;;  ld e, a ; main key to A
;;          ; C is MODE 0 'KLC' from above still
;;  call rom_key_decode
;;  jp push_a

; SPACE  ( -- )   bl emit

  hdr 1,'SPACE'
space:
  ld a,32
  jp emit_a

; EMIT  ( char -- )
  ; XXX TODO make it defered
  hdr 1,'EMIT'
emit:
  pop hl
emit_l:
  ld a,l
emit_a:
  rst 0x10
  jp pause

; XXX OLD
;;;   (vemit) @execute 1 out +! pause
;;  call  do_colon
;;  dw lit,vemit
;;  dw fetch_execute
;;  dw one,outt,pstor
;;  dw pause
;;  dw exit

; TYPE  ( c-addr u -- )
; 0max 0 ?do count emit loop drop
; XXX TODO use ROM call instead
  hdr 1,'TYPE'
type:

; XXX OLD
;;  call do_colon
;;  dw zero_max,zero
;;  dw paren_question_do,type2
;;type1:
;;  dw count,emit
;;  dw paren_loop,type1
;;type2:
;;  dw drop
;;  dw exit

  save_ip
  call rom_chan_s ; set print to screen
  pop bc ; length
  pop de ; address
  call rom_print_string
restore_ip_next: equ $
saved_ip: equ $+1
  ld bc,0 ; restore IP
  jp next

; SPACES  ( +n -- ) 0max 0 ?do space loop

  ; XXX TODO in assembly
  hdr 1,'SPACES'
spacs:
  call do_colon
  dw zero_max,zero ; 0max 0
  dw paren_question_do,spacs2 ; ?do
spacs1:
  dw space
  dw paren_loop,spacs1 ; loop
spacs2:
  dw exit

; CR  ( -- )

  hdr 1,'CR'
cr:
  ; XXX TODO -- printer too? lf_char?
  ld a,cr_char
  jp emit_a

;  PAGE  ( -- )

  hdr 1,'PAGE'
page:
  ; XXX FIXME -- this is only for printer
  ld a,ff_char ; formfeed char
  jp emit_a

; CONSOLE  ( -- )   (vcon) @ (vemit) !
  ; set EMIT to terminal

  hdr 1,'CONSOLE'
console:
  ; XXX TODO
; XXX OLD
;;  ld hl,(vcon)
;;  ld (vemit),hl
  jp next

; PRINTER  ( -- )
  ; set EMIT to printer
  hdr 1,'PRINTER'
printer:
  ; XXX TODO
; XXX OLD
;;  ld hl,(vlst)
;;  ld (vemit),hl
  jp next

; }}} **********************************************************
; Compiler functions {{{

; wfind  ( c-addr wid -- 0 | xt nfa -1 | xt nfa 1 )

  hdr x,'WFIND',,1
wfind:
  call do_colon   ; save IP
  dw $+2
  pop hl
  ld a,l
  or h
  jp z,wfind2  ; wid=0
  ld e,(hl)
  inc hl
  ld d,(hl)
wfind1:
  pop hl    ; string
  push hl
  ld a,e   ; end of list?
  or d
  ex de,hl
  jp nz,wfind3
wfind2:
  pop de    ; discard string
  jp wfind6    ; no match

wfind3:
  push hl    ; save nfa
  ld c,(hl)
  ld a,c
  and 0x1f
  ld b,a   ; dict name length
  ld a,(de)    ; string length
  xor c   ; check lengths/smudge bit
  and 0x3f
  jp z,wfind5
  inc hl    ; to link
wfind4:
  inc hl
  dec b
  jp nz,wfind4
  ld e,(hl)    ; next nfa
  inc hl
  ld d,(hl)
  pop hl    ; discard old
  jp wfind1

wfind5:
  inc hl    ; check each char
  inc de
  ld a,(de)
   if ucase
  call uppercase_a
   endif
  ld c,a
  ld a,(hl)
   if ucase
  call uppercase_a
   endif
  xor c
  jp nz,wfind4 ; no match
  dec b
  jp nz,wfind5
  inc hl    ; to link
  inc hl    ; to cfa pointer
  inc hl
  ld e,(hl)    ; get xt
  inc hl
  ld d,(hl)
  pop hl    ; nfa
  pop bc    ; discard string
  push de
  push hl
  ld a,(hl)
  and 0x40   ; immediate?
  ld hl,-1
  jp z,wfind6
  inc hl
  inc hl
wfind6:
  push hl
  jp exit    ; restore IP

; (find)  ( c-addr -- c-addr 0 | xt -1 | xt 1 )
;       0 3 0 do over i cells context + @
;       wfind ?dup if nip 2nip leave then loop

  hdr x,'(FIND)',,1 ; searches CONTEXT CURRENT FORTH
paren_find:
  call do_colon
  dw zero
  dw three
  dw zero
  dw paren_do,paren_find3
paren_find1:
  dw over
  dw i_,cells
  dw cont,plus,fetch
  dw wfind,question_dup
  dw question_branch,paren_find2
  dw nip,tnip
  dw paren_leave,paren_find1-cw
paren_find2:
  dw paren_loop,paren_find1
paren_find3:
  dw exit

; FIND  ( c-addr -- c-addr 0 | xt -1 | xt 1 )

  hdr 1,'FIND',,1
find:
  call fetch_execute
  dw paren_find

   if 0

; SEARCH-WORDLIST  ( c-addr u wid -- 0 | xt -1 | xt 1 )
;       >r wpack r> wfind dup if nip then

  hdr 1,'SEARCH-WORDLIST',,1
search_wordlist:
  call do_colon
  dw to_r
  dw wpack
  dw from_r
  dw wfind
  dw dup
  dw question_branch,search_wordlist1
  dw nip
search_wordlist1:
  dw exit

   endif

   if warning_options

; -?  ( -- )    warning @ 0fffe and warning !

  hdr 1,'-?',,1 ; disable warnings for next definition only
dques:
  ld hl,warnn1
  ld a,(hl)
  and 0xfe    ; clear bit 0
  ld (hl),a
  jp next

; warning?  ( -- 0|1 )  warning @ dup if dup 1 and tuck if -1
;       else $7fff and 1 then or warning ! then

  hdr x,'WARNING?',,1 ; get warning flag and apply mask
qwarn:
  call do_colon
  dw warnn,fetch
  dw dup
  dw question_branch,qwarn3
  dw dup,one,and_ ; test bit 0
  dw tuck
  dw question_branch,qwarn1
  dw true    ; enable all warnings
  dw branch,qwarn2
qwarn1:
  dw lit,07fffh  ; disable compile warning
  dw and_
  dw one   ; enable redefinition warning
qwarn2:
  dw or_
  dw warnn,store
qwarn3:
  dw exit

   endif

; IMMEDIATE  ( -- ) $40 xnfa

  hdr 1,'IMMEDIATE',,1
immediate:
  ld e,0x40
  jp smudg1

; SMUDGE  ( -- )    $20 xnfa

  hdr 1,'SMUDGE',,1 ; FIG
smudg:
  ld e,0x20
smudg1:
  push de
; jp xnfa

; xnfa  ( x -- )    toggle nfa bit

xnfa:
  ld hl,(last1)
  jp ctog1

; header  ( xt|0 "name" -- )
;       warning? 2>r bl-word dup c@ 32 1 within
;       abort" invalid name" dup find nip r> and
;       if dup count type ."  is redefined "
;       then dup count tuck + get-current w>name
;       over ! cell+ swap 5 + dph @ over dph +!
;       dup get-current ! rot r> ?dup 0= if here
;       then dup rot ! over last 2! swap cmove

  hdr x,'HEADER',,1
header:
  call do_colon
   if warning_options
  dw qwarn
   else
  dw warnn,fetch
   endif
  dw two_to_r
  dw blword
  dw dup,c_fetch
  dw c_lit
  db 32
  dw one,within
  dw paren_abort_quote
  dcs 'invalid name'
  dw dup,find,nip
  dw from_r,and_
  dw question_branch,header1
  dw dup,count,type
  dw paren_dot_quote
  dcs ' is redefined '
header1:
  dw dup,count
  dw tuck
  dw plus
  dw getcur,wtnam
  dw over,store
  dw cell_plus,swap
  dw c_lit
  db 5
  dw plus
  dw dph,fetch
  dw over,dph,pstor
  dw dup
  dw getcur
  dw store   ; CP/M version
  dw rot
  dw from_r,question_dup,zero_equals
  dw question_branch,header2
  dw here
header2:
  dw dup,rot,store
  dw over,last,two_store
  dw swap,cmove
  dw exit

; ,call  ( addr -- )  $CD c, ,

  hdr x,',CALL',,1
comma_call:
  call do_colon
  dw c_lit
  db 0xcd    ; 'call' opcode
  dw c_comma
  dw comma
  dw exit

; BUIld ( xt "name" -- )  0 header ,call

  hdr 1,'BUILD',,1
build:
  call do_colon
  dw zero,header ; 0 header
  dw comma_call ; ,call
  dw exit

; :  ( -- )   (do_colon) build smudge bal off !csp
;       sp@ cf0 ! ]

  hdr 1,':',,1
colon:
  call do_colon
  dw lit,do_colon
  dw build
  dw smudg
colon1:
  dw bal,off
  dw scsp
   if control_flow_stack_extensions
  dw sp_fetch
  dw cfz,store
   endif
  dw right_bracket
  dw exit

; EXIT  ( -- )    postpone (exit) immediate

  hdr 1,'EXIT',1,1
exitt:
  call do_colon
  dw compile,exit
  dw exit

; ;  ( -- )   postpone exit bal @ ?bal ?csp smudge
;       postpone [ ;immediate

  hdr 1,';',1,1
semic:
  call do_colon
  dw exitt
  dw bal,fetch
  dw qbal
  dw qcsp
  dw smudg
  dw left_bracket
  dw exit

; :NONAME  ( -- xt )  warning? drop here dup (dnfa) last 2!
;       (do_colon) ,call bal off !csp sp@ cf0 ! ]

  hdr 1,':NONAME',,1
nonam:
  call do_colon
   if warning_options
  dw qwarn,drop  ; allow -?
   endif
  dw here
  dw dup    ; allow RECURSE etc
  dw lit,dnfa  ; allow IMMEDIATE etc
  dw last,two_store
  dw lit,do_colon
  dw comma_call
  dw branch,colon1

; (;CODE)     r> last cell+ @ 1+ !

  hdr 1,'(;CODE)',,1
pscod:
  ld hl,(last2)
  inc hl
  ld (hl),c
  inc hl
  ld (hl),b
  jp exit

; DOES>     postpone (;code) (do_colon) ,call ;immediate

  hdr 1,'DOES>',1,1
does:
  call do_colon
  dw compile,pscod
  dw lit,do_colon
  dw comma_call
  dw exit

; CREATE  ( -- addr ) 'next build

  hdr 1,'CREATE',,1
creat:
  ld hl,next
  push hl
  jp build

; VARIABLE  ( -- addr ) create 2 allot

  hdr 1,'VARIABLE',,1
var:
  call do_colon
  dw creat
  dw two,allot
  dw exit

; VALUE  ( -- x )   (dotcon) build ,

  hdr 1,'VALUE',,1
value:
  call do_colon
value1:
  dw lit,do_value
  dw build
  dw comma
  dw exit

; CONSTANT  ( -- x )  char? if (do_byte_constant) build c,
;       else value then

  hdr 1,'CONSTANT',,1
con:
  call do_colon
  dw char_question
  dw question_branch,value1
  dw lit,do_byte_constant
  dw build
  dw c_comma
  dw exit

; 2VARIABLE  ( -- addr )  create 4 allot

  hdr 1,'2VARIABLE',,1
two_variable:
  call do_colon
  dw creat
  dw c_lit
  db 4
  dw allot
  dw exit

dotvar: equ next

; 2CONSTANT  ( -- x2 x1 )  (dotcon) build , ,

  hdr 1,'2CONSTANT',,1
two_constant:
  call do_colon
  dw lit,dotcon
  dw build
  dw comma,comma
  dw exit

dotcon: equ two_fetch   ; 2@

; USER  ( -- addr ) (do_user_variable) build ,

  hdr 1,'USER',,1 ; FIG
user:
  call do_colon
  dw lit,do_user_variable
  dw build
  dw comma
  dw exit

; ADDR  ( -- addr ) ' >body state @ if postpone literal then
;       ;immediate

  hdr 1,'ADDR',1,1  ; state-smart
addr:
  call do_colon
  dw tick,tbody
  dw state_question
  dw question_branch,addr1
  dw literal
addr1:
  dw exit

; (to)  ( x -- )    r> dup cell+ >r @ >body !

  hdr x,'(TO)'
paren_to:
  ld a,(bc)
  ld l,a
  inc bc
  ld a,(bc)
  ld h,a
  inc bc
  inc hl
  inc hl
  inc hl
  jp store1

; TO      ' state? if postpone (to) , else >body !
;       then ;immediate

  hdr 1,'TO',1,1  ; state-smart
to:
  call do_colon
  dw tick
  dw state_question
  dw question_branch,to1
  dw compile,paren_to
  dw comma
  dw branch,to2
to1:
  dw tbody,store
to2:
  dw exit

undef:
  call do_colon
  dw one
  dw paren_abort_quote
  dcs 'uninitiated DEFER'

; DEFER  ( "name" -- )

  hdr 1,'DEFER',,1
defer:
  call do_colon
  dw lit,fetch_execute  ; ['] @execute
  dw build              ; build
  dw lit,undef,comma    ; undef ,
  dw exit

; IS  ( xt "name" -- )

  hdr 1,'IS',1,,to  ; state-smart
is: equ to

paren_is: equ paren_to

; AKA  ( "oldname" "newname" -- )  defined tuck ?defined (header)
;         $80 xnfa 0> if immediate then
; XXX TODO ' alias' too
  hdr 1,'AKA',,1
aka:
  call do_colon
  dw defined_
  dw tuck,qdef
  dw header   ; equivalent of
  dw c_lit    ; ALIAS ( xt "newname" -- )
  db 0x80   ;
  dw xnfa    ;
  dw zero_greater_than
  dw question_branch,aka1
  dw immediate
aka1:
  dw exit

; }}} **********************************************************
; Constants {{{

; TRUE

  hdr 1,'TRUE'
true:
  ld hl,-1
  push hl
  jp next

; FALSE

  hdr 1,'FALSE'
false:
  ld hl,0
  push hl
  jp next

; -1  ( -- -1 )   aka true -1

  hdr 1,'-1',,,true

; 0  ( -- 0 )   aka false 0

  hdr 1,'0',,,false
zero: equ false

; 1  ( -- 1 )

  hdr 1,'1'
one:
  call do_byte_constant
  db 1

; 2  ( -- 2 )

  hdr 1,'2'
two:
  call do_byte_constant
  db 2

; 3  ( -- 3 )

  hdr 1,'3'
three:
  call do_byte_constant
  db 3

; BL  ( -- 32 )   ascii value for space character

  hdr 1,'BL'
bl:
  call do_byte_constant
  db sp_char

; B/BUF  ( -- u )  bytes per screen buffer

  hdr 1,'B/BUF',,1  ; FIG
bbuf:
  call do_value
bbuf1:
  dw 128*8 ; default

; C/L  ( -- u )    chars per screen line

  hdr 1,'C/L',,1  ; FIG
csll:
  call do_value
  dw 64 ; default

; For applications, LIMIT is the upper limit of available memory.
; In forth, it is the beginning of the area which holds the screen file
; buffer, word headers and system definitions.

; LIMIT  ( -- addr )

  hdr 1,'LIMIT' ; FIG
limit:
  call do_value   ; application word - used by BUF
limit1:
  ds cw    ; patched by COLD

; hbuf  ( -- addr ) handle r/w buffer

  hdr x,'HBUF'
hbuf:
  call do_value
hbuf1:
  ds cw    ; patched by COLD

; 'NEXT  ( -- addr )  address of NEXT

  hdr 1,"'NEXT"
tnext:
  call do_constant
tnext1:
  dw next

; #FCB  ( -- u )    number of file handles

  hdr 1,'#FCB'
nfcb:
  call do_value
nfcb1:
  dw max_open_file_handles

; SYS-VEC  ( -- addr )  system vector table

; XXX -- This word is not used in DX-Forth.
; It appears only in <misc.fs>, but commented out.
; XXX TODO -- The useful values could be converted to variables.

  hdr 1,'SYS-VEC'
sysvec:
  call do_create

vkeyq:
  dw qterm   ;  0 KEY?
vkey:
  dw conin   ;  2 KEY
vemit:
  dw conout    ;  4 EMIT
vcon:
  dw conout    ;  6 CONSOLE out
vlst:
  dw lstout    ;  8 PRINTER out
ainit:
  dw do_f_init_patch   ; 10 FINIT patch
aident:
  dw do_f_identify_patch   ; 12 FIDENTIFY patch
afnumb:
  dw interpret12    ; 14 FNUMBER patch
nfps:
  dw f_stack_size   ; 16 floating point stack size (bytes)
anumb:
  dw interpret8   ; 18 NUMBER? patch
nfpm:
  dw f_stack_items*fw    ; 20 fp-stack min (bytes)
nrts:
  dw return_stack_size   ; 22 return stack (bytes)
nus:
  dw user_area_size    ; 24 user area (bytes)
npno:
  dw pictured_numeric_buffer_size   ; 26 HOLD buffer size (bytes)
;nmscon: ; XXX OLD
;  dw -2386   ; 28 MS timing constant 
;ntmode: ; XXX OLD
;  dw 3   ; 30 Timer 0 mode

; }}} **********************************************************
; Variables {{{

; UP  ( -- addr )   user area pointer

  hdr 1,'UP'
up:
  call do_constant
  dw user_area_pointer

; FSP  ( -- addr )  fp stack pointer

  hdr 1,'FSP'
fsp:
  call do_create
fspp:
  ds cw

; boot  ( -- addr ) boot word (holds forth/application xt)

  hdr x,'BOOT'
boot:
  call do_create
;;boot1: ; XXX OLD
boot_xt:
  dw 0   ; xt
;;boot2: ; XXX OLD
;;  dw 0   ; 0=forth ; XXX OLD

; SYS  ( -- addr )
; compile system or application

  hdr 1,'SYS'
sys:
  call do_create   ; application word - used by HERE, UNUSED
sys1:
  dw 0

; last  ( -- addr ) occupies 2 cells

  hdr x,'LAST',,1
last:
  call do_create
last1:
  dw top_nfa    ; latest nfa
last2:
  dw top_xt   ; latest xt

; BLK

  hdr 1,'BLK',,1
blk:
  call do_create
blk1:
  ds cw

; >IN

  hdr 1,'>IN',,1
in_:
  call do_create
in_1:
  ds cw

; SCR     occupies 2 cells

  hdr 1,'SCR',,1
scr:
  call do_create
  ds 2*cw

; STATE

  hdr 1,'STATE',,1
state:
  call do_create
state1:
  ds cw

; 'SOURCE     occupies 2 cells

  hdr 1,"'SOURCE",,1
tick_source:
  call do_create
tick_source1:
  ds 2*cw

; WARNING

  hdr 1,'WARNING',,1  ; FIG
warnn:
  call do_create
warnn1:
  ds cw

; CSP

  hdr 1,'CSP',,1  ; FIG
cspp:
  call do_create
cspp1:
  ds cw

; CHECKING

  hdr 1,'CHECKING',,1
check:
  call do_create
check1:
  ds cw

; errmsg  ( -- addr ) message holder for abort"

  hdr x,'ERRMSG'
errmsg:
  call do_create
errmsg1:
  ds 2*cw

; CONTEXT  ( -- addr )

  hdr 1,'CONTEXT',,1
cont:
  call do_create
acont:
  ds cw    ; context
acurr:
  ds cw    ; current
  dw forth1    ; forth

; get-context  ( -- wid )

  hdr x,'GET-CONTEXT',,1
getcon:
  ld hl,(acont)
  push hl
  jp next

; GET-CURRENT  ( -- wid )

  hdr 1,'GET-CURRENT',,1
getcur:
  ld hl,(acurr)
  push hl
  jp next

; SET-CURRENT  ( wid -- )

  hdr 1,'SET-CURRENT',,1
setcur:
  ld hl,acurr
  jp store1

; zbuf  ( -- addr ) filename buffer pointers

  hdr x,'ZBUF'
zbuf:
  call do_create
zbuf1:
  dw zb1 ; next buffer
  dw zb2 ; last buffer

; }}} **********************************************************
; User variables {{{

; user variables 0, 2, 4 reserved for future expansion

; S0

  hdr 1,'S0'    ; FIG
s0:
  call do_user_variable
  dw 6

; R0

  hdr 1,'R0'    ; FIG
r0:
  call do_user_variable
  dw 8

; DP      application dictionary pointer

  hdr 1,'DP'    ; FIG
dpp:
  call do_user_variable
  dw 10

; XXX OLD
;;; dph     system dictionary pointer
;;
;;  hdr x,'DPH',,1  ; must follow DP
;;dph:
;;  call do_user_variable
;;  dw 12
dph: equ dpp ; XXX NEW

; VOC-LINK

  hdr 1,'VOC-LINK',,1 ; FIG
vocl:
  call do_user_variable
  dw 14

; FS0

  hdr 1,'FS0'
fs0:
  call do_user_variable
  dw 16

; user variable 18 reserved for future expansion

; End of boot-up literals

; DPL

  hdr 1,'DPL'   ; FIG
dpl:
  call do_user_variable
  dw 20

; hld

  hdr x,'HLD'   ; FIG
hld:
  call do_user_variable
  dw 22

; BASE

  hdr 1,'BASE'
base:
  call do_user_variable
  dw 24

; bytes 26-27   reserved for locals

; OUT

  hdr 1,'OUT'   ; FIG
outt:
  call do_user_variable
  dw 28

; bytes 30-33   reserved

; CATCHER

  hdr 1,'CATCHER'
catcher:
  call do_user_variable
  dw 34

; bytes 36-43   reserved

; User area bytes 44 onwards are available for user applications

; }}} **********************************************************
; Forth system {{{

; sys?  ( -- flag ) sys@ 0<>

  hdr x,'SYS?'
sysq:
  ld hl,sys1
sysq1:
  ; XXX TODO -- maybe faster: use A, OR and write PUSH_A
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  jp zero_not_equals

; state?  ( -- flag ) state @ 0<>

  hdr x,'STATE?',,1
state_question:
  ld hl,state1
  jp sysq1

; check?  ( -- flag ) checking @ 0<>

  hdr x,'CHECK?',,1
chkq:
  ld hl,check1
  jp sysq1

; APPLICATION  ( -- ) sys off

  hdr 1,'APPLICATION',,1
app:
  ld hl,sys1
  jp off_hl

; SYSTEM  ( -- )    sys on

  hdr 1,'SYSTEM',,1
system:
  ld hl,sys1
  jp on_hl

; XXX OLD
;;; h  ( -- addr )    sys@ if dph else dp then
;;
;;  hdr x,'H'
;;hh:
;;  ld hl,(sys1)
;;  ld a,l
;;  or h
;;  jp z,dpp
;;  jp dph

; ALLOT  ( n -- )   here over 0max dup unused u>
;       abort" no data space" erase h +!

  hdr 1,'ALLOT'
allot:
  call do_colon
  dw here,over
  dw zero_max,dup
  dw unused,u_greater_than
  dw paren_abort_quote
  dcs 'no data space'
  dw erase
;;  dw hh,pstor ; XXX OLD
  dw dpp,pstor ; XXX NEW
  dw exit

; HERE  ( -- addr )

  hdr 1,'HERE'
here:
  call do_colon
;;  dw hh,fetch ; XXX OLD
  dw dpp,fetch ; XXX NEW
  dw exit

; C,  ( char -- )   here 1 allot c!

  hdr 1,'C,',,1
c_comma:
  call do_colon
  dw here
  dw one,allot
  dw c_store
  dw exit

; ,  ( n -- )   here 2 allot !

  hdr 1,',',,1
comma:
  call do_colon
  dw here
  dw two,allot
  dw store
  dw exit

; >BODY  ( xt -- addr ) 3 +

  hdr 1,'>BODY'
tbody:
  ld de,3
  jp plus_de

; BODY>  ( addr -- xt ) 3 -
;
; XXX -- this word was commented out in DX-Forth, why?
  hdr x,'BODY>'
fbody:
  ld de,-3
  jp plus_de

; XXX NEW -- DX-Forth 4.09
;  n>count  ( nfa -- h-addr len )  aka (name) n>count

  hdr x,'N>COUNT',,,pname
ncnt: equ  pname

; XXX OLD -- DX-Forth 4.00
;;; n>link  ( nfa -- lfa )
;;
;;  header x,'N>LINK',,1
;;nlnk:
;;  pop hl
;;  ld a,(hl)  ; name length and flags
;;  and 0x1f    ; name length only
;;  ld e,a
;;  ld d,0
;;  add hl,de
;;  inc hl
;;  jp push_hl

; XXX NEW -- DX-Forth 4.09
;  n>link  ( nfa -- lfa )    n>count +

  hdr x,'N>LINK',,1
nlnk:
  call do_colon
  dw ncnt,plus
  dw exit

; N>NAME  ( nfa1 -- nfa2 | 0 )

  hdr 1,'N>NAME',,1
ntnam:
  call do_colon
  dw nlnk,fetch  ; n>link @
  dw exit

; name>  ( nfa -- xt )

  hdr x,'NAME>',,1
namef:
  call do_colon
  dw nlnk,cell_plus,fetch ; n>link cell+ @
  dw exit

; W>NAME  ( wid -- nfa | 0 )  aka @ w>name

  hdr 1,'W>NAME',,,fetch
wtnam: equ fetch

; -alias  ( nfa -- nfa flag )  dup c@ $80 <

  hdr x,'-ALIAS',,1 ; false if alias
dalias:
  pop hl
  push hl
  ld a,(hl)
  cp 0x80
  jp zero_less_than2

; XXX OLD -- DX-Forth 4.00
;;; >name  ( xt -- nfa | 0 )
;;;       voc-link begin @ dup while tuck 2-
;;;       w>name begin ?dup while -alias if 2dup
;;;       name> = if -rot 2drop exit then then
;;;       n>name repeat swap repeat nip
;;
;;  header x,'>NAME',,1
;;to_name:
;;  call  do_colon
;;  dw vocl
;;to_name1:
;;  dw fetch
;;  dw dup
;;  dw question_branch,to_name5
;;  dw tuck
;;  dw two_minus
;;  dw wtnam
;;to_name2:
;;  dw question_dup
;;  dw question_branch,to_name4
;;  dw dalias    ; skip if alias
;;  dw question_branch,to_name3
;;  dw two_dup,namef
;;  dw equals
;;  dw question_branch,to_name3
;;  dw drot,two_drop
;;  dw exit
;;to_name3:
;;  dw ntnam
;;  dw branch,to_name2
;;to_name4:
;;  dw swap
;;  dw branch,to_name1
;;to_name5:
;;  dw nip
;;  dw exit    ; not found

; XXX NEW -- DX-Forth 4.09
;  >name  ( xt -- nfa | 0 )
;        voc-link begin @ dup while tuck cell- w>name
;        begin ?dup while -alias if 2dup name> = if
;        -rot 2drop exit then then n>name repeat swap
;        repeat nip

  hdr x,'>NAME',,1
to_name:
  call do_colon
  dw vocl
to_name1:
  dw fetch
  dw dup
  dw question_branch,to_name5
  dw tuck
  dw cell_minus
  dw wtnam
to_name2:
  dw question_dup
  dw question_branch,to_name4
  dw dalias    ; skip if alias
  dw question_branch,to_name3
  dw two_dup,namef
  dw equals
  dw question_branch,to_name3
  dw drot,two_drop
  dw exit
to_name3:
  dw ntnam
  dw branch,to_name2
to_name4:
  dw swap
  dw branch,to_name1
to_name5:
  dw nip
  dw exit    ; not found

; XXX OLD -- DX-Forth 4.00
;;; (NAME)  ( nfa -- c-addr u ) count 31 and
;;
;;  header 1,'(NAME)',,1
;;pname:
;;  call  do_colon
;;  dw count
;;  dw c_lit
;;  db 31
;;  dw and_
;;  dw exit

; XXX NEW -- DX-Forth 4.09
;  (NAME)  ( nfa -- c-addr u )  count 31 and

  hdr 1,'(NAME)',,1
pname:
  pop de
  ld a,(de)
  inc  de
  and 0x1f
  ld l,a
  ld h,0
  push de
  jp next

; .ID  ( nfa | 0 -- )   ?dup if (name) type exit then
;         ." [noname]"

  hdr 1,'.ID',,1
dotid:
  call do_colon
  dw question_dup
  dw question_branch,dotid1
  dw pname
  dw type
  dw exit
dotid1:
  dw paren_dot_quote
  dcs '[noname]'
  dw exit

; .NAME  ( xt -- )  >name .id

  hdr 1,'.NAME',,1
dotnam:
  call do_colon
  dw to_name,dotid
  dw exit

; .WID  ( wid -- )  cell+ cell+ @ .id
; XXX Renamed to '.VOC' in DX-Forth 4.09
  hdr 1,'.WID',,1
dotwid:
  call do_colon
  dw cell_plus,cell_plus
  dw fetch,dotid
  dw exit

; !CSP  ( -- )    sp@ csp !

  hdr 1,'!CSP',,1 ; FIG
scsp:
  ld hl,0
  add hl,sp
  ld (cspp1),hl
  jp next

; ?CSP  ( -- )    sp@ csp @ - ?bal

  hdr 1,'?CSP',,1 ; FIG
qcsp:
  call do_colon
  dw sp_fetch
  dw cspp,fetch
  dw minus
  dw qbal
  dw exit

; ?COMP  ( -- )   state? 0= abort" compilation only'

  hdr 1,'?COMP',,1  ; FIG
qcomp:
  call do_colon
  dw state,fetch
  dw zero_equals
  dw paren_abort_quote
  dcs 'compilation only'
  dw exit

; ?EXEC  ( -- )   state? abort" execution only'

  hdr 1,'?EXEC',,1  ; FIG
qexec:
  call do_colon
  dw state_question
  dw paren_abort_quote
  dcs 'execution only'
  dw exit

; ?STACK  ( -- )    sp@ s0 @ over u< swap pad u< or
;       abort" stack?" r0 @ rp@ u< rp@ fs0 @ u<
;       or abort" r-stack?" fs0 @ fsp @ u< fsp @
;       fs0 @ (nfpm) @ - u< or abort" f-stack?"

  hdr 1,'?STACK',,1 ; FIG
qstac:
  call do_colon
  dw sp_fetch
  dw s0,fetch
  dw over,u_less_than
  dw swap
  dw pad
  dw u_less_than
  dw or_
  dw paren_abort_quote
  dcs 'stack?'
  dw r0,fetch
  dw rp_fetch
  dw u_less_than
  dw rp_fetch
  dw fs0    ; = S0 if no float
  dw fetch
  dw u_less_than,or_
  dw paren_abort_quote
  dcs 'r-stack?'
; dw fs0,fetch
; dw fsp,fetch
; dw u_less_than
; dw fsp,fetch
; dw fs0,fetch
; dw lit,nfpm
; dw fetch
; dw minus
; dw u_less_than
; dw or_
; dw paren_abort_quote
; dcs 'f-stack?'
  dw exit

; ?defined  ( flag -- ) 0= abort" is undefined"

  hdr x,'?DEFINED',,1
qdef:
  call do_colon
  dw zero_equals
  dw paren_abort_quote
  dcs 'is undefined'
  dw exit

; [       state off ;immediate

  hdr 1,'[',1,1
left_bracket:
  ld hl,state1
  jp off_hl

; ]     state on

  hdr 1,']',,1
right_bracket:
  ld hl,state1 ; must be -1 for INTERPRET to work
  jp on_hl

; COMPILE,  ( xt -- ) warning @ 0< if dup limit u< sys? d0=
;       if dup .name ."  is system " then then ,

  hdr 1,'COMPILE,',,1
comxt:
  call do_colon
  dw warnn,fetch
   if warning_options
  dw zero_less_than
   endif
  dw question_branch,comxt1
  dw dup,limit
  dw u_less_than
  dw sysq
  dw d_zero_equals
  dw question_branch,comxt1
  dw dup
  dw dotnam
  dw paren_dot_quote
  dcs ' is system '
comxt1:
  dw comma
  dw exit

; COMPILE  ( -- )   ?comp r> dup cell+ >r @ compile,

  hdr 1,'COMPILE',,1
compile:
  call do_colon
  dw qcomp   ; prevent crash if interpreting
  dw from_r
  dw dup,cell_plus
  dw to_r
  dw fetch
  dw comxt
  dw exit

; POSTPONE    defined dup ?defined 0< if compile
;       compile then compile, ;immediate

  hdr 1,'POSTPONE',1,1
postp:
  call do_colon
  dw defined_
  dw dup,qdef
  dw zero_less_than
  dw question_branch,postp1
  dw compile,compile
postp1:
  dw comxt
  dw exit

; XXX OLD -- DX-Forth 4.00
;;; (ACCEPT)  ( c-addr +n1 -- +n2)
;;;       0 begin key dup >r dup bl 127 within 2over -
;;;       and if dup emit over 4 pick + c! 1+ else 2dup
;;;       dup 8 = swap esc = or and if esc = if 0 swap
;;;       else 1- 1 then begin 8 dup emit space emit 1-
;;;       dup 0= until then drop then r> 13 = until
;;;       -rot 2drop
;;
;;  header x,'(ACCEPT)'
;;pacce:
;;  call  do_colon
;;  dw zero
;;pacce1:
;;  dw key
;;  dw dup,to_r
;;  dw dup,bl  ; only accept chars between 32 and 126
;;  dw c_lit
;;  db 127
;;  dw within
;;  dw two_over,minus
;;  dw and_
;;  dw question_branch,pacce2
;;  dw dup,emit
;;  dw over
;;  dw c_lit
;;  db 4
;;  dw pick
;;  dw plus
;;  dw c_store
;;  dw one_plus
;;  dw branch,pacce6
;;pacce2:
;;  dw two_dup
;;  dw dup
;;  dw c_lit
;;  db bs_char    ; backspace?
;;  dw equals,swap
;;  dw c_lit
;;  db esc_char    ; escape?
;;  dw equals,or_
;;  dw and_
;;  dw question_branch,pacce5
;;  dw c_lit
;;  db esc_char    ; escape?
;;  dw equals
;;  dw question_branch,pacce3
;;  dw zero,swap
;;  dw branch,pacce4
;;pacce3:
;;  dw one_minus,one
;;pacce4:
;;  dw c_lit
;;  db bs_char
;;  dw dup,emit
;;  dw space,emit
;;  dw one_minus
;;  dw dup,zero_equals
;;  dw question_branch,pacce4
;;pacce5:
;;  dw drop
;;pacce6:
;;  dw from_r
;;  dw c_lit
;;  db cr_char
;;  dw equals
;;  dw question_branch,pacce1
;;  dw drot,two_drop
;;  dw exit

; XXX NEW -- DX-Forth 4.09 -- modified
;  (ACCEPT)  ( c-addr +n1 -- +n2)
;        0 begin key dup >r dup bl 127 within 2over -
;        and if dup emit over 4 pick + c! 1+ else 2dup
;        dup bs_char = swap esc = or and if esc = if
;        0 swap else 1- 1 then begin 8 dup emit space
;        emit 1- dup 0= until then drop then r> 13 =
;        until -rot 2drop

  hdr x,'(ACCEPT)'
pacce:
  call do_colon
  dw zero
pacce1:
  dw key
  dw dup,to_r
  dw dup,bl  ; only accept chars between 32 and 126
  dw c_lit
  db 127
  dw within
  dw two_over,minus
  dw and_
  dw question_branch,pacce2
  dw dup,emit
  dw over
  dw c_lit
  db 4
  dw pick
  dw plus
  dw c_store
  dw one_plus
  dw branch,pacce6
pacce2:
  dw two_dup
  dw dup
  dw lit,bs_char,equals
  dw swap
  dw c_lit
  db esc_char    ; escape?
  dw equals,or_
  dw and_
  dw question_branch,pacce5
  dw c_lit
  db esc_char    ; escape?
  dw equals
  dw question_branch,pacce3
  dw zero,swap
  dw branch,pacce4
pacce3:
  dw one_minus,one
pacce4:
  dw c_lit
  db bs_char
  dw dup,emit
  dw space,emit
  dw one_minus
  dw dup,zero_equals
  dw question_branch,pacce4
pacce5:
  dw drop
pacce6:
  dw from_r
  dw c_lit
  db cr_char
  dw equals
  dw question_branch,pacce1
  dw drot,two_drop
  dw exit

; ACCEPT  ( c-addr +n1 -- +n2)

  hdr 1,'ACCEPT'
accept:
  call fetch_execute
  dw pacce

; PAD  ( -- addr )  dp @ (npno) @ +

  hdr 1,'PAD'
pad:
  call do_colon
  dw dpp,fetch
  dw lit,npno
  dw fetch
  dw plus
  dw exit

; SOURCE  ( -- c-addr u )   'source 2@

  hdr 1,'SOURCE',,1
source:
  ld hl,tick_source1
  jp two_fetch1

; PARSE  ( char -- c-addr u ) 0 (parse)

  hdr 1,'PARSE',,1
parse:
  ld hl,0
  push hl
  jp paren_parse ; XXX NEW -- because headers and code share the same zone

; (parse)  ( char f -- c-addr u ) 2>r source >in @ /string r> if tuck
;         r@ skip over - >in +! then 2dup r>
;         scan nip tuck - dup rot 0<> - >in +!

  hdr 0,'(PARSE)',,1
paren_parse:
  call do_colon
  dw two_to_r
  dw source
  dw in_,fetch,sstr
  dw from_r
  dw question_branch,paren_parse1
  dw tuck
  dw r_fetch,skip
  dw rot,over,minus
  dw in_,pstor
paren_parse1:
  dw two_dup
  dw from_r
  dw scan,nip
  dw tuck
  dw minus,dup
  dw rot,zero_not_equals
  dw minus
  dw in_,pstor
  dw exit

; +psb  ( a1 n1 n2 -- n3 )  >r (parsed_string_buffer_size) r@ - umin r> 2dup + >r
;         (parsed_string_buffer) + swap cmove r>

  hdr x,'+PSB',,1
ppsb:
  call do_colon
  dw to_r
  dw lit,parsed_string_buffer_size
  dw r_fetch,minus
  dw u_min
  dw from_r
  dw two_dup,plus
  dw to_r
  dw lit,parsed_string_buffer
  dw plus
  dw swap
  dw cmove
  dw from_r
  dw exit

; PARSE$  ( char "ccc" -- a n ) 0 begin >r dup parse 2dup r> +psb >r
;         1+ + dup source + u< while 2dup c@ =
;         while 1 dup >in +! r> +psb repeat
;         then 2drop (parsed_string_buffer) r>

  hdr 1,'PARSE$',,1
parss:
  call do_colon
  dw zero
parss1:
  dw to_r
  dw dup,parse
  dw two_dup
  dw from_r,ppsb
  dw to_r
  dw one_plus,plus
  dw dup
  dw source,plus
  dw u_less_than
  dw question_branch,parss2
  dw two_dup,c_fetch
  dw equals
  dw question_branch,parss2
  dw one,dup
  dw in_,pstor
  dw from_r,ppsb
  dw branch,parss1
parss2:
  dw two_drop
  dw lit,parsed_string_buffer
  dw from_r
  dw exit

; pwa  ( -- adr )   parsed word address

  hdr x,'PWA',,1
pwa:
  call do_value
  ds cw

; XXX OLD -- DX-Forth 4.00
;;; >wbuf  ( c-addr1 +n -- c-addr2 )
;;;       255 min (hm-5) over - dup to pwa place pwa
;;;       bl affix
;;
;;  header x,'>WBUF',,1  ; uses WORD's buffer
;;twbuf:
;;  call  do_colon
;;  dw c_lit
;;  db 255
;;  dw min
;;   if retro
;;  dw dpp,fetch
;;   else
;;  dw lit,hm-5
;;  dw over,minus
;;   endif
;;  dw dup
;;  dw paren_to,pwa
;;  dw place
;;  dw pwa
;;  dw bl   ; trailing blank
;;  dw affix
;;  dw exit
;;
;;; WORD  ( char -- c-addr )  true (parse) >wbuf
;;
;;  header 1,'WORD',,1
;;word:
;;  call  do_colon
;;  dw true,paren_parse
;;  dw twbuf
;;  dw exit
;;
;;; bl-word  ( -- addr )  bl word
;;
;;  header x,'BL-WORD',,1
;;blword:
;;  call  do_colon
;;  dw bl,word
;;  dw exit

; XXX NEW -- DX-Forth 4.09
;  wpack  ( c-addr1 +n -- c-addr2 )
;        255 min (hm-5) over - dup to pwa packed
;        bl affix

  hdr x,'WPACK',,1  ; pack string in WORD's buffer
wpack:
  call do_colon
  dw c_lit
  db 255
  dw min
   if  retro
  dw dpp,fetch
   else
  dw lit,hm-5
  dw over,minus
   endif
  dw dup
  dw paren_to,pwa
  dw packd
  dw bl,affix  ; trailing blank
  dw exit

;  WORD  ( char -- c-addr )  true (parse) wpack

  hdr 1,'WORD',,1
word:
  call do_colon
  dw true,paren_parse
  dw wpack
  dw exit

;  bl-word  ( -- c-addr )  bl word

  hdr x,'BL-WORD',,1
blword:
  ld hl,0x20
  push hl
  jp word

; token  ( -- c-addr u )  bl-word count

  hdr 1,'TOKEN',,1
token:
  call do_colon
  dw blword,count
  dw exit

; defined  ( -- c-addr 0 | xt -1 | xt 1 ) bl-word find

  hdr x,'DEFINED',,1
defined_:
  call do_colon
  dw blword,find
  dw exit

; '  ( -- addr )    defined ?defined

  hdr 1,"'",,1
tick:
  call do_colon
  dw defined_
  dw qdef
  dw exit

; [UNDEFINED]  ( -- flag )  defined nip 0= ;immediate

  hdr 1,'[UNDEFINED]',1,1
budef:
  call do_colon
  dw defined_
  dw nip
  dw zero_equals
  dw exit

; [DEFINED]  ( -- flag )  postpone [undefined] 0= ;immediate

  hdr 1,'[DEFINED]',1,1
bdef:
  call do_colon
  dw budef,zero_equals
  dw exit

; (  ( "ccc<delim>" ) [char] ) parse 2drop ;immediate

  hdr 1,'(',1,1
paren:
  call do_colon
  dw c_lit
  db ')'
  dw parse,two_drop
  dw exit

; .(  ( "ccc<delim>" )  [char] ) parse$ type ;immediate

  hdr 1,'.(',1,1
dotp:
  call do_colon
  dw c_lit
  db ')'
  dw parss,type
  dw exit

; \  ( "ccc" -- )   source nip blk @ if c/l >in @ over / 1+ *
;       min then >in ! ;immediate

  hdr 1,'\',1,1
bslas:
  call do_colon
  dw source,nip
  dw blk,fetch
  dw question_branch,bslas1
  dw csll
  dw in_,fetch
  dw over,slash
  dw one_plus,star
  dw min
bslas1:
  dw in_,store
  dw exit

; \\  ( "ccc" -- )  source nip >in ! ;immediate

  hdr 1,'\\',1,1
bslss:
  call do_colon
  dw source,nip
  dw in_,store
  dw exit

; XXX NEW -- DX-Forth 4.09
;  LINK,  ( a -- )    here over @ , swap !

  hdr 1,'LINK,',,1
linkc:
  call do_colon
  dw here
  dw over,fetch
  dw comma
  dw swap,store
  dw exit

; XXX OLD -- DX-Forth 4.00
;;; WORDLIST  ( -- wid )  $2001 , here 0 , here dup voc-link @ , !
;;;       0 ,
;;
;;  header 0,'WORDLIST',,1 ; nameless wordlists not supported
;;wlist:
;;  call  do_colon
;;  dw lit,0x2001
;;  dw comma
;;  dw here
;;  dw zero    ; nfa of top word in vocabulary
;;  dw comma
;;  dw here,vocl
;;  dw dup,fetch   ; link to previous vocabulary
;;  dw comma
;;  dw store
;;  dw zero,comma  ; null name
;;  dw exit

; XXX NEW -- DX-Forth 4.09
;  WORDLIST  ( -- wid )  $2001 , here 0 , voc-link link, 0 ,

  hdr x,'WORDLIST',,1
wlist:
  call do_colon
  dw lit,2001h
  dw comma
  dw here
  dw zero    ; nfa of top word in vocabulary
  dw comma
  dw vocl,linkc  ; link in wordlist
  dw zero,comma  ; null name
  dw exit

; VOCABULARY  ( "name" )
;       sys? system wordlist
;       ;;  create dup ,  ;; XXX OLD -- DX-Forth 4.00
;       dup value  ;; XXX NEW -- DX-Forth 4.09
;       last @
;       swap cell+ cell+ ! sys ! does> @ context !

  hdr 1,'VOCABULARY',,1
vocabulary:
  call do_colon
  dw sysq
  dw system
  dw wlist
;;  dw creat,dup,comma ; XXX OLD -- DX-Forth 4.00
  dw dup,value ; XXX NEW -- DX-Forth 4.09
  dw last,fetch   ; set name field in wordlist struct
  dw swap
  dw cell_plus,cell_plus
  dw store
  dw sys,store
  dw pscod
do_vocabulary:
  call do_colon
  dw fetch
  dw cont,store
  dw exit

; DEFINITIONS  ( -- ) get-context set-current

  hdr 1,'DEFINITIONS',,1
defin:
  call do_colon
  dw getcon
  dw setcur
  dw exit

; wordlist structure

forth3  defl  previous_nfa

  dw 0x2001    ; dummy nfa for vocabulary chaining
forth1:
  dw top_nfa    ; nfa of top word in vocabulary
forth2:
  dw 0   ; previous vocabulary
  dw forth3    ; vocabulary nfa

; FORTH     vocabulary forth

  hdr 1,'FORTH',,1
forth:
  call do_vocabulary
  dw forth1

; UNUSED  ( -- u )
;
;   sys? if (esm) @ else sp@ then here
;   255 + 2dup u> -rot - and

  hdr 1,'UNUSED'
unused:
  call do_colon
  dw sysq
  dw question_branch,unused1
  dw lit,esm
  dw fetch
  dw branch,unused2
unused1:
  dw sp_fetch
unused2:
  dw here
  dw c_lit    ; allow margin
  db 255
  dw plus
  dw two_dup
  dw u_greater_than
  dw drot
  dw minus
  dw and_
  dw exit

; INTERPRET  ( -- ) begin bl-word dup c@ while find ?dup if
;       state? = if compile, else execute then
;       else count base @ >r over c@ case [char] $
;       of hex 1 endof [char] # of decimal 1 endof
;       0 swap endcase /string 2dup number? if
;       2nip dpl @ 0< if drop state? if
;       postpone literal then else state? if
;       postpone 2literal then then true else
;       fnumber then r> base ! ?defined then ?stack
;       repeat drop

  hdr 1,'INTERPRET',,1
interpret:
  call do_colon
interpret1:
  dw blword
  dw dup,c_fetch
  dw question_branch,interpret15  ; while not end of input stream
  dw find
  dw question_dup
  dw question_branch,interpret4 ; if found
  dw state_question
  dw equals
  dw question_branch,interpret2 ; if compiling and not immediate
  dw comxt
  dw branch,interpret3
interpret2:
  dw execute
interpret3:
  dw branch,interpret14
interpret4:
  dw count
  dw base,fetch,to_r
  dw over,c_fetch
  dw c_lit
  db '$'
  dw paren_of,interpret5
  dw hex,one
  dw branch,interpret7
interpret5:
  dw c_lit
  db '#'
  dw paren_of,interpret6
  dw decimal,one
  dw branch,interpret7
interpret6:
  dw zero,swap
  dw drop
interpret7:
  dw sstr
  dw two_dup
interpret8:
  dw numq    ; NUMBER? patch
  dw question_branch,interpret12
  dw tnip
  dw dpl,fetch,zero_less_than
  dw question_branch,interpret10
  dw drop
  dw state_question
  dw question_branch,interpret9
  dw literal
interpret9:
  dw branch,interpret11
interpret10:
  dw state_question
  dw question_branch,interpret11
  dw two_literal
interpret11:
  dw true
  dw branch,interpret13
interpret12:
  dw f_number_patch
interpret13:
  dw from_r,base,store
  dw qdef
interpret14:
  dw qstac
  dw branch,interpret1
interpret15:
  dw drop
  dw exit

; (eval)  ( c-addr u blk -- ) blk @ >in @ 2>r source 2>r blk !
;         'source 2! >in off interpret 2r>
;         'source 2! 2r> >in ! blk !

  hdr x,'(EVAL)',,1   ; does not restore block contents
peval:
  call do_colon
  dw blk,fetch
  dw in_,fetch
  dw two_to_r
  dw source,two_to_r
  dw blk,store
  dw tick_source,two_store
  dw in_,off     ; reset >IN
  dw interpret
  dw two_from_r,tick_source,two_store
  dw two_from_r
  dw in_,store
  dw blk,store
  dw exit

; ?BLOCK   ( -- )     blk @ ?dup if block drop then

  hdr x,'?BLOCK',,1   ; reload block
qblock:
  call do_colon
  dw blk,fetch,question_dup
  dw question_branch,qblock1
  dw block,drop
qblock1:
  dw exit

; EVALUATE  ( c-addr u -- ) 0 (eval) ?block

  hdr 1,'EVALUATE',,1
eval:
  call do_colon
  dw zero,peval
  dw qblock
  dw exit

; (refill)  ( -- flag )
;       blk @ ?dup if 1+ dup #screens u< and dup
;       while dup blk ! block b/buf else (tib)
;       dup 80 accept space then 'source 2! >in
;       off true then

  hdr x,'(REFILL)',,1   ; doesn't correctly handle source
paren_refill:
  call do_colon     ; from EVALUATE
   if debug
  dw paren_dot_quote
  dcs '(REFILL) '
   endif
  dw blk,fetch,question_dup
  dw question_branch,paren_refill1
  dw one_plus,dup
  dw nscr,u_less_than
  dw and_,dup
  dw question_branch,paren_refill3
  dw dup,blk,store
  dw block,bbuf
  dw branch,paren_refill2
paren_refill1:
  dw lit,tib
  dw dup
  dw c_lit
  db 80
  dw accept
  dw space
paren_refill2:
  dw tick_source,two_store
  dw in_,off
  dw true
paren_refill3:
  dw exit

; REFILL  ( -- flag )

  hdr 1,'REFILL',,1
refill:
  call fetch_execute
  dw paren_refill

; reset  ( -- )   catcher off -caps console

  hdr x,'RESET'
reset:
  call do_colon
  dw catcher,off   ; reset error handler
  dw dcaps        ; reset COMPARE/SEARCH caps
  dw console      ; set EMIT vector
  dw exit

; /interpret  ( -- )  blk off >in off postpone [

  hdr x,'/INTERPRET',,1
slash_interpret:
  ld hl,0
  ld (blk1),hl
  ld (in_1),hl
  jp left_bracket

; forth-reset  ( -- )
;       0 set-limit empty warning on checking
;       on (fdbs) (file_descriptor_size*nfd) erase empty-buffers
;       /interpret 'source off bl-word drop

  hdr x,'FORTH-RESET',,1
forth_reset:
  call do_colon
; XXX TODO
; XXX OLD
;;  dw zero
;;  dw setlim
;;  dw empty   ; reset vocabulary pointers
;;  dw warnn,on  ; enable warnings
;;  dw check,on  ; enable checking
;;  dw lit,fdbs  ; clear files
;;  dw lit,file_descriptor_size*nfd ;
;;  dw erase   ;
;;  dw empty_buffers   ; mark screen buffer as empty
;;  dw slash_interpret   ; reset interpreter
;;  dw tick_source,off  ; clear parsed word buffer
;;  dw blword,drop ;
  dw exit

; QUIT  ( -- )

  hdr 1,'QUIT',,1
quit:
  call do_colon
quit1:
  dw r0,fetch,rp_store      ; r0 @ rp!
  dw reset                  ; reset
;** dw vnorm ; XXX OLD
  dw slash_interpret        ; /interpret
   if debug
  dw paren_dot_quote
  dcs 'QUIT '
   endif
quit2:                          ; begin
  ; XXX FIXME move 'cr' to 'if'?
  dw cr,paren_refill,drop       ;   cr  (refill) drop
  dw interpret                  ;   interpret
  dw state_question,zero_equals ;   state? 0=
  dw question_branch,quit3      ;   if
  dw paren_dot_quote            ;     ."  ok" 
  dcs ' ok'
quit3:                          ;   then
  dw branch,quit2               ; again

; RETURN  ( u -- )
; Exit to BASIC with return code u.
; The return code is used as line number for disk operations.

  hdr 1,'RETURN'
return:
  ; XXX TODO restore stack, etc.
  pop bc
  ret

; BYE  ( -- )
; Exit to the BASIC command line.

  hdr 1,'BYE',,1
bye:
  ; XXX TODO restore the stack, etc.
  im 1
  rst 0x08     ; error
  db 0xff      ; 0: "OK"

if 0
  ; XXX TODO -- Code from Benschop's ZX Spectrum Forth-83
  ld sp,(sys_err_sp) 
  pop bc
  ld bc,0x1303 
  push bc
  im 1
  ld (IY+31),2 ; update sys_e_line
  rst 0x08     ; error
  db 0xff      ; error 0: OK
endif

; boot?  ( -- bootword )  (iboot) @

  ; XXX TODO -- convert this into a variable that holds an xt
  hdr x,'BOOT?'
bootq:
  ld hl,(iboot)
  push hl
  jp next

; (abort)  ( -- )   s0 @ sp! fs0 @ fsp ! boot? if 1 return then
;       quit

  hdr x,'(ABORT)'
pabor:
  call do_colon
  dw s0,fetch
  dw sp_store
  dw fs0,fetch
  dw fsp,store
  dw bootq
   if debug
  dw question_branch,pabor1
  dw one
  dw return
pabor1  dw paren_dot_quote
  dcs ' (ABORT) '
  dw quit
   else
  dw question_branch,quit1
  dw one
  dw return
   endif

; .error  ( -- )
;       cr blk @ ?dup if file? and if filename type
;       >in @ 2- 0max blk @ 2dup scr 2! ."  Scr "
;       u. c/l / ." Line " . cr then then ." Error: "
;       [char] " dup emit pwa count 31 min type emit

  hdr x,'.ERROR',,1
doterr:
  call do_colon
  dw cr
  dw blk,fetch
  dw question_dup
  dw question_branch,doterr1
  dw gcfile_question
  dw and_    ; screen file open and loading from block?
  dw question_branch,doterr1
  dw loadfile,type
  dw in_,fetch
  dw two_minus    ; adjust pointer
  dw zero_max
  dw blk,fetch
  dw two_dup    ; set error block, offset
  dw scr,two_store
  dw paren_dot_quote
  dcs ' Screen '
  dw u_dot
  dw csll
  dw slash
  dw paren_dot_quote
  dcs 'Line '
  dw dot
  dw cr
doterr1:
  dw paren_dot_quote
  dcs 'Error: '
  dw c_lit
  db '"'
  dw dup,emit
  dw pwa,count
  dw c_lit
  db 31
  dw min
  dw type
  dw emit
  dw exit

; error  ( n -- )
;       -1 of (abort) then
;       -2 of boot cell+ @ 0=
;       if .error then space errmsg 2@ type (abort) then
;       ."  exception = " . (abort)

  hdr x,'ERROR'
error:
  call do_colon
  dw true    ; -1
  dw paren_of,error1
  dw pabor
error1:
  dw lit,-2
  dw paren_of,error3
  dw boot,cell_plus,fetch
  dw zero_equals
  dw question_branch,error2
  dw doterr    ; skipped by applications
error2:
  dw space
  dw errmsg,two_fetch
  dw type
  dw pabor
error3:
  dw paren_dot_quote
  dcs ' exception = '
  dw dot
  dw pabor
  dw exit

; CATCH  ( xt -- n | 0 )  sp@ >r fsp @ >r catcher @ >r rp@ catcher
;       ! execute r> catcher ! 2r> 2drop 0

  hdr 1,'CATCH'
catch:
  call do_colon
  dw sp_fetch,to_r
  dw fsp,fetch
  dw to_r
  dw catcher,fetch,to_r
  dw rp_fetch,catcher,store
  dw execute
  dw from_r,catcher,store
  dw two_from_r,two_drop
  dw zero
  dw exit

; THROW  ( n -- )   ?dup if catcher @ ?dup 0= if error then rp!
;       r> catcher ! r> fsp ! r> swap >r sp! drop
;       r> then

  hdr 1,'THROW'
throw:
  call do_colon
  dw question_dup
  dw question_branch,throw2
  dw catcher,fetch
   if debug
  dw paren_dot_quote
  dcs ' THROW:'
  dw over,dot
  dw paren_dot_quote
  dcs 'CATCHER:'
  dw dup,u_dot,space,space
   endif
  dw question_dup,zero_equals
  dw question_branch,throw1
  dw error
throw1:
  dw rp_store
  dw from_r,catcher,store
  dw from_r,fsp,store
  dw from_r,swap,to_r
  dw sp_store
  dw drop,from_r
throw2:
  dw exit

; ABORT  ( -- )   -1 throw

  hdr 1,'ABORT'
abort:
  ld hl,-1
abort1:
  push hl
  jp throw

; (abort")  ( n -- )  r> count rot if errmsg 2! -2 throw then +
;       >r

  hdr x,'(ABORT")'
paren_abort_quote:
  call do_colon
  dw from_r,count
  dw rot
  dw question_branch,paren_abort_quote_1
  dw errmsg
  dw two_store
  dw lit,-2
  dw throw
paren_abort_quote_1:
  dw plus,to_r
  dw exit

; ABORT"      postpone (abort") ," ;immediate

  hdr 1,'ABORT"',1,1
abort_quote:
  call do_colon
  dw compile,paren_abort_quote
  dw comq
  dw exit

; XXX OLD -- DX-Forth 4.00
;;; CMDTAIL  ( -- c-addr u )  (dosbuf) count
;;
;;  header 1,'CMDTAIL'
;;cmdtail:ld de,dosbuf
;;  jp count1
;;; XXX OLD -- DX-Forth 4.09
;;;  CMDTAIL  ( -- c-addr u )  (dosbuf) count bl skip -trailing
;;
;;  hdr  1,'CMDTAIL'
;;cmdtail:call  do_colon
;;  dw c_lit
;;  db dosbuf
;;  dw count
;;  dw bl,skip
;;  dw dtrai
;;  dw exit

; Cold boot

;nodos  db 'wrong DOS version',cr_char,lf_char,'$'
;noram:  db 'not enough RAM'
crlf:  db cr_char,lf_char,'$' ; XXX TMP 

cold_boot:
  ; XXX TODO
  jp cold ; XXX TMP
; XXX OLD
;;  call  get_current_drive      ; save default drive and user
;;  ld (defdrv),a
;;  call  get_current_user
;;  ld (defusr),a
;;
;;  ld hl,(z3eadr)   ; test for ZSYSTEM
;;  push  hl
;;  ld de,27
;;  add hl,de
;;  ld e,(hl)
;;  inc hl
;;  ld d,(hl)
;;  pop hl
;;  call  hl_minus_de_to_hl
;;  ld hl,0
;;  jp z,cldd1
;;  ld (z3eadr),hl   ; not present or invalid z3eadr
;;
;;cldd1:
;;  ld (stack),hl    ; hl=0
;;
;;  ld a,(noboot)    ; test noboot flag
;;  or  a
;;  ld a,(0x0005+2)   ; bdos base
;;  jp z,cldd2
;;
;;  add hl,sp     ; save old stack
;;  ld (stack),hl
;;  sub 8     ; skip over CCP
;;
;;cldd2:
;;  ld sp,tmp_stack
;;  ld h,a
;;  ld l,0
;;  ld (esm),hl    ; patch end of memory value
;;  ex  de,hl
;;
;;  ld hl,(boot1)    ; get BOOT word
;;  ld (iboot),hl    ; save it
;;  ld a,h
;;  or  l
;;  ld l,a
;;  ld a,(boot2)
;;  and l
;;  jp z,cldd3     ; need forth system
;;
;;  ld hl,noop
;;  ld (cold1),hl
;;  ld hl,(ulimit)
;;  ld a,l
;;  or  h
;;  jp nz,cldd6
;;  ex  de,hl
;;  jp cldd6
;;
;;cldd3:
;;  dec a     ; set command line flag
;;  ld (cmdf),a
;;
;;  ld hl,(idph)   ; move system segment into place
;;  ld de,hm
;; XXX Some changes here in DX-Forth 4.09
;;  call  hl_minus_de_to_hl
;;cldd4:
;;  ld b,0     ; later patched to LD B,H
;;cldd5:
;;  ld c,0     ; later patched to LD C,L
;;  ld hl,(idp)
;;  call  bmovu
;;  ld de,sm
;;
;;cldd6:
;;  ex  de,hl
;;  ld (limit1),hl   ; patch LIMIT
;;
;;  db 0xc3      ; 'jmp'
;;cldd7:
;;  dw movpat      ; later patched to 'cold'

; BOOTMESSAGE  ( -- )

; XXX NEW -- after Gforth
; XXX TODO -- defered

bootmessage:
  call do_colon
  dw paren_dot_quote
  dcs "DZX-Forth "
  dw paren_dot_quote
  version
  dw paren_dot_quote
  dcs cr_char,"Copyright (C) 2014 Marcos Cruz"
  dw paren_dot_quote
  dcs cr_char,"(programandala.net)"
  dw paren_dot_quote
  dcs cr_char,"Type 'bye' to exit.",cr_char
  dw exit

; COLD ( -- )

  hdr 1,'COLD'    ; FIG
cold:
; XXX TODO
; XXX OLD
;;  ld sp,tmp_stack
;;  ld hl,(limit1)   ; get LIMIT
;;  ld de,-recsiz    ; file r/w buffer size
;;  add hl,de
;;  ld (hbuf1),hl    ; patch HBUF
;;  push  hl
;;  ld hl,(nfcb1)    ; #fcb
;;  ld de,-file_handle_size    ; handle size
;;  call  hl_by_de_to_hlde_unsigned
;;  pop hl
;;  add hl,de
;;  ex  de,hl
;;  ld hl,(nus)    ; user area size
;;  call  de_minus_hl_to_hl
;;  ld (user_area_pointer),hl    ; patch UP
;;  ld (ir0),hl    ; patch R0
;;  ld (return_stack_pointer),hl    ; patch RP
;;  ex  de,hl
;;  ld hl,(nrts)   ; return stack size
;;  call  de_minus_hl_to_hl
;;  ld (fspp),hl   ; init fp stack
;;  ld (ifs0),hl   ; patch FS0
;;; XXX These lines were commented out in the original source:
;;; ex  de,hl
;;; ld hl,(nfps)   ; fp stack size
;;; call  de_minus_hl_to_hl
;;  ld sp,hl     ; set cpu stack pointer
;;  ld (is0),hl    ; patch S0
;;   if control_flow_stack_extensions
;;  ld (cfz1),hl   ; init CF0 with safe value
;;   endif
;;  ld hl,(user_area_pointer)    ; init boot up variables
;;  ex  de,hl
;;  ld hl,initu
;;  ld bc,initu2-initu
;;  call  bmovu

;  ld a,3
;  ld (sys_bordcr),a
;  out (254),a

  ld hl,0      ; patch 'pause'
  ld (pause1),hl
  xor a
  ld (sys_last_k),a ; delete the last key; XXX needed by 'key?'?

; XXX OLD
;;  ld de,dosbuf   ; reset DOS DTA
;;  ld c,26
;;  call  0x0005

  ; XXX TEST -- it works:
;;  call rom_chan_s ; set print to screen
;;  ld bc,9 ; length
;;  ld de,tmpmsg ; address
;;  call rom_print_string
;;  jr tmp
;;tmpmsg:
;;  db "DZX-Forth"
;;tmp:

  ; XXX TEST -- it works:
;;  ld bc,9 ; length
;;  ld de,tmpmsg ; address
;;  push de
;;  push bc
;;  call rom_chan_s ; set print to screen
;;  pop bc
;;  pop de
;;  call rom_print_string
;;  jr tmp
;;tmpmsg:
;;  db "DZX-Forth"
;;tmp:

  call do_colon
;;  dw zfh     ; reset handles
;;  dw sys,off     ; default is APPLICATION

; ----------------------- XXX TMP -- for testing
;  dw noop
;  dw lit,2
;  dw border
;  dw decimal     ; default base

  ; XXX TEST -- it works:
;  dw lit,-10
;  dw return

  ; XXX TEST -- it works:
;  dw paren_dot_quote
;  dcs 'DZX-Forth'

  dw cls
  dw bootmessage

  ; XXX TEST -- it works:
;  dw lit,sys_last_k
;  dw c_fetch
;  dw return

  ; XXX TEST -- it works:
;;  dw c_lit
;;  db '"'
;;  dw emit
;;  dw key
;;  dw emit
;;  dw c_lit
;;  db '"'
;;  dw emit
;;  dw lit,2
;;  dw return
  
  dw bye  ; XXX works


  ; XXX NEW
;  dw cls
;  dw bootmessage
;forever:
;  dw branch,forever ; XXX INFORMER
; -----------------------


;;  dw reset     ; general reset
cold1:
;;  dw forth_reset
do_f_init_patch:
  dw f_init_patch
;;  dw bootq
;;  dw dup,boot,store     ; restore BOOT
;;  dw question_dup
;;  dw question_branch,cold3
;;  dw execute      ; run application
  dw zero,return  ; exit to DOS

cold3:
; XXX OLD >>>>>>>>>>>>>>>>>>>>>>>> command line parameter
;;  dw cmdtail     ; process command-line
;;  dw lit,cmdf
;;  dw c_fetch,and_
;;  dw tuck
;;  dw lit,tib     ; copy to tib
;;  dw zero,pstr
;;  dw tick_source,two_store
;;  dw question_branch,cold5
;;  dw zero
;;  dw lit,cmdf    ; disable
;;  dw c_store
;;  dw blword      ; parse first word
;;  dw fetch
;;  dw lit
;;  db 1,'-'     ; skips file open
;;  dw minus
;;  dw question_branch,cold4
;;  dw in_,off
;;  dw getfilename,popen
; XXX OLD <<<<<<<<<<<<<<<<<<<<<<<<

;;cold4:
;;  dw interpret      ; interpret
;;cold5:
;;;;  dw invid     ; terminal init sequence ; XXX OLD
;;  dw cr,page
;;  dw paren_dot_quote
;;  db cold8-$-1
;;cold6:
;;  db 'DZX-Forth '
;;  version
;;cold7:
;;cold8:
;;;;  dw lit,termn   ; show terminal name ; XXX OLD
;;;;  dw count,type
;;  dw paren_dot_quote
;;  db do_f_identify_patch-$-1
;;  db cr_char,lf_char
do_f_identify_patch:
  dw f_identify_patch
;;  dw cr
;;  dw gcfile_question
;;  dw question_branch,cold10
;;  dw cr
;;  dw paren_dot_quote
;;  dcs 'Using '
;;  dw loadfile,type
;;  dw cr
;;cold10:
;;  dw quit      ; jump to interpreter

; XXX OLD 
;;; SET-LIMIT  ( addr -- )  $fff0 and (ulimit) !
;;
;;  hdr  1,'SET-LIMIT',,1
;;setlim:
;;  pop hl
;;  ld a,l
;;  and 0x00f0
;;  ld l,a
;;  ld (ulimit),hl
;;  jp next

; }}} **********************************************************
; Dictionary support {{{

;  FREEZE  ( -- )    up @ (initu) (initu2-initu) cmove

  hdr 1,'FREEZE',,1
freez:
  call do_colon
  dw up,fetch
  dw lit,initu
  dw lit,initu2-initu
  dw cmove
  dw exit

;  'prune      variable 'prune  'prune off

  hdr x,"'PRUNE",,1
tprun:
  call do_create
  dw toppru    ; 0=end

;  REMEMBER  ( xt -- )  'prune link, ,

  hdr 1,'REMEMBER',,1  ; add xt to prunes
remem:
  call do_colon
  dw tprun,linkc
  dw comma
  dw exit

;  xdp  ( adr -- adr xdp )  dup limit u< if dp else dph then

  hdr x,'XDP',,1
xdp:
  pop de
  push de
  ld hl,limit1
  ex de,hl
  call compare_de_hl_unsigned
  jp nc,dph
  jp dpp

;  prunes  ( -- )    begin 'prune @ dup while dup xdp @ u< 0=
;        while 2@ 'prune ! execute repeat then drop

  hdr x,'PRUNES',,1
pruns:
  call do_colon
pruns1:
  dw tprun,fetch
  dw dup
  dw question_branch,pruns2
  dw dup
  dw xdp,fetch
  dw u_less_than,zero_equals
  dw question_branch,pruns2
  dw two_fetch
  dw tprun,store
  dw execute
  dw branch,pruns1
pruns2:
  dw drop
  dw exit

;  ?protected ( h-addr -- h-addr )  (idph) @ over u> check? and
;          abort" is protected"

  hdr x,'?PROTECTED',,1
qprot:
  call do_colon
  dw lit,idph
  dw fetch
  dw over,u_greater_than
  dw chkq,and_
  dw paren_abort_quote
  dcs 'is protected'
  dw exit

;  name? ( "name" -- xt nfa )  bl-word get-context wfind ?defined
;          ?protected

  hdr x,'NAME?',,1  ; find name in context wordlist
nameq:
  call do_colon
  dw blword
  dw getcon
  dw wfind,qdef
  dw qprot
  dw exit

;  lfind  ( wid nfa -- lfa |0 )  swap begin 2dup @ - while @
;          dup while n>link repeat then nip

  hdr x,'LFIND',,1  ; find link field containing nfa, 0=none
lfind:
  call do_colon
  dw swap
lfind1:
  dw two_dup,fetch
  dw minus
  dw question_branch,lfind2
  dw fetch,dup
  dw question_branch,lfind2
  dw nlnk
  dw branch,lfind1
lfind2:
  dw nip
  dw exit

;  BEHEAD  ( "name1" "name2" -- )  name? nip name? nip 2dup u< if swap
;          then n>name get-context rot lfind !

  hdr 1,'BEHEAD',,1  ; unlink word heads
behead:
  call do_colon
  dw nameq,nip
  dw nameq,nip
  dw two_dup,u_less_than
  dw question_branch,behead1
  dw swap
behead1:
  dw ntnam
  dw getcon
  dw rot,lfind
  dw store
  dw exit

;  ?voc  ( flag -- )    abort" invalid vocabulary"

  hdr x,'?VOC',,1
qvoc:
  call do_colon
        dw paren_abort_quote
        dcs  'invalid vocabulary'
        dw exit

;  CHAIN   ( "name" -- )    get-current postpone addr @ 2dup =
;          ?voc cell- $2001 over @ - ?voc
;          2dup lfind ?voc swap 0 lfind
;          ?protected 2dup u> ?voc !

  hdr 1,'CHAIN',,1
chain:
  call do_colon
  dw getcur
  dw addr,fetch
  dw two_dup,equals  ; same wordlist
  dw qvoc
  dw cell_minus
  dw lit,2001h
  dw over,fetch,minus  ; not a wordlist
  dw qvoc
  dw two_dup,lfind  ; already chained
  dw qvoc
  dw swap
  dw zero,lfind
  dw qprot
  dw two_dup,u_greater_than  ; forward reference
  dw qvoc
  dw store
  dw exit

;  (forget)  ( nfa dp -- )  dp ! >r voc-link begin @ dup cell+ @ r@
;        u< until dup voc-link ! begin dup cell-
;        dup @ begin dup r@ u< 0= while -alias if
;        dup name> dp @ umin dp ! then n>name
;        repeat swap ! @ ?dup 0= until r> dup dp
;        cell+ ! (idph) @ u< if freeze then prunes

  hdr x,'(FORGET)',,1
pforg:
  call do_colon
  dw dpp,store  ; starting maximums
  dw to_r
  dw vocl    ; trim vocs > nfa
pforg1:
  dw fetch
  dw dup,cell_plus,fetch
  dw r_fetch,u_less_than
  dw question_branch,pforg1
  dw dup,vocl,store
pforg2:
  dw dup,cell_minus  ; scan remaining vocs
  dw dup
  dw fetch
pforg3:
  dw dup,r_fetch  ; for each word >= nfa
  dw u_less_than,zero_equals
  dw question_branch,pforg5
  dw dalias    ; not an alias
  dw question_branch,pforg4
  dw dup,namef  ; get its xt
  dw dpp,fetch
  dw u_min,dpp,store  ; trim dict
pforg4:
  dw ntnam
  dw branch,pforg3
pforg5:
  dw swap,store
  dw fetch
  dw question_dup,zero_equals
  dw question_branch,pforg2  ; until all vocs done
  dw from_r
  dw dup,dpp
  dw cell_plus,store
  dw lit,idph  ; below fence?
  dw fetch,u_less_than
  dw question_branch,pforg6
  dw freez    ; fix bootup values
pforg6:
  dw pruns    ; run prunes chain
  dw exit

;  EMPTY  ( -- )    forth definitions (idp) 2@ (forget)

  hdr 1,'EMPTY',,1
empty:
  call do_colon
  dw forth,defin  ; switch to a safe vocabulary
  dw lit,idp
  dw two_fetch
  dw pforg
  dw exit

;  FORGET  ( "name" -- )  get-current context ! name? -alias 0=
;        abort" is alias" swap limit over u> if
;        drop dp @ then (forget)

  hdr 1,'FORGET',,1
forg:
  call do_colon
  dw getcur
  dw cont,store
  dw nameq
  dw dalias,zero_equals  ; alias?
  dw paren_abort_quote
  dcs 'is alias'
  dw swap
  dw limit
  dw over,u_less_than
  dw question_branch,forg1
  dw drop
  dw dpp,fetch
forg1:
  dw pforg
  dw exit

;  MARKER  ( "name" -- )  sys? system create sys !

  hdr 1,'MARKER',,1
marker:
  call do_colon
  dw sysq
  dw system
  dw creat
  dw sys,store
  dw exit

; }}} **********************************************************
; XXX {{{

; S,  ( c-addr u -- )
; 255 min 0max here over 1+ allot place

  hdr x,'S,',,1
s_comma:
  call do_colon
  dw c_lit
  db 255
  dw min
  dw zero_max
  dw here,over
  dw one_plus,allot
  dw place
  dw exit

; ,"  ( "ccc" -- )  [char] " parse$ s,

  hdr 1,',"',,1
comq:
  call do_colon
  dw c_lit
  db '"'
  dw parss
  dw s_comma
  dw exit

; XXX OLD -- DX-Forth 4.00
;;; (s")  ( -- c-addr u ) r> count 2dup + >r
;;
;;  header x,'(S")'
;;paren_s_quot:
;;  call  do_colon
;;  dw from_r,count
;;  dw two_dup,plus,to_r
;;  dw exit

; XXX NEW -- DX-Forth 4.09
; (s")  ( -- c-addr u ) r> count 2dup + >r

  hdr x,'(S")'
paren_s_quot:
  ld a,(bc)
  ld l,a
  ld h,0
  inc bc
  push bc
  push hl
  add hl,bc
  ld c,l
  ld b,h
  jp next

; SLITERAL  ( c-addr u -- )  postpone (s") s, ;immediate

  hdr 1,'SLITERAL',1,1
s_literal:
  call do_colon
  dw compile,paren_s_quot
  dw s_comma
  dw exit

; S"  ( -- c-addr u ) [char] " parse$ state? if postpone sliteral
;       then ;immediate

  hdr 1,'S"',1,1  ; state-smart
s_quote:
  call do_colon
  dw c_lit
  db '"'
  dw parss
  dw state_question
  dw question_branch,s_quote1
  dw s_literal
s_quote1:
  dw exit

; XXX OLD -- DX-Forth 4.00
;;; (.")      r> count 2dup + >r type
;;
;;  header x,'(.")'
;;paren_dot_quote:
;;  call  do_colon
;;  dw from_r,count
;;  dw two_dup,plus,to_r
;;  dw type
;;  dw exit

; XXX NEW -- DX-Forth 4.09
; (.")      r> count 2dup + >r type

  hdr x,'(.")'
paren_dot_quote:
  ld a,(bc)  ; length of the string
  ld h,0
  ld l,a
  inc bc      ; address of the first char
  push bc     ; address
  push hl     ; length
  add hl,bc   ; calculate the new IP
  ld b,h
  ld c,l      ; update the IP
  jp type

; ."      compile (.") ," ;immediate

  hdr 1,'."',1,1
dot_quote:
  call do_colon
  dw compile,paren_dot_quote
  dw comq
  dw exit

; CHAR?  ( x -- x flag )

  hdr x,'CHAR?',,1
char_question:
  pop hl
  push hl
  ld l,h
  jp zero_equals_hl

; LITERAL  ( n -- ) char? if postpone c_lit c, exit then
;       postpone lit , ;immediate

  hdr 1,'LITERAL',1,1
literal:
  call do_colon
  dw char_question
  dw question_branch,literal1
  dw compile,c_lit
  dw c_comma
  dw exit
literal1:
  dw compile,lit
  dw comma
  dw exit

; 2LITERAL  ( d -- )  postpone 2lit , , ;immediate

  hdr 1,'2LITERAL',1,1
two_literal:
  call do_colon
  dw compile,two_lit
  dw comma,comma
  dw exit

; [']     ' [compile] literal  ;immediate

  hdr 1,"[']",1,1
bracket_tick:
  call do_colon
  dw tick
  dw literal
  dw exit

; [COMPILE]   ' compile,  ;immediate

  hdr 1,'[COMPILE]',1,1
bracket_compile:
  call do_colon
  dw tick
  dw comxt
  dw exit

; RECURSE  ( -- )   last cell+ @ compile, ;immediate

  hdr 1,'RECURSE',1,1
recurse:
  ld hl,(last2)
  push hl
  jp comxt

; CHAR  ( -- char ) bl word 1+ c@

  hdr 1,'CHAR',,1
char:
  call do_colon
  dw bl,word
  dw one_plus,c_fetch
  dw exit

; [CHAR]  ( -- char ) char [compile] literal

  hdr 1,'[CHAR]',1,1
bracket_char:
  call do_colon
  dw char
  dw literal
  dw exit

; Y/N  ( -- flag )  ." (y/n) N\bs" key upcase [char] Y = dup
;       if [char] Y else [char] N then emit space

  hdr 1,'Y/N'
yn:
  call do_colon
  dw paren_dot_quote
  dcs '(y/n) N',bs_char
  dw key,upcas
  dw c_lit
  db 'Y'
  dw equals,dup
  dw question_branch,yn1
  dw c_lit
  db 'Y'
  dw branch,yn2
yn1:
  dw c_lit
  db 'N'
yn2:
  dw emit,space
  dw exit

; CHAR+  ( c-addr1 -- c-addr2 ) aka 1+ char+

  hdr 1,'CHAR+',,,one_plus
char_plus: equ one_plus

; CHARS  ( n1 -- n2 )   aka noop chars immediate

  hdr 1,'CHARS',1,,noop
chars: equ next

; CELL+  ( addr1 -- addr2 ) aka 2+ cell+

  hdr 1,'CELL+',,,two_plus
cell_plus: equ two_plus

; CELL-  ( addr1 -- addr2 ) aka 2- cell-

  hdr 1,'CELL-',,,two_minus
cell_minus: equ two_minus

; CELLS  ( n1 -- n2 )   aka 2* cells

  hdr 1,'CELLS',,,tstar
cells: equ tstar

; ALIGN  ( -- )     aka noop align immediate

  hdr 1,'ALIGN',1,,noop
align: equ next

; ALIGNED  ( addr -- a-addr ) aka noop aligned immediate

  hdr 1,'ALIGNED',1,,noop
aligned: equ next

; DZX-FORTH  ( -- minor major )

  hdr 1,'DZX-FORTH'
dzx_forth:
; XXX OLD
;;  ld hl,(dxver)
;;  jp dosver1
; XXX TODO
  jp next

; }}} **********************************************************
; Files {{{

;  RESET-DISKS  ( -- )

  hdr 1,'RESET-DISKS'
reset_disks:
  ld a,25
  call bdoss
  push af
  ld a,13
  call bdoss
  pop af
  ld e,a
  ld a,14
  call bdoss
  jp next

;  >DRIVE  ( u1 -- u2 )  ?dup if 1- else 0 25 bdos then

  hdr 1,'>DRIVE'
to_drive:
  pop de
  ld a,e
  dec  a
  call m,get_current_drive
  jp push_a

;  PATH  ( u1 -- c-addr u2 ior )
;        255 32 bdos 0 <# [char] : hold #s rot >drive
;        [char] A + hold #> 0

  hdr 1,'PATH'  ; uses numeric buffer
path:
  call do_colon
  dw c_lit
  db 255
  dw c_lit
  db 32
  dw bdos
  dw zero,bdigs
  dw c_lit
  db ':'
  dw hold
  dw digs
  dw rot,to_drive
  dw c_lit
  db 'A'
  dw plus
  dw hold,edigs
  dw zero
  dw exit

;  -PATH  ( addr1 u1 -- addr2 u2 )
;        2dup [char] : scan dup if 1 /string 2swap
;        then 2drop

  hdr 1,'-PATH'
dpath:
  call do_colon
  dw two_dup
  dw c_lit
  db ':'
  dw scan,dup
  dw question_branch,dpath1
  dw one,sstr
  dw tswap
dpath1:
  dw two_drop
  dw exit

;  filetype?  ( addr1 u1 -- u2 )  -path [char] . scan nip

  hdr x,'FILETYPE?'  ; get filetype length
filetype_question:
  call do_colon
  dw dpath
  dw c_lit
  db '.'
  dw scan,nip
  dw exit

;  +EXT  ( addr1 u1 addr2 u2 -- addr3 u3 )
;        2over filetype? if 2drop exit then 3 min
;        s" ." 2rot -trailing (filename_size-5) min zbuf
;        @ 1+ 0 +string +string +string

  hdr 1,'+EXT'  ; uses filename buffer
plus_ext:
  call do_colon
  dw two_over,filetype_question
  dw question_branch,plus_ext1
  dw two_drop,exit
plus_ext1:
  dw three,min
  dw paren_s_quot
  dcs '.'
  dw trot
  dw dtrai    ; trim trailing blanks
  dw c_lit
  db filename_size-5
  dw min
  dw zbuf,fetch    ; unused
  dw one_plus
  dw zero
  dw pstr
  dw pstr
  dw pstr
  dw exit

;  -EXT  ( addr1 u1 -- addr2 u2 )  2dup filetype? -

  hdr 1,'-EXT'
minus_ext:
  call do_colon
  dw two_dup,filetype_question
  dw minus
  dw exit

;  SETFCB  ( addr u fcb-addr -- user# )

  hdr 1,'SETFCB'
sfcb:
  call get_current_user    ; current user
  ld (sfcb10+1),a
  call get_current_drive    ; current drive
  inc  a
  pop de
  ld (de),a
  ld (sfcb5+1),a
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
  ex de,hl
  jp sfcb2

sfcb1:
  inc  de
  dec  c
sfcb2:
  call sfcb12    ; skip blanks
  cp ' '
  jp z,sfcb1

  push de
  push bc
  cp '9'+1    ; user number
  jp c,sfcb3
  sub  'A'-1    ; drive A-P
  jp c,sfcb6
  cp 16+1
  jp nc,sfcb6
  ld (sfcb5+1),a
  call sfcb11
  cp ':'
  jp z,sfcb5

sfcb3:
  ld b,0
sfcb4:
  sub  '0'
  jp c,sfcb6
  cp 9+1
  jp nc,sfcb6
  push bc
  ld c,a
  ld a,b
  add a,a
  add a,a
  add a,b
  add a,a
  add a,c
  pop bc
  ld b,a
  call sfcb11
  cp ':'
  jp nz,sfcb4

  ld a,b
  cp 31+1    ; user 0-31
  jp nc,sfcb6
  ld (sfcb10+1),a

sfcb5:
  ld (hl),0    ; modified
  pop af
  pop af
  call sfcb11
  jp sfcb7

sfcb6:
  pop bc    ; not du:
  pop de
sfcb7:
  ld b,8
  call sfcb15

  cp '.'
  jp z,sfcb8
  ld c,1
sfcb8:
  inc  de
  dec  c

  ld b,3
  call sfcb15

  ld b,21    ; clear EX..CR fields
sfcb9:
  inc  hl
  ld (hl),0
  dec  b
  jp nz,sfcb9

  pop bc
sfcb10:
  ld a,0    ; modified
  jp push_a

sfcb11:
  inc  de    ; get next
  dec  c
sfcb12:
  inc  c    ; get char
  dec  c
  ld a,c
  ret  z
  ld a,(de)
  call uppercase_a
  and a
  ret

sfcb13:
  call sfcb12    ; test delimiter
  cp ' '+1
  jp c,sfcb14
  cp ','
  ret  z
  cp '_'
;  ret  z
  jp nc,sfcb14
  cp '.'
  ret  z
  cp ':'
  ret  c
  cp '>'
  ret  nc
sfcb14:
  cp a
  ret

sfcb15:
  call sfcb13    ; fill field
  jp z,sfcb19
  inc  hl
  cp '*'
  jp nz,sfcb16
  ld (hl),'?'
  jp sfcb17

sfcb16:
  ld (hl),a
  inc  de
  dec  c
sfcb17:
  dec  b
  jp nz,sfcb15

sfcb18:
  call sfcb13    ; scan delimiter
  ret  z
  inc  de
  dec  c
  jp sfcb18

sfcb19:
  inc  hl
  ld (hl),' '
  dec  b
  jp nz,sfcb19
  ret

old_user:
  db 255    ; 255 = ignore

;  GETUSR  ( -- u )  get user

  hdr 1,'GETUSR'
getusr:
  call get_current_user
  jp push_a

;  SETUSR  ( u -- )  set user

  hdr 1,'SETUSR'
setusr:
  call get_current_user
  ld (old_user),a  ; save current user
  pop hl
  ld a,l
setusr1:
  cp 255
  call nz,set_current_user
  jp next

;  RSTUSR  ( -- )    restore user

  hdr 1,'RSTUSR'
rstusr:
  ld a,(old_user)
  jp setusr1

;  REC@  ( addr -- +d )  dup >r @ r> 2+ c@ 7 0 do d2* loop

  hdr 1,'REC@'
rec_fetch:
  pop hl
  inc  hl
  inc  hl
  xor a
  ld a,(hl)
  rra
  ld d,a
  dec  hl
  ld a,(hl)
  rra
  ld e,a
  dec  hl
  ld a,(hl)
  rra
  ld h,a
  ld a,0
  rra
  ld l,a
  ex de,hl
  push de
  jp next

;  REC!  ( +d addr -- )  >r 7 0 do d2/ loop r@ 2+ c! r> !

  hdr 1,'REC!'
rec_store:
  pop de
  ld l,c
  ld h,b
  pop bc
  ex (sp),hl
  ex de,hl
  ld a,e
  rla
  ld a,d
  rla
  ld (hl),a
  inc  hl
  ld a,c
  rla
  ld (hl),a
  inc  hl
  ld a,b
  rla
  ld (hl),a
  pop bc
  jp next

;  >FNAME  ( addr1 u -- addr2 )  (filename_size-1) min zbuf @ packed 0 affix
;          zbuf 2@ swap zbuf 2!

  hdr 1,'>FNAME'
tfnam:
  call do_colon
  dw c_lit
  db filename_size-1
  dw min
  dw zbuf,fetch
  dw packd
  dw zero,affix  ; trailing null
  dw zbuf,two_fetch
  dw swap
  dw zbuf,two_store
  dw exit

;  fh  ( -- addr )

  hdr x,'FH'
fh:
  call do_value    ; current file handle
fh1:
  dw 0

;  /fh  ( -- )    #fcb (file_handle_size) * hbuf over - swap erase

  hdr x,'/FH'
zfh:
  ld hl,(nfcb1)
  ld de,file_handle_size
  call hl_by_de_to_hlde_unsigned
  ld hl,(hbuf1)
  call hl_minus_de_to_hl
  push hl
  push de
  jp erase

;  use  ( -- addr )  fh (file_handle_size) negate * hbuf +

  hdr x,'USE'
use:
  ld hl,(fh1)
  ld de,-file_handle_size
  call hl_by_de_to_hlde_unsigned
  ld hl,(hbuf1)
  add hl,de
  push hl
  jp next

;  uid  ( -- addr )  use 1+

  hdr x,'UID'
uid:
  call do_colon    ; user number
  dw use,one_plus
  dw exit

;  fcb  ( -- a )    use 6 +

  hdr x,'FCB'
fcb:
  call do_colon    ; FCB address
  dw use
  dw c_lit
  db 6
  dw plus
  dw exit

;  rwp@  ( -- ud )    use 2+ 2@

  hdr x,'RWP@'
rwp_fetch:
  call do_colon
  dw use,two_plus
  dw two_fetch
  dw exit

;  rwp!  ( ud -- )    use 2+ 2! ;

  hdr x,'RWP!'
rwpst:
  call do_colon
  dw use,two_plus
  dw two_store
  dw exit

;  >IOR  ( err# -- ior )  dup if $fe00 or then

  hdr 1,'>IOR'
ior:
  pop hl
  ld a,h
  or l
  jp z,ior1
  ld h,0xfe
ior1:
  push hl
  jp next

;  ?ior  ( flag err# -- ior )  and ior ;

  hdr x,'?IOR'
qior:
  call do_colon
  dw and_
  dw ior
  dw exit

;  getfh  ( -- fid | 0 )  #fcb 1+ begin 1- dup while dup to fh
;        use c@ 0= until then

  hdr x,'GETFH'
gtfh:
  call do_colon    ; get free handle, 0 if none
  dw nfcb
  dw one_plus
gtfh1:
  dw one_minus
  dw dup
  dw question_branch,gtfh2
  dw dup
  dw paren_to,fh
  dw use,c_fetch
  dw zero_equals
  dw question_branch,gtfh1
gtfh2:
  dw exit

;  setfh  ( fid mask -- 0 | err )  swap dup 1- 0 #fcb within if to fh
;          use c@ and 0= 5 and exit then 2drop
;          6

  hdr x,'SETFH'
stfh:
  call do_colon    ; select/check handle
  dw swap    ; mode mask: 1=read 2=write 3=r/w
  dw dup,one_minus
  dw zero
  dw nfcb
  dw within
  dw question_branch,stfh1
  dw paren_to,fh
  dw use,c_fetch
  dw and_,zero_equals
  dw c_lit
  db 5
  dw and_
  dw exit
stfh1:
  dw two_drop
  dw c_lit
  db 6
  dw exit

;  FILE-POSITION  ( fideid -- ud ior )  3 setfh rwp@ rot ior

  hdr 1,'FILE-POSITION'
fpos:
  call do_colon
  dw three,stfh
  dw rwp_fetch
  dw rot
  dw ior
  dw exit

;  REPOSITION-FILE  ( ud fid -- ior )  3 setfh dup >r if 2drop else
;              rwp! then r> ior

  hdr 1,'REPOSITION-FILE'
reposf:
  call do_colon
  dw three,stfh
  dw dup,to_r
  dw question_branch,reposf1
  dw two_drop
  dw branch,reposf2
reposf1:
  dw rwpst
reposf2:
  dw from_r
  dw ior
  dw exit

;  xf5  ( -- )    $80 fcb 5 + ctoggle

  hdr x,'XF5'
xff:
  call do_colon
  dw c_lit
  db 0x80
  dw fcb
  dw c_lit
  db 5
  dw plus
  dw ctog
  dw exit

;  FILE-SIZE  ( fid -- ud ior )  3 setfh dup 0= if uid c@ setusr
;          xf5 fcb 16 bdos drop xf5 fcb 35
;          bdos drop rstusr then fcb 33 +
;          rec@ rot ior

  hdr 1,'FILE-SIZE'
file_size:
  call do_colon
  dw three,stfh
  dw dup,zero_equals
  dw question_branch,fsiz1
  dw uid,c_fetch
  dw setusr
  dw xff
  dw fcb
  dw c_lit
  db 16
  dw bdos,drop
  dw xff
  dw fcb
  dw c_lit
  db 35
  dw bdos,drop
  dw rstusr
fsiz1:
  dw fcb
  dw c_lit
  db 33
  dw plus
  dw rec_fetch
  dw rot
  dw ior
  dw exit

;  CLOSE-FILE  ( fid -- ior )  3 setfh dup if ior exit then use c!
;          uid c@ setusr fcb 16 bdos rstusr 255
;          = 2 ?ior

  hdr 1,'CLOSE-FILE'
closf:
  call do_colon
  dw three,stfh
  dw dup
  dw question_branch,closf1
  dw ior
  dw exit
closf1:
  dw use,c_store
  dw uid,c_fetch
  dw setusr
  dw fcb
  dw c_lit
  db 16
closf2:
  dw bdos
  dw rstusr
  dw c_lit
  db 255
  dw equals
  dw two
  dw qior
  dw exit

;  R/O  ( -- fam )      aka 0 r/o

  hdr 1,'R/O',,,zero
rso: equ  zero

;  W/O  ( -- fam )      aka 1 w/o

  hdr 1,'W/O',,,one
wso: equ  one

;  R/W  ( -- fam )      aka 2 r/w

  hdr 1,'R/W',,,two
rsw: equ  two

;  BIN  ( fam1 -- fam2 )    aka noop bin immediate

  hdr 1,'BIN',1,,noop
binn: equ  next

;  open1  ( addr u fam -- | x ior )
;          getfh 0= if 2drop 4 ior unnest exit
;          then 1+ use c! >fname count fcb
;          setfcb dup uid c! setusr 0 0 rwp!

  hdr x,'OPEN1'
open1:
  call do_colon
  dw gtfh,zero_equals
  dw question_branch,open11
  dw two_drop
  dw c_lit
  db 4
  dw ior
   if  debug
  dw paren_dot_quote
  dcs 'UNNEST_OPEN1'
   endif
  dw unnest
  dw exit
open11:
  dw one_plus
  dw use,c_store
  dw tfnam,count
  dw fcb
  dw sfcb
  dw dup
  dw uid,c_store
  dw setusr
  dw zero,zero
  dw rwpst
  dw exit

;  open2  ( fn# -- fid flag )  fh fcb rot bdos 255 = rstusr

  hdr x,'OPEN2'
open2:
  call do_colon
  dw fh
  dw fcb
  dw rot
  dw bdos
  dw c_lit
  db 255
  dw equals
  dw rstusr
  dw exit

;  open3  ( flag err -- | ior )  ?ior ?dup if 0 use c! unnest then

  hdr x,'OPEN3'
open3:
  call do_colon
  dw qior
  dw question_dup
  dw question_branch,open31
  dw zero
  dw use,c_store
   if  debug
  dw paren_dot_quote
  dcs 'UNNEST_OPEN3'
   endif
  dw unnest
open31:
  dw exit

;  OPEN-FILE  ( addr u fam -- fid ior )
;          open1 15 open2 2 open3 fcb 9 + c@
;          6 rshift use c@ and 1 > 5 open3 0

  hdr 1,'OPEN-FILE'
openf:
  call do_colon
  dw open1
  dw c_lit
  db 15
  dw open2
  dw two,open3
  dw fcb    ; test if file R/O and mode=write
  dw c_lit
  db 9
  dw plus,c_fetch
  dw c_lit
  db 6
  dw rshift
  dw use,c_fetch,and_
  dw one,greater_than
  dw c_lit
  db 5
  dw open3,zero
  dw exit

;  CREATE-FILE  ( addr u fam -- fid ior )
;          open1 fcb 19 bdos drop 22 open2
;          5 open3 0

  hdr 1,'CREATE-FILE'
creatf:
  call do_colon
  dw open1
  dw fcb
  dw c_lit
  db 19
  dw bdos,drop
  dw c_lit
  db 22
  dw open2
  dw c_lit
  db 5
  dw open3
  dw zero
  dw exit

;  >FCB  ( addr u -- fcb usr )  2dup >fname 18 + -rot 2 pick setfcb

  hdr 1,'>FCB'
tfcb:
  call do_colon
  dw two_dup,tfnam
  dw c_lit
  db 18
  dw plus
  dw drot
  dw two,pick
  dw sfcb
  dw exit

;  DELETE-FILE  ( addr u -- ior )  >fcb setusr 19 bdos rstusr 255 = 2
;          ?ior

  hdr 1,'DELETE-FILE'
delf:
  call do_colon
  dw tfcb,setusr
  dw c_lit
  db 19
  dw branch,closf2

;  RENAME-FILE  ( addr1 u1 addr2 u2 -- ior )
;          2swap >fcb setusr >r >fcb drop r@ c@
;          over c! dup 15 bdos 255 = if r@ 16 +
;          16 cmove r> 23 bdos 255 = 2 ?ior else
;          16 bdos r> 2drop 5 ior then rstusr

  hdr 1,'RENAME-FILE'
renf:
  call do_colon
  dw tswap
  dw tfcb,setusr,to_r
  dw tfcb,drop
  dw r_fetch,c_fetch
  dw over,c_store
  dw dup
  dw c_lit
  db 15
  dw bdos
  dw c_lit
  db 255
  dw equals
  dw question_branch,renf1
  dw r_fetch
  dw c_lit
  db 16
  dw plus
  dw c_lit
  db 16
  dw cmove,from_r
  dw c_lit
  db 23
  dw branch,closf2
renf1:
  dw c_lit
  db 16
  dw bdos
  dw from_r,two_drop
  dw c_lit
  db 5
  dw ior
  dw rstusr
  dw exit

;  offs  ( -- x )      0 value offs

  hdr x,'OFFS'
offs:
  call do_value
  dw 0

;  setsiz  ( -- size )    rwp@ over $7F and to offs fcb 33 +
;          rec! (recsiz) offs -

  hdr x,'SETSIZ'
setsiz:
  call do_colon
  dw rwp_fetch,over
  dw c_lit
  db 0x7f
  dw and_
  dw paren_to,offs
  dw fcb
  dw c_lit
  db 33
  dw plus,rec_store
  dw c_lit
  db recsiz
  dw offs,minus
  dw exit

;  SETDMA  ( a -- )    26 bdos drop

  hdr 1,'SETDMA'
setdma:
  pop de
  ld a,26
  call bdoss
  jp next

;  ranrw  ( a size fn# -- a size | a u' )
;          fcb swap bdos if drop unnest r> then

  hdr x,'RANRW'
ranrw:
  call do_colon
  dw fcb,swap,bdos
  dw question_branch,ranrw1
  dw drop
   if  debug
  dw paren_dot_quote
  dcs 'UNNEST_RW'
   endif
  dw unnest
  dw from_r
ranrw1:
  dw exit

;  rdini  ( a u fid mask -- u a u | u ior )
;          setfh ?dup if nip ior unnest exit
;          then tuck

  hdr x,'RDINI'
rdini:
  call do_colon
  dw stfh,question_dup
  dw question_branch,rdini1
  dw nip
  dw ior
   if  debug
  dw paren_dot_quote
  dcs 'UNNEST_RDINI'
   endif
  dw unnest
  dw exit
rdini1:
  dw tuck
  dw exit

;  fread  ( a u1 -- a u2 )    begin dup while >r setsiz r@ umin
;          dup (recsiz) = if over setdma 33
;          ranrw else hbuf setdma 33 ranrw 2dup
;          hbuf offs + -rot cmove then dup >r +
;          rwp@ r@ m+ rwp! 2r> - repeat

  hdr x,'FREAD'
fread:
  call do_colon
fread1:
  dw dup
  dw question_branch,fread4
  dw to_r
  dw setsiz
  dw r_fetch,u_min
  dw dup
  dw c_lit
  db recsiz
  dw equals
  dw question_branch,fread2
  dw over,setdma
  dw c_lit
  db 33
  dw ranrw
  dw branch,fread3
fread2:
  dw hbuf,setdma
  dw c_lit
  db 33
  dw ranrw
  dw two_dup,hbuf
  dw offs,plus
  dw drot,cmove
fread3:
  dw dup,to_r
  dw plus
  dw rwp_fetch
  dw r_fetch,m_plus
  dw rwpst
  dw two_from_r,minus
  dw branch,fread1
fread4:
  dw exit

;  wrini  ( a u fid mask -- a u | ior )
;          setfh ?dup if nip nip ior unnest          then

  hdr x,'WRINI'
wrini:
  call do_colon
  dw stfh,question_dup
  dw question_branch,wrini1
  dw nip,nip
  dw ior
   if  debug
  dw paren_dot_quote
  dcs 'UNNEST_WRINI'
   endif
  dw unnest
wrini1:
  dw exit

;  fwrite  ( a u1 -- a u2 )  begin dup while >r setsiz r@ umin dup
;          (recsiz) = if over setdma else hbuf
;          (recsiz) $1A fill hbuf setdma fcb 33
;          bdos drop 2dup hbuf offs + swap cmove
;          then 34 ranrw dup >r + rwp@ r@ m+
;          rwp! 2r> - repeat

  hdr x,'FWRITE'
fwrit:
  ; XXX TODO
  ; XXX TMP -- 2drop
  pop hl
  pop hl
  jp next
; XXX OLD
;;  call  do_colon
;;fwrit1:
;;  dw dup
;;  dw question_branch,fwrit4
;;  dw to_r
;;  dw setsiz
;;  dw r_fetch,u_min
;;  dw dup
;;  dw c_lit
;;  db recsiz
;;  dw equals
;;  dw question_branch,fwrit2
;;  dw over,setdma
;;  dw branch,fwrit3
;;fwrit2:
;;  dw hbuf
;;  dw c_lit
;;  db recsiz
;;  dw c_lit
;;  db ctlz
;;  dw fill
;;  dw hbuf,setdma
;;  dw fcb
;;  dw c_lit
;;  db 33
;;  dw bdos,drop
;;  dw two_dup
;;  dw hbuf
;;  dw offs,plus
;;  dw swap
;;  dw cmove
;;fwrit3:
;;  dw c_lit
;;  db 34
;;  dw ranrw
;;  dw dup,to_r
;;  dw plus
;;  dw rwp_fetch
;;  dw r_fetch,m_plus
;;  dw rwpst
;;  dw two_from_r,minus
;;  dw branch,fwrit1
;;fwrit4:
;;  dw exit

;  READ-FILE  ( addr u1 fid -- u2 ior )  1 rdini uid c@ setusr fread
;          rstusr nip - 0

  hdr 1,'READ-FILE'
readf:
  call do_colon
  dw one,rdini
  dw uid,c_fetch
  dw setusr
  dw fread
  dw rstusr
  dw nip
  dw minus
  dw zero
  dw exit

;  WRITE-FILE  ( addr u fid -- ior )  2 wrini uid c@ setusr fwrite
;          rstusr nip 0<> 255 ?ior

  hdr 1,'WRITE-FILE'
writf:
  call do_colon
  dw two,wrini
  dw uid,c_fetch
  dw setusr
  dw fwrit
  dw rstusr
  dw nip
  dw zero_not_equals
  dw c_lit
  db 255
  dw qior
  dw exit

;  WRITE-LINE  ( c-addr u fileid -- ior )
;        dup >r write-file ?dup if r> drop exit
;        then (crlf) 2 r> write-file

  hdr 1,'WRITE-LINE'
writl:
  call do_colon
  dw dup,to_r
  dw writf,question_dup
  dw question_branch,writl1
  dw from_r,drop
  dw exit
writl1:
  dw lit,crlf
  dw two
  dw from_r
  dw writf
  dw exit

;  eol?  ( addr -- 2|1|0 )    c@ $0D of 2 exit then $0A of 1 exit
;          then drop 0

  hdr x,'EOL?'
eolq:
  pop hl
  ld a,(hl)
  cp cr_char
  jp z,two
  cp lf_char
  jp z,one
  jp zero

;  READ-LINE  ( addr u1 fid -- u2 flag ior )  >r over swap r> read-file
;          ?dup if exit then 2dup over + swap
;          ?do i dup c@ $1A = if rot - fh
;          file-size drop rwp! leave then eol?
;          ?dup if i + >r over + r> swap - dup
;          0<> rwp@ d+ rwp! i swap - -1 0 unloop
;          exit then loop nip dup 0<> 0

  hdr 1,'READ-LINE'
readl:
; XXX TODO
  pop hl
  pop hl
  pop hl
  jp next
; XXX OLD -- DX-Forth 4.00
;;  call  do_colon
;;  dw to_r,over,swap,from_r
;;  dw readf,question_dup
;;  dw question_branch,readl1
;;  dw exit
;;readl1:
;;  dw two_dup,over,plus,swap
;;  dw paren_question_do,readl5
;;readl2:
;;  dw i_
;;  dw dup,c_fetch
;;  dw c_lit
;;  db ctlz
;;  dw equals
;;  dw question_branch,readl3
;;  dw rot,minus
;;  dw fh,file_size,drop,rwpst
;;  dw paren_leave,readl2-cw
;;readl3:
;;  dw eolq,question_dup
;;  dw question_branch,readl4
;;  dw i_,plus,to_r
;;  dw over,plus
;;  dw from_r
;;  dw swap,minus
;;  dw dup,zero_not_equals  ; handle buffer > 32K
;;  dw rwp_fetch,d_plus,rwpst
;;  dw i_,swap,minus
;;  dw true,zero
;;  dw unloo,exit
;;readl4:
;;  dw paren_loop,readl2
;;readl5:
;;  dw nip
;;  dw dup,zero_not_equals,zero
;;  dw exit

; screen file selector

; XXX OLD
fdtab:
  gfdb      ; fdb table

;  sfp  ( -- a )

  hdr x,'SFP',,1
sfp:
  call do_create
sfp1:
  dw fdtab    ; current
sfp2:
  dw fdtab+cw  ; swap-file

;  SWAP-FILE  ( -- )  scr @ scr# ! sfp 2@ swap sfp 2!
;        scr# @ scr ! empty-buffers

  hdr 1,'SWAP-FILE',,1
swapf:
  call do_colon
  dw scr,fetch
  dw snum,store
  dw sfp,two_fetch
  dw swap
  dw sfp,two_store
  dw snum,fetch
  dw scr,store
  dw empty_buffers
  dw exit

;  FDB  ( -- addr )  (fdtab) (nfd) 0 do dup @ @ 0= if unloop exit
;        then cell+ loop abort" too many files"

  hdr 1,'FDB',,1  ; get a free slot
fdb:
  call do_colon
  dw lit,fdtab
  dw c_lit
  db nfd
  dw zero
  dw paren_do,fdb3
fdb1:
  dw dup,fetch,fetch
  dw zero_equals
  dw question_branch,fdb2
  dw unloo
  dw exit
fdb2:
  dw cell_plus
  dw paren_loop,fdb1
fdb3:
  dw paren_abort_quote
  dcs 'too many files'
  dw exit

; file descriptor fields
;
;  FD  cell    status 0=closed
;  FID  cell    file handle
;  BLKS  cell    file size (blocks)
;  SCR#  cell    current SCR#
;  FNB  'filename_size' bytes  file name

;  fd  ( -- addr )

  hdr x,'FD',,1
fd:
  call do_colon    ; file descriptor field
  dw sfp,fetch,fetch
  dw exit

;  fid  ( -- addr )

  hdr x,'FID',,1
fid:
  ld e,cw*1    ; file handle field
fid1:
  ld d,0
  push de
  call do_colon
  dw fd,plus
  dw exit

;  blks  ( -- addr )

  hdr x,'BLKS',,1
blks:
  ld e,cw*2    ; file size field
  jp fid1

;  scr#  ( -- addr )

  hdr x,'SCR#',,1
snum:
  ld e,cw*3    ; current SCR# field
  jp fid1

;  fnb  ( -- addr )

  hdr x,'FNB',,1
fnb:
  ld e,cw*4    ; file name field
  jp fid1

;  buf  ( -- addr )

  hdr x,'BUF',,1
buf:
  call do_constant    ; file buffer address
  dw block_buffer

;  blk#  ( -- addr )

  hdr x,'BLK#',,1
bnum:
  call do_create    ; block#, update flag
bnum1:
  ds cw

;  FILE?  ( -- flag )

  hdr 1,'FILE?',,1
gcfile_question:
  call do_colon
  dw fd,fetch ; fd @
  dw zero_not_equals ; 0<>
  dw exit

;  LOADFILE  ( -- c-addr u )  fnb count

  hdr 1,'LOADFILE',,1
loadfile:
  call do_colon
  dw fnb,count
  dw exit

;  ?open  ( -- )    file? 0= abort" no file open"

  hdr x,'?OPEN',,1
qopen:
  call do_colon
  dw gcfile_question
  dw zero_equals
  dw paren_abort_quote
  dcs 'no file open'
  dw exit

;  #SCREENS  ( -- +n )  ?open blks @

  hdr 1,'#SCREENS',,1
nscr:
  call do_colon
  dw qopen
  dw blks,fetch
  dw exit

;  EMPTY-BUFFERS  ( -- )  $7fff blk# !

  hdr 1,'EMPTY-BUFFERS',,1
empty_buffers:
  ld hl,7fffh
  ld (bnum1),hl
  jp next

;  UPDATE  ( -- )    ?open blk# @ $8000 or blk# !

  hdr 1,'UPDATE',,1
update:
  call do_colon
  dw qopen
  dw bnum,fetch
  dw lit,8000h
  dw or_
  dw bnum,store
  dw exit

;  blkerr  ( flag -- )  abort" block r/w error"

  hdr x,'BLKERR',,1
blkerr:
  call do_colon
  dw paren_abort_quote
  dcs 'block r/w error'
  dw exit

;  blk-rw  ( +n mode -- )  >r b/buf um* fid @ reposition-file blkerr
;        buf b/buf fid @ r> if write-file else
;        read-file blkerr b/buf < then blkerr

  hdr x,'BLK-RW',,1
blkrw:
  call do_colon
  dw to_r
  dw bbuf,umstr
  dw fid,fetch
  dw reposf
  dw blkerr
  dw buf,bbuf
  dw fid,fetch
  dw from_r
  dw question_branch,blkrw1
  dw writf
  dw branch,blkrw2
blkrw1:
  dw readf
  dw blkerr
  dw bbuf,less_than
blkrw2:
  dw blkerr
  dw exit

;  ?blk  ( +n -- +n )  dup #screens 0 within
;        abort" block out of range"

  hdr x,'?BLK',,1
qblk:
  call do_colon
  dw dup
  dw nscr,zero
  dw within    ; block in range?
  dw paren_abort_quote
  dcs 'block out of range'
  dw exit

;  SAVE-BUFFERS  ( -- )  ?open blk# @ 0< if blk# @ $7fff and
;        dup blk# ! ?blk 1 blk-rw then

  hdr 1,'SAVE-BUFFERS',,1
save_buffers:
  call do_colon
  dw qopen
  dw bnum,fetch
  dw zero_less_than
  dw question_branch,savbuf1
  dw bnum,fetch
  dw lit,7fffh
  dw and_
  dw dup
  dw bnum,store
  dw qblk    ; block in range?
  dw one,blkrw
savbuf1:
  dw exit

;  FLUSH  ( -- )    save-buffers empty-buffers

  hdr 1,'FLUSH',,1
flush:
  call do_colon
  dw save_buffers,empty_buffers
  dw exit

;  BUFFER  ( +n -- addr )  save-buffers ?blk blk# ! buf

  hdr 1,'BUFFER',,1
buffer:
  call do_colon
  dw save_buffers
  dw qblk
  dw bnum,store
  dw buf
  dw exit

;  BLOCK  ( +n -- addr )  ?open blk# @ $7fff and over - if dup
;        buffer drop 0 blk-rw else drop then buf

  hdr 1,'BLOCK',,1
block:
  call do_colon
  dw qopen
  dw bnum,fetch
  dw lit,7fffh
  dw and_,over,minus
  dw question_branch,block1
  dw dup,buffer,drop
  dw zero,blkrw
  dw branch,block2
block1:
  dw drop
block2:
  dw buf
  dw exit

;  -->  ( -- )    blk @ 0= abort" loading only" (refill) drop
;        ;immediate

  hdr 1,'-->',1,1
arrow:
  call do_colon
  dw blk,fetch
  dw zero_equals
  dw paren_abort_quote
  dcs 'loading only'
  dw paren_refill,drop
  dw exit

;  (thru)  ( +n1 +n2 -- )  1+ swap ?do i block b/buf i (eval) loop

  hdr x,'(THRU)',,1
pthru:
  call do_colon
  dw one_plus,swap
  dw paren_question_do,pthru2
pthru1:
  dw i_,block
  dw bbuf
  dw i_,peval
  dw paren_loop,pthru1
pthru2:
  dw exit

;  THRU  ( +n1 +n2 -- )  (thru) ?block

  hdr 1,'THRU',,1
thru:
  call do_colon
  dw pthru
  dw qblock
  dw exit

;  LOAD  ( +n -- )   dup thru

  hdr 1,'LOAD',,1
load:
  pop hl
  push hl
  push hl
  jp thru

;  fnbuf  ( -- addr )

  hdr x,'FNBUF',,1
fnbuf:
  call do_create    ; current file handle
  ds filename_size

;  (fbk)  ( +n -- )  #screens 2dup u< if drop dup loadfile -ext
;        s" $$$" +ext fnbuf place fnbuf count w/o
;        create-file throw over 0 ?do dup i block
;        b/buf rot write-file throw loop close-file
;        throw fid @ close-file throw loadfile
;        delete-file throw fnbuf count loadfile
;        rename-file throw loadfile r/w open-file
;        throw fid ! then over blks ! ?do i buffer
;        b/buf blank update save-buffers loop

  hdr x,'(FBK)',,1
pfbk:
  call do_colon
  dw nscr    ; tests if file open
  dw two_dup,u_less_than
  dw question_branch,pfbk3
  dw drop,dup
  dw loadfile,minus_ext
  dw paren_s_quot
  dcs '$$$'
  dw plus_ext
  dw fnbuf,place
  dw fnbuf,count
  dw wso,creatf,throw
  dw over,zero
  dw paren_question_do,pfbk2
pfbk1:
  dw dup
  dw i_,block
  dw bbuf
  dw rot,writf,throw
  dw paren_loop,pfbk1
pfbk2:
  dw closf,throw
  dw fid,fetch
  dw closf,throw
  dw loadfile,delf,throw
  dw fnbuf,count
  dw loadfile,renf,throw
  dw loadfile
  dw rsw,openf,throw
  dw fid,store
pfbk3:
  dw over
  dw blks,store  ; update max block
  dw paren_question_do,pfbk5
pfbk4:
  dw i_,buffer
  dw bbuf,blank
  dw update,save_buffers
  dw paren_loop,pfbk4
pfbk5:
  dw exit

;  FILEBLOCKS  ( +n -- )  ['] (fbk) catch abort" can't resize file"

  hdr 1,'FILEBLOCKS',,1
fbloc:
  call do_colon
  dw lit,pfbk
  dw catch
  dw paren_abort_quote
  dcs "can't resize file"
  dw exit

;  CLOSE  ( -- )    file? if flush fid @ close-file drop
;        fd off then empty-buffers
;
; NOTE: errors are NOT reported with this function

  hdr 1,'CLOSE',,1  ; close current file
close:
  call do_colon
  dw gcfile_question
  dw question_branch,close1
  dw flush
  dw fid,fetch
  dw closf,drop
  dw fd,off
close1:
  dw empty_buffers
  dw exit

;  CLOSE-ALL  ( -- )  close (fdtab) nfd 0 do dup sfp ! close
;        cell+ loop drop

  hdr 1,'CLOSE-ALL',,1
closa:
  call do_colon
  dw close    ; ensure buffer flushed
  dw lit,fdtab
  dw c_lit
  db nfd
  dw zero
  dw paren_do,closa2
closa1:
  dw dup
  dw sfp,store
  dw close
  dw cell_plus
  dw paren_loop,closa1
closa2:
  dw drop
  dw exit

;  lastfile  ( -- c-addr u )  zbuf cell+ @ count

  hdr x,'LASTFILE',,1
lastf:
  call do_colon    ; last named file used by open-file etc
  dw zbuf,cell_plus
  dw fetch,count
  dw exit

;  .lastfile  ( -- )  beep cr lastfile type space

  hdr x,'.LASTFILE',,1
dotlf:
  call do_colon
  dw beep,cr
  dw lastf,type
  dw space
  dw exit

;  ?create  ( c-addr u -- fileid )
;        r/o open-file 0= tuck if close-file then
;        drop if .lastfile ." exists - delete it? "
;        y/n 0= if abort then then lastfile r/w
;        create-file abort" can't create file"

  hdr x,'?CREATE',,1
question_create:
  call do_colon
  dw rso,openf  ; test if file exists
  dw zero_equals,tuck
  dw question_branch,question_create1
  dw closf
question_create1:
  dw drop
  dw question_branch,question_create2
  dw dotlf
  dw paren_dot_quote
  dcs 'exists - delete it? '
  dw yn,zero_equals
  dw question_branch,question_create2
  dw abort
question_create2:
  dw lastf,rsw,creatf
  dw paren_abort_quote
  dcs "can't create file"
  dw exit

;  init-scr  ( fileid ior -- )  if drop exit then fdb sfp ! fd on
;          dup fid ! file-size drop b/buf
;          um/mod nip blks ! lastfile fnb
;          place loadfile upper empty-buffers

  hdr x,'INIT-SCR',,1
iniscr:
  call do_colon    ; init screenfile
  dw question_branch,iniscr1
  dw drop
  dw exit
iniscr1:
  dw fdb,sfp,store
  dw fd,on
  dw dup,fid,store
  dw file_size,drop
  dw bbuf,umslm,nip  ; overflow stores $FFFF
  dw blks,store
  dw lastf,fnb,place
  dw loadfile,upper
  dw empty_buffers
  dw exit

;  OPEN  ( c-addr u fam -- ior )
;         fdb drop >r s" scr" +ext r>
;         open-file tuck init-scr

  hdr 1,'OPEN',,1  ; open a screen file
open:
  call do_colon
  dw fdb,drop  ; free slot?
  dw to_r
  dw paren_s_quot
  dcs 'scr'
  dw plus_ext
  dw from_r,openf
  dw tuck
  dw iniscr
  dw exit

;  (open)  ( c-addr u -- )    r/w open abort" can't open file"

  hdr x,'(OPEN)',,1
popen:
  call do_colon
  dw rsw,open
  dw paren_abort_quote
  dcs "can't open file"
  dw exit

;  GETFILENAME  ( -- c-addr u )  token dup 0= abort" specify filename"

  hdr 1,'GETFILENAME',,1
getfilename:
  call do_colon
  dw token
  dw dup,zero_equals
  dw paren_abort_quote
  dcs 'specify filename'
  dw exit

;  USING  ( "filename[.SCR]" -- )  close getfilename r/w open ?dup if
;          .lastfile -507 = if ." access denied"
;          0 else ." not found - create it? "
;          y/n then 0= if abort then lastfile
;          ?create 0 init-scr then 0 0 scr 2!

  hdr 1,'USING',,1  ; open/make a screen file
using:
  call do_colon
  dw close
  dw getfilename
  dw rsw,open,question_dup
  dw question_branch,using4
  dw dotlf
  dw lit,-507
  dw equals
  dw question_branch,using1
  dw paren_dot_quote
  dcs 'access denied'
  dw zero
  dw branch,using2
using1:
  dw paren_dot_quote
  dcs 'not found - create it? '
  dw yn
using2:
  dw zero_equals
  dw question_branch,using3
  dw abort
using3:
  dw lastf,question_create
  dw zero,iniscr
using4:
  dw zero,zero  ; reset SCR
  dw scr,two_store
  dw exit

;  LOADED  ( +n1 +n2 c-addr u -- )  sfp @ >r (open) (thru) close r>
;          sfp ! ?block

  hdr 1,'LOADED',,1
loaded:
  call do_colon
  dw sfp,fetch
  dw to_r
  dw popen
  dw pthru
  dw close
  dw from_r
  dw sfp,store
  dw qblock
  dw exit

;  FLOAD  ( +n "filename[.SCR]" -- )  dup getfilename loaded

  hdr 1,'FLOAD',,1
fload:
  call do_colon
  dw dup
  dw getfilename
  dw loaded
  dw exit

;  SAVE  ( "filename[.COM]" -- )
;        0 0 freeze getfilename s" com" +ext
;        ?create >r over swap boot 2! (cold6) (zb1)
;        dup (zbsiz*2) erase (cold7-cold6) cmove
;        $100 dp @ over - r@ write-file boot cell+
;        off ?dup 0= if (hm) dph @ over - rot 0=
;        and r@ write-file then r> close-file or
;        abort" can't save file"

  hdr 1,'SAVE',,1
save:
  call do_colon
  ; XXX TODO
  ; XXX OLD
;;  dw zero,zero
;;save1:
;;  dw freez
;;  dw getfilename
;;  dw paren_s_quot
;;  dcs 'com'
;;  dw plus_ext
;;  dw question_create
;;  dw to_r    ; fid
;;  dw over,swap  ; set boot flags
;;  dw boot,two_store
;;  dw lit,cold6  ; insert compiler logo
;;  dw lit,zb1
;;  dw dup
;;  dw c_lit
;;  db zbsiz*2
;;  dw erase
;;  dw c_lit
;;  db cold7-cold6
;;  dw cmove
;;  dw lit,0x0100
;;  dw dpp,fetch
;;  dw over,minus
;;  dw r_fetch,writf  ; save application
;;  dw boot,cell_plus,off  ; reset forth flag
;;  dw question_dup,zero_equals
;;  dw question_branch,save2
;;  dw lit,hm
;;  dw dph,fetch
;;  dw over,minus
;;  dw rot,zero_equals,and_  ; system size
;;  dw r_fetch,writf  ; save system
;;save2:
;;  dw from_r,closf,or_
;;  dw paren_abort_quote
;;  dcs  "can't save file"
  dw exit

;  TURNKEY  ( "bootword" "filename[.COM]" -- )

  hdr 1,'TURNKEY',,1
turnkey:
  call do_colon
  ; XXX TODO
  dw exit
  ; XXX OLD
;;  dw true
;;turnkey1:
;;  dw tick
;;  dw branch,save1

;  TURNKEY-SYSTEM  ( "bootword" "filename[.COM]" -- )

  hdr 1,'TURNKEY-SYSTEM',,1
turnkey_system:
  call do_colon
  call do_colon
  ; XXX TODO
  dw exit
  ; XXX OLD
;;  dw zero
;;  dw branch,turnkey1

; }}} **********************************************************
; Graphics {{{

; BORDER  ( n -- )

  hdr 1,'BORDER'
border:
  ; Code based on Benschop's Forth-83:
  ;   : BORDER  ( n -- )
  ;     DUP DUP 4 < 7 AND SWAP 8 * + 23624 C! 254 P! ;
  ; And this is the translation in Z80:
  pop hl
  ld a,l
  cp 4 ; dark color?
  jp nc,border_a
  ; dark color
  sla a
  sla a
  sla a ; *8 (converted to paper)
  add a,7 ; white ink
border_a:
  ld (sys_bordcr),a
  ld a,l
  out (254),a
  jp next

; PAPER  ( n -- )
  hdr 1,'PAPER'
paper:
  ; XXX TODO
  jp next

; INK  ( n -- )
  hdr 1,'INK'
ink:
  ; XXX TODO
  jp next

; GOVER ( n -- )
  hdr 1,'GOVER'
gover:
  ; XXX TODO -- Benschop's Forth-83 does this:
  ; 23697 DUP C@ 252 AND ROT 3 * OR SWAP C!
  jp next

; INVERSE  ( n -- )
  hdr 1,'INVERSE'
inverse:
  ; XXX TODO -- Benschop's Forth-83 does this:
  ; 23697 DUP C@ 243 AND ROT 12 * OR SWAP C!
  jp next

; NORMAL  ( -- )
  hdr 1,'NORMAL'
normal:
  ; XXX TODO -- Benschop's Forth-83 does this:
  ; 0 INK 7 PAPER 0 FLASH 0 BRIGHT 7 BORDER 0 GOVER 0 INV
  jp next

; }}} **********************************************************
; Floating point functions {{{

  if float

;  -FP  ( -- addr )    marker -FP

  hdr 1,'-FP',,1
dfp:
  call next

;  FLOAT+ ( f-addr1 -- f-addr2 )  4 +

  hdr 1,'FLOAT+'
floatp:
  pop hl
  ld de,fw
  add hl,de
  push hl
  jp next

;  FLOATS ( n1 -- n2 )    4 *

  hdr 1,'FLOATS'
floats:
  pop hl
  add hl,hl
  add hl,hl
  push hl
  jp next

;  FALIGN  ( -- )      aka noop falign immediate

  hdr 1,'FALIGN',1,,noop
falign: equ  next

;  FALIGNED ( addr -- f-addr )  aka noop faligned immediate

  hdr 1,'FALIGNED',1,,noop
falignd: equ  next

;  F,  (F: r -- ) or ( r -- )  , ,

  hdr 1,'F,',,1
fcomm:
  call do_colon
  dw comma,comma
  dw exit

;  FLITERAL  ( -- r )
  ; aka fliteral 2literal immediate

  hdr 1,'FLITERAL',1,,two_literal
f_literal equ  two_literal
f_lit:    equ  two_lit

;  FCONSTANT  ( -- r )
  ; aka 2constant fconstant

  hdr 1,'FCONSTANT',,,two_constant
f_constant: equ  two_constant

do_f_constant: equ  two_fetch

;  FVARIABLE  ( -- f-addr )
;  aka 2variable fvariable

  hdr 1,'FVARIABLE',,,two_variable
f_variable: equ  two_variable

;  FDEPTH   ( -- +n )  depth 2/

  hdr 1,'FDEPTH'
fdepth:
  call do_colon
  dw depth
  dw twodiv
  dw exit

;  FDROP  ( r -- )

  hdr 1,'FDROP',,,two_drop  ; aka 2drop fdrop
f_drop: equ  two_drop

;  FDUP  ( r -- r r )

  hdr 1,'FDUP',,,two_dup    ; aka 2dup fdup
f_dup: equ  two_dup

;  FSWAP  ( r1 r2 -- r2 r1 )

  hdr 1,'FSWAP',,,tswap  ; aka 2swap fswap
f_swap: equ  tswap

;  FOVER  ( r1 r2 -- r1 r2 r1 )

  hdr 1,'FOVER',,,two_over  ; aka 2over fover
f_over: equ  two_over

;  FROT  ( r1 r2 r3 -- r2 r3 r1 )

  hdr 1,'FROT',,,trot    ; aka 2rot frot
f_rot: equ  trot

;  F@  ( f-addr -- r )

  hdr 1,'F@',,,two_fetch    ; aka 2@ f@
f_fetch: equ  two_fetch

;  F!  ( r f-addr -- )

  hdr 1,'F!',,,two_store    ; aka 2! f!
f_store: equ  two_store

;  FPICK  ( +n -- r )  floats sp@ cell+ + f@

  hdr 1,'FPICK'
fpick:
  call do_colon
  dw floats
;   if  fstack
;  dw fsp,fetch
;   else
  dw sp_fetch,cell_plus
;   endif
  dw plus,f_fetch
  dw exit

; floating point accumulator

acce:
  ds 5    ; accumulator exponent
accs: equ  acce+1    ; accumulator sign
acc1  equ  accs+1    ; accumulator 1st fraction
acc2  equ  acc1+1    ; accumulator 2nd fraction
acc3  equ  acc2+1    ; accumulator 3rd fraction

sf:
  ds 1    ; subtraction flag

f1:
  ds fw    ; temp float storage
f2:
  ds fw    ;

f_ten:
  call do_f_constant    ; fconstant
fp10:
  db 0x84,0x20,0,0  ; 10.0

; save/load temp fp registers

savf1:
  ld hl,f1    ; save regs to f1
  jp str

savf2:
  ld hl,f2    ; save regs to f2
  jp str

lodf1:
  ld hl,f1    ; load accum/regs from f1
  jp lod

lodf2:
  ld hl,f2    ; load accum/regs from f2
  jp lod

; pop float from stack to accum, saving bc

ldop:
  pop de
  pop hl
  ld (f1),hl
  pop hl
  ld (f1+2),hl
  push bc
  push de
  ld hl,f1
  jp lod

; pop 2 float from stack to hl (f2) and accum, saving bc

ld2op:
  pop hl
  ld (ld2op1),hl
  pop hl
  ld (f2),hl
  pop hl
  ld (f2+2),hl
  call ldop
  ld hl,(ld2op1)
  push hl
  ld hl,f2
  ret

ld2op1:
  ds 2

; push float registers to stack, restore bc and exit

svop:
  ld l,a
  ld h,b
  ld e,c
  pop bc
  push de
  jp next

; str  store registers to accum

strr:
  ld hl,acce
  ld (hl),e
  inc  hl

; entry - hl=adr, a=exp, bcd (packed)
; exit  - none

str:
  ld (hl),a
str1:
  inc  hl    ; entry when hl=accs
  ld (hl),b
  inc  hl
  ld (hl),c
  inc  hl
  ld (hl),d
  ret

; zero - set accum and regs to zero

zro:
  xor a
  ld (acce),a
  ld b,a
  ld c,a
  ld d,a
  ret

; overflow - set regs to maximum, set cy

ovf:
  ld bc,7fffh
  ld a,c
  ld d,c
  scf
  ret

; chs  change sign of accumulator
; entry - none
; exit  - bcd (packed), a=exp, flags set

chs:
  ld a,0x80
  jp fab1

; change sign of accumulator and again on result
; (when calling routine completes)

chss:
  call chs
  ld hl,chs
  ex (sp),hl
  jp (hl)

; fab  set acc to absolute
;
; entry - none
; exit  - bcd (packed), a=exp, flags set

fab:
  xor a
fab1:
  ld hl,accs
  and (hl)
  xor 0x80
  ld (hl),a    ; fall thru tst

; tst  load registers from acc and test
; exit  - bcd (packed), a=exp, flags set

tst:
  ld hl,acce
  ld a,(hl)
  and a
  jp z,zro
  ld e,a    ; e exp
  inc  hl
  ld a,(hl)    ; accs
  inc  hl
  xor (hl)    ; pack msb with sign
  inc  hl
  ld c,(hl)
  inc  hl
  ld d,(hl)
  jp tst1

; lod  load float (hl) to accum and regs, set flags
; entry - hl=adr
; exit  - bcd (packed), a=exp, flags set

lod:
  ld a,(hl)
  and a
  jp z,zro
  ld e,a
  inc  hl
  ld a,(hl)
  inc  hl
  ld c,(hl)
  inc  hl
  ld d,(hl)
  ld l,a
  or 0x80
  ld b,a
  xor l
lod2:
  call strr
  xor b

; entry - acd (packed), e=exp
; exit  - bcd (packed), a=exp, flags set

tst1:
  ld b,a
tst2:
  or 1    ; test sign, clear Z C flags
  ld a,e
  ret

; entry - a=exp
; exit  - e=exp  Z=zero M=negative

tstr:
  ld e,a
tstr1:
  or a
  ret  z
tstr2:
  ld a,b
  jp tst2

; fcmp  compare registers with (hl), return M if regs < (hl)

fcmp:
  ld e,a
  ld a,(hl)
  or a
  ld a,e
  jp z,tstr1    ; hl zero, test sign regs
  or a
  inc  hl
  ld a,(hl)
  cpl
  jp z,tst2    ; regs zero, test sign hl
  xor b
  jp p,tstr2    ; signs differ
  call fcmp1
  rra
  xor b    ; complement sign for neg values
  ld a,e
  ret

fcmp1:
  dec  hl
  ld a,e
  cp (hl)
  ret  nz
  inc  hl
  ld a,b
  cp (hl)
  ret  nz
  inc  hl
  ld a,c
  cp (hl)
  ret  nz
  inc  hl
  ld a,d
  cp (hl)
  ret  nz
  pop hl
  ld a,e
  ret

; right shift bcd by a bits
;
; entry - bcd, a=shift count
; exit  - bcde

shr_:
  ld e,0
  ld l,8    ; shift 8 bits by moving registers
shr_1:
  cp l
  jp m,shr_2    ; less than 8
  ld e,d
  ld d,c
  ld c,b
  ld b,0
  sub  l
  jp nz,shr_1
shr_2:
  and a
  ret  z    ; done
  ld l,a
shr_3:
  and a    ; clear carry
  ld a,b
  rra
  ld b,a
  ld a,c
  rra
  ld c,a
  ld a,d
  rra
  ld d,a
  ld a,e
  rra
  ld e,a
  dec  l
  jp nz,shr_3
  ret

; left shift bcde one bit
;
; entry - bcde
; exit  - bcde

shl_:
  ld a,e
  rla
  ld e,a
  ld a,d
  rla
  ld d,a
  ld a,c
  rla
  ld c,a
  ld a,b
  adc  a,a
  ld b,a
  ret

; Complement bcde adjust accs, return sign flag

fcpl:
  ld hl,accs    ; change accum sign
  ld a,(hl)
  xor 0x80
  ld (hl),a
  xor a    ; complement fraction
  ld l,a
  sub  e
  ld e,a
  ld a,l
  sbc a,d
  ld d,a
  ld a,l
  sbc a,c
  ld c,a
  ld a,l
  sbc a,b
  ld b,a
  ret

; Normalize bcde registers, adjust acce
;
; entry - bcde
; exit  - bcde, z= bcde=0 or acce=0

norm:
  ld l,32    ; max shift
norm1:
  ld a,b
  and a
  jp nz,norm3
  ld b,c
  ld c,d
  ld d,e
  ld e,a
  ld a,l
  sub  8
  ld l,a
  jp nz,norm1
  ret     ; bcde = zero

norm2:
  dec  l    ; shl until bit 31 set
  call shl_
norm3:
  jp p,norm2

  ld a,l    ; adjust accum exp
  sub  32
  ld hl,acce
  add a,(hl)
  ld (hl),a
  ret  z    ; if zero exp
  rra      ; move borrow bit to sign
  and a    ; set sign to indicate underflow
  ret

; Round the bcde registers, save to acc
;
; entry - bcde
; exit  - bcd, a=packed msb, e=exp, cy=ovf

rondr:
  ld a,e    ; lsb
  and a    ; test sign and clear cy
  ld hl,acce    ; exp
  ld e,(hl)
  call m,rondr1
  ret  c    ; rounder overflow
  ld a,b
  inc  hl    ; accs
  xor (hl)    ; a=packed msb
  jp str1    ; save bcd to acc

; round up bcd e=exp, cy=ovf

rondr1:
  inc  d
  ret  nz
  inc  c
  ret  nz
  inc  b
  ret  nz
  ld b,0x80    ; new 1st fraction
  ld a,e    ; inc exp
  add a,1    ; adjust cy
  ld e,a
  ld (acce),a  ; new acc exp
  ret

; fsu  floating point subtract subroutine

fsu:
  ld a,0x80    ; mask to change operand sign
  jp fad1

; fad  floating point add subroutine

fad:
  xor a
fad1:
  ld e,(hl)    ; load operand to abcd
  inc  hl
  xor (hl)
  ld b,a
  inc  hl
  ld c,(hl)
  inc  hl
  ld d,(hl)
  ld a,e
  and a
  jp z,tst    ; operand zero

  ld l,b    ; unpack
  ld a,b
  or 0x80
  ld b,a
  xor l    ; generate subtraction flag
  ld hl,accs
  xor (hl)
  ld (sf),a

; determine relative magnitudes of operand and accum

  dec  hl    ; acce
  ld a,(hl)
  and a
  jp z,fad8    ; accum zero

  sub  e    ; get difference of exponents
  jp c,fad2    ; accum smaller

; check for insignificant operand

  jp m,tst
  cp 25    ; compare shift count to 25
  jp c,fad3
  jp tst

; check for insignificant accum, exchange accum and operand

fad2:
  jp p,fad8
  cp 0-25    ; compare shift count to -25
  jp c,fad8

  ld (hl),e    ; set acce

  ld e,a    ; save shift count

  ld a,(sf)    ; set accum sign
  inc  hl    ; accs
  xor (hl)
  ld (hl),a

  xor a    ; complement shift count
  sub  e

  inc  hl    ; exchange fraction
  ld e,(hl)
  ld (hl),b
  ld b,e
  inc  hl
  ld e,(hl)
  ld (hl),c
  ld c,e
  inc  hl
  ld e,(hl)
  ld (hl),d
  ld d,e

; position the operand, check if add or subtract

fad3:
  call shr_
  ld hl,acc3
  ld a,(sf)
  and a
  jp m,fad4

  ld a,(hl)    ; add
  add a,d
  ld d,a
  dec  hl
  ld a,(hl)
  adc  a,c
  ld c,a
  dec  hl
  ld a,(hl)
  adc  a,b
  ld b,a
  jp nc,fpack

  rra      ; got carry, so rshift fraction
  ld b,a
  ld a,c
  rra
  ld c,a
  ld a,d
  rra
  ld d,a
  rra
  ld e,a
  ld hl,acce    ; and adjust exponent
  ld a,(hl)
  add a,1
  ld (hl),a
  jp c,ovf    ; overflow
  jp fpack

fad4:
  xor a    ; subtract
  sub  e
  ld e,a
  ld a,(hl)
  sbc a,d
  ld d,a
  dec  hl
  ld a,(hl)
  sbc a,c
  ld c,a
  dec  hl
  ld a,(hl)
  sbc a,b
  ld b,a

; complement bcde if carry

cnpack:
  call c,fcpl

; normalize and pack bcde

npack:
  ld a,b
  and a
  call p,norm
  jp p,zro    ; underflow or zero

; pack bcde

fpack:
  call rondr    ; round bcde
  jp c,ovf
  jp tst1

; move operand to accumulator

fad8:
  ld a,(sf)
  ld hl,accs
  xor (hl)
  jp lod2

; read the operand at (hl), check the accum exponent

mdex:
  ld b,a
  inc  hl
  ld c,(hl)
  inc  hl
  ld d,(hl)
  inc  hl
  ld e,(hl)

  ld hl,acce    ; accum exp
  ld a,(hl)
  and a
  ret  z    ; is zero

  add a,b    ; result exp plus bias
  ld b,a
  rra      ; carry to sign
  xor b    ; carry and sign must differ
  ld a,b    ; result exp plus bias
  ld b,0x80    ; exp bias, sign mask, most sig bit
  jp p,mdex1    ; if over or underflow
  sub  b    ; remove excess exp bias
  ret  z    ; return if underflow
  ld (hl),a    ; result exp
  inc  hl    ; address accum sign
  ld a,(hl)
  xor c    ; result sign in sign bit
  and b    ; result sign
  ld (hl),a    ; store it
  ld a,c    ; operand sign and 1st fraction
  or b    ; operand first fraction
  ret

mdex1:
  rlca      ; set carry bit if overflow
  ret  c
  xor a    ; clear a register
  ret      ; return if underflow

; fmu  floating point multiplication subroutine

fmu:
  ld a,(hl)    ; operand exponent
  and a
  push hl
  call nz,mdex    ; read operand
  pop hl
  jp z,zro    ; zero or underflow
  jp c,ovf    ; overflow
  call mulx    ; fixed mult
  ld a,b    ; normalize if necessary
  and a
  jp m,fpack

  ld hl,acce    ; dec accum exp
  dec  (hl)
  ret  z    ; underflow
  call shl_
  jp fpack

; fixed point multiply subroutine

mulx:
  ld hl,mulx4
  ld (hl),e    ; 3rd multiplicand
  inc  hl
  ld (hl),d    ; 2nd multiplicand
  inc  hl
  ld (hl),a    ; 1st multiplicand

  xor a    ; clear 6th product
  ld e,a    ; clear 5th product
  ld d,a    ; clear 4th product

; multiply  by each accumulator fraction in turn

  ld hl,acc3
  call mulx2    ; multiply by accum 3rd fraction
  ld hl,acc2
  call mulx1    ; multiply by accum 2nd fraction
  ld hl,acc1

; multiply by one accumulator byte

mulx1:
  ld a,d    ; 5th partial product
  ld e,c    ; 4th partial prod
  ld d,b    ; 3rd partial prod
mulx2:
  ld b,(hl)    ; multiplier
  ld l,a    ; 5th partial prod
  xor a    ; zero a register
  ld c,a    ; 2nd partial prod
  sub  b    ; set carry bit for exit flag
  jp c,mulx3    ; if multiplier is not zero
  ld c,d    ; 2nd partial product
  ld d,e    ; 3rd partial prod
  ret

; loop for each bit of multiplier byte

mulx3:
  ld a,l    ; 5th partial product, exit flag
  adc  a,a    ; shift exit flag out if done
  ret  z    ; exit if multiplication done
  ld l,a    ; 5th partial prod, exit flag
  ld a,e    ; 4th partial prod
  rla      ; shift 4th partial prod
  ld e,a    ; 4th partial prod
  ld a,d    ; 3rd partial prod
  rla
  ld d,a
  ld a,c    ; 2nd partial prod
  rla
  ld c,a
  ld a,b    ; 1st partial prod and multiplier
  rla
  ld b,a
  jp nc,mulx3  ; if no addition required

; add the multiplicand to the product if the multiplier bit is one

  ld a,(mulx4)  ; operand 3rd fraction
  add a,e
  ld e,a    ; 4th partial prod
  ld a,(mulx4+1)  ; operand 2nd fraction
  adc  a,d
  ld d,a    ; 3rd partial prod
  ld a,(mulx4+2)  ; operand 1st fraction
  adc  a,c
  ld c,a    ; 2nd partial prod
  jp nc,mulx3  ; if no carry to 1st prod
  inc  b    ; add carry to 1st prod
  and a    ; clear carry bit
  jp mulx3

mulx4:
  ds 3

; fdi  floating point division subroutine

fdi:
  xor a
  sub  (hl)    ; complement of divisor exponent
  cp 1    ; set carry if division by zero
  push hl
  call nc,mdex    ; read operand if not zero
  pop hl
  jp c,ovf    ; overflow or division by zero
  jp z,zro    ; underflow or zero
  ld c,a
  call divx    ; fixed division
  jp nc,ovf
  jp fpack

; fixed point divide subroutine

; subtract divisor from accum to obtain 1st remainder

divx:
  ld hl,acc3
  ld a,(hl)    ; accum 3rd fraction
  sub  e
  ld (hl),a
  dec  hl
  ld a,(hl)    ; accum 2nd fraction
  sbc a,d
  ld (hl),a
  dec  hl
  ld a,(hl)    ; accum 1st fraction
  sbc a,c
  ld (hl),a

; halve the divisor and store for addition or subtraction

  ld a,c    ; get carry bit
  rla
  ld a,c    ; divisor 1st fraction
  rra
  ld (divx4+3),a
  ld a,d    ; divisor 2nd fraction
  rra
  ld (divx4+2),a
  ld a,e    ; divisor 3rd fraction
  rra
  ld (divx4+1),a  ; 3rd subtract divisor
  ld b,0    ; init quot 1st fraction
  ld a,b    ; divisor 4th fraction is zero
  rra
  ld (divx4),a  ; 4th subtract divisor

; load 1st remainder

  ld a,(hl)    ; 1st fraction
  inc  hl
  ld d,(hl)    ; 2nd fraction
  inc  hl
  ld e,(hl)    ; 3rd fraction

; position remainder, initialise quotient, check sign

  ex de,hl    ; remainder 3rd fraction
        ; remainder 2nd fraction
  ld e,a    ; remainder 1st fraction
  ld c,b    ; init quot 2nd fraction
  ld d,b    ; init quot 3rd fraction
  and a
  jp m,divx3    ; if remainder is negative

; adjust exponent

  ld a,(acce)  ; increment quotient exp
  inc  a
  ret  z    ; overflow
  ld (acce),a

  inc  d    ; init quot 3rd fraction

; subtract the divisor if remainder positive

divx1:
  push bc
  ld c,l
  ld b,h
  xor a    ; 4th fraction is zero
  ld hl,divx4
  sub  (hl)
  ld a,c    ; 3rd fraction
  inc  hl
  sbc a,(hl)
  ld c,a
  ld a,b    ; 2nd fraction
  inc  hl
  sbc a,(hl)
  ld b,a
  ld a,e    ; 1st fraction
  inc  hl
  sbc a,(hl)
  ld e,a
  ld l,c
  ld h,b
divx2:
  pop bc

  ld a,(divx4)  ; remainder 4th fraction
  rlca      ; shift remainder 4th fraction to carry

; shift the remainder left one bit

  ld a,b
  rla
  ret  c    ; division complete
  rra      ; shift BCDEHL
  ld a,l
  rla
  ld l,a
  ld a,h
  rla
  ld h,a
  call shl_

; branch if subtraction is required

  ld a,d    ; quotient 3rd fraction
  rrca      ; remainder sign indic to carry bit
  jp c,divx1    ; to sub divisor if remainder positive

; add the divisor if the remainder is negative

divx3:
  push bc
  ld bc,divx4+1
  ld a,(bc)    ; 3rd fraction
  add a,l
  ld l,a
  inc  bc
  ld a,(bc)    ; 2nd fraction
  adc  a,h
  ld h,a
  inc  bc
  ld a,(bc)    ; 1st fraction
  adc  a,e
  ld e,a
  jp divx2

divx4:
  ds fw

; convert 32 bit signed integer to float
; entry - abcd (int)

flt:
  ld e,d
  ld d,c
  ld c,b
  ld b,a

; convert 32 bit signed integer to float
; entry - bc:de (int)

flt0:
  ld a,32    ; scaling factor
flt1:
  xor 0x80    ; apply exponent bias
  ld hl,acce
  ld (hl),a
  inc  hl
  ld (hl),0x80  ; assume positive accum sign
  ld a,b    ; set cy if integer negative
  and a
  rla
  jp cnpack    ; complete the conversion

; convert signed integer A to float

flta:
  ld de,0
  ld c,e
  ld b,a
  ld a,8
  jp flt1

; fix  convert float in acc to 32 bit integer
;
; exit  - abcd (int)

fix:
  ld e,32    ; scaling factor
  ld hl,acce
  ld a,(hl)
  and a
  jp z,zro    ; zero
  ld a,e
  add a,0x80-1    ; add bias-1
  sub  (hl)    ; shift count -1
  ret  c    ; accum too large
  cp 31    ; compare to large shift
  jp nc,zro    ; accum too small
  add a,1    ; shift count
  ld hl,acc1
  ld b,(hl)
  inc  hl
  ld c,(hl)
  inc  hl
  ld d,(hl)
  call shr_    ; position the fraction
  ld a,(accs)  ; complement if negative
  and a
  call p,fcpl
  ld a,1    ; set flags
  or b
  ld a,b
  ld b,c
  ld c,d
  ld d,e
  ret

; Floor accum to integer
;
; entry - abcd
; exit  - abcd e=signed integer

flr:
  ld e,d
  cp 0x80+24
  ret  nc    ; no fraction
flr1:
  ld e,a
  ld a,0x80    ; unpack b
  or b
  ld b,a
  ld a,(accs)
  rla
  push af
  jp c,flr3    ; positive
  ld a,d    ; decr bcd
  or a
  jp nz,flr2
  dec  bc
flr2:
  dec  d
flr3:
  ld a,0x80+24
  sub  e
  call shr_
  pop af
  call nc,rondr1  ; incr bcd
  ld a,0x80+24
  ld (acce),a
  ld a,d
  jp c,flr4
  cpl
  inc  a
flr4:
  push af
  ld e,0
  call npack    ; normalise and pack
  pop hl
  ld e,h
  ret

; Round accum to integer

rnd:
  call tstr
  call m,chss
  cp 0x80+24
  ret  nc    ; no fraction
  ld hl,fp50    ; 0.5
  call fad
  jp flr1

;  FABS  ( r1 -- r2 )

  hdr 1,'FABS'
f_abs:
  call ldop
  call fab
  jp svop

;  FNEGATE  ( r1 -- r2 )

  hdr 1,'FNEGATE'
fneg:
  call ldop
  call chs
  jp svop

;  D>F  ( d -- r )

  hdr 1,'D>F'
d_to_f:
  pop hl
  pop de
  push bc
  ld c,l
  ld b,h
  call flt0
  jp svop

;  F>D  ( r -- d )

  hdr 1,'F>D'
f_to_d:
  call ldop
  call fix
  ld e,d
  ld d,c
  ld l,b
  ld h,a
  pop bc
  push de
  jp next

;  S>F  ( n -- r )    s>d d>f

  hdr 1,'S>F'
s_to_f:
  call do_colon
  dw s_to_d,d_to_f
  dw exit

;  F>S  ( r -- n )    f>d d>s

  hdr 1,'F>S'
f_to_s:
  call do_colon
  dw f_to_d,d_to_s
  dw exit

;  F0=  ( r -- flag )

  hdr 1,'F0='
f_zero_equals:
  pop hl
  ld h,l
  ex (sp),hl
  jp zero_equals

;  F=  ( r1 r2 -- flag )

  hdr 1,'F='
f_equals:
  call ld2op
  call fcmp
  pop bc
  jp nz,false
  jp true

;  F0<  ( r -- flag )

  hdr 1,'F0<'
f_zero_less_than:
  pop hl
  pop de
  ld a,l
  or a
  jp z,false    ; zero
  ld a,h
  rla
  jp c,true    ; negative
  jp false

;  F<  ( r1 r2 -- flag )

  hdr 1,'F<'
f_less_than:
  call ld2op
  call fcmp
  pop bc
  jp m,true
  jp false

;  F0>  ( r -- flag )

  hdr 1,'F0>'
f_zero_greater_than:
  call ldop
f_zero_greater_than1:
  pop bc
  jp z,false
  jp m,false
  jp true

;  F>  ( r1 r2 -- flag )

  hdr 1,'F>'
f_greater_than:
  call ld2op
  call fcmp
  jp f_zero_greater_than1

;  FMIN  ( r1 r2 -- r1 | r2 )  fover fover f< 0= if fswap then fdrop

  hdr 1,'FMIN'
f_min:
  call ld2op
  push hl
  call fcmp
  pop hl
  call p,lod    ; r1 >= r2
  jp svop

;  FMAX  ( r1 r2 -- r1 | r2 )  fover fover f< if fswap then fdrop

  hdr 1,'FMAX'
f_max:
  call ld2op
  push hl
  call fcmp
  pop hl
  call m,lod    ; r1 < r2
  jp svop

;  FLOOR  ( r1 -- r2 )

  hdr 1,'FLOOR'
floor:
  call ldop
  call flr
  jp svop

;  FROUND  ( r1 -- r2 )

  hdr 1,'FROUND'
f_round:
  call ldop
  call rnd
  jp svop

;  F+  ( r1 r2 -- r3 )

  hdr 1,'F+'
f_plus:
  call ld2op
  call fad
  jp svop

;  F-  ( r1 r2 -- r3 )

  hdr 1,'F-'
f_minus:
  call ld2op
  call fsu
  jp svop

;  F*  ( r1 r2 -- r3 )

  hdr 1,'F*'
f_star:
  call ld2op
  call fmu
  jp svop

;  F/  ( r1 r2 -- r3 )

  hdr 1,'F/'
f_slash:
  call ld2op
  call fdi
  jp svop

;  FRANDOM  ( r1 -- r2 )

  hdr 1,'FRANDOM'
f_random:
  call ldop
  jp m,f_random1    ; seed generator
  push af
  ld hl,f_random4
  call lod
  ld e,a
  pop af
  ld a,e
  jp z,svop    ; return last value
  ld hl,f_random2  ; get next value
  call fmu
  ld hl,f_random3
  call fad
f_random1:
  ld hl,acc3
  ld b,(hl)    ; swap msb lsb
  dec  hl
  ld c,(hl)
  dec  hl
  ld d,(hl)
  dec  hl
  ld (hl),0x80  ; make positive
  dec  hl
  ld e,(hl)
  ld (hl),0x80  ; fix exponent
  call npack    ; normalise
  ld hl,f_random4
  call str
  jp svop

f_random2:
  db 0x98,0x35,0x44,0x7a
f_random3:
  db 0x68,0x28,0xb1,0x46
f_random4:
  db 0x80,0x31,0x41,0x59    ; seed

finstr:
  ds 3  ; string addr, count
finsgn:
  ds 1  ; sign
finpt:
  ds 1  ; decimal point flag
finexp:
  ds 1  ; decimal exponent
fincvt:
  ds 1  ; converted digits

; fin  convert character string to float
; entry - hl=adr, a=len
; exit  - result in accum, cy=error

fin:
  dec  hl    ; init string adr, count
  ld (finstr),hl
  inc  a
  ld (finstr+2),a

  ld a,0x80    ; set sign positive
  ld (finsgn),a
  xor a
  ld (finpt),a  ; clear decimal point flag
  ld (finexp),a  ; set decimal exponent = 0
  ld (fincvt),a  ; zero converted digits
  ld (acce),a  ; zero accum

  call fin17    ; get 1st char
  jp z,fin14    ; treat zero length as zero blanks

  cp ' '
  jp nz,fin2
fin1:
  call fin17    ; treat all blanks as zero
  jp z,fin14
  cp ' '
  jp z,fin1
  scf
  ret

fin2:
  cp '+'    ; check for sign
  jp z,fin3
  cp '-'
  jp nz,fin4
  xor a    ; set negative flag
  ld (finsgn),a
fin3:
  call fin17    ; get char after sign
  scf
  ret  z    ; none

fin4:
  cp '.'    ; check for decimal point
  jp nz,fin7
  ld hl,finpt
  xor (hl)
  ld (hl),a
  jp nz,fin8
fin5:
  scf      ; 2nd decimal point
  ret

fin6:
  ld a,(fincvt)
  or a
  jp z,fin5
  jp fin14

; process char

fin7:
  call fin18    ; convert char to digit
  ret  c    ; bad

  ld hl,fincvt
  inc  (hl)
  push af
  ld hl,fp10    ; mult old value by 10
  call fmu
  call savf1
  pop af    ; convert digit to floating point
  call flta
  ld hl,f1    ; add to old value
  call fad

  ld a,(finpt)  ; if decimal point
  and a
  jp z,fin8
  ld hl,finexp  ; decrement exponent
  dec  (hl)

; get next char

fin8:
  ld b,0    ; zero exponent
  call fin17
  jp z,fin6    ; done

; check for exponent

  cp '+'
  jp z,fin10
  cp '-'
  jp z,fin10
  call uppercase_a
  cp 'E'
  jp z,fin9
  cp 'D'
  jp nz,fin4

; process exponent

fin9:
  call fin17    ; next char
  jp z,fin6    ; done

fin10:
  ld b,a    ; save 1st char
  sub  '-'    ; compare minus sign
  ld e,a
  jp z,fin11
  add a,'-'-'+'  ; compare plus sign
  ld a,b
  jp nz,fin12

fin11:
  call fin17    ; got sign, get 1st digit

fin12:
  ld b,0    ; possible decimal exponent
  jp z,fin6    ; none - assume zero exponent

fin13:
  call fin18
  ret  c    ; not digit
  ld c,a    ; accumulate exponent
  ld a,b
  add a,a
  add a,a
  add a,b
  add a,a
  add a,c
  ld b,a
  call fin17    ; get next
  jp nz,fin13

  ld a,e    ; test exponent sign
  and a
  jp nz,fin14
  sub  b    ; complement if neg
  ld b,a

fin14:
  ld a,(finsgn)  ; store accum sign
  ld (accs),a

; adjust exponent

  ld a,b
fin15:
  ld hl,finexp
  add a,(hl)
  jp z,tst    ; done
  ld (hl),a
  ld hl,fp10
  jp p,fin16
  call fdi    ; div by 10
  ld a,1
  jp fin15

fin16:
  call fmu    ; mul by 10
  ret  c    ; overflow
  ld a,0xff
  jp fin15

; get next char, return z if end reached

fin17:
  ld hl,finstr+2
  dec  (hl)
  ld hl,(finstr)
  inc  hl
  ld (finstr),hl
  ld a,(hl)
  ret

; convert ascii char (a) to digit, return cy if not in range 0-9

fin18:
  sub  '0'
  ret  c
  cp 10
  ccf
  ret

;  >FLOAT  ( c-addr u -- r true | false )

  hdr 1,'>FLOAT'
to_float:
  pop hl
  ld a,l    ; assume u <= 255
  pop hl
  push bc
  call fin
  ld e,c
  ld h,b
  ld l,a
  pop bc
  jp c,false
  push de
  push hl
  jp true

  hdr 1,'MAX-PRECISION'
mprec:
  call do_byte_constant    ; max precision
  db maxsig

  hdr x,'EXSN'
exsn:
  call do_create    ; exponent, sign
  ds 2*cw

;  REPRESENT  ( r c-addr n -- exp sign flag )
;        2dup max-precision max [char] 0 fill
;        max-precision min 2>r fdup f0< 0 exsn 2!
;        fabs fdup f0= 0= if begin fdup 1.0e f<
;        0= while 10.0e f/ 1 exsn +! repeat begin
;        fdup 0.1e f< while 10.0e f* -1 exsn +!
;        repeat then r@ 0 max 0 ?do 10.0e f* loop
;        fround f>d 2dup <# #s #> dup r@ - exsn +!
;        2r> rot min 1 max cmove d0= if 1 0 else
;        exsn 2@ swap then true

  hdr 1,'REPRESENT'
repr:
  call do_colon
  dw two_dup
  dw mprec,max
  dw c_lit
  db '0'
  dw fill
  dw mprec,min
  dw two_to_r
  dw f_dup,f_zero_less_than
  dw zero,exsn,two_store
  dw f_abs
  dw f_dup,f_zero_equals
  dw zero_equals
  dw question_branch,repr3
repr1:
  dw f_dup    ; begin
  dw f_lit
  db 0x81,0,0,0
  dw f_less_than,zero_equals
  dw question_branch,repr2  ; while
  dw f_ten,f_slash
  dw one,exsn,pstor
  dw branch,repr1  ; repeat
repr2:
  dw f_dup    ; begin
  dw f_lit
  db 0x7d,0x4c,0xcc,0xcd
  dw f_less_than
  dw question_branch,repr3  ; while
  dw f_ten,f_star
  dw true,exsn,pstor
  dw branch,repr2  ; repeat
repr3:
  dw r_fetch
  dw zero,max,zero
  dw paren_question_do,repr5
repr4:
  dw f_ten,f_star
  dw paren_loop,repr4
repr5:
  dw f_round,f_to_d
  dw two_dup
  dw bdigs,digs,edigs
  dw dup
  dw r_fetch,minus  ; handle overflow
  dw exsn,pstor
  dw two_from_r
  dw rot,min
  dw one,max
  dw cmove
  dw d_zero_equals
  dw question_branch,repr6
  dw one,zero  ; 0.0E fixup
  dw branch,repr7
repr6:
  dw exsn,two_fetch
  dw swap
repr7:
  dw true
  dw exit

;  PRECISION  ( -- u )

  hdr 1,'PRECISION'
prec:
  call do_value
  dw maxsig    ; default

;  SET-PRECISION  ( u -- )   1 max max-precision min to precision

  hdr 1,'SET-PRECISION'
setpr:
  call do_colon
  dw one,max
  dw mprec,min
  dw paren_to,prec
  dw exit

  hdr 1,'FDP'
fdp:
  call do_create    ; decimal point display
  dw -1    ; set by FINIT
  ds 2

  hdr x,'FBUF'
fbuf:
  call do_create    ; fp string buffer
  ds maxsig

  hdr x,'EX#'
exn:
  call do_value    ; exponent
  ds cw

  hdr x,'SN#'
snn:
  call do_value    ; sign
  ds cw

  hdr x,'EF#'
efn:
  call do_value    ; exponent factor
  ds cw

  hdr x,'PL#'
pln:
  call do_value    ; places after decimal point
  ds cw

;  (f1)  ( r -- r exp )
;        fdup fbuf max-precision represent 2drop

  hdr x,'(F1)'  ; get exponent
pf1:
  call do_colon
  dw f_dup
  dw fbuf,mprec
  dw repr,two_drop  ; never error
  dw exit

;  (f2)  ( exp -- offset exp' )  s>d ef# fm/mod ef# *

  hdr x,'(F2)'  ; apply exponent factor
pf2:
  call do_colon
  dw s_to_d
  dw efn,fmmod
  dw efn,star
  dw exit

;  (f3)  ( r places -- c-addr u )
;                               dup to pl# 0< if precision else (f1) ef# 0>
;                               if 1- (f2) drop 1+ then pl# + max-precision
;                               min then fbuf swap represent drop to sn# to
;                               ex# fbuf max-precision -trailing <# ;

  hdr x,'(F3)'  ; float to ascii
pf3:
  call do_colon
  dw dup
  dw paren_to,pln
  dw zero_less_than
  dw question_branch,pf31
  dw prec
  dw branch,pf33
pf31:
  dw pf1
  dw efn,zero_greater_than
  dw question_branch,pf32
  dw one_minus
  dw pf2,drop
  dw one_plus
pf32:
  dw pln,plus
  dw mprec,min
pf33:
  dw fbuf,swap
  dw repr
  dw drop    ; never error
  dw paren_to,snn
  dw paren_to,exn
  dw fbuf
  dw mprec
  dw dtrai
  dw bdigs
  dw exit

;  (f4)  ( exp -- )  pl# 0< >r dup abs s>d r@ 0= if # then #s
;        2drop dup sign 0< r> d0= if [char] + hold
;        then [char] E hold

  hdr x,'(F4)'  ; insert exponent
pf4:
  call do_colon
  dw pln,zero_less_than
  dw to_r
  dw dup
  dw abs,s_to_d
  dw r_fetch,zero_equals
  dw question_branch,pf41
  dw dig
pf41:
  dw digs
  dw two_drop
  dw dup,sign
  dw zero_less_than
  dw from_r
  dw d_zero_equals
  dw question_branch,pf42
  dw c_lit
  db '+'
  dw hold
pf42:
  dw c_lit
  db 'E'
  dw hold
  dw exit

;  (f5)  ( n -- +n|0 )  0max dup fdp 2+ +!

  hdr x,'(F5)'  ; conditionally set flag
pf5:
  call do_colon
  dw zero_max
  dw dup
  dw fdp,two_plus
  dw pstor
  dw exit

;  (f6)  ( c-addr u -- )  (f5) shold

  hdr x,'(F6)'  ; insert string
pf6:
  call do_colon
  dw pf5,shold
  dw exit

;  (f7)  ( n -- )    (f5) [char] 0 nhold

  hdr x,'(F7)'  ; insert '0's
pf7:
  call do_colon
  dw pf5
  dw c_lit
  db '0'
  dw nhold
  dw exit

;  (f8)  ( -- )    sn# sign 0 0 #>

  hdr x,'(F8)'  ; insert sign
pf8:
  call do_colon
  dw snn,sign
  dw zero,zero
  dw edigs
  dw exit

;  (f9)  ( c-addr u1 -- c-addr u2 )
;        pl# 0< if begin dup while 1- 2dup
;        + c@ [char] 0 - until 1+ then then

  hdr x,'(F9)'  ; trim trailing '0's
pf9:
  call do_colon
  dw pln,zero_less_than
  dw question_branch,pf92
pf91:
  dw dup
  dw question_branch,pf92
  dw one_minus,two_dup
  dw plus,c_fetch
  dw c_lit
  db '0'
  dw minus
  dw question_branch,pf91
  dw one_plus
pf92:
  dw exit

;  (fa)  ( u1 -- u1 u2 )  pl# 0< if dup else pl# then

  hdr x,'(FA)'
pfaa:
  call do_colon
  dw pln,zero_less_than
  dw question_branch,pfaa1
  dw dup
  dw branch,pfaa2
pfaa1:
  dw pln
pfaa2:
  dw exit

;  (fb)  ( c-addr u n -- )  fdp cell+ off >r (f9) r@ + (fa) over -
;        (f7) (fa) min r@ - (f6) r> (fa) min (f7)
;        fdp 2@ or if [char] . hold then

  hdr x,'(FB)'  ; insert fraction n places right of dec. pt
pfbb:
  call do_colon
  dw fdp,two_plus
  dw off
  dw to_r
  dw pf9
  dw r_fetch,plus
  dw pfaa
  dw over,minus
  dw pf7
  dw pfaa,min
  dw r_fetch,minus
  dw pf6
  dw from_r
  dw pfaa,min
  dw pf7
  dw fdp,two_fetch,or_
  dw question_branch,pfbb1
  dw c_lit
  db '.'
  dw hold
pfbb1:
  dw exit

;  (fc)  ( c-addr u n -- )
;        >r 2dup r@ min 2swap r> /string 0 (fb) (f6)

  hdr x,'(FC)'  ; split into int/frac and insert
pfcc:
  call do_colon
  dw to_r
  dw two_dup
  dw r_fetch,min
  dw tswap
  dw from_r,sstr
  dw zero,pfbb
  dw pf6
  dw exit

;  (fd)  ( r n factor -- c-addr u )
;        to ef# (f3) ex# 1- (f2) (f4) 1+ (fc) (f8)

  hdr x,'(FD)'  ; exponent form
pfdd:
  call do_colon
  dw paren_to,efn
  dw pf3
  dw exn,one_minus
  dw pf2
  dw pf4
  dw one_plus,pfcc
  dw pf8
  dw exit

;  (FS.)  ( r n -- c-addr u )  1 (fd)

  hdr 1,'(FS.)'
pfsd:
  ld hl,1
  push hl
  jp pfdd

;  FS.R  ( r n1 n2 -- )
;        >r (fs.) r> s.r

  hdr 1,'FS.R'
fsdr:
  call do_colon
  dw to_r
  dw pfsd
  dw branch,d_dot_r1

;  FS.  ( r -- )    -1 0 fs.r space

  hdr 1,'FS.'
fsdot:
  call do_colon
  dw true
  dw zero,fsdr
  dw space
  dw exit

   if  fpeng

;  (FE.)  ( r -- c-addr u )  3 (fd)

  hdr 1,'(FE.)'
pfse:
  ld hl,3
  push hl
  jp pfdd

;  FE.R  ( r n1 n2 -- )  >r (fe.) r> s.r

  hdr 1,'FE.R'
fedr:
  call do_colon
  dw to_r
  dw pfse
  dw branch,d_dot_r1

;  FE.  ( r -- )    -1 0 fe.r space

  hdr 1,'FE.'
fedot:
  call do_colon
  dw true
  dw zero,fedr
  dw space
  dw exit

   endif

;  (F.)  ( r n -- c-addr u )
;        0 to ef# (f3) ex# dup max-precision > if
;        fbuf 0 0 (fb) max-precision - (f7) (f6)
;        else dup 0> if (fc) else abs (fb) 1 (f7)
;        then then (f8)

  hdr 1,'(F.)'
paren_f_dot:
  call do_colon
  dw zero
  dw paren_to,efn
  dw pf3
  dw exn,dup
  dw mprec,greater_than
  dw question_branch,paren_f_dot1  ; if
  dw fbuf,zero
  dw zero,pfbb
  dw mprec,minus
  dw pf7
  dw pf6
  dw branch,paren_f_dot3  ; else
paren_f_dot1:
  dw dup,zero_greater_than
  dw question_branch,paren_f_dot2
  dw pfcc
  dw branch,paren_f_dot3  ; else
paren_f_dot2:
  dw abs
  dw pfbb
  dw one,pf7
paren_f_dot3:
  dw pf8    ; then then
  dw exit

;  F.R  ( r n1 n2 -- )  >r (f.) r> s.r

  hdr 1,'F.R'
f_dot_r:
  call do_colon
  dw to_r
  dw paren_f_dot
  dw branch,d_dot_r1

;  F.  ( r -- )    -1 0 f.r space

  hdr 1,'F.'
f_dot:
  call do_colon
  dw true
  dw zero,f_dot_r
  dw space
  dw exit

;  (G.)  ( r n -- c-addr u )  >r (f1) -3 7 within  r> swap if (f.) else
;        (fs.) then

  hdr 1,'(G.)'
paren_g_dot:
  call do_colon
  dw to_r
  dw pf1
  dw lit,-3
  dw c_lit
  db 7
  dw within
  dw from_r,swap
  dw question_branch,paren_g_dot1  ; if
  dw paren_f_dot
  dw branch,paren_g_dot2  ; else
paren_g_dot1:
  dw pfsd
paren_g_dot2:
  dw exit    ; then

;  G.R  ( r n1 n2 -- )  >r (g.) r> s.r

  hdr 1,'G.R'
g_dot_r:
  call do_colon
  dw to_r,paren_g_dot
  dw branch,d_dot_r1

;  G.  ( r -- )    -1 0 g.r space

  hdr 1,'G.'
g_dot:
  call do_colon
  dw true
  dw zero,g_dot_r
  dw space
  dw exit

;  sqr

sqr:
  call tstr
  ret  z    ; zero
  jp m,ovf    ; neg
  call savf1
  and a
  rra
  add a,0x40
  call savf2
  ld d,5
sqr1:
  push de
  call lodf1
  ld hl,f2
  call fdi
  ld hl,f2
  call fad
  sub  1
  call savf2
  pop de
  dec  d
  jp nz,sqr1
  ld hl,f2
  jp lod

;  poly

poly:
  push hl
  call savf1
  pop hl
  ld a,(hl)
  ld (poly3),a
  inc  hl
  push hl
  call lod
  jp poly2

poly1:
  ld hl,poly3
  dec  (hl)
  pop hl
  ret  z
  push hl
  ld hl,f1
  call fmu
  pop hl
  push hl
  call fad
poly2:
  pop hl
  inc  hl
  inc  hl
  inc  hl
  inc  hl
  push hl
  jp poly1

poly3:
  ds 1

;  polx

polx:
  push hl
  call savf2
  ld hl,f2
  call fmu
  pop hl
  call poly
  ld hl,f2
  jp fmu

;  exp

exp:
  ld hl,ln2
  call fdi
  cp 0x88
  jp nc,ovf
  cp 0x68
  ld hl,fp1
  jp c,lod
  call savf2
  call flr
  call savf1
  ld a,e
  add a,0x81
  jp z,exp1
  push af
  call lodf2
  ld hl,f1
  call fsu
  ld hl,exp4
  call poly
  pop af
  ld bc,0
  ld d,b
  call savf1
  ld hl,f1
  jp fmu

exp1:
  call tst
  jp m,zro
  jp ovf

exp4:
  db 7
  db 0x74,0x59,0x88,0x7c
  db 0x77,0x26,0x97,0x00e0
  db 0x7a,0x1e,0x1d,0xc4
  db 0x7c,0x63,0x50,0x5e
  db 0x7e,0x75,0xfe,0x1a
ln2:
  db 0x80,0x31,0x72,0x18    ; ln2
fp1:
  db 0x81,0,0,0    ; 1.0

;  log

log:
  call tstr
  jp m,ovf    ; neg
  jp z,ovf    ; zero
  xor 0x80
  push af
  ld a,0x80
  ld hl,log2
  call poly
  call savf1
  pop af
  call flta
  ld hl,f1
  call fad
  ld hl,ln2
  jp fmu

log2:
  db 9
  db 0x82,0x94,0xee,0xd8
  db 0x84,0x7d,0xaa,0xa9
  db 0x86,0xbf,0x99,0x7d
  db 0x87,0x28,0xe5,0x7b
  db 0x87,0x00c0,0x71,0x8a
  db 0x87,0x14,0x95,0x6e
  db 0x86,0x00a0,0x1e,0xb2
  db 0x85,0x02,0x7a,0xad
  db 0x83,0x8d,0x9d,0x09

;  sin / cos

cos:
  ld hl,fpi2
  call fad
sin:
  or a
  ret  z
  cp 0x80+25
  jp nc,ovf
  ld hl,f2pi
  call fdi
  call savf1
  call flr
  or a
  push af
  ld hl,f2
  call nz,str
  call lodf1
  pop af
  ld hl,f2
  call nz,fsu
  ld hl,fp25    ; 0.25
  call fsu
  push af
  jp m,sin1
  ld hl,fp50    ; 0.5
  call fsu
  call p,chs
sin1:
  ld hl,fp25    ; 0.25
  call fad
  ld e,a
  pop af
  ld a,e
  call p,chs
  ld hl,sin7
  jp polx

sin7:
  db 5
  db 0x86,0x1e,0xd7,0xfb
  db 0x87,0x99,0x26,0x64
  db 0x87,0x23,0x34,0x58
  db 0x86,0xa5,0x5d,0xe1
f2pi:
  db 0x83,0x49,0fh,0xdb ; 2pi

fpi2:
  db 0x81,0x49,0x0f,0xdb ; pi/2

fp50:
  db 0x80,0,0,0  ; 0.5
fp25:
  db 0x7f,0,0,0  ; 0.25

;  atan

atan:
  call tstr
  call m,chss    ; make positive
  cp 0x81
  jp c,atan1    ; < 1
  ld hl,atan3
  push hl
  call savf1
  ld hl,fp1
  call lod
  ld hl,f1
  call fdi
atan1:
  ld hl,atan9
  call fcmp
  jp m,atan2
  ld hl,atan4
  push hl
  call savf1
  ld hl,atan7
  call fad
  ld hl,atan11
  call str
  call lodf1
  ld hl,atan6
  call poly
  ld hl,atan11
  call fdi
atan2:
  ld hl,atan8
  jp polx

atan3:
  ld hl,fpi2
  call fsu
  jp chs

atan4:
  ld hl,atan10
  jp fad

atan6:
  db 2
atan7:
  db 0x81,0x5d,0xb3,0xd7
  db 0x81,0x80,0,0    ; -1.0

atan8:
  db 4
  db 0x7e,0x83,0x35,0x62
  db 0x7e,0x4c,0x24,0x50
  db 0x7f,0xaa,0xa9,0x79
  db 0x81,0,0,0

atan9:
  db 0x7f,0x09,0x38,0xa3
atan10:
  db 0x80,0x06,0x0a,0x92

atan11:
  ds fw

;  FSQRT  ( r1 -- r2 )

  hdr 1,'FSQRT'
fsqr:
  call ldop
  call sqr
  jp svop

;  FEXP  ( r1 -- r2 )

  hdr 1,'FEXP'
f_exp:
  call ldop
  call exp
  jp svop

;  FLN  ( r1 -- r2 )

  hdr 1,'FLN'
f_ln:
  call ldop
  call log
  jp svop

;  F**  ( r1 r2 -- r3 )  fswap fln f* fexp

  hdr 1,'F**'
f_star_star:
  call do_colon
  dw f_swap,f_ln
  dw f_star,f_exp
  dw exit

;  FSIN  ( r1 -- r2 )

  hdr 1,'FSIN'
f_sin:
  call ldop
  call sin
  jp svop

;  FCOS  ( r1 -- r2 )

  hdr 1,'FCOS'
f_cos:
  call ldop
  call cos
  jp svop

;  FATAN  ( r1 -- r2 )

  hdr 1,'FATAN'
f_atan:
  call ldop
  call atan
  jp svop

;  PI  ( -- r )

  hdr 1,'PI'
f_pi:
  call do_f_constant
  db 0x82,0x49,0fh,0xdb  ; pi

;  finit  ( -- )    max-precision set-precision fdp on

  hdr x,'FINIT'
f_init:
  call do_colon
  dw mprec,setpr
  dw fdp,on
  dw exit

;  fidentify  ( -- )

  hdr x,'FIDENTIFY',,1
f_identify:
  call do_colon
  dw cr
  dw paren_dot_quote
  db f_identify1-$-1
  db 'Software floating-point ('
;   if  fstack
;  db 'separate'
;   else
  db 'common'
;   endif
  db ' stack)'
f_identify1:
  dw exit

;  fnumber  ( c-addr u -- [r] flag )
;        2dup s" E" caps search -rot 2drop decimal?
;        and if >float else 2drop 0 then dup >r
;        state? and if postpone fliteral then r>

  hdr x,'FNUMBER',,1
f_number:
  call do_colon
  dw two_dup    ; scan 'E'
  dw paren_s_quot
  dcs 'E'
   if  ucase
  dw caps
   endif
  dw search
  dw drot,two_drop
  dw dcmq    ; decimal base?
  dw and_
  dw question_branch,f_number2
f_number1:
  dw to_float
  dw branch,f_number3
f_number2:
  dw two_drop,zero
f_number3:
  dw dup,to_r
  dw state_question
  dw and_
  dw question_branch,f_number4
  dw f_literal
f_number4:
  dw from_r
  dw exit

;   ( -- )
;        :noname ['] noop dup (do_f_init_patch) ! (do_f_identify_patch) !
;        ['] false (interpret12) ! (nfps) off (nfpm) off
;        ; remember

  hdr x,'(-FP)',,1
fprun:
  ld hl,noop
  ld (do_f_init_patch),hl    ; INIT
  ld (do_f_identify_patch),hl    ; INDENTIFY
  ld hl,false
  ld (interpret12),hl    ; FNUMBER
;  ld hl,0
;  ld (nfps),hl
;  ld (nfpm),hl
  jp next

fprun1:
  dw 0    ; link
  dw fprun    ; xt

  endif

; }}} **********************************************************
; XXX {{{

; XXX TODO it seems these 'last_' labels could be renamed
; to 'top_' instead:
top_nfa: equ last_nfa   ; nfa of top word in forth vocabulary
top_xt equ last_xt   ; xt of top word in forth vocabulary

initdp: equ $

initdph: equ $

; Code is run once then disabled.

; MOVE-PATCH  ( -- )

;;movpat:
;;  ld a,0x44   ; change to LD B,H
;;  ld (cldd4),a
;;  ld (cldd5),a
;;  ld hl,cold
;;  ld (cldd7),hl  ; patch myself out
;;  jp (hl)

;  end cold_boot
  end sm
